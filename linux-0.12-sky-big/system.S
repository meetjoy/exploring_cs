
tools/system:     file format elf32-i386


Disassembly of section .text:

00000000 <main>:
struct drive_info { char dummy[32]; } drive_info;	// 用于存放硬盘参数表信息.

// 内核初始化主程序.初始化结束后将以任务0(idle任务即空闲任务)的身份运行.
// 英文注释含义是"这里确实是void,没错.在startup程序(head.s)中就是这样假设的".参见head.h程序代码.
int main(void)										/* This really IS void, no error here. */
{													/* The startup routine assumes (well, ...) this */
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	57                   	push   %edi
       e:	56                   	push   %esi
       f:	53                   	push   %ebx
      10:	51                   	push   %ecx
      11:	e8 16 6a 00 00       	call   6a2c <__x86.get_pc_thunk.bx>
      16:	81 c3 ea 0f 02 00    	add    $0x20fea,%ebx
      1c:	83 ec 5c             	sub    $0x5c,%esp
#ifdef EM
	// 开启仿真协处理器
	__asm__("movl %cr0,%eax \n\t" \
      1f:	0f 20 c0             	mov    %cr0,%eax
      22:	83 f0 06             	xor    $0x6,%eax
      25:	0f 22 c0             	mov    %eax,%cr0
	// 首先保存根文件系统设备和交换文件设备号,并根据setup.s程序中获取的信息设置控制台终端屏幕行,列数环境变量TERM,并用其设置初始init进程
	// 中执行etc/rc文件和shell程序使用的环境变量,以及复制内存0x90080处的硬盘表.
	// 其中ROOT_DEV已在前面包含进的include/linux/fs.h文件上被声明为extern_int
	// 而SWAP_DEV在include/linux/mm.h文件内也作了相同声明.这里mm.h文件并没有显式地列在本程序前部,因为前面包含进的include/linux/sched.h
	// 文件中已经含有它.
 	ROOT_DEV = ORIG_ROOT_DEV;										// ROOT_DEV定义在fs/super.c
      28:	0f b7 15 fc 01 09 00 	movzwl 0x901fc,%edx
      2f:	c7 c0 0c 50 02 00    	mov    $0x2500c,%eax
	i = vsprintf(str, fmt, args);
      35:	8d b3 20 16 00 00    	lea    0x1620(%ebx),%esi
 	ROOT_DEV = ORIG_ROOT_DEV;										// ROOT_DEV定义在fs/super.c
      3b:	89 10                	mov    %edx,(%eax)
 	SWAP_DEV = ORIG_SWAP_DEV;										// SWAP_DEV定义在mm/swap.c
      3d:	0f b7 15 fa 01 09 00 	movzwl 0x901fa,%edx
      44:	c7 c0 e4 40 02 00    	mov    $0x240e4,%eax
      4a:	89 10                	mov    %edx,(%eax)
      4c:	8d 83 a5 65 ff ff    	lea    -0x9a5b(%ebx),%eax
	i = vsprintf(str, fmt, args);
      52:	8d 55 c4             	lea    -0x3c(%ebp),%edx
      55:	52                   	push   %edx
      56:	50                   	push   %eax
      57:	56                   	push   %esi
      58:	89 45 c0             	mov    %eax,-0x40(%ebp)
      5b:	e8 e6 82 00 00       	call   8346 <vsprintf>
   	sprintf(term, "TERM=con%dx%d", CON_COLS, CON_ROWS);
	envp[1] = term;
	envp_rc[1] = term;
    drive_info = DRIVE_INFO;										// 复制内存0x90080处的硬盘参数表.
      60:	c7 c0 00 36 03 00    	mov    $0x33600,%eax
	// 接着根据机器物理内存容量设置高速缓冲区和主内存的位置和范围.
	// 高速缓存末端地址->buffer_memory_end;机器内存容量->memory_end;主内存开始地址->main_memory_start.
	// 设置物理内存大小
	memory_end = (1 << 20) + (EXT_MEM_K << 10);						// 内存大小=1MB + 扩展内存(k)*1024字节.
	memory_end &= 0xfffff000;										// 忽略不到4KB(1页)的内存数.
	if (memory_end > 16 * 1024 * 1024)								// 如果内存量超过16MB,则按16MB计.
      66:	83 c4 10             	add    $0x10,%esp
	envp[1] = term;
      69:	89 b3 24 00 00 00    	mov    %esi,0x24(%ebx)
	envp_rc[1] = term;
      6f:	89 b3 38 00 00 00    	mov    %esi,0x38(%ebx)
    drive_info = DRIVE_INFO;										// 复制内存0x90080处的硬盘参数表.
      75:	b9 08 00 00 00       	mov    $0x8,%ecx
      7a:	be 80 00 09 00       	mov    $0x90080,%esi
      7f:	89 c7                	mov    %eax,%edi
	memory_end = (1 << 20) + (EXT_MEM_K << 10);						// 内存大小=1MB + 扩展内存(k)*1024字节.
      81:	0f b7 05 02 00 09 00 	movzwl 0x90002,%eax
    drive_info = DRIVE_INFO;										// 复制内存0x90080处的硬盘参数表.
      88:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	memory_end = (1 << 20) + (EXT_MEM_K << 10);						// 内存大小=1MB + 扩展内存(k)*1024字节.
      8a:	c1 e0 0a             	shl    $0xa,%eax
      8d:	05 00 00 10 00       	add    $0x100000,%eax
	memory_end &= 0xfffff000;										// 忽略不到4KB(1页)的内存数.
      92:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	if (memory_end > 16 * 1024 * 1024)								// 如果内存量超过16MB,则按16MB计.
      97:	3d 00 00 00 01       	cmp    $0x1000000,%eax
	memory_end &= 0xfffff000;										// 忽略不到4KB(1页)的内存数.
      9c:	89 83 48 16 00 00    	mov    %eax,0x1648(%ebx)
	if (memory_end > 16 * 1024 * 1024)								// 如果内存量超过16MB,则按16MB计.
      a2:	7e 0a                	jle    ae <nr_system_calls+0x5c>
		memory_end = 16 * 1024 * 1024;
      a4:	c7 83 48 16 00 00 00 	movl   $0x1000000,0x1648(%ebx)
      ab:	00 00 01 
	// 根据物理内存的大小设置高速缓冲去的末端大小
	if (memory_end > 12 * 1024 * 1024) 								// 如果内存>12MB,则设置缓冲区末端=4MB
      ae:	8b 83 48 16 00 00    	mov    0x1648(%ebx),%eax
      b4:	3d 00 00 c0 00       	cmp    $0xc00000,%eax
      b9:	7e 0c                	jle    c7 <nr_system_calls+0x75>
		buffer_memory_end = 4 * 1024 * 1024;
      bb:	c7 83 44 16 00 00 00 	movl   $0x400000,0x1644(%ebx)
      c2:	00 40 00 
      c5:	eb 1d                	jmp    e4 <nr_system_calls+0x92>
	else if (memory_end > 6 * 1024 * 1024)							// 否则若内存>6MB,则设置缓冲区末端=2MB
      c7:	3d 00 00 60 00       	cmp    $0x600000,%eax
      cc:	7e 0c                	jle    da <nr_system_calls+0x88>
		buffer_memory_end = 2 * 1024 * 1024;
      ce:	c7 83 44 16 00 00 00 	movl   $0x200000,0x1644(%ebx)
      d5:	00 20 00 
      d8:	eb 0a                	jmp    e4 <nr_system_calls+0x92>
	else
		buffer_memory_end = 1 * 1024 * 1024;						// 否则则设置缓冲区末端=1MB
      da:	c7 83 44 16 00 00 00 	movl   $0x100000,0x1644(%ebx)
      e1:	00 10 00 
	// 根据高速缓冲区的末端大小设置主内存区的起始地址
	main_memory_start = buffer_memory_end;							// 主内存起始位置 = 缓冲区末端
      e4:	8b 93 44 16 00 00    	mov    0x1644(%ebx),%edx
	// 参见kernel/blk_drv/ramdisk.c.
#ifdef RAMDISK
	main_memory_start += rd_init(main_memory_start, RAMDISK * 1024);
#endif
	// 以下是内核进行所有方面的初始化工作.
	mem_init(main_memory_start, memory_end);						// 主内存区初始化.(mm/memory.c)
      ea:	56                   	push   %esi
      eb:	56                   	push   %esi
      ec:	50                   	push   %eax
		time.tm_sec = CMOS_READ(0);				// 当前时间秒值(均是BCD码值)
      ed:	be 70 00 00 00       	mov    $0x70,%esi
	mem_init(main_memory_start, memory_end);						// 主内存区初始化.(mm/memory.c)
      f2:	52                   	push   %edx
	main_memory_start = buffer_memory_end;							// 主内存起始位置 = 缓冲区末端
      f3:	89 93 40 16 00 00    	mov    %edx,0x1640(%ebx)
	mem_init(main_memory_start, memory_end);						// 主内存区初始化.(mm/memory.c)
      f9:	e8 40 a6 00 00       	call   a73e <mem_init>
	trap_init();                                    				// 陷阱门(硬件中断向量)初始化.(kernel/traps.c)
      fe:	e8 07 78 00 00       	call   790a <trap_init>
	blk_dev_init();													// 块设备初始化.(blk_drv/ll_rw_blk.c)
     103:	e8 8d 09 01 00       	call   10a95 <blk_dev_init>
	chr_dev_init();													// 字符设备初始化.(chr_drv/tty_io.c)
     108:	e8 3e 2b 01 00       	call   12c4b <chr_dev_init>
 	tty_init();														// tty初始化(chr_drv/tty_io.c)
     10d:	e8 3a 2b 01 00       	call   12c4c <tty_init>
     112:	83 c4 10             	add    $0x10,%esp
		time.tm_sec = CMOS_READ(0);				// 当前时间秒值(均是BCD码值)
     115:	b8 80 00 00 00       	mov    $0x80,%eax
     11a:	89 f2                	mov    %esi,%edx
     11c:	ee                   	out    %al,(%dx)
     11d:	eb 00                	jmp    11f <startup+0x1f>
     11f:	eb 00                	jmp    121 <startup+0x21>
     121:	ba 71 00 00 00       	mov    $0x71,%edx
     126:	ec                   	in     (%dx),%al
     127:	eb 00                	jmp    129 <startup+0x29>
     129:	eb 00                	jmp    12b <startup+0x2b>
     12b:	88 45 b4             	mov    %al,-0x4c(%ebp)
     12e:	0f b6 c8             	movzbl %al,%ecx
		time.tm_min = CMOS_READ(2);				// 当前分钟值.
     131:	89 f2                	mov    %esi,%edx
     133:	b8 82 00 00 00       	mov    $0x82,%eax
     138:	ee                   	out    %al,(%dx)
     139:	eb 00                	jmp    13b <startup+0x3b>
     13b:	eb 00                	jmp    13d <startup+0x3d>
     13d:	ba 71 00 00 00       	mov    $0x71,%edx
     142:	ec                   	in     (%dx),%al
     143:	eb 00                	jmp    145 <startup+0x45>
     145:	eb 00                	jmp    147 <startup+0x47>
     147:	88 45 b0             	mov    %al,-0x50(%ebp)
		time.tm_hour = CMOS_READ(4);			// 当前小时值.
     14a:	89 f2                	mov    %esi,%edx
     14c:	b8 84 00 00 00       	mov    $0x84,%eax
     151:	ee                   	out    %al,(%dx)
     152:	eb 00                	jmp    154 <startup+0x54>
     154:	eb 00                	jmp    156 <startup+0x56>
     156:	ba 71 00 00 00       	mov    $0x71,%edx
     15b:	ec                   	in     (%dx),%al
     15c:	eb 00                	jmp    15e <startup+0x5e>
     15e:	eb 00                	jmp    160 <startup+0x60>
     160:	88 45 ac             	mov    %al,-0x54(%ebp)
		time.tm_mday = CMOS_READ(7);			// 一月中的当天日期.
     163:	89 f2                	mov    %esi,%edx
     165:	b8 87 00 00 00       	mov    $0x87,%eax
     16a:	ee                   	out    %al,(%dx)
     16b:	eb 00                	jmp    16d <startup+0x6d>
     16d:	eb 00                	jmp    16f <startup+0x6f>
     16f:	ba 71 00 00 00       	mov    $0x71,%edx
     174:	ec                   	in     (%dx),%al
     175:	eb 00                	jmp    177 <startup+0x77>
     177:	eb 00                	jmp    179 <startup+0x79>
     179:	88 45 a8             	mov    %al,-0x58(%ebp)
		time.tm_mon = CMOS_READ(8);				// 当前月份(1-12)
     17c:	89 f2                	mov    %esi,%edx
     17e:	b8 88 00 00 00       	mov    $0x88,%eax
     183:	ee                   	out    %al,(%dx)
     184:	eb 00                	jmp    186 <startup+0x86>
     186:	eb 00                	jmp    188 <startup+0x88>
     188:	ba 71 00 00 00       	mov    $0x71,%edx
     18d:	ec                   	in     (%dx),%al
     18e:	eb 00                	jmp    190 <startup+0x90>
     190:	eb 00                	jmp    192 <startup+0x92>
     192:	88 45 a4             	mov    %al,-0x5c(%ebp)
		time.tm_year = CMOS_READ(9);			// 当前年份.
     195:	89 f2                	mov    %esi,%edx
     197:	b8 89 00 00 00       	mov    $0x89,%eax
     19c:	ee                   	out    %al,(%dx)
     19d:	eb 00                	jmp    19f <startup+0x9f>
     19f:	eb 00                	jmp    1a1 <startup+0xa1>
     1a1:	ba 71 00 00 00       	mov    $0x71,%edx
     1a6:	ec                   	in     (%dx),%al
     1a7:	eb 00                	jmp    1a9 <startup+0xa9>
     1a9:	eb 00                	jmp    1ab <startup+0xab>
     1ab:	89 c7                	mov    %eax,%edi
	} while (time.tm_sec != CMOS_READ(0));
     1ad:	89 f2                	mov    %esi,%edx
     1af:	b8 80 00 00 00       	mov    $0x80,%eax
     1b4:	ee                   	out    %al,(%dx)
     1b5:	eb 00                	jmp    1b7 <startup+0xb7>
     1b7:	eb 00                	jmp    1b9 <startup+0xb9>
     1b9:	ba 71 00 00 00       	mov    $0x71,%edx
     1be:	ec                   	in     (%dx),%al
     1bf:	eb 00                	jmp    1c1 <startup+0xc1>
     1c1:	eb 00                	jmp    1c3 <startup+0xc3>
     1c3:	0f b6 c0             	movzbl %al,%eax
     1c6:	39 c1                	cmp    %eax,%ecx
     1c8:	0f 85 47 ff ff ff    	jne    115 <startup+0x15>
	BCD_TO_BIN(time.tm_sec);					// 转换成进进制数值.
     1ce:	89 c8                	mov    %ecx,%eax
     1d0:	8b 55 b4             	mov    -0x4c(%ebp),%edx
	startup_time = kernel_mktime(&time);		// 计算开机时间.kernel/mktime.c
     1d3:	83 ec 0c             	sub    $0xc,%esp
	BCD_TO_BIN(time.tm_sec);					// 转换成进进制数值.
     1d6:	c1 f8 04             	sar    $0x4,%eax
     1d9:	6b c0 0a             	imul   $0xa,%eax,%eax
     1dc:	83 e2 0f             	and    $0xf,%edx
     1df:	01 d0                	add    %edx,%eax
	BCD_TO_BIN(time.tm_min);
     1e1:	8b 55 b0             	mov    -0x50(%ebp),%edx
	BCD_TO_BIN(time.tm_sec);					// 转换成进进制数值.
     1e4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		time.tm_min = CMOS_READ(2);				// 当前分钟值.
     1e7:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
	BCD_TO_BIN(time.tm_min);
     1eb:	83 e2 0f             	and    $0xf,%edx
     1ee:	c1 f8 04             	sar    $0x4,%eax
     1f1:	6b c0 0a             	imul   $0xa,%eax,%eax
     1f4:	01 d0                	add    %edx,%eax
	BCD_TO_BIN(time.tm_hour);
     1f6:	8b 55 ac             	mov    -0x54(%ebp),%edx
	BCD_TO_BIN(time.tm_min);
     1f9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		time.tm_hour = CMOS_READ(4);			// 当前小时值.
     1fc:	0f b6 45 ac          	movzbl -0x54(%ebp),%eax
	BCD_TO_BIN(time.tm_hour);
     200:	83 e2 0f             	and    $0xf,%edx
     203:	c1 f8 04             	sar    $0x4,%eax
     206:	6b c0 0a             	imul   $0xa,%eax,%eax
     209:	01 d0                	add    %edx,%eax
	BCD_TO_BIN(time.tm_mday);
     20b:	8b 55 a8             	mov    -0x58(%ebp),%edx
	BCD_TO_BIN(time.tm_hour);
     20e:	89 45 cc             	mov    %eax,-0x34(%ebp)
		time.tm_mday = CMOS_READ(7);			// 一月中的当天日期.
     211:	0f b6 45 a8          	movzbl -0x58(%ebp),%eax
	BCD_TO_BIN(time.tm_mday);
     215:	83 e2 0f             	and    $0xf,%edx
     218:	c1 f8 04             	sar    $0x4,%eax
     21b:	6b c0 0a             	imul   $0xa,%eax,%eax
     21e:	01 d0                	add    %edx,%eax
	BCD_TO_BIN(time.tm_mon);
     220:	8b 55 a4             	mov    -0x5c(%ebp),%edx
	BCD_TO_BIN(time.tm_mday);
     223:	89 45 d0             	mov    %eax,-0x30(%ebp)
		time.tm_year = CMOS_READ(9);			// 当前年份.
     226:	89 f8                	mov    %edi,%eax
	BCD_TO_BIN(time.tm_year);
     228:	83 e7 0f             	and    $0xf,%edi
		time.tm_year = CMOS_READ(9);			// 当前年份.
     22b:	0f b6 c0             	movzbl %al,%eax
	BCD_TO_BIN(time.tm_year);
     22e:	c1 f8 04             	sar    $0x4,%eax
	BCD_TO_BIN(time.tm_mon);
     231:	83 e2 0f             	and    $0xf,%edx
	BCD_TO_BIN(time.tm_year);
     234:	6b c0 0a             	imul   $0xa,%eax,%eax
     237:	01 c7                	add    %eax,%edi
		time.tm_mon = CMOS_READ(8);				// 当前月份(1-12)
     239:	0f b6 45 a4          	movzbl -0x5c(%ebp),%eax
	BCD_TO_BIN(time.tm_year);
     23d:	89 7d d8             	mov    %edi,-0x28(%ebp)
	BCD_TO_BIN(time.tm_mon);
     240:	c1 f8 04             	sar    $0x4,%eax
     243:	6b c0 0a             	imul   $0xa,%eax,%eax
	time.tm_mon--;								// tm_mon中月份范围是0~11.
     246:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
     24a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	startup_time = kernel_mktime(&time);		// 计算开机时间.kernel/mktime.c
     24d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
     250:	50                   	push   %eax
     251:	e8 ab 9b 00 00       	call   9e01 <kernel_mktime>
     256:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
     25c:	89 02                	mov    %eax,(%edx)
	time_init();													// 设置开机启动时间.
 	sched_init();													// 调度程序初始化(加载任务0的tr,ldtr)(kernel/sched.c)
     25e:	e8 bf 6f 00 00       	call   7222 <sched_init>
	buffer_init(buffer_memory_end);									// 缓冲管理初始化,建内存链表等.(fs/buffer.c)
     263:	58                   	pop    %eax
     264:	ff b3 44 16 00 00    	pushl  0x1644(%ebx)
     26a:	e8 10 c3 00 00       	call   c57f <buffer_init>
	hd_init();														// 硬盘初始化.	(blk_drv/hd.c)
     26f:	e8 d4 1b 01 00       	call   11e48 <hd_init>
	floppy_init();													// 软驱初始化.	(blk_drv/floppy.c)
     274:	e8 c6 11 01 00       	call   1143f <floppy_init>
	sti();															// 所有初始化工作都完了,于是开启中断.
     279:	fb                   	sti    
	// 打印内核初始化完毕
	Log(LOG_INFO_TYPE, "<<<<< Linux0.12 Kernel Init Finished, Ready Start Process0 >>>>>\n");
     27a:	5a                   	pop    %edx
     27b:	8d 83 b3 65 ff ff    	lea    -0x9a4d(%ebx),%eax
     281:	59                   	pop    %ecx
     282:	50                   	push   %eax
     283:	6a 00                	push   $0x0
     285:	e8 05 72 01 00       	call   1748f <Log>
	// 下面过程通过在堆栈中设置的参数,利用中断返回指令启动任务0执行.
	move_to_user_mode();											// 移到用户模式下执行.(include/asm/system.h)
     28a:	89 e0                	mov    %esp,%eax
     28c:	6a 17                	push   $0x17
     28e:	50                   	push   %eax
     28f:	9c                   	pushf  
     290:	6a 0f                	push   $0xf
     292:	68 98 02 00 00       	push   $0x298
     297:	cf                   	iret   
     298:	b8 17 00 00 00       	mov    $0x17,%eax
     29d:	8e d8                	mov    %eax,%ds
     29f:	8e c0                	mov    %eax,%es
     2a1:	8e e0                	mov    %eax,%fs
     2a3:	8e e8                	mov    %eax,%gs
	__asm__ volatile (
     2a5:	b8 02 00 00 00       	mov    $0x2,%eax
     2aa:	cd 80                	int    $0x80
	if (__res >= 0)  															/* 如果返回值>=0,则直接返回该值 */
     2ac:	83 c4 10             	add    $0x10,%esp
     2af:	85 c0                	test   %eax,%eax
     2b1:	79 0c                	jns    2bf <blocked+0xaf>
	errno = -__res;  															/* 否则置出错号,并返回-1 */
     2b3:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
     2b9:	f7 d8                	neg    %eax
     2bb:	89 02                	mov    %eax,(%edx)
     2bd:	eb 07                	jmp    2c6 <blocked+0xb6>
	if (!fork_for_process0()) {										/* we count on this going ok */
     2bf:	75 05                	jne    2c6 <blocked+0xb6>
		init();														// 在新建的子进程(任务1即init进程)中执行.
     2c1:	e8 90 65 00 00       	call   6856 <init>
	 * 我们就回到这里,一直循环执行'pause()'.
	 */
	// pause()系统调用(kernel/sched.c)会把任务0转换成可中断等待状态,再执行调度函数.但是调度函数只要发现系统中没有其他任务可以运行时就会切换
	// 到任务0,是不信赖于任务0的状态.
	for(;;)
		__asm__("int $0x80"::"a" (__NR_pause):);					// 即执行系统调用pause().
     2c6:	b8 1d 00 00 00       	mov    $0x1d,%eax
     2cb:	cd 80                	int    $0x80
     2cd:	eb fc                	jmp    2cb <blocked+0xbb>
     2cf:	90                   	nop

000002d0 <pg_dir>:
     2d0:	b8 10 00 00 00       	mov    $0x10,%eax
     2d5:	8e d8                	mov    %eax,%ds
     2d7:	8e c0                	mov    %eax,%es
     2d9:	8e e0                	mov    %eax,%fs
     2db:	8e e8                	mov    %eax,%gs
     2dd:	0f b2 25 e0 10 02 00 	lss    0x210e0,%esp
     2e4:	e8 58 00 00 00       	call   341 <setup_idt>
     2e9:	e8 83 00 00 00       	call   371 <setup_gdt>
     2ee:	b8 10 00 00 00       	mov    $0x10,%eax
     2f3:	8e d8                	mov    %eax,%ds
     2f5:	8e c0                	mov    %eax,%es
     2f7:	8e e0                	mov    %eax,%fs
     2f9:	8e e8                	mov    %eax,%gs
     2fb:	0f b2 25 e0 10 02 00 	lss    0x210e0,%esp
     302:	31 c0                	xor    %eax,%eax
     304:	40                   	inc    %eax
     305:	a3 00 00 00 00       	mov    %eax,0x0
     30a:	39 05 00 00 10 00    	cmp    %eax,0x100000
     310:	74 f2                	je     304 <pg_dir+0x34>
     312:	0f 20 c0             	mov    %cr0,%eax
     315:	25 11 00 00 80       	and    $0x80000011,%eax
     31a:	83 c8 02             	or     $0x2,%eax
     31d:	0f 22 c0             	mov    %eax,%cr0
     320:	e8 05 00 00 00       	call   32a <check_x87>
     325:	e9 a6 53 00 00       	jmp    56d0 <after_page_tables>

0000032a <check_x87>:
     32a:	db e3                	fninit 
     32c:	9b df e0             	fstsw  %ax
     32f:	3c 00                	cmp    $0x0,%al
     331:	74 0b                	je     33e <check_x87+0x14>
     333:	0f 20 c0             	mov    %cr0,%eax
     336:	83 f0 06             	xor    $0x6,%eax
     339:	0f 22 c0             	mov    %eax,%cr0
     33c:	c3                   	ret    
     33d:	90                   	nop
     33e:	db e4                	fnsetpm(287 only) 
     340:	c3                   	ret    

00000341 <setup_idt>:
     341:	8d 15 f8 56 00 00    	lea    0x56f8,%edx
     347:	b8 00 00 08 00       	mov    $0x80000,%eax
     34c:	66 89 d0             	mov    %dx,%ax
     34f:	66 ba 00 8e          	mov    $0x8e00,%dx
     353:	8d 3d 88 57 00 00    	lea    0x5788,%edi
     359:	b9 00 01 00 00       	mov    $0x100,%ecx

0000035e <rp_sidt>:
     35e:	89 07                	mov    %eax,(%edi)
     360:	89 57 04             	mov    %edx,0x4(%edi)
     363:	83 c7 08             	add    $0x8,%edi
     366:	49                   	dec    %ecx
     367:	75 f5                	jne    35e <rp_sidt>
     369:	0f 01 1d 7a 57 00 00 	lidtl  0x577a
     370:	c3                   	ret    

00000371 <setup_gdt>:
     371:	0f 01 15 82 57 00 00 	lgdtl  0x5782
     378:	c3                   	ret    
	...

000012d0 <pg0>:
	...

000022d0 <pg1>:
	...

000032d0 <pg2>:
	...

000042d0 <pg3>:
	...

000052d0 <tmp_floppy_area>:
	...

000056d0 <after_page_tables>:
    56d0:	6a 00                	push   $0x0
    56d2:	6a 00                	push   $0x0
    56d4:	6a 00                	push   $0x0
    56d6:	68 e2 56 00 00       	push   $0x56e2
    56db:	68 00 00 00 00       	push   $0x0
    56e0:	eb 3c                	jmp    571e <setup_paging>

000056e2 <L6>:
    56e2:	eb fe                	jmp    56e2 <L6>

000056e4 <int_msg>:
    56e4:	55                   	push   %ebp
    56e5:	6e                   	outsb  %ds:(%esi),(%dx)
    56e6:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
    56ea:	6e                   	outsb  %ds:(%esi),(%dx)
    56eb:	20 69 6e             	and    %ch,0x6e(%ecx)
    56ee:	74 65                	je     5755 <setup_paging+0x37>
    56f0:	72 72                	jb     5764 <setup_paging+0x46>
    56f2:	75 70                	jne    5764 <setup_paging+0x46>
    56f4:	74 0a                	je     5700 <ignore_int+0x8>
    56f6:	0d                   	.byte 0xd
	...

000056f8 <ignore_int>:
    56f8:	50                   	push   %eax
    56f9:	51                   	push   %ecx
    56fa:	52                   	push   %edx
    56fb:	1e                   	push   %ds
    56fc:	06                   	push   %es
    56fd:	0f a0                	push   %fs
    56ff:	b8 10 00 00 00       	mov    $0x10,%eax
    5704:	8e d8                	mov    %eax,%ds
    5706:	8e c0                	mov    %eax,%es
    5708:	8e e0                	mov    %eax,%fs
    570a:	68 e4 56 00 00       	push   $0x56e4
    570f:	e8 0d 2a 00 00       	call   8121 <printk>
    5714:	58                   	pop    %eax
    5715:	0f a1                	pop    %fs
    5717:	07                   	pop    %es
    5718:	1f                   	pop    %ds
    5719:	5a                   	pop    %edx
    571a:	59                   	pop    %ecx
    571b:	58                   	pop    %eax
    571c:	cf                   	iret   
    571d:	90                   	nop

0000571e <setup_paging>:
    571e:	b9 00 14 00 00       	mov    $0x1400,%ecx
    5723:	31 c0                	xor    %eax,%eax
    5725:	31 ff                	xor    %edi,%edi
    5727:	fc                   	cld    
    5728:	f3 ab                	rep stos %eax,%es:(%edi)
    572a:	c7 05 d0 02 00 00 d7 	movl   $0x12d7,0x2d0
    5731:	12 00 00 
    5734:	c7 05 d4 02 00 00 d7 	movl   $0x22d7,0x2d4
    573b:	22 00 00 
    573e:	c7 05 d8 02 00 00 d7 	movl   $0x32d7,0x2d8
    5745:	32 00 00 
    5748:	c7 05 dc 02 00 00 d7 	movl   $0x42d7,0x2dc
    574f:	42 00 00 
    5752:	bf cc 52 00 00       	mov    $0x52cc,%edi
    5757:	b8 07 f0 ff 00       	mov    $0xfff007,%eax
    575c:	fd                   	std    
    575d:	ab                   	stos   %eax,%es:(%edi)
    575e:	2d 00 10 00 00       	sub    $0x1000,%eax
    5763:	7d f8                	jge    575d <setup_paging+0x3f>
    5765:	fc                   	cld    
    5766:	31 c0                	xor    %eax,%eax
    5768:	0f 22 d8             	mov    %eax,%cr3
    576b:	0f 20 c0             	mov    %cr0,%eax
    576e:	0d 00 00 00 80       	or     $0x80000000,%eax
    5773:	0f 22 c0             	mov    %eax,%cr0
    5776:	c3                   	ret    
    5777:	90                   	nop
	...

0000577a <idt_descr>:
    577a:	ff 07                	incl   (%edi)
    577c:	88 57 00             	mov    %dl,0x0(%edi)
    577f:	00 00                	add    %al,(%eax)
	...

00005782 <gdt_descr>:
    5782:	ff 07                	incl   (%edi)
    5784:	88 5f 00             	mov    %bl,0x0(%edi)
	...

00005788 <idt>:
	...

00005f88 <gdt>:
	...
    5f90:	ff 0f                	decl   (%edi)
    5f92:	00 00                	add    %al,(%eax)
    5f94:	00 9a c0 00 ff 0f    	add    %bl,0xfff00c0(%edx)
    5f9a:	00 00                	add    %al,(%eax)
    5f9c:	00 92 c0 00 00 00    	add    %dl,0xc0(%edx)
	...

00006788 <fork>:
_syscall0(int, fork)
    6788:	e8 9b 02 00 00       	call   6a28 <__x86.get_pc_thunk.dx>
    678d:	81 c2 73 a8 01 00    	add    $0x1a873,%edx
    6793:	b8 02 00 00 00       	mov    $0x2,%eax
    6798:	cd 80                	int    $0x80
    679a:	85 c0                	test   %eax,%eax
    679c:	79 0d                	jns    67ab <fork+0x23>
    679e:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
    67a4:	f7 d8                	neg    %eax
    67a6:	89 02                	mov    %eax,(%edx)
    67a8:	83 c8 ff             	or     $0xffffffff,%eax
    67ab:	c3                   	ret    

000067ac <pause>:
_syscall0(int, pause)
    67ac:	e8 77 02 00 00       	call   6a28 <__x86.get_pc_thunk.dx>
    67b1:	81 c2 4f a8 01 00    	add    $0x1a84f,%edx
    67b7:	b8 1d 00 00 00       	mov    $0x1d,%eax
    67bc:	cd 80                	int    $0x80
    67be:	85 c0                	test   %eax,%eax
    67c0:	79 0d                	jns    67cf <pause+0x23>
    67c2:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
    67c8:	f7 d8                	neg    %eax
    67ca:	89 02                	mov    %eax,(%edx)
    67cc:	83 c8 ff             	or     $0xffffffff,%eax
    67cf:	c3                   	ret    

000067d0 <setup>:
_syscall1(int, setup, void *, BIOS)
    67d0:	53                   	push   %ebx
    67d1:	31 c0                	xor    %eax,%eax
    67d3:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    67d7:	e8 4c 02 00 00       	call   6a28 <__x86.get_pc_thunk.dx>
    67dc:	81 c2 24 a8 01 00    	add    $0x1a824,%edx
    67e2:	cd 80                	int    $0x80
    67e4:	85 c0                	test   %eax,%eax
    67e6:	79 0d                	jns    67f5 <setup+0x25>
    67e8:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
    67ee:	f7 d8                	neg    %eax
    67f0:	89 02                	mov    %eax,(%edx)
    67f2:	83 c8 ff             	or     $0xffffffff,%eax
    67f5:	5b                   	pop    %ebx
    67f6:	c3                   	ret    

000067f7 <sync>:
_syscall0(int, sync)
    67f7:	e8 2c 02 00 00       	call   6a28 <__x86.get_pc_thunk.dx>
    67fc:	81 c2 04 a8 01 00    	add    $0x1a804,%edx
    6802:	b8 24 00 00 00       	mov    $0x24,%eax
    6807:	cd 80                	int    $0x80
    6809:	85 c0                	test   %eax,%eax
    680b:	79 0d                	jns    681a <sync+0x23>
    680d:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
    6813:	f7 d8                	neg    %eax
    6815:	89 02                	mov    %eax,(%edx)
    6817:	83 c8 ff             	or     $0xffffffff,%eax
    681a:	c3                   	ret    

0000681b <printf>:

// 下面函数产生格式化信息并输出到标准输出设备stdout(1),这里是指屏幕上显示.参数'*fmt'指定输出将采用的格式,参见标准C语言书籍.
// 该子程序正好是vsprintf如何使用的一个简单例子.该程序使用vsprintf()将格式化的字符串放入printbuf缓冲区,然后用write()将
// 缓冲区的内容输出到标准设备(1--stdout).vsprintf()函数的实现见kernel/vsprintf.c.
int printf(const char *fmt, ...)
{
    681b:	57                   	push   %edi
    681c:	56                   	push   %esi
    681d:	53                   	push   %ebx
	va_list args;
	int i;

	va_start(args, fmt);
	write(1, printbuf, i = vsprintf(printbuf, fmt, args));
    681e:	50                   	push   %eax
    681f:	e8 08 02 00 00       	call   6a2c <__x86.get_pc_thunk.bx>
    6824:	81 c3 dc a7 01 00    	add    $0x1a7dc,%ebx
    682a:	8d 44 24 18          	lea    0x18(%esp),%eax
    682e:	8d bb 60 16 00 00    	lea    0x1660(%ebx),%edi
    6834:	50                   	push   %eax
    6835:	ff 74 24 18          	pushl  0x18(%esp)
    6839:	57                   	push   %edi
    683a:	e8 07 1b 00 00       	call   8346 <vsprintf>
    683f:	83 c4 0c             	add    $0xc,%esp
    6842:	89 c6                	mov    %eax,%esi
    6844:	50                   	push   %eax
    6845:	57                   	push   %edi
    6846:	6a 01                	push   $0x1
    6848:	e8 27 0b 01 00       	call   17374 <write>
	va_end(args);
	return i;
    684d:	83 c4 10             	add    $0x10,%esp
}
    6850:	89 f0                	mov    %esi,%eax
    6852:	5b                   	pop    %ebx
    6853:	5e                   	pop    %esi
    6854:	5f                   	pop    %edi
    6855:	c3                   	ret    

00006856 <init>:

// 在main()中已经进行子系统初始化,包括内存管理,各种硬件设备和驱动程序.init()函数在任务0第1次创建的子进程(任务1)中.它首先对第一个将要执行
// 的程序(shell)的环境进行初始化,然后以登录shell方式加载程序并执行之.
void init(void)
{
    6856:	57                   	push   %edi
    6857:	56                   	push   %esi
    6858:	53                   	push   %ebx
    6859:	e8 ce 01 00 00       	call   6a2c <__x86.get_pc_thunk.bx>
    685e:	81 c3 a2 a7 01 00    	add    $0x1a7a2,%ebx
    6864:	83 ec 10             	sub    $0x10,%esp
	// 在块设备子目录kernel/blk_drv/hd.c.
	setup((void *) &drive_info);
	// 下面以读写访问方式打开设备"/dev/tty0",它对应终端控制台.由于这是第一次打开文件操作,因此产生的文件句柄号(文件描述符)肯定是0.该句柄是UNIX类操作
	// 系统默认的控制台标准输入句柄stdin.这里再把它以读和写的方式分别打开是为了复制产生标准输出(写)句柄stdout和标准出错输出句柄stderr.函数前面的"(void)"
	// 前缀用于表示强制函数无需返回值.
	(void) open("/dev/tty1", O_RDWR, 0);
    6867:	8d bb e0 64 ff ff    	lea    -0x9b20(%ebx),%edi
	setup((void *) &drive_info);
    686d:	ff b3 e4 ff ff ff    	pushl  -0x1c(%ebx)
    6873:	e8 58 ff ff ff       	call   67d0 <setup>
	(void) open("/dev/tty1", O_RDWR, 0);
    6878:	6a 00                	push   $0x0
    687a:	6a 02                	push   $0x2
    687c:	57                   	push   %edi
    687d:	e8 94 0a 01 00       	call   17316 <open>
	(void) dup(0);													// 复制句柄,产生句柄1号--stdout标准输出设备.
    6882:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    6889:	e8 1a 0b 01 00       	call   173a8 <dup>
	(void) dup(0);													// 复制句柄,产生句柄2号--stderr标准出错输出设备.
    688e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    6895:	e8 0e 0b 01 00       	call   173a8 <dup>
	// 进程1执行的用户级代码的开始
	printf("<<<<< Process 1 console fd = %d >>>>>\n", fd);
    689a:	5e                   	pop    %esi
    689b:	58                   	pop    %eax
    689c:	8d 83 ea 64 ff ff    	lea    -0x9b16(%ebx),%eax
    68a2:	6a 00                	push   $0x0
    68a4:	50                   	push   %eax
    68a5:	e8 71 ff ff ff       	call   681b <printf>
	// 下面打印缓冲区块数和总字节数,每块1024字节,以及主内存区空闲内存字节数.
	printf("<<<<< %d buffers = %d bytes buffer space >>>>>\n\r", NR_BUFFERS,
    68aa:	c7 c0 00 50 02 00    	mov    $0x25000,%eax
    68b0:	83 c4 0c             	add    $0xc,%esp
    68b3:	8b 00                	mov    (%eax),%eax
    68b5:	89 c2                	mov    %eax,%edx
    68b7:	c1 e2 0a             	shl    $0xa,%edx
    68ba:	52                   	push   %edx
    68bb:	50                   	push   %eax
    68bc:	8d 83 11 65 ff ff    	lea    -0x9aef(%ebx),%eax
    68c2:	50                   	push   %eax
    68c3:	e8 53 ff ff ff       	call   681b <printf>
			NR_BUFFERS * BLOCK_SIZE);
	printf("<<<<< Free mem: %d bytes >>>>>\n\r", memory_end - main_memory_start);
    68c8:	58                   	pop    %eax
    68c9:	8b 83 48 16 00 00    	mov    0x1648(%ebx),%eax
    68cf:	2b 83 40 16 00 00    	sub    0x1640(%ebx),%eax
    68d5:	5a                   	pop    %edx
    68d6:	50                   	push   %eax
    68d7:	8d 83 42 65 ff ff    	lea    -0x9abe(%ebx),%eax
    68dd:	50                   	push   %eax
    68de:	e8 38 ff ff ff       	call   681b <printf>
	// 下面fork()用于创建一个子进程(任务2).对于被创建的子进程,fork()将返回0值,对于原进程(父进程)则返回子进程的进程号pid.所以第202--206行是子进程执行的内容.
	// 该子进程关闭了句柄0(stdin),以只读方式打开/etc/rc文件,并使用execve()函数将进程自身替换成/bin/sh程序(即shell程序),然后执行/bin/sh程序.所携带的参数
	// 和环境变量分别由argv_rc和envp_rc数组给出.关闭句柄0并立刻打开/etc/rc文件的作用是把标准输入stdin重定向到/etc/rc/文件.这样shell程序/bin/sh就可以运行
	// rc文件中设置的命令.由于这里sh的运行方式是非交互式的,因此在执行完rc文件中的命令后就会立刻退出,进程2也随之结束.并于execve()函数说明请参见fs/exec.c程序.
	// 函数_exit()退出时的出错码1 - 操作未许可;2 -- 文件或目录不存在.
	if (!(pid = fork())) {
    68e3:	e8 a0 fe ff ff       	call   6788 <fork>
    68e8:	83 c4 10             	add    $0x10,%esp
    68eb:	83 f8 00             	cmp    $0x0,%eax
    68ee:	75 5a                	jne    694a <init+0xf4>
		close(0);
    68f0:	83 ec 0c             	sub    $0xc,%esp
    68f3:	6a 00                	push   $0x0
    68f5:	e8 50 0a 01 00       	call   1734a <close>
		if (open("/etc/rc", O_RDONLY, 0))
    68fa:	8d 83 63 65 ff ff    	lea    -0x9a9d(%ebx),%eax
    6900:	83 c4 0c             	add    $0xc,%esp
    6903:	6a 00                	push   $0x0
    6905:	6a 00                	push   $0x0
    6907:	50                   	push   %eax
    6908:	e8 09 0a 01 00       	call   17316 <open>
    690d:	83 c4 10             	add    $0x10,%esp
    6910:	85 c0                	test   %eax,%eax
    6912:	74 0d                	je     6921 <init+0xcb>
			_exit(1);												// 若打开文件失败,则退出(lib/_exit.c).
    6914:	83 ec 0c             	sub    $0xc,%esp
    6917:	6a 01                	push   $0x1
    6919:	e8 ea 09 01 00       	call   17308 <_exit>
    691e:	83 c4 10             	add    $0x10,%esp
		execve("/bin/sh", argv_rc, envp_rc);						// 替换成/bin/sh程序并执行.
    6921:	8d 83 34 00 00 00    	lea    0x34(%ebx),%eax
    6927:	51                   	push   %ecx
    6928:	50                   	push   %eax
    6929:	8d 83 40 00 00 00    	lea    0x40(%ebx),%eax
    692f:	50                   	push   %eax
    6930:	8d 83 05 66 ff ff    	lea    -0x99fb(%ebx),%eax
    6936:	50                   	push   %eax
    6937:	e8 ba 0a 01 00       	call   173f6 <execve>
		_exit(2);													// 若execve()执行失败则退出.
    693c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    6943:	e8 c0 09 01 00       	call   17308 <_exit>
    6948:	eb 33                	jmp    697d <init+0x127>
    694a:	89 c6                	mov    %eax,%esi
    }
	// 下面还是父进程（1）执行的语句。wait()等待子进程停止或终止，返回值应是子进程的进程号（pid)。这三句的作用是父进程等待子进程
	// 的结束。&i是存放返回状态信息的位置。如果wait()返回值不等于子进程号，则继续等待。
  	if (pid > 0)
    694c:	7e 14                	jle    6962 <init+0x10c>
		while (pid != wait(&i));
    694e:	83 ec 0c             	sub    $0xc,%esp
    6951:	8d 44 24 18          	lea    0x18(%esp),%eax
    6955:	50                   	push   %eax
    6956:	e8 03 0b 01 00       	call   1745e <wait>
    695b:	83 c4 10             	add    $0x10,%esp
    695e:	39 f0                	cmp    %esi,%eax
    6960:	75 ec                	jne    694e <init+0xf8>
	// 失败”信息并继续执行。对于所创建的子进程将关闭所有以前还遗留的句柄（stdin、stdout、stderr），新创建一个会话并设置进程组号，
	// 然后重新打开/dev/tty0作为stdin，并复制成stdout和stderr。再次执行系统解释程序/bin/sh。但这次执行所选用的参数和环境数组另
	// 选了一套。然后父进程再次运行wait()等等。如果子进程又停止了执行，则在标准输出上显示出错信息“子进程pid停止了运行，返回码是i”，
	// 然后继续重试下去...，形成“大”死循环。
	while (1) {
		if ((pid = fork()) < 0) {
    6962:	e8 21 fe ff ff       	call   6788 <fork>
    6967:	85 c0                	test   %eax,%eax
    6969:	89 c6                	mov    %eax,%esi
    696b:	79 15                	jns    6982 <init+0x12c>
			printf("Fork failed in init %c\r\n", ' ');
    696d:	8d 83 6b 65 ff ff    	lea    -0x9a95(%ebx),%eax
    6973:	52                   	push   %edx
    6974:	52                   	push   %edx
    6975:	6a 20                	push   $0x20
    6977:	50                   	push   %eax
    6978:	e8 9e fe ff ff       	call   681b <printf>
			continue;
    697d:	83 c4 10             	add    $0x10,%esp
    6980:	eb e0                	jmp    6962 <init+0x10c>
		}
		if (!pid) {                             					// 新的子进程。
    6982:	75 74                	jne    69f8 <init+0x1a2>
			close(0); close(1); close(2);
    6984:	83 ec 0c             	sub    $0xc,%esp
    6987:	6a 00                	push   $0x0
    6989:	e8 bc 09 01 00       	call   1734a <close>
    698e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    6995:	e8 b0 09 01 00       	call   1734a <close>
    699a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
    69a1:	e8 a4 09 01 00       	call   1734a <close>
			setsid();                       						// 创建一新的会话期，见后面说明。
    69a6:	e8 27 0a 01 00       	call   173d2 <setsid>
			(void) open("/dev/tty1", O_RDWR, 0);
    69ab:	83 c4 0c             	add    $0xc,%esp
    69ae:	6a 00                	push   $0x0
    69b0:	6a 02                	push   $0x2
    69b2:	57                   	push   %edi
    69b3:	e8 5e 09 01 00       	call   17316 <open>
			(void) dup(0);
    69b8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    69bf:	e8 e4 09 01 00       	call   173a8 <dup>
			(void) dup(0);
    69c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    69cb:	e8 d8 09 01 00       	call   173a8 <dup>
			_exit(execve("/bin/sh", argv, envp));
    69d0:	8d 83 20 00 00 00    	lea    0x20(%ebx),%eax
    69d6:	83 c4 0c             	add    $0xc,%esp
    69d9:	50                   	push   %eax
    69da:	8d 83 2c 00 00 00    	lea    0x2c(%ebx),%eax
    69e0:	50                   	push   %eax
    69e1:	8d 83 05 66 ff ff    	lea    -0x99fb(%ebx),%eax
    69e7:	50                   	push   %eax
    69e8:	e8 09 0a 01 00       	call   173f6 <execve>
    69ed:	89 04 24             	mov    %eax,(%esp)
    69f0:	e8 13 09 01 00       	call   17308 <_exit>
    69f5:	83 c4 10             	add    $0x10,%esp
		}
		while (1)
			if (pid == wait(&i))
    69f8:	83 ec 0c             	sub    $0xc,%esp
    69fb:	8d 44 24 18          	lea    0x18(%esp),%eax
    69ff:	50                   	push   %eax
    6a00:	e8 59 0a 01 00       	call   1745e <wait>
    6a05:	83 c4 10             	add    $0x10,%esp
    6a08:	39 f0                	cmp    %esi,%eax
    6a0a:	75 ec                	jne    69f8 <init+0x1a2>
				break;
		printf("\n\rchild %d died with code %04x\n\r", pid, i);
    6a0c:	50                   	push   %eax
    6a0d:	8d 83 84 65 ff ff    	lea    -0x9a7c(%ebx),%eax
    6a13:	ff 74 24 10          	pushl  0x10(%esp)
    6a17:	56                   	push   %esi
    6a18:	50                   	push   %eax
    6a19:	e8 fd fd ff ff       	call   681b <printf>
		sync();
    6a1e:	e8 d4 fd ff ff       	call   67f7 <sync>
    6a23:	e9 55 ff ff ff       	jmp    697d <init+0x127>

00006a28 <__x86.get_pc_thunk.dx>:
    6a28:	8b 14 24             	mov    (%esp),%edx
    6a2b:	c3                   	ret    

00006a2c <__x86.get_pc_thunk.bx>:
    6a2c:	8b 1c 24             	mov    (%esp),%ebx
    6a2f:	c3                   	ret    

00006a30 <sys_alarm>:
// 进程数据结构中报警定时值alarm的单位是系统滴答（1滴答为10毫秒），它是系统开机起到设置定时操作时系统滴答值jiffies和转换成滴答
// 单位的定时值之和，即'jiffies + HZ*定时秒值'。而参数给出的是以秒为单位的定时值，因此本函数的主要操作是进行两个单位的转换。
// 其中常数HZ = 100,是内核系统运行频率。定义在inlucde/sched.h上。
// 参数seconds是新的定时时间值，单位是秒。
int sys_alarm(long seconds)
{
    6a30:	57                   	push   %edi
    6a31:	56                   	push   %esi
    6a32:	31 c0                	xor    %eax,%eax
    6a34:	53                   	push   %ebx
    6a35:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    6a39:	e8 ee ff ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    6a3e:	81 c3 c2 a5 01 00    	add    $0x1a5c2,%ebx
	int old = current->alarm;
    6a44:	8b b3 60 13 00 00    	mov    0x1360(%ebx),%esi
    6a4a:	8b 96 dc 02 00 00    	mov    0x2dc(%esi),%edx

	if (old)
    6a50:	85 d2                	test   %edx,%edx
    6a52:	74 13                	je     6a67 <sys_alarm+0x37>
		old = (old - jiffies) / HZ;
    6a54:	8b 83 6c 1a 00 00    	mov    0x1a6c(%ebx),%eax
    6a5a:	bf 64 00 00 00       	mov    $0x64,%edi
    6a5f:	29 c2                	sub    %eax,%edx
    6a61:	89 d0                	mov    %edx,%eax
    6a63:	31 d2                	xor    %edx,%edx
    6a65:	f7 f7                	div    %edi
	current->alarm = (seconds>0)?(jiffies+HZ*seconds):0;
    6a67:	31 d2                	xor    %edx,%edx
    6a69:	85 c9                	test   %ecx,%ecx
    6a6b:	7e 0b                	jle    6a78 <sys_alarm+0x48>
    6a6d:	8b 93 6c 1a 00 00    	mov    0x1a6c(%ebx),%edx
    6a73:	6b c9 64             	imul   $0x64,%ecx,%ecx
    6a76:	01 ca                	add    %ecx,%edx
    6a78:	89 96 dc 02 00 00    	mov    %edx,0x2dc(%esi)
	return (old);
}
    6a7e:	5b                   	pop    %ebx
    6a7f:	5e                   	pop    %esi
    6a80:	5f                   	pop    %edi
    6a81:	c3                   	ret    

00006a82 <sys_getpid>:

// 取当前进程号pid。
int sys_getpid(void)
{
    6a82:	e8 f3 33 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6a87:	05 79 a5 01 00       	add    $0x1a579,%eax
	return current->pid;
    6a8c:	8b 80 60 13 00 00    	mov    0x1360(%eax),%eax
    6a92:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
}
    6a98:	c3                   	ret    

00006a99 <sys_getppid>:

// 取父进程号ppid。
int sys_getppid(void)
{
    6a99:	e8 dc 33 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6a9e:	05 62 a5 01 00       	add    $0x1a562,%eax
	return current->p_pptr->pid;
    6aa3:	8b 80 60 13 00 00    	mov    0x1360(%eax),%eax
    6aa9:	8b 80 bc 02 00 00    	mov    0x2bc(%eax),%eax
    6aaf:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
}
    6ab5:	c3                   	ret    

00006ab6 <sys_getuid>:

// 取用户uid。
int sys_getuid(void)
{
    6ab6:	e8 bf 33 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6abb:	05 45 a5 01 00       	add    $0x1a545,%eax
	return current->uid;
    6ac0:	8b 80 60 13 00 00    	mov    0x1360(%eax),%eax
    6ac6:	0f b7 80 cc 02 00 00 	movzwl 0x2cc(%eax),%eax
}
    6acd:	c3                   	ret    

00006ace <sys_geteuid>:

// 取有效的用户号euid。
int sys_geteuid(void)
{
    6ace:	e8 a7 33 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6ad3:	05 2d a5 01 00       	add    $0x1a52d,%eax
	return current->euid;
    6ad8:	8b 80 60 13 00 00    	mov    0x1360(%eax),%eax
    6ade:	0f b7 80 ce 02 00 00 	movzwl 0x2ce(%eax),%eax
}
    6ae5:	c3                   	ret    

00006ae6 <sys_getgid>:

// 取组号gid。
int sys_getgid(void)
{
    6ae6:	e8 8f 33 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6aeb:	05 15 a5 01 00       	add    $0x1a515,%eax
	return current->gid;
    6af0:	8b 80 60 13 00 00    	mov    0x1360(%eax),%eax
    6af6:	0f b7 80 d2 02 00 00 	movzwl 0x2d2(%eax),%eax
}
    6afd:	c3                   	ret    

00006afe <sys_getegid>:

// 取有效的组号egid。
int sys_getegid(void)
{
    6afe:	e8 77 33 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6b03:	05 fd a4 01 00       	add    $0x1a4fd,%eax
	return current->egid;
    6b08:	8b 80 60 13 00 00    	mov    0x1360(%eax),%eax
    6b0e:	0f b7 80 d4 02 00 00 	movzwl 0x2d4(%eax),%eax
}
    6b15:	c3                   	ret    

00006b16 <sys_nice>:

// 系统调用功能 -- 降低对CPU的使用优先权（有人会用吗？）。
// 应该限制increment为大于0的值，否则可使优先仅增大！！
int sys_nice(long increment)
{
    6b16:	e8 5f 33 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6b1b:	05 e5 a4 01 00       	add    $0x1a4e5,%eax
	if (current->priority-increment > 0)
    6b20:	8b 90 60 13 00 00    	mov    0x1360(%eax),%edx
    6b26:	8b 42 08             	mov    0x8(%edx),%eax
    6b29:	2b 44 24 04          	sub    0x4(%esp),%eax
    6b2d:	85 c0                	test   %eax,%eax
    6b2f:	7e 03                	jle    6b34 <sys_nice+0x1e>
		current->priority -= increment;
    6b31:	89 42 08             	mov    %eax,0x8(%edx)
	return 0;
}
    6b34:	31 c0                	xor    %eax,%eax
    6b36:	c3                   	ret    

00006b37 <show_task>:
{
    6b37:	56                   	push   %esi
    6b38:	53                   	push   %ebx
    6b39:	83 c8 ff             	or     $0xffffffff,%eax
    6b3c:	51                   	push   %ecx
    6b3d:	8b 74 24 14          	mov    0x14(%esp),%esi
    6b41:	e8 e6 fe ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    6b46:	81 c3 ba a4 01 00    	add    $0x1a4ba,%ebx
		p->state, p->p_pptr->pid, p->p_cptr ? p->p_cptr->pid : -1);
    6b4c:	8b 96 c0 02 00 00    	mov    0x2c0(%esi),%edx
	printk("%d: pid=%d, state=%d, father=%d, child=%d, ", nr, p->pid,
    6b52:	85 d2                	test   %edx,%edx
    6b54:	74 06                	je     6b5c <show_task+0x25>
    6b56:	8b 82 2c 02 00 00    	mov    0x22c(%edx),%eax
    6b5c:	52                   	push   %edx
    6b5d:	52                   	push   %edx
    6b5e:	50                   	push   %eax
    6b5f:	8b 86 bc 02 00 00    	mov    0x2bc(%esi),%eax
    6b65:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    6b6b:	8d 83 50 66 ff ff    	lea    -0x99b0(%ebx),%eax
    6b71:	ff 36                	pushl  (%esi)
    6b73:	ff b6 2c 02 00 00    	pushl  0x22c(%esi)
    6b79:	ff 74 24 28          	pushl  0x28(%esp)
    6b7d:	50                   	push   %eax
    6b7e:	e8 9e 15 00 00       	call   8121 <printk>
    6b83:	83 c4 20             	add    $0x20,%esp
	i = 0;
    6b86:	31 c0                	xor    %eax,%eax
	while (i < j && !((char *)(p + 1))[i])				// 检测指定任务数据结构以后等于0的字节数.
    6b88:	80 bc 06 84 04 00 00 	cmpb   $0x0,0x484(%esi,%eax,1)
    6b8f:	00 
    6b90:	75 08                	jne    6b9a <show_task+0x63>
		i++;
    6b92:	40                   	inc    %eax
	while (i < j && !((char *)(p + 1))[i])				// 检测指定任务数据结构以后等于0的字节数.
    6b93:	3d 7c 0b 00 00       	cmp    $0xb7c,%eax
    6b98:	75 ee                	jne    6b88 <show_task+0x51>
	printk("%d/%d chars free in kstack\n\r", i, j);
    6b9a:	52                   	push   %edx
    6b9b:	68 7c 0b 00 00       	push   $0xb7c
    6ba0:	50                   	push   %eax
    6ba1:	8d 83 7c 66 ff ff    	lea    -0x9984(%ebx),%eax
    6ba7:	50                   	push   %eax
    6ba8:	e8 74 15 00 00       	call   8121 <printk>
	printk("   PC=%08X.", *(1019 + (unsigned long *) p));
    6bad:	59                   	pop    %ecx
    6bae:	58                   	pop    %eax
    6baf:	8d 83 99 66 ff ff    	lea    -0x9967(%ebx),%eax
    6bb5:	ff b6 ec 0f 00 00    	pushl  0xfec(%esi)
    6bbb:	50                   	push   %eax
    6bbc:	e8 60 15 00 00       	call   8121 <printk>
	if (p->p_ysptr || p->p_osptr)
    6bc1:	8b 86 c4 02 00 00    	mov    0x2c4(%esi),%eax
    6bc7:	83 c4 10             	add    $0x10,%esp
    6bca:	85 c0                	test   %eax,%eax
    6bcc:	75 09                	jne    6bd7 <show_task+0xa0>
    6bce:	83 be c8 02 00 00 00 	cmpl   $0x0,0x2c8(%esi)
    6bd5:	74 2b                	je     6c02 <show_task+0xcb>
			p->p_osptr ? p->p_osptr->pid : -1);
    6bd7:	8b 96 c8 02 00 00    	mov    0x2c8(%esi),%edx
		printk("   Younger sib=%d, older sib=%d\n\r",
    6bdd:	83 c9 ff             	or     $0xffffffff,%ecx
    6be0:	85 d2                	test   %edx,%edx
    6be2:	74 06                	je     6bea <show_task+0xb3>
    6be4:	8b 8a 2c 02 00 00    	mov    0x22c(%edx),%ecx
    6bea:	83 ca ff             	or     $0xffffffff,%edx
    6bed:	85 c0                	test   %eax,%eax
    6bef:	74 06                	je     6bf7 <show_task+0xc0>
    6bf1:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    6bf7:	8d 83 a5 66 ff ff    	lea    -0x995b(%ebx),%eax
    6bfd:	56                   	push   %esi
    6bfe:	51                   	push   %ecx
    6bff:	52                   	push   %edx
    6c00:	eb 09                	jmp    6c0b <show_task+0xd4>
		printk("\n\r");
    6c02:	8d 83 42 70 ff ff    	lea    -0x8fbe(%ebx),%eax
    6c08:	83 ec 0c             	sub    $0xc,%esp
    6c0b:	50                   	push   %eax
    6c0c:	e8 10 15 00 00       	call   8121 <printk>
    6c11:	83 c4 10             	add    $0x10,%esp
}
    6c14:	58                   	pop    %eax
    6c15:	5b                   	pop    %ebx
    6c16:	5e                   	pop    %esi
    6c17:	c3                   	ret    

00006c18 <show_state>:
{
    6c18:	56                   	push   %esi
    6c19:	53                   	push   %ebx
	for (i = 0; i < NR_TASKS; i++)
    6c1a:	31 f6                	xor    %esi,%esi
    6c1c:	e8 0b fe ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    6c21:	81 c3 df a3 01 00    	add    $0x1a3df,%ebx
{
    6c27:	83 ec 10             	sub    $0x10,%esp
	printk("\rTask-info:\n\r");
    6c2a:	8d 83 c7 66 ff ff    	lea    -0x9939(%ebx),%eax
    6c30:	50                   	push   %eax
    6c31:	e8 eb 14 00 00       	call   8121 <printk>
    6c36:	83 c4 10             	add    $0x10,%esp
		if (task[i])
    6c39:	8b 84 b3 60 12 00 00 	mov    0x1260(%ebx,%esi,4),%eax
    6c40:	85 c0                	test   %eax,%eax
    6c42:	74 0c                	je     6c50 <show_state+0x38>
			show_task(i, task[i]);
    6c44:	52                   	push   %edx
    6c45:	52                   	push   %edx
    6c46:	50                   	push   %eax
    6c47:	56                   	push   %esi
    6c48:	e8 ea fe ff ff       	call   6b37 <show_task>
    6c4d:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NR_TASKS; i++)
    6c50:	46                   	inc    %esi
    6c51:	83 fe 40             	cmp    $0x40,%esi
    6c54:	75 e3                	jne    6c39 <show_state+0x21>
}
    6c56:	58                   	pop    %eax
    6c57:	5b                   	pop    %ebx
    6c58:	5e                   	pop    %esi
    6c59:	c3                   	ret    

00006c5a <math_state_restore>:
{
    6c5a:	e8 1b 32 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6c5f:	05 a1 a3 01 00       	add    $0x1a3a1,%eax
	if (last_task_used_math == current)
    6c64:	8b 88 60 13 00 00    	mov    0x1360(%eax),%ecx
    6c6a:	39 88 60 1a 00 00    	cmp    %ecx,0x1a60(%eax)
    6c70:	74 39                	je     6cab <math_state_restore+0x51>
	__asm__("fwait");
    6c72:	9b                   	fwait
	if (last_task_used_math) {
    6c73:	8b 90 60 1a 00 00    	mov    0x1a60(%eax),%edx
    6c79:	85 d2                	test   %edx,%edx
    6c7b:	74 06                	je     6c83 <math_state_restore+0x29>
		__asm__("fnsave %0"::"m" (last_task_used_math->tss.i387));
    6c7d:	dd b2 18 04 00 00    	fnsave 0x418(%edx)
	last_task_used_math = current;
    6c83:	8b 90 60 13 00 00    	mov    0x1360(%eax),%edx
	if (current->used_math) {
    6c89:	66 83 ba 28 03 00 00 	cmpw   $0x0,0x328(%edx)
    6c90:	00 
	last_task_used_math = current;
    6c91:	89 90 60 1a 00 00    	mov    %edx,0x1a60(%eax)
	if (current->used_math) {
    6c97:	74 07                	je     6ca0 <math_state_restore+0x46>
		__asm__("frstor %0"::"m" (current->tss.i387));
    6c99:	dd a2 18 04 00 00    	frstor 0x418(%edx)
    6c9f:	c3                   	ret    
		__asm__("fninit"::);					// 向协处理器发初始化命令.
    6ca0:	db e3                	fninit 
		current->used_math=1;					// 设置已使用协处理器标志.
    6ca2:	66 c7 82 28 03 00 00 	movw   $0x1,0x328(%edx)
    6ca9:	01 00 
}
    6cab:	c3                   	ret    

00006cac <schedule>:
{
    6cac:	e8 77 fd ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
    6cb1:	81 c2 4f a3 01 00    	add    $0x1a34f,%edx
    6cb7:	55                   	push   %ebp
    6cb8:	57                   	push   %edi
    6cb9:	56                   	push   %esi
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6cba:	8d b2 5c 13 00 00    	lea    0x135c(%edx),%esi
{
    6cc0:	53                   	push   %ebx
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6cc1:	8d 8a 60 12 00 00    	lea    0x1260(%edx),%ecx
{
    6cc7:	83 ec 10             	sub    $0x10,%esp
    6cca:	89 f3                	mov    %esi,%ebx
		if (*p) {
    6ccc:	8b 06                	mov    (%esi),%eax
    6cce:	85 c0                	test   %eax,%eax
    6cd0:	74 6c                	je     6d3e <schedule+0x92>
			if ((*p)->timeout && (*p)->timeout < jiffies) {
    6cd2:	8b b8 d8 02 00 00    	mov    0x2d8(%eax),%edi
    6cd8:	85 ff                	test   %edi,%edi
    6cda:	74 1f                	je     6cfb <schedule+0x4f>
    6cdc:	8b aa 6c 1a 00 00    	mov    0x1a6c(%edx),%ebp
    6ce2:	39 ef                	cmp    %ebp,%edi
    6ce4:	73 15                	jae    6cfb <schedule+0x4f>
				if ((*p)->state == TASK_INTERRUPTIBLE)
    6ce6:	83 38 01             	cmpl   $0x1,(%eax)
				(*p)->timeout = 0;
    6ce9:	c7 80 d8 02 00 00 00 	movl   $0x0,0x2d8(%eax)
    6cf0:	00 00 00 
				if ((*p)->state == TASK_INTERRUPTIBLE)
    6cf3:	75 06                	jne    6cfb <schedule+0x4f>
					(*p)->state = TASK_RUNNING;
    6cf5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			if ((*p)->alarm && (*p)->alarm < jiffies) {
    6cfb:	8b b8 dc 02 00 00    	mov    0x2dc(%eax),%edi
    6d01:	85 ff                	test   %edi,%edi
    6d03:	74 1b                	je     6d20 <schedule+0x74>
    6d05:	8b aa 6c 1a 00 00    	mov    0x1a6c(%edx),%ebp
    6d0b:	39 ef                	cmp    %ebp,%edi
    6d0d:	73 11                	jae    6d20 <schedule+0x74>
				(*p)->signal |= (1 << (SIGALRM - 1));
    6d0f:	81 48 0c 00 20 00 00 	orl    $0x2000,0xc(%eax)
				(*p)->alarm = 0;
    6d16:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%eax)
    6d1d:	00 00 00 
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) && (*p)->state == TASK_INTERRUPTIBLE)
    6d20:	8b b8 10 02 00 00    	mov    0x210(%eax),%edi
    6d26:	81 e7 ff fe fb ff    	and    $0xfffbfeff,%edi
    6d2c:	f7 d7                	not    %edi
    6d2e:	85 78 0c             	test   %edi,0xc(%eax)
    6d31:	74 0b                	je     6d3e <schedule+0x92>
    6d33:	83 38 01             	cmpl   $0x1,(%eax)
    6d36:	75 06                	jne    6d3e <schedule+0x92>
				(*p)->state = TASK_RUNNING;
    6d38:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6d3e:	83 ee 04             	sub    $0x4,%esi
    6d41:	39 ce                	cmp    %ecx,%esi
    6d43:	77 87                	ja     6ccc <schedule+0x20>
		c = -1;
    6d45:	83 cf ff             	or     $0xffffffff,%edi
		next = 0;
    6d48:	31 f6                	xor    %esi,%esi
		i = NR_TASKS;
    6d4a:	b8 40 00 00 00       	mov    $0x40,%eax
		while (--i) {
    6d4f:	48                   	dec    %eax
    6d50:	74 1e                	je     6d70 <schedule+0xc4>
			if (!*--p)
    6d52:	8b ac 82 60 12 00 00 	mov    0x1260(%edx,%eax,4),%ebp
    6d59:	85 ed                	test   %ebp,%ebp
    6d5b:	74 f2                	je     6d4f <schedule+0xa3>
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
    6d5d:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
    6d61:	75 ec                	jne    6d4f <schedule+0xa3>
    6d63:	8b 6d 04             	mov    0x4(%ebp),%ebp
    6d66:	39 fd                	cmp    %edi,%ebp
    6d68:	7e e5                	jle    6d4f <schedule+0xa3>
    6d6a:	89 ef                	mov    %ebp,%edi
    6d6c:	89 c6                	mov    %eax,%esi
    6d6e:	eb df                	jmp    6d4f <schedule+0xa3>
		if (c) break;
    6d70:	85 ff                	test   %edi,%edi
    6d72:	75 1c                	jne    6d90 <schedule+0xe4>
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6d74:	89 de                	mov    %ebx,%esi
			if (*p)
    6d76:	8b 3e                	mov    (%esi),%edi
    6d78:	85 ff                	test   %edi,%edi
    6d7a:	74 0b                	je     6d87 <schedule+0xdb>
				(*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
    6d7c:	8b 47 04             	mov    0x4(%edi),%eax
    6d7f:	d1 f8                	sar    %eax
    6d81:	03 47 08             	add    0x8(%edi),%eax
    6d84:	89 47 04             	mov    %eax,0x4(%edi)
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    6d87:	83 ee 04             	sub    $0x4,%esi
    6d8a:	39 ce                	cmp    %ecx,%esi
    6d8c:	77 e8                	ja     6d76 <schedule+0xca>
    6d8e:	eb b5                	jmp    6d45 <schedule+0x99>
	switch_to(next);					// 切换到任务号为next的任务,并运行之.
    6d90:	89 f2                	mov    %esi,%edx
    6d92:	8b 0c b1             	mov    (%ecx,%esi,4),%ecx
    6d95:	c1 e2 04             	shl    $0x4,%edx
    6d98:	83 c2 20             	add    $0x20,%edx
    6d9b:	39 0d 60 23 02 00    	cmp    %ecx,0x22360
    6da1:	74 19                	je     6dbc <schedule+0x110>
    6da3:	66 89 54 24 0c       	mov    %dx,0xc(%esp)
    6da8:	87 0d 60 23 02 00    	xchg   %ecx,0x22360
    6dae:	ff 6c 24 08          	ljmp   *0x8(%esp)
    6db2:	39 0d 60 2a 02 00    	cmp    %ecx,0x22a60
    6db8:	75 02                	jne    6dbc <schedule+0x110>
    6dba:	0f 06                	clts   
}
    6dbc:	83 c4 10             	add    $0x10,%esp
    6dbf:	5b                   	pop    %ebx
    6dc0:	5e                   	pop    %esi
    6dc1:	5f                   	pop    %edi
    6dc2:	5d                   	pop    %ebp
    6dc3:	c3                   	ret    

00006dc4 <sys_pause>:
{
    6dc4:	e8 b1 30 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6dc9:	05 37 a2 01 00       	add    $0x1a237,%eax
	current->state = TASK_INTERRUPTIBLE;
    6dce:	8b 80 60 13 00 00    	mov    0x1360(%eax),%eax
    6dd4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	schedule();
    6dda:	e8 cd fe ff ff       	call   6cac <schedule>
}
    6ddf:	31 c0                	xor    %eax,%eax
    6de1:	c3                   	ret    

00006de2 <__sleep_on>:
{
    6de2:	55                   	push   %ebp
    6de3:	57                   	push   %edi
    6de4:	56                   	push   %esi
    6de5:	53                   	push   %ebx
    6de6:	e8 41 fc ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    6deb:	81 c3 15 a2 01 00    	add    $0x1a215,%ebx
    6df1:	83 ec 0c             	sub    $0xc,%esp
	if (!p)
    6df4:	85 c0                	test   %eax,%eax
    6df6:	74 77                	je     6e6f <__sleep_on+0x8d>
    6df8:	89 c6                	mov    %eax,%esi
	if (current == &(init_task.task))
    6dfa:	8d 83 00 01 00 00    	lea    0x100(%ebx),%eax
    6e00:	39 83 60 13 00 00    	cmp    %eax,0x1360(%ebx)
    6e06:	89 d5                	mov    %edx,%ebp
    6e08:	75 12                	jne    6e1c <__sleep_on+0x3a>
		panic("task[0] trying to sleep");
    6e0a:	8d 83 d5 66 ff ff    	lea    -0x992b(%ebx),%eax
    6e10:	83 ec 0c             	sub    $0xc,%esp
    6e13:	50                   	push   %eax
    6e14:	e8 b9 12 00 00       	call   80d2 <panic>
    6e19:	83 c4 10             	add    $0x10,%esp
	*p = current;
    6e1c:	8b 83 60 13 00 00    	mov    0x1360(%ebx),%eax
	tmp = *p;
    6e22:	8b 3e                	mov    (%esi),%edi
	*p = current;
    6e24:	89 06                	mov    %eax,(%esi)
	current->state = state;
    6e26:	8b 83 60 13 00 00    	mov    0x1360(%ebx),%eax
    6e2c:	89 28                	mov    %ebp,(%eax)
repeat:	schedule();
    6e2e:	e8 79 fe ff ff       	call   6cac <schedule>
	if (*p && *p != current) {
    6e33:	8b 06                	mov    (%esi),%eax
    6e35:	85 c0                	test   %eax,%eax
    6e37:	74 18                	je     6e51 <__sleep_on+0x6f>
    6e39:	8b 93 60 13 00 00    	mov    0x1360(%ebx),%edx
    6e3f:	39 d0                	cmp    %edx,%eax
    6e41:	74 20                	je     6e63 <__sleep_on+0x81>
		(**p).state = 0;
    6e43:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		current->state = TASK_UNINTERRUPTIBLE;
    6e49:	c7 02 02 00 00 00    	movl   $0x2,(%edx)
		goto repeat;
    6e4f:	eb dd                	jmp    6e2e <__sleep_on+0x4c>
		printk("Warning: *P = NULL\n\r");
    6e51:	8d 83 ed 66 ff ff    	lea    -0x9913(%ebx),%eax
    6e57:	83 ec 0c             	sub    $0xc,%esp
    6e5a:	50                   	push   %eax
    6e5b:	e8 c1 12 00 00       	call   8121 <printk>
    6e60:	83 c4 10             	add    $0x10,%esp
	if (*p = tmp)
    6e63:	85 ff                	test   %edi,%edi
    6e65:	89 3e                	mov    %edi,(%esi)
    6e67:	74 06                	je     6e6f <__sleep_on+0x8d>
		tmp->state = 0;
    6e69:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
    6e6f:	83 c4 0c             	add    $0xc,%esp
    6e72:	5b                   	pop    %ebx
    6e73:	5e                   	pop    %esi
    6e74:	5f                   	pop    %edi
    6e75:	5d                   	pop    %ebp
    6e76:	c3                   	ret    

00006e77 <interruptible_sleep_on>:
	__sleep_on(p, TASK_INTERRUPTIBLE);
    6e77:	8b 44 24 04          	mov    0x4(%esp),%eax
    6e7b:	ba 01 00 00 00       	mov    $0x1,%edx
    6e80:	e9 5d ff ff ff       	jmp    6de2 <__sleep_on>

00006e85 <sleep_on>:
	__sleep_on(p, TASK_UNINTERRUPTIBLE);
    6e85:	8b 44 24 04          	mov    0x4(%esp),%eax
    6e89:	ba 02 00 00 00       	mov    $0x2,%edx
    6e8e:	e9 4f ff ff ff       	jmp    6de2 <__sleep_on>

00006e93 <wake_up>:
{
    6e93:	56                   	push   %esi
    6e94:	53                   	push   %ebx
    6e95:	52                   	push   %edx
    6e96:	8b 74 24 10          	mov    0x10(%esp),%esi
    6e9a:	e8 8d fb ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    6e9f:	81 c3 61 a1 01 00    	add    $0x1a161,%ebx
	if (p && *p) {
    6ea5:	85 f6                	test   %esi,%esi
    6ea7:	74 3e                	je     6ee7 <wake_up+0x54>
    6ea9:	8b 06                	mov    (%esi),%eax
    6eab:	85 c0                	test   %eax,%eax
    6ead:	74 38                	je     6ee7 <wake_up+0x54>
		if ((**p).state == TASK_STOPPED)						// 处于停止状态.
    6eaf:	83 38 04             	cmpl   $0x4,(%eax)
    6eb2:	75 12                	jne    6ec6 <wake_up+0x33>
			printk("wake_up: TASK_STOPPED");
    6eb4:	8d 83 02 67 ff ff    	lea    -0x98fe(%ebx),%eax
    6eba:	83 ec 0c             	sub    $0xc,%esp
    6ebd:	50                   	push   %eax
    6ebe:	e8 5e 12 00 00       	call   8121 <printk>
    6ec3:	83 c4 10             	add    $0x10,%esp
		if ((**p).state == TASK_ZOMBIE)							// 处于僵死状态.
    6ec6:	8b 06                	mov    (%esi),%eax
    6ec8:	83 38 03             	cmpl   $0x3,(%eax)
    6ecb:	75 12                	jne    6edf <wake_up+0x4c>
			printk("wake_up: TASK_ZOMBIE");
    6ecd:	8d 83 18 67 ff ff    	lea    -0x98e8(%ebx),%eax
    6ed3:	83 ec 0c             	sub    $0xc,%esp
    6ed6:	50                   	push   %eax
    6ed7:	e8 45 12 00 00       	call   8121 <printk>
    6edc:	83 c4 10             	add    $0x10,%esp
		(**p).state=0;											// 置为就绪状态TASK_RUNNING.
    6edf:	8b 06                	mov    (%esi),%eax
    6ee1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    6ee7:	58                   	pop    %eax
    6ee8:	5b                   	pop    %ebx
    6ee9:	5e                   	pop    %esi
    6eea:	c3                   	ret    

00006eeb <ticks_to_floppy_on>:
{
    6eeb:	57                   	push   %edi
    6eec:	56                   	push   %esi
	unsigned char mask = 0x10 << nr;
    6eed:	b8 10 00 00 00       	mov    $0x10,%eax
{
    6ef2:	53                   	push   %ebx
    6ef3:	8b 74 24 10          	mov    0x10(%esp),%esi
    6ef7:	e8 30 fb ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    6efc:	81 c3 04 a1 01 00    	add    $0x1a104,%ebx
	unsigned char mask = 0x10 << nr;
    6f02:	89 f1                	mov    %esi,%ecx
    6f04:	d3 e0                	shl    %cl,%eax
	if (nr > 3)
    6f06:	83 fe 03             	cmp    $0x3,%esi
	unsigned char mask = 0x10 << nr;
    6f09:	89 c7                	mov    %eax,%edi
	if (nr > 3)
    6f0b:	76 12                	jbe    6f1f <ticks_to_floppy_on+0x34>
		panic("floppy_on: nr>3");
    6f0d:	8d 83 2d 67 ff ff    	lea    -0x98d3(%ebx),%eax
    6f13:	83 ec 0c             	sub    $0xc,%esp
    6f16:	50                   	push   %eax
    6f17:	e8 b6 11 00 00       	call   80d2 <panic>
    6f1c:	83 c4 10             	add    $0x10,%esp
	moff_timer[nr] = 10000;							/* 100 s = very big :-) */	// 停转维持时间.
    6f1f:	c7 84 b3 80 1d 00 00 	movl   $0x2710,0x1d80(%ebx,%esi,4)
    6f26:	10 27 00 00 
	cli();											/* use floppy_off to turn it off */	// 关中断
    6f2a:	fa                   	cli    
	mask |= current_DOR;
    6f2b:	8a 8b 60 00 00 00    	mov    0x60(%ebx),%cl
	if (!selected) {
    6f31:	c7 c2 80 50 02 00    	mov    $0x25080,%edx
	mask |= current_DOR;
    6f37:	89 f8                	mov    %edi,%eax
    6f39:	09 c8                	or     %ecx,%eax
	if (!selected) {
    6f3b:	80 3a 00             	cmpb   $0x0,(%edx)
    6f3e:	75 05                	jne    6f45 <ticks_to_floppy_on+0x5a>
		mask &= 0xFC;
    6f40:	83 e0 fc             	and    $0xfffffffc,%eax
		mask |= nr;
    6f43:	09 f0                	or     %esi,%eax
	if (mask != current_DOR) {
    6f45:	38 c1                	cmp    %al,%cl
    6f47:	8d bb 90 1d 00 00    	lea    0x1d90(%ebx),%edi
    6f4d:	74 29                	je     6f78 <ticks_to_floppy_on+0x8d>
		outb(mask, FD_DOR);
    6f4f:	ba f2 03 00 00       	mov    $0x3f2,%edx
    6f54:	ee                   	out    %al,(%dx)
		if ((mask ^ current_DOR) & 0xf0)
    6f55:	31 c1                	xor    %eax,%ecx
    6f57:	80 e1 f0             	and    $0xf0,%cl
    6f5a:	74 09                	je     6f65 <ticks_to_floppy_on+0x7a>
			mon_timer[nr] = HZ / 2;
    6f5c:	c7 04 b7 32 00 00 00 	movl   $0x32,(%edi,%esi,4)
    6f63:	eb 0d                	jmp    6f72 <ticks_to_floppy_on+0x87>
		else if (mon_timer[nr] < 2)
    6f65:	83 3c b7 01          	cmpl   $0x1,(%edi,%esi,4)
    6f69:	7f 07                	jg     6f72 <ticks_to_floppy_on+0x87>
			mon_timer[nr] = 2;
    6f6b:	c7 04 b7 02 00 00 00 	movl   $0x2,(%edi,%esi,4)
		current_DOR = mask;
    6f72:	88 83 60 00 00 00    	mov    %al,0x60(%ebx)
	sti();											// 开中断.
    6f78:	fb                   	sti    
	return mon_timer[nr];							// 最后返回启动马达所需的时间值.
    6f79:	8b 04 b7             	mov    (%edi,%esi,4),%eax
}
    6f7c:	5b                   	pop    %ebx
    6f7d:	5e                   	pop    %esi
    6f7e:	5f                   	pop    %edi
    6f7f:	c3                   	ret    

00006f80 <floppy_on>:
{
    6f80:	56                   	push   %esi
    6f81:	53                   	push   %ebx
    6f82:	e8 f3 2e 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6f87:	05 79 a0 01 00       	add    $0x1a079,%eax
    6f8c:	52                   	push   %edx
    6f8d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	cli();
    6f91:	fa                   	cli    
		sleep_on(nr + wait_motor);
    6f92:	8d b4 98 a0 1d 00 00 	lea    0x1da0(%eax,%ebx,4),%esi
	while (ticks_to_floppy_on(nr))
    6f99:	83 ec 0c             	sub    $0xc,%esp
    6f9c:	53                   	push   %ebx
    6f9d:	e8 49 ff ff ff       	call   6eeb <ticks_to_floppy_on>
    6fa2:	83 c4 10             	add    $0x10,%esp
    6fa5:	85 c0                	test   %eax,%eax
    6fa7:	74 0e                	je     6fb7 <floppy_on+0x37>
		sleep_on(nr + wait_motor);
    6fa9:	83 ec 0c             	sub    $0xc,%esp
    6fac:	56                   	push   %esi
    6fad:	e8 d3 fe ff ff       	call   6e85 <sleep_on>
    6fb2:	83 c4 10             	add    $0x10,%esp
    6fb5:	eb e2                	jmp    6f99 <floppy_on+0x19>
	sti();
    6fb7:	fb                   	sti    
}
    6fb8:	58                   	pop    %eax
    6fb9:	5b                   	pop    %ebx
    6fba:	5e                   	pop    %esi
    6fbb:	c3                   	ret    

00006fbc <floppy_off>:
	moff_timer[nr] = 3 * HZ;
    6fbc:	8b 54 24 04          	mov    0x4(%esp),%edx
    6fc0:	e8 b5 2e 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    6fc5:	05 3b a0 01 00       	add    $0x1a03b,%eax
    6fca:	c7 84 90 80 1d 00 00 	movl   $0x12c,0x1d80(%eax,%edx,4)
    6fd1:	2c 01 00 00 
}
    6fd5:	c3                   	ret    

00006fd6 <do_floppy_timer>:
{
    6fd6:	57                   	push   %edi
    6fd7:	56                   	push   %esi
	unsigned char mask = 0x10;
    6fd8:	bf 10 00 00 00       	mov    $0x10,%edi
    6fdd:	e8 a0 2e 00 00       	call   9e82 <__x86.get_pc_thunk.si>
    6fe2:	81 c6 1e a0 01 00    	add    $0x1a01e,%esi
{
    6fe8:	53                   	push   %ebx
    6fe9:	31 db                	xor    %ebx,%ebx
		if (!(mask & current_DOR))						// 如果不是DOR指定的马达则跳过.
    6feb:	8a 8e 60 00 00 00    	mov    0x60(%esi),%cl
    6ff1:	89 f8                	mov    %edi,%eax
    6ff3:	84 c1                	test   %al,%cl
    6ff5:	74 53                	je     704a <do_floppy_timer+0x74>
		if (mon_timer[i]) {								// 如果马达启动定时到则唤醒进程.
    6ff7:	8b 94 33 90 1d 00 00 	mov    0x1d90(%ebx,%esi,1),%edx
    6ffe:	85 d2                	test   %edx,%edx
    7000:	74 23                	je     7025 <do_floppy_timer+0x4f>
			if (!--mon_timer[i])
    7002:	8d 42 ff             	lea    -0x1(%edx),%eax
    7005:	85 c0                	test   %eax,%eax
    7007:	89 84 33 90 1d 00 00 	mov    %eax,0x1d90(%ebx,%esi,1)
    700e:	75 3a                	jne    704a <do_floppy_timer+0x74>
				wake_up(i + wait_motor);
    7010:	8d 84 1e a0 1d 00 00 	lea    0x1da0(%esi,%ebx,1),%eax
    7017:	83 ec 0c             	sub    $0xc,%esp
    701a:	50                   	push   %eax
    701b:	e8 73 fe ff ff       	call   6e93 <wake_up>
    7020:	83 c4 10             	add    $0x10,%esp
    7023:	eb 25                	jmp    704a <do_floppy_timer+0x74>
		} else if (!moff_timer[i]) {					// 如果马达停转定时到则复位相应马达启动位,并且更新数字输出寄存器.
    7025:	8b 94 33 80 1d 00 00 	mov    0x1d80(%ebx,%esi,1),%edx
    702c:	85 d2                	test   %edx,%edx
    702e:	75 12                	jne    7042 <do_floppy_timer+0x6c>
			current_DOR &= ~mask;
    7030:	f7 d0                	not    %eax
			outb(current_DOR, FD_DOR);
    7032:	ba f2 03 00 00       	mov    $0x3f2,%edx
			current_DOR &= ~mask;
    7037:	21 c8                	and    %ecx,%eax
    7039:	88 86 60 00 00 00    	mov    %al,0x60(%esi)
			outb(current_DOR, FD_DOR);
    703f:	ee                   	out    %al,(%dx)
    7040:	eb 08                	jmp    704a <do_floppy_timer+0x74>
			moff_timer[i]--;							// 否则马达停转计时递减.
    7042:	4a                   	dec    %edx
    7043:	89 94 33 80 1d 00 00 	mov    %edx,0x1d80(%ebx,%esi,1)
    704a:	83 c3 04             	add    $0x4,%ebx
	for (i = 0 ; i < 4 ; i++, mask <<= 1) {
    704d:	01 ff                	add    %edi,%edi
    704f:	83 fb 10             	cmp    $0x10,%ebx
    7052:	75 97                	jne    6feb <do_floppy_timer+0x15>
}
    7054:	5b                   	pop    %ebx
    7055:	5e                   	pop    %esi
    7056:	5f                   	pop    %edi
    7057:	c3                   	ret    

00007058 <add_timer>:
{
    7058:	55                   	push   %ebp
    7059:	57                   	push   %edi
    705a:	56                   	push   %esi
    705b:	53                   	push   %ebx
    705c:	e8 cb f9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    7061:	81 c3 9f 9f 01 00    	add    $0x19f9f,%ebx
    7067:	83 ec 0c             	sub    $0xc,%esp
    706a:	8b 6c 24 24          	mov    0x24(%esp),%ebp
    706e:	8b 7c 24 20          	mov    0x20(%esp),%edi
	if (!fn)
    7072:	85 ed                	test   %ebp,%ebp
    7074:	74 7c                	je     70f2 <add_timer+0x9a>
	cli();
    7076:	fa                   	cli    
	if (jiffies <= 0)
    7077:	85 ff                	test   %edi,%edi
    7079:	7f 04                	jg     707f <add_timer+0x27>
		(fn)();
    707b:	ff d5                	call   *%ebp
    707d:	eb 72                	jmp    70f1 <add_timer+0x99>
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    707f:	8d b3 80 1a 00 00    	lea    0x1a80(%ebx),%esi
    7085:	8d 83 80 1d 00 00    	lea    0x1d80(%ebx),%eax
			if (!p->fn)
    708b:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
    708f:	74 09                	je     709a <add_timer+0x42>
		for (p = timer_list ; p < timer_list + TIME_REQUESTS ; p++)
    7091:	83 c6 0c             	add    $0xc,%esi
    7094:	39 c6                	cmp    %eax,%esi
    7096:	75 f3                	jne    708b <add_timer+0x33>
    7098:	eb 04                	jmp    709e <add_timer+0x46>
		if (p >= timer_list + TIME_REQUESTS)
    709a:	39 c6                	cmp    %eax,%esi
    709c:	72 12                	jb     70b0 <add_timer+0x58>
			panic("No more time requests free");
    709e:	8d 83 3d 67 ff ff    	lea    -0x98c3(%ebx),%eax
    70a4:	83 ec 0c             	sub    $0xc,%esp
    70a7:	50                   	push   %eax
    70a8:	e8 25 10 00 00       	call   80d2 <panic>
    70ad:	83 c4 10             	add    $0x10,%esp
		p->next = next_timer;
    70b0:	8b 83 74 1a 00 00    	mov    0x1a74(%ebx),%eax
		p->fn = fn;
    70b6:	89 6e 04             	mov    %ebp,0x4(%esi)
		p->jiffies = jiffies;
    70b9:	89 3e                	mov    %edi,(%esi)
		next_timer = p;
    70bb:	89 b3 74 1a 00 00    	mov    %esi,0x1a74(%ebx)
		p->next = next_timer;
    70c1:	89 46 08             	mov    %eax,0x8(%esi)
		while (p->next && p->next->jiffies < p->jiffies) {
    70c4:	8b 46 08             	mov    0x8(%esi),%eax
    70c7:	85 c0                	test   %eax,%eax
    70c9:	74 26                	je     70f1 <add_timer+0x99>
    70cb:	8b 08                	mov    (%eax),%ecx
    70cd:	8b 16                	mov    (%esi),%edx
    70cf:	39 d1                	cmp    %edx,%ecx
    70d1:	7d 1a                	jge    70ed <add_timer+0x95>
			p->jiffies -= p->next->jiffies;
    70d3:	29 ca                	sub    %ecx,%edx
			p->fn = p->next->fn;
    70d5:	8b 58 04             	mov    0x4(%eax),%ebx
			fn = p->fn;
    70d8:	8b 4e 04             	mov    0x4(%esi),%ecx
			p->jiffies -= p->next->jiffies;
    70db:	89 16                	mov    %edx,(%esi)
			p->fn = p->next->fn;
    70dd:	89 5e 04             	mov    %ebx,0x4(%esi)
			p->next->fn = fn;
    70e0:	89 48 04             	mov    %ecx,0x4(%eax)
			p->jiffies = p->next->jiffies;
    70e3:	8b 08                	mov    (%eax),%ecx
    70e5:	89 0e                	mov    %ecx,(%esi)
			p->next->jiffies = jiffies;
    70e7:	89 10                	mov    %edx,(%eax)
    70e9:	89 c6                	mov    %eax,%esi
    70eb:	eb d7                	jmp    70c4 <add_timer+0x6c>
			p->next->jiffies -= p->jiffies;
    70ed:	29 d1                	sub    %edx,%ecx
    70ef:	89 08                	mov    %ecx,(%eax)
	sti();
    70f1:	fb                   	sti    
}
    70f2:	83 c4 0c             	add    $0xc,%esp
    70f5:	5b                   	pop    %ebx
    70f6:	5e                   	pop    %esi
    70f7:	5f                   	pop    %edi
    70f8:	5d                   	pop    %ebp
    70f9:	c3                   	ret    

000070fa <do_timer>:
{
    70fa:	57                   	push   %edi
    70fb:	56                   	push   %esi
    70fc:	53                   	push   %ebx
    70fd:	8b 74 24 10          	mov    0x10(%esp),%esi
    7101:	e8 26 f9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    7106:	81 c3 fa 9e 01 00    	add    $0x19efa,%ebx
	if (blankcount || !blankinterval) {
    710c:	c7 c7 24 2d 03 00    	mov    $0x32d24,%edi
    7112:	8b 83 70 1a 00 00    	mov    0x1a70(%ebx),%eax
    7118:	83 3f 00             	cmpl   $0x0,(%edi)
    711b:	0f 85 d2 00 00 00    	jne    71f3 <do_timer+0xf9>
    7121:	c7 c2 28 2d 03 00    	mov    $0x32d28,%edx
    7127:	83 3a 00             	cmpl   $0x0,(%edx)
    712a:	0f 84 e8 00 00 00    	je     7218 <do_timer+0x11e>
	} else if (!blanked) {
    7130:	85 c0                	test   %eax,%eax
    7132:	75 0f                	jne    7143 <do_timer+0x49>
		blank_screen();
    7134:	e8 9a d2 00 00       	call   143d3 <blank_screen>
		blanked = 1;
    7139:	c7 83 70 1a 00 00 01 	movl   $0x1,0x1a70(%ebx)
    7140:	00 00 00 
	if (hd_timeout)
    7143:	c7 c2 f0 50 02 00    	mov    $0x250f0,%edx
    7149:	8b 02                	mov    (%edx),%eax
    714b:	85 c0                	test   %eax,%eax
    714d:	74 0c                	je     715b <do_timer+0x61>
		if (!--hd_timeout)
    714f:	48                   	dec    %eax
    7150:	85 c0                	test   %eax,%eax
    7152:	89 02                	mov    %eax,(%edx)
    7154:	75 05                	jne    715b <do_timer+0x61>
			hd_times_out();							// 硬盘访问超时处理(blk_drv/hd.c).
    7156:	e8 81 ac 00 00       	call   11ddc <hd_times_out>
	if (beepcount)									// 扬声器发声时间滴答数(chr_drv/console.c)
    715b:	c7 c2 20 2d 03 00    	mov    $0x32d20,%edx
    7161:	8b 02                	mov    (%edx),%eax
    7163:	85 c0                	test   %eax,%eax
    7165:	74 0c                	je     7173 <do_timer+0x79>
		if (!--beepcount)
    7167:	48                   	dec    %eax
    7168:	85 c0                	test   %eax,%eax
    716a:	89 02                	mov    %eax,(%edx)
    716c:	75 05                	jne    7173 <do_timer+0x79>
			sysbeepstop();
    716e:	e8 d1 d1 00 00       	call   14344 <sysbeepstop>
	if (cpl)
    7173:	85 f6                	test   %esi,%esi
    7175:	8b 83 60 13 00 00    	mov    0x1360(%ebx),%eax
    717b:	74 08                	je     7185 <do_timer+0x8b>
		current->utime++;
    717d:	ff 80 e0 02 00 00    	incl   0x2e0(%eax)
    7183:	eb 06                	jmp    718b <do_timer+0x91>
		current->stime++;
    7185:	ff 80 e4 02 00 00    	incl   0x2e4(%eax)
	if (next_timer) {
    718b:	8b 83 74 1a 00 00    	mov    0x1a74(%ebx),%eax
    7191:	85 c0                	test   %eax,%eax
    7193:	75 10                	jne    71a5 <do_timer+0xab>
	if (current_DOR & 0xf0)
    7195:	f6 83 60 00 00 00 f0 	testb  $0xf0,0x60(%ebx)
    719c:	74 2f                	je     71cd <do_timer+0xd3>
		do_floppy_timer();
    719e:	e8 33 fe ff ff       	call   6fd6 <do_floppy_timer>
    71a3:	eb 28                	jmp    71cd <do_timer+0xd3>
		next_timer->jiffies--;
    71a5:	ff 08                	decl   (%eax)
		while (next_timer && next_timer->jiffies <= 0) {
    71a7:	8b 83 74 1a 00 00    	mov    0x1a74(%ebx),%eax
    71ad:	85 c0                	test   %eax,%eax
    71af:	74 e4                	je     7195 <do_timer+0x9b>
    71b1:	83 38 00             	cmpl   $0x0,(%eax)
    71b4:	7f df                	jg     7195 <do_timer+0x9b>
			fn = next_timer->fn;
    71b6:	8b 50 04             	mov    0x4(%eax),%edx
			next_timer->fn = NULL;
    71b9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			next_timer = next_timer->next;
    71c0:	8b 40 08             	mov    0x8(%eax),%eax
    71c3:	89 83 74 1a 00 00    	mov    %eax,0x1a74(%ebx)
			(fn)();									// 调用定时处理函数.
    71c9:	ff d2                	call   *%edx
    71cb:	eb da                	jmp    71a7 <do_timer+0xad>
	if ((--current->counter) > 0) return;
    71cd:	8b 93 60 13 00 00    	mov    0x1360(%ebx),%edx
    71d3:	8b 42 04             	mov    0x4(%edx),%eax
    71d6:	48                   	dec    %eax
    71d7:	85 c0                	test   %eax,%eax
    71d9:	7e 05                	jle    71e0 <do_timer+0xe6>
    71db:	89 42 04             	mov    %eax,0x4(%edx)
    71de:	eb 3e                	jmp    721e <do_timer+0x124>
	if (!cpl) return;								// 对于内核态程序,不信赖counter值进行调试.
    71e0:	85 f6                	test   %esi,%esi
	current->counter = 0;
    71e2:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
	if (!cpl) return;								// 对于内核态程序,不信赖counter值进行调试.
    71e9:	74 33                	je     721e <do_timer+0x124>
}
    71eb:	5b                   	pop    %ebx
    71ec:	5e                   	pop    %esi
    71ed:	5f                   	pop    %edi
	schedule();
    71ee:	e9 b9 fa ff ff       	jmp    6cac <schedule>
		if (blanked)
    71f3:	85 c0                	test   %eax,%eax
    71f5:	74 1d                	je     7214 <do_timer+0x11a>
			unblank_screen();
    71f7:	e8 d8 d1 00 00       	call   143d4 <unblank_screen>
		if (blankcount)
    71fc:	8b 07                	mov    (%edi),%eax
    71fe:	85 c0                	test   %eax,%eax
    7200:	74 03                	je     7205 <do_timer+0x10b>
			blankcount--;
    7202:	48                   	dec    %eax
    7203:	89 07                	mov    %eax,(%edi)
		blanked = 0;
    7205:	c7 83 70 1a 00 00 00 	movl   $0x0,0x1a70(%ebx)
    720c:	00 00 00 
    720f:	e9 2f ff ff ff       	jmp    7143 <do_timer+0x49>
		if (blankcount)
    7214:	8b 07                	mov    (%edi),%eax
    7216:	eb ea                	jmp    7202 <do_timer+0x108>
		if (blanked)
    7218:	85 c0                	test   %eax,%eax
    721a:	74 e9                	je     7205 <do_timer+0x10b>
    721c:	eb d9                	jmp    71f7 <do_timer+0xfd>
}
    721e:	5b                   	pop    %ebx
    721f:	5e                   	pop    %esi
    7220:	5f                   	pop    %edi
    7221:	c3                   	ret    

00007222 <sched_init>:

// 内核调度程序的初始化子程序
void sched_init(void)
{
    7222:	e8 57 2c 00 00       	call   9e7e <__x86.get_pc_thunk.cx>
    7227:	81 c1 d9 9d 01 00    	add    $0x19dd9,%ecx
    722d:	56                   	push   %esi
    722e:	53                   	push   %ebx
		panic("Struct sigaction MUST be 16 bytes");
	// 在全局描述符表中设置初始任务(任务0)的任务状态段描述符和局部数据表描述符.
	// FIRST_TSS_ENTRY和FIRST_LDT_ENTRY的值分别是4和5,定义在include/linux/sched.h中.gdt是一个描述符表数组(include/linux/head.h),
	// 实际上对应程序head.s中的他已描述符表基址(gdt).因此gdt+FIRST_TSS_ENTRY即为gdt[FIRST_TSS_ENTRY](即是gdt[4]),即gdt数组第4项的地址
	// 参见include/asm/system.h
	set_tss_desc(gdt + FIRST_TSS_ENTRY, &(init_task.task.tss));
    722f:	c7 c2 88 5f 00 00    	mov    $0x5f88,%edx
    7235:	8d 81 b0 04 00 00    	lea    0x4b0(%ecx),%eax
    723b:	66 c7 42 20 68 00    	movw   $0x68,0x20(%edx)
    7241:	66 89 42 22          	mov    %ax,0x22(%edx)
    7245:	c1 c8 10             	ror    $0x10,%eax
    7248:	88 42 24             	mov    %al,0x24(%edx)
    724b:	c6 42 25 89          	movb   $0x89,0x25(%edx)
    724f:	c6 42 26 00          	movb   $0x0,0x26(%edx)
    7253:	88 62 27             	mov    %ah,0x27(%edx)
    7256:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt + FIRST_LDT_ENTRY, &(init_task.task.ldt));
    7259:	8d 81 98 04 00 00    	lea    0x498(%ecx),%eax
    725f:	66 c7 42 28 68 00    	movw   $0x68,0x28(%edx)
    7265:	66 89 42 2a          	mov    %ax,0x2a(%edx)
    7269:	c1 c8 10             	ror    $0x10,%eax
    726c:	88 42 2c             	mov    %al,0x2c(%edx)
    726f:	c6 42 2d 82          	movb   $0x82,0x2d(%edx)
    7273:	c6 42 2e 00          	movb   $0x0,0x2e(%edx)
    7277:	88 62 2f             	mov    %ah,0x2f(%edx)
    727a:	c1 c8 10             	ror    $0x10,%eax
    727d:	31 c0                	xor    %eax,%eax
	// 清任务数组和描述符表项(注意i=1开始,所以初始任务的描述符还在).描述符项结构定义在文件include/linux/head.h中.
	p = gdt + 2 + FIRST_TSS_ENTRY;
	// 初始化除进程一以外的其他进程指针
	for(i = 1; i < NR_TASKS; i++) {
		task[i] = NULL;
    727f:	c7 84 08 64 12 00 00 	movl   $0x0,0x1264(%eax,%ecx,1)
    7286:	00 00 00 00 
    728a:	83 c0 04             	add    $0x4,%eax
		p->a = p->b = 0;
    728d:	c7 42 34 00 00 00 00 	movl   $0x0,0x34(%edx)
    7294:	c7 42 30 00 00 00 00 	movl   $0x0,0x30(%edx)
		p++;
		p->a = p->b = 0;
    729b:	c7 42 3c 00 00 00 00 	movl   $0x0,0x3c(%edx)
    72a2:	83 c2 10             	add    $0x10,%edx
    72a5:	c7 42 28 00 00 00 00 	movl   $0x0,0x28(%edx)
	for(i = 1; i < NR_TASKS; i++) {
    72ac:	3d fc 00 00 00       	cmp    $0xfc,%eax
    72b1:	75 cc                	jne    727f <sched_init+0x5d>
	}
	/* Clear NT, so that we won't have troubles with that later on */
	/* 清除标志寄存器中的位NT,这样以后就不会有麻烦 */
	// EFLAGS中的NT标志位用于控制任务的嵌套调用.当NT位置位时,那么当前中断任务执行IRET指令时就会引起任务切换.NT指出TSS中的back_link字段是否有效.
	// NT=0时无效.
	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
    72b3:	9c                   	pushf  
    72b4:	81 24 24 ff bf ff ff 	andl   $0xffffbfff,(%esp)
    72bb:	9d                   	popf   
	// 将任务0的TSS段选择符加载到任务寄存器tr.将局部描述符表段选择符加载到局部描述符表寄存器ldtr中.注意!!是将GDT中相应LDT描述符的选择符加载到ldtr.
	// 只明确加这一次,以后新任务LDT的加载,是CPU根据TSS中的LDT项自动加载.
	ltr(0);								// 定义在include/linux/sched.h
    72bc:	b8 20 00 00 00       	mov    $0x20,%eax
    72c1:	0f 00 d8             	ltr    %ax
	lldt(0);							// 其中参数(0)是任务号.
    72c4:	b8 28 00 00 00       	mov    $0x28,%eax
    72c9:	0f 00 d0             	lldt   %ax
	// 下面代码用于初始化8253定时器.通道0,选择工作方式3,二进制计数方式.通道0的输出引脚接在中断控制主芯片的IRQ0上,它每10毫秒发出一个IRQ0请求.
	// LATCH是初始定时计数值.
	outb_p(0x36, 0x43);					/* binary, mode 3, LSB/MSB, ch 0 */
    72cc:	b8 36 00 00 00       	mov    $0x36,%eax
    72d1:	ba 43 00 00 00       	mov    $0x43,%edx
    72d6:	ee                   	out    %al,(%dx)
    72d7:	eb 00                	jmp    72d9 <sched_init+0xb7>
    72d9:	eb 00                	jmp    72db <sched_init+0xb9>
	outb_p(LATCH & 0xff, 0x40);			/* LSB */	// 定时值低字节
    72db:	ba 40 00 00 00       	mov    $0x40,%edx
    72e0:	b8 9b 00 00 00       	mov    $0x9b,%eax
    72e5:	ee                   	out    %al,(%dx)
    72e6:	eb 00                	jmp    72e8 <sched_init+0xc6>
    72e8:	eb 00                	jmp    72ea <sched_init+0xc8>
	outb(LATCH >> 8, 0x40);				/* MSB */	// 定时值高字节
    72ea:	b8 2e 00 00 00       	mov    $0x2e,%eax
    72ef:	ee                   	out    %al,(%dx)
	// 设置时钟中断处理程序句柄(设置时钟中断门).修改中断控制器屏蔽码,允许时钟中断.
	// 然后设置系统调用中断门.这两个设置中断描述衔表IDT中描述符的宏定义在文件include/asm/system.h中.两者的区别参见system.h文件开始处的说明.
	set_intr_gate(0x20, &timer_interrupt);
    72f0:	be 00 00 08 00       	mov    $0x80000,%esi
    72f5:	c7 c3 88 57 00 00    	mov    $0x5788,%ebx
    72fb:	c7 c2 4c 74 00 00    	mov    $0x744c,%edx
    7301:	89 f0                	mov    %esi,%eax
    7303:	66 89 d0             	mov    %dx,%ax
    7306:	66 ba 00 8e          	mov    $0x8e00,%dx
    730a:	89 83 00 01 00 00    	mov    %eax,0x100(%ebx)
    7310:	89 93 04 01 00 00    	mov    %edx,0x104(%ebx)
	outb(inb_p(0x21) & ~0x01, 0x21);
    7316:	ba 21 00 00 00       	mov    $0x21,%edx
    731b:	ec                   	in     (%dx),%al
    731c:	eb 00                	jmp    731e <sched_init+0xfc>
    731e:	eb 00                	jmp    7320 <sched_init+0xfe>
    7320:	25 fe 00 00 00       	and    $0xfe,%eax
    7325:	ee                   	out    %al,(%dx)
	set_system_gate(0x80, &system_call);
    7326:	c7 c2 54 73 00 00    	mov    $0x7354,%edx
    732c:	89 f0                	mov    %esi,%eax
    732e:	66 89 d0             	mov    %dx,%ax
    7331:	66 ba 00 ef          	mov    $0xef00,%dx
    7335:	89 83 00 04 00 00    	mov    %eax,0x400(%ebx)
    733b:	89 93 04 04 00 00    	mov    %edx,0x404(%ebx)
}
    7341:	5b                   	pop    %ebx
    7342:	5e                   	pop    %esi
    7343:	c3                   	ret    

00007344 <bad_sys_call>:
    7344:	6a da                	push   $0xffffffda
    7346:	eb 50                	jmp    7398 <ret_from_sys_call>

00007348 <reschedule>:
    7348:	68 98 73 00 00       	push   $0x7398
    734d:	e9 5a f9 ff ff       	jmp    6cac <schedule>
    7352:	66 90                	xchg   %ax,%ax

00007354 <system_call>:
    7354:	1e                   	push   %ds
    7355:	06                   	push   %es
    7356:	0f a0                	push   %fs
    7358:	50                   	push   %eax
    7359:	52                   	push   %edx
    735a:	51                   	push   %ecx
    735b:	53                   	push   %ebx
    735c:	ba 10 00 00 00       	mov    $0x10,%edx
    7361:	8e da                	mov    %edx,%ds
    7363:	8e c2                	mov    %edx,%es
    7365:	ba 17 00 00 00       	mov    $0x17,%edx
    736a:	8e e2                	mov    %edx,%fs
    736c:	3b 05 64 10 02 00    	cmp    0x21064,%eax
    7372:	73 d0                	jae    7344 <bad_sys_call>
    7374:	8b 1c 85 00 21 02 00 	mov    0x22100(,%eax,4),%ebx
    737b:	83 fb 00             	cmp    $0x0,%ebx
    737e:	75 05                	jne    7385 <sys_call>
    7380:	e8 d4 1b 00 00       	call   8f59 <sys_default>

00007385 <sys_call>:
    7385:	ff d3                	call   *%ebx
    7387:	50                   	push   %eax
    7388:	a1 60 23 02 00       	mov    0x22360,%eax
    738d:	83 38 00             	cmpl   $0x0,(%eax)
    7390:	75 b6                	jne    7348 <reschedule>
    7392:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
    7396:	74 b0                	je     7348 <reschedule>

00007398 <ret_from_sys_call>:
    7398:	a1 60 23 02 00       	mov    0x22360,%eax
    739d:	3b 05 60 22 02 00    	cmp    0x22260,%eax
    73a3:	74 34                	je     73d9 <ret_from_sys_call+0x41>
    73a5:	66 83 7c 24 24 0f    	cmpw   $0xf,0x24(%esp)
    73ab:	75 2c                	jne    73d9 <ret_from_sys_call+0x41>
    73ad:	66 83 7c 24 30 17    	cmpw   $0x17,0x30(%esp)
    73b3:	75 24                	jne    73d9 <ret_from_sys_call+0x41>
    73b5:	8b 58 0c             	mov    0xc(%eax),%ebx
    73b8:	8b 88 10 02 00 00    	mov    0x210(%eax),%ecx
    73be:	f7 d1                	not    %ecx
    73c0:	21 d9                	and    %ebx,%ecx
    73c2:	0f bc c9             	bsf    %ecx,%ecx
    73c5:	74 12                	je     73d9 <ret_from_sys_call+0x41>
    73c7:	0f b3 cb             	btr    %ecx,%ebx
    73ca:	89 58 0c             	mov    %ebx,0xc(%eax)
    73cd:	41                   	inc    %ecx
    73ce:	51                   	push   %ecx
    73cf:	e8 bd 28 00 00       	call   9c91 <do_signal>
    73d4:	59                   	pop    %ecx
    73d5:	85 c0                	test   %eax,%eax
    73d7:	75 af                	jne    7388 <sys_call+0x3>
    73d9:	58                   	pop    %eax
    73da:	5b                   	pop    %ebx
    73db:	59                   	pop    %ecx
    73dc:	5a                   	pop    %edx
    73dd:	83 c4 04             	add    $0x4,%esp
    73e0:	0f a1                	pop    %fs
    73e2:	07                   	pop    %es
    73e3:	1f                   	pop    %ds
    73e4:	cf                   	iret   
    73e5:	8d 76 00             	lea    0x0(%esi),%esi

000073e8 <coprocessor_error>:
    73e8:	1e                   	push   %ds
    73e9:	06                   	push   %es
    73ea:	0f a0                	push   %fs
    73ec:	6a ff                	push   $0xffffffff
    73ee:	52                   	push   %edx
    73ef:	51                   	push   %ecx
    73f0:	53                   	push   %ebx
    73f1:	50                   	push   %eax
    73f2:	b8 10 00 00 00       	mov    $0x10,%eax
    73f7:	8e d8                	mov    %eax,%ds
    73f9:	8e c0                	mov    %eax,%es
    73fb:	b8 17 00 00 00       	mov    $0x17,%eax
    7400:	8e e0                	mov    %eax,%fs
    7402:	68 98 73 00 00       	push   $0x7398
    7407:	e9 99 ef 00 00       	jmp    163a5 <math_error>

0000740c <device_not_available>:
    740c:	1e                   	push   %ds
    740d:	06                   	push   %es
    740e:	0f a0                	push   %fs
    7410:	6a ff                	push   $0xffffffff
    7412:	52                   	push   %edx
    7413:	51                   	push   %ecx
    7414:	53                   	push   %ebx
    7415:	50                   	push   %eax
    7416:	b8 10 00 00 00       	mov    $0x10,%eax
    741b:	8e d8                	mov    %eax,%ds
    741d:	8e c0                	mov    %eax,%es
    741f:	b8 17 00 00 00       	mov    $0x17,%eax
    7424:	8e e0                	mov    %eax,%fs
    7426:	68 98 73 00 00       	push   $0x7398
    742b:	0f 06                	clts   
    742d:	0f 20 c0             	mov    %cr0,%eax
    7430:	a9 04 00 00 00       	test   $0x4,%eax
    7435:	0f 84 1f f8 ff ff    	je     6c5a <math_state_restore>
    743b:	55                   	push   %ebp
    743c:	56                   	push   %esi
    743d:	57                   	push   %edi
    743e:	6a 00                	push   $0x0
    7440:	e8 40 e0 00 00       	call   15485 <math_emulate>
    7445:	83 c4 04             	add    $0x4,%esp
    7448:	5f                   	pop    %edi
    7449:	5e                   	pop    %esi
    744a:	5d                   	pop    %ebp
    744b:	c3                   	ret    

0000744c <timer_interrupt>:
    744c:	1e                   	push   %ds
    744d:	06                   	push   %es
    744e:	0f a0                	push   %fs
    7450:	6a ff                	push   $0xffffffff
    7452:	52                   	push   %edx
    7453:	51                   	push   %ecx
    7454:	53                   	push   %ebx
    7455:	50                   	push   %eax
    7456:	b8 10 00 00 00       	mov    $0x10,%eax
    745b:	8e d8                	mov    %eax,%ds
    745d:	8e c0                	mov    %eax,%es
    745f:	b8 17 00 00 00       	mov    $0x17,%eax
    7464:	8e e0                	mov    %eax,%fs
    7466:	ff 05 6c 2a 02 00    	incl   0x22a6c
    746c:	b0 20                	mov    $0x20,%al
    746e:	e6 20                	out    %al,$0x20
    7470:	8b 44 24 24          	mov    0x24(%esp),%eax
    7474:	83 e0 03             	and    $0x3,%eax
    7477:	50                   	push   %eax
    7478:	e8 7d fc ff ff       	call   70fa <do_timer>
    747d:	83 c4 04             	add    $0x4,%esp
    7480:	e9 13 ff ff ff       	jmp    7398 <ret_from_sys_call>
    7485:	8d 76 00             	lea    0x0(%esi),%esi

00007488 <sys_execve>:
    7488:	8d 44 24 20          	lea    0x20(%esp),%eax
    748c:	50                   	push   %eax
    748d:	e8 64 62 00 00       	call   d6f6 <do_execve>
    7492:	83 c4 04             	add    $0x4,%esp
    7495:	c3                   	ret    
    7496:	66 90                	xchg   %ax,%ax

00007498 <sys_fork>:
    7498:	e8 d5 0b 00 00       	call   8072 <find_empty_process>
    749d:	85 c0                	test   %eax,%eax
    749f:	78 0e                	js     74af <sys_fork+0x17>
    74a1:	0f a8                	push   %gs
    74a3:	56                   	push   %esi
    74a4:	57                   	push   %edi
    74a5:	55                   	push   %ebp
    74a6:	50                   	push   %eax
    74a7:	e8 b1 08 00 00       	call   7d5d <copy_process>
    74ac:	83 c4 14             	add    $0x14,%esp
    74af:	c3                   	ret    

000074b0 <hd_interrupt>:
    74b0:	50                   	push   %eax
    74b1:	51                   	push   %ecx
    74b2:	52                   	push   %edx
    74b3:	1e                   	push   %ds
    74b4:	06                   	push   %es
    74b5:	0f a0                	push   %fs
    74b7:	b8 10 00 00 00       	mov    $0x10,%eax
    74bc:	8e d8                	mov    %eax,%ds
    74be:	8e c0                	mov    %eax,%es
    74c0:	b8 17 00 00 00       	mov    $0x17,%eax
    74c5:	8e e0                	mov    %eax,%fs
    74c7:	b0 20                	mov    $0x20,%al
    74c9:	e6 a0                	out    %al,$0xa0
    74cb:	eb 00                	jmp    74cd <hd_interrupt+0x1d>
    74cd:	eb 00                	jmp    74cf <hd_interrupt+0x1f>
    74cf:	31 d2                	xor    %edx,%edx
    74d1:	89 15 f0 50 02 00    	mov    %edx,0x250f0
    74d7:	87 15 f4 50 02 00    	xchg   %edx,0x250f4
    74dd:	85 d2                	test   %edx,%edx
    74df:	75 05                	jne    74e6 <hd_interrupt+0x36>
    74e1:	ba ae 1d 01 00       	mov    $0x11dae,%edx
    74e6:	e6 20                	out    %al,$0x20
    74e8:	ff d2                	call   *%edx
    74ea:	0f a1                	pop    %fs
    74ec:	07                   	pop    %es
    74ed:	1f                   	pop    %ds
    74ee:	5a                   	pop    %edx
    74ef:	59                   	pop    %ecx
    74f0:	58                   	pop    %eax
    74f1:	cf                   	iret   

000074f2 <floppy_interrupt>:
    74f2:	50                   	push   %eax
    74f3:	51                   	push   %ecx
    74f4:	52                   	push   %edx
    74f5:	1e                   	push   %ds
    74f6:	06                   	push   %es
    74f7:	0f a0                	push   %fs
    74f9:	b8 10 00 00 00       	mov    $0x10,%eax
    74fe:	8e d8                	mov    %eax,%ds
    7500:	8e c0                	mov    %eax,%es
    7502:	b8 17 00 00 00       	mov    $0x17,%eax
    7507:	8e e0                	mov    %eax,%fs
    7509:	b0 20                	mov    $0x20,%al
    750b:	e6 20                	out    %al,$0x20
    750d:	31 c0                	xor    %eax,%eax
    750f:	87 05 84 50 02 00    	xchg   %eax,0x25084
    7515:	85 c0                	test   %eax,%eax
    7517:	75 05                	jne    751e <floppy_interrupt+0x2c>
    7519:	b8 f4 13 01 00       	mov    $0x113f4,%eax
    751e:	ff d0                	call   *%eax
    7520:	0f a1                	pop    %fs
    7522:	07                   	pop    %es
    7523:	1f                   	pop    %ds
    7524:	5a                   	pop    %edx
    7525:	59                   	pop    %ecx
    7526:	58                   	pop    %eax
    7527:	cf                   	iret   

00007528 <parallel_interrupt>:
    7528:	50                   	push   %eax
    7529:	b0 20                	mov    $0x20,%al
    752b:	e6 20                	out    %al,$0x20
    752d:	58                   	pop    %eax
    752e:	cf                   	iret   

0000752f <die>:
void alignment_check(void);					// int46(kernel/asm.s)

// 该子程序用来打印出错中断的名称,出错号,调用程序的EIP,EFLAGS,ESP,fs段寄存器值,段的基址,段的长度,进程号pid,任务号,10字节指令码.如果
// 堆栈在用户数据段,则还打印16字节堆栈内容.这些信息可用于程序调试.
static void die(char * str, long esp_ptr, long nr)
{
    752f:	55                   	push   %ebp
    7530:	57                   	push   %edi
	long * esp = (long *) esp_ptr;
	int i;

	printk("%s: %04x\n\r",str, nr & 0xffff);
    7531:	0f b7 c9             	movzwl %cx,%ecx
{
    7534:	56                   	push   %esi
    7535:	53                   	push   %ebx
    7536:	89 d6                	mov    %edx,%esi
    7538:	e8 ef f4 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    753d:	81 c3 c3 9a 01 00    	add    $0x19ac3,%ebx
    7543:	83 ec 10             	sub    $0x10,%esp
	printk("%s: %04x\n\r",str, nr & 0xffff);
    7546:	51                   	push   %ecx
    7547:	50                   	push   %eax
    7548:	8d 83 58 67 ff ff    	lea    -0x98a8(%ebx),%eax
    754e:	50                   	push   %eax
    754f:	e8 cd 0b 00 00       	call   8121 <printk>
	// 下行打印语句显示当前调用进程的CS:EIP,EFLAGS和SS:ESP的值.
	// (1) EIP:\t%04x:%p\n	-- esp[1]是段选择符(cs),esp[0]是eip
	// (2) EFLAGS:\t%p	-- esp[2]是eflags
	// (2) ESP:\t%04x:%p\n	-- esp[4]是原ss,esp[3]是原esp
	printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
    7554:	59                   	pop    %ecx
    7555:	8d 83 63 67 ff ff    	lea    -0x989d(%ebx),%eax
    755b:	5f                   	pop    %edi
    755c:	ff 76 0c             	pushl  0xc(%esi)
    755f:	ff 76 10             	pushl  0x10(%esi)
    7562:	ff 76 08             	pushl  0x8(%esi)
    7565:	ff 36                	pushl  (%esi)
    7567:	ff 76 04             	pushl  0x4(%esi)
    756a:	50                   	push   %eax
    756b:	e8 b1 0b 00 00       	call   8121 <printk>
		esp[1], esp[0], esp[2], esp[4], esp[3]);
	printk("fs: %04x\n", _fs());
    7570:	83 c4 18             	add    $0x18,%esp
    7573:	66 8c e0             	mov    %fs,%ax
    7576:	0f b7 c0             	movzwl %ax,%eax
    7579:	50                   	push   %eax
    757a:	8d 83 89 67 ff ff    	lea    -0x9877(%ebx),%eax
    7580:	50                   	push   %eax
    7581:	e8 9b 0b 00 00       	call   8121 <printk>
	printk("base: %p, limit: %p\n", get_base(current->ldt[1]), get_limit(0x17));
    7586:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
    758c:	83 c4 0c             	add    $0xc,%esp
    758f:	b8 17 00 00 00       	mov    $0x17,%eax
    7594:	0f 03 c0             	lsl    %ax,%eax
    7597:	40                   	inc    %eax
    7598:	8b 0f                	mov    (%edi),%ecx
    759a:	8a b1 a7 03 00 00    	mov    0x3a7(%ecx),%dh
    75a0:	8a 91 a4 03 00 00    	mov    0x3a4(%ecx),%dl
    75a6:	c1 e2 10             	shl    $0x10,%edx
    75a9:	66 8b 91 a2 03 00 00 	mov    0x3a2(%ecx),%dx
    75b0:	50                   	push   %eax
    75b1:	8d 83 93 67 ff ff    	lea    -0x986d(%ebx),%eax
    75b7:	52                   	push   %edx
    75b8:	50                   	push   %eax
    75b9:	e8 63 0b 00 00       	call   8121 <printk>
	if (esp[4] == 0x17) {						// 或原ss值为0x17(用户栈),则还打印出用户栈的4个长字值(16字节).
    75be:	83 c4 10             	add    $0x10,%esp
    75c1:	83 7e 10 17          	cmpl   $0x17,0x10(%esi)
    75c5:	75 52                	jne    7619 <die+0xea>
		printk("Stack: ");
    75c7:	8d 83 a8 67 ff ff    	lea    -0x9858(%ebx),%eax
    75cd:	83 ec 0c             	sub    $0xc,%esp
    75d0:	31 ed                	xor    %ebp,%ebp
    75d2:	50                   	push   %eax
    75d3:	e8 49 0b 00 00       	call   8121 <printk>
    75d8:	83 c4 10             	add    $0x10,%esp
		for (i = 0; i < 4; i++)
			printk("%p ", get_seg_long(0x17, i + (long *)esp[3]));
    75db:	8b 56 0c             	mov    0xc(%esi),%edx
    75de:	b8 17 00 00 00       	mov    $0x17,%eax
    75e3:	0f a0                	push   %fs
    75e5:	8e e0                	mov    %eax,%fs
    75e7:	64 8b 04 2a          	mov    %fs:(%edx,%ebp,1),%eax
    75eb:	0f a1                	pop    %fs
    75ed:	83 c5 04             	add    $0x4,%ebp
    75f0:	52                   	push   %edx
    75f1:	52                   	push   %edx
    75f2:	50                   	push   %eax
    75f3:	8d 83 b0 67 ff ff    	lea    -0x9850(%ebx),%eax
    75f9:	50                   	push   %eax
    75fa:	e8 22 0b 00 00       	call   8121 <printk>
		for (i = 0; i < 4; i++)
    75ff:	83 c4 10             	add    $0x10,%esp
    7602:	83 fd 10             	cmp    $0x10,%ebp
    7605:	75 d4                	jne    75db <die+0xac>
		printk("\n");
    7607:	8d 83 58 74 ff ff    	lea    -0x8ba8(%ebx),%eax
    760d:	83 ec 0c             	sub    $0xc,%esp
    7610:	50                   	push   %eax
    7611:	e8 0b 0b 00 00       	call   8121 <printk>
    7616:	83 c4 10             	add    $0x10,%esp
	}
	str(i);										// 取当前运行任务的任务号(include/linux/sched.h).
    7619:	31 c0                	xor    %eax,%eax
	printk("Pid: %d, process nr: %d\n\r", current->pid, 0xffff & i);
    761b:	51                   	push   %ecx
	str(i);										// 取当前运行任务的任务号(include/linux/sched.h).
    761c:	66 0f 00 c8          	str    %ax
    7620:	83 e8 20             	sub    $0x20,%eax
    7623:	c1 e8 04             	shr    $0x4,%eax
	printk("Pid: %d, process nr: %d\n\r", current->pid, 0xffff & i);
    7626:	0f b7 c0             	movzwl %ax,%eax
    7629:	50                   	push   %eax
    762a:	8b 07                	mov    (%edi),%eax
                        						// 进程号,任务号.
	for(i = 0; i < 10; i++)
    762c:	31 ff                	xor    %edi,%edi
	printk("Pid: %d, process nr: %d\n\r", current->pid, 0xffff & i);
    762e:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    7634:	8d 83 b4 67 ff ff    	lea    -0x984c(%ebx),%eax
    763a:	50                   	push   %eax
    763b:	e8 e1 0a 00 00       	call   8121 <printk>
    7640:	83 c4 10             	add    $0x10,%esp
		printk("%02x ", 0xff & get_seg_byte(esp[1], (i+(char *)esp[0])));
    7643:	8b 16                	mov    (%esi),%edx
    7645:	8b 46 04             	mov    0x4(%esi),%eax
    7648:	0f a0                	push   %fs
    764a:	8e e0                	mov    %eax,%fs
    764c:	64 8a 04 3a          	mov    %fs:(%edx,%edi,1),%al
    7650:	0f a1                	pop    %fs
    7652:	0f b6 c0             	movzbl %al,%eax
	for(i = 0; i < 10; i++)
    7655:	47                   	inc    %edi
		printk("%02x ", 0xff & get_seg_byte(esp[1], (i+(char *)esp[0])));
    7656:	52                   	push   %edx
    7657:	52                   	push   %edx
    7658:	50                   	push   %eax
    7659:	8d 83 ce 67 ff ff    	lea    -0x9832(%ebx),%eax
    765f:	50                   	push   %eax
    7660:	e8 bc 0a 00 00       	call   8121 <printk>
	for(i = 0; i < 10; i++)
    7665:	83 c4 10             	add    $0x10,%esp
    7668:	83 ff 0a             	cmp    $0xa,%edi
    766b:	75 d6                	jne    7643 <die+0x114>
	printk("\n\r");
    766d:	8d 83 42 70 ff ff    	lea    -0x8fbe(%ebx),%eax
    7673:	83 ec 0c             	sub    $0xc,%esp
    7676:	50                   	push   %eax
    7677:	e8 a5 0a 00 00       	call   8121 <printk>
	do_exit(11);								/* play segment exception */
    767c:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    7683:	e8 62 1f 00 00       	call   95ea <do_exit>
}
    7688:	83 c4 1c             	add    $0x1c,%esp
    768b:	5b                   	pop    %ebx
    768c:	5e                   	pop    %esi
    768d:	5f                   	pop    %edi
    768e:	5d                   	pop    %ebp
    768f:	c3                   	ret    

00007690 <do_double_fault>:

// 以下这些以do_开头的函数是asm.s中对应中断处理程序调用的C函数.
void do_double_fault(long esp, long error_code)
{
    7690:	e8 e5 27 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    7695:	05 6b 99 01 00       	add    $0x1996b,%eax
	die("double fault", esp, error_code);
    769a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    769e:	8b 54 24 04          	mov    0x4(%esp),%edx
    76a2:	8d 80 d4 67 ff ff    	lea    -0x982c(%eax),%eax
    76a8:	e9 82 fe ff ff       	jmp    752f <die>

000076ad <do_general_protection>:
}

void do_general_protection(long esp, long error_code)
{
    76ad:	e8 c8 27 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    76b2:	05 4e 99 01 00       	add    $0x1994e,%eax
	die("general protection", esp, error_code);
    76b7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    76bb:	8b 54 24 04          	mov    0x4(%esp),%edx
    76bf:	8d 80 e1 67 ff ff    	lea    -0x981f(%eax),%eax
    76c5:	e9 65 fe ff ff       	jmp    752f <die>

000076ca <do_alignment_check>:
}

void do_alignment_check(long esp, long error_code)
{
    76ca:	e8 ab 27 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    76cf:	05 31 99 01 00       	add    $0x19931,%eax
    die("alignment check", esp, error_code);
    76d4:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    76d8:	8b 54 24 04          	mov    0x4(%esp),%edx
    76dc:	8d 80 f4 67 ff ff    	lea    -0x980c(%eax),%eax
    76e2:	e9 48 fe ff ff       	jmp    752f <die>

000076e7 <do_divide_error>:
}

void do_divide_error(long esp, long error_code)
{
    76e7:	e8 8e 27 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    76ec:	05 14 99 01 00       	add    $0x19914,%eax
	die("divide error", esp, error_code);
    76f1:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    76f5:	8b 54 24 04          	mov    0x4(%esp),%edx
    76f9:	8d 80 04 68 ff ff    	lea    -0x97fc(%eax),%eax
    76ff:	e9 2b fe ff ff       	jmp    752f <die>

00007704 <do_int3>:
// 参数是进入中断后被顺序压入堆栈的寄存器值.参见asm.s程序.
void do_int3(long * esp, long error_code,
		long fs, long es, long ds,
		long ebp, long esi, long edi,
		long edx, long ecx, long ebx, long eax)
{
    7704:	57                   	push   %edi
    7705:	56                   	push   %esi
	int tr;

	__asm__("str %%ax":"=a" (tr):"0" (0));		// 取任务寄存器值->tr
    7706:	31 ff                	xor    %edi,%edi
{
    7708:	53                   	push   %ebx
	__asm__("str %%ax":"=a" (tr):"0" (0));		// 取任务寄存器值->tr
    7709:	89 f8                	mov    %edi,%eax
{
    770b:	8b 74 24 10          	mov    0x10(%esp),%esi
    770f:	e8 18 f3 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    7714:	81 c3 ec 98 01 00    	add    $0x198ec,%ebx
	__asm__("str %%ax":"=a" (tr):"0" (0));		// 取任务寄存器值->tr
    771a:	66 0f 00 c8          	str    %ax
    771e:	89 c7                	mov    %eax,%edi
	printk("eax\t\tebx\t\tecx\t\tedx\n\r%8x\t%8x\t%8x\t%8x\n\r",
    7720:	8d 83 11 68 ff ff    	lea    -0x97ef(%ebx),%eax
    7726:	83 ec 0c             	sub    $0xc,%esp
    7729:	ff 74 24 3c          	pushl  0x3c(%esp)
    772d:	ff 74 24 44          	pushl  0x44(%esp)
    7731:	ff 74 24 4c          	pushl  0x4c(%esp)
    7735:	ff 74 24 54          	pushl  0x54(%esp)
    7739:	50                   	push   %eax
    773a:	e8 e2 09 00 00       	call   8121 <printk>
		eax, ebx, ecx, edx);
	printk("esi\t\tedi\t\tebp\t\tesp\n\r%8x\t%8x\t%8x\t%8x\n\r",
    773f:	8d 83 37 68 ff ff    	lea    -0x97c9(%ebx),%eax
    7745:	83 c4 14             	add    $0x14,%esp
    7748:	56                   	push   %esi
    7749:	ff 74 24 34          	pushl  0x34(%esp)
    774d:	ff 74 24 40          	pushl  0x40(%esp)
    7751:	ff 74 24 40          	pushl  0x40(%esp)
    7755:	50                   	push   %eax
    7756:	e8 c6 09 00 00       	call   8121 <printk>
		esi, edi, ebp, (long) esp);
	printk("\n\rds\tes\tfs\ttr\n\r%4x\t%4x\t%4x\t%4x\n\r",
    775b:	8d 83 5d 68 ff ff    	lea    -0x97a3(%ebx),%eax
    7761:	83 c4 14             	add    $0x14,%esp
    7764:	57                   	push   %edi
    7765:	ff 74 24 28          	pushl  0x28(%esp)
    7769:	ff 74 24 30          	pushl  0x30(%esp)
    776d:	ff 74 24 38          	pushl  0x38(%esp)
    7771:	50                   	push   %eax
    7772:	e8 aa 09 00 00       	call   8121 <printk>
		ds, es, fs, tr);
	printk("EIP: %8x   CS: %4x  EFLAGS: %8x\n\r", esp[0], esp[1], esp[2]);
    7777:	8d 83 7e 68 ff ff    	lea    -0x9782(%ebx),%eax
    777d:	83 c4 20             	add    $0x20,%esp
    7780:	ff 76 08             	pushl  0x8(%esi)
    7783:	ff 76 04             	pushl  0x4(%esi)
    7786:	ff 36                	pushl  (%esi)
    7788:	50                   	push   %eax
    7789:	e8 93 09 00 00       	call   8121 <printk>
}
    778e:	83 c4 10             	add    $0x10,%esp
    7791:	5b                   	pop    %ebx
    7792:	5e                   	pop    %esi
    7793:	5f                   	pop    %edi
    7794:	c3                   	ret    

00007795 <do_nmi>:

void do_nmi(long esp, long error_code)
{
    7795:	e8 e0 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    779a:	05 66 98 01 00       	add    $0x19866,%eax
	die("nmi", esp, error_code);
    779f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    77a3:	8b 54 24 04          	mov    0x4(%esp),%edx
    77a7:	8d 80 a0 68 ff ff    	lea    -0x9760(%eax),%eax
    77ad:	e9 7d fd ff ff       	jmp    752f <die>

000077b2 <do_debug>:
}

void do_debug(long esp, long error_code)
{
    77b2:	e8 c3 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    77b7:	05 49 98 01 00       	add    $0x19849,%eax
	die("debug", esp, error_code);
    77bc:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    77c0:	8b 54 24 04          	mov    0x4(%esp),%edx
    77c4:	8d 80 a4 68 ff ff    	lea    -0x975c(%eax),%eax
    77ca:	e9 60 fd ff ff       	jmp    752f <die>

000077cf <do_overflow>:
}

void do_overflow(long esp, long error_code)
{
    77cf:	e8 a6 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    77d4:	05 2c 98 01 00       	add    $0x1982c,%eax
	die("overflow", esp, error_code);
    77d9:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    77dd:	8b 54 24 04          	mov    0x4(%esp),%edx
    77e1:	8d 80 aa 68 ff ff    	lea    -0x9756(%eax),%eax
    77e7:	e9 43 fd ff ff       	jmp    752f <die>

000077ec <do_bounds>:
}

void do_bounds(long esp, long error_code)
{
    77ec:	e8 89 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    77f1:	05 0f 98 01 00       	add    $0x1980f,%eax
	die("bounds", esp, error_code);
    77f6:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    77fa:	8b 54 24 04          	mov    0x4(%esp),%edx
    77fe:	8d 80 b3 68 ff ff    	lea    -0x974d(%eax),%eax
    7804:	e9 26 fd ff ff       	jmp    752f <die>

00007809 <do_invalid_op>:
}

void do_invalid_op(long esp, long error_code)
{
    7809:	e8 6c 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    780e:	05 f2 97 01 00       	add    $0x197f2,%eax
	die("invalid operand", esp, error_code);
    7813:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    7817:	8b 54 24 04          	mov    0x4(%esp),%edx
    781b:	8d 80 ba 68 ff ff    	lea    -0x9746(%eax),%eax
    7821:	e9 09 fd ff ff       	jmp    752f <die>

00007826 <do_device_not_available>:
}

void do_device_not_available(long esp, long error_code)
{
    7826:	e8 4f 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    782b:	05 d5 97 01 00       	add    $0x197d5,%eax
	die("device not available", esp, error_code);
    7830:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    7834:	8b 54 24 04          	mov    0x4(%esp),%edx
    7838:	8d 80 ca 68 ff ff    	lea    -0x9736(%eax),%eax
    783e:	e9 ec fc ff ff       	jmp    752f <die>

00007843 <do_coprocessor_segment_overrun>:
}

void do_coprocessor_segment_overrun(long esp, long error_code)
{
    7843:	e8 32 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    7848:	05 b8 97 01 00       	add    $0x197b8,%eax
	die("coprocessor segment overrun", esp, error_code);
    784d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    7851:	8b 54 24 04          	mov    0x4(%esp),%edx
    7855:	8d 80 df 68 ff ff    	lea    -0x9721(%eax),%eax
    785b:	e9 cf fc ff ff       	jmp    752f <die>

00007860 <do_invalid_TSS>:
}

void do_invalid_TSS(long esp, long error_code)
{
    7860:	e8 15 26 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    7865:	05 9b 97 01 00       	add    $0x1979b,%eax
	die("invalid TSS", esp, error_code);
    786a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    786e:	8b 54 24 04          	mov    0x4(%esp),%edx
    7872:	8d 80 fb 68 ff ff    	lea    -0x9705(%eax),%eax
    7878:	e9 b2 fc ff ff       	jmp    752f <die>

0000787d <do_segment_not_present>:
}

void do_segment_not_present(long esp, long error_code)
{
    787d:	e8 f8 25 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    7882:	05 7e 97 01 00       	add    $0x1977e,%eax
	die("segment not present", esp, error_code);
    7887:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    788b:	8b 54 24 04          	mov    0x4(%esp),%edx
    788f:	8d 80 07 69 ff ff    	lea    -0x96f9(%eax),%eax
    7895:	e9 95 fc ff ff       	jmp    752f <die>

0000789a <do_stack_segment>:
}

void do_stack_segment(long esp, long error_code)
{
    789a:	e8 db 25 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    789f:	05 61 97 01 00       	add    $0x19761,%eax
	die("stack segment", esp, error_code);
    78a4:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    78a8:	8b 54 24 04          	mov    0x4(%esp),%edx
    78ac:	8d 80 1b 69 ff ff    	lea    -0x96e5(%eax),%eax
    78b2:	e9 78 fc ff ff       	jmp    752f <die>

000078b7 <do_coprocessor_error>:
}

void do_coprocessor_error(long esp, long error_code)
{
    78b7:	e8 be 25 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    78bc:	05 44 97 01 00       	add    $0x19744,%eax
    78c1:	56                   	push   %esi
    78c2:	53                   	push   %ebx
	if (last_task_used_math != current)
    78c3:	c7 c6 60 2a 02 00    	mov    $0x22a60,%esi
    78c9:	c7 c3 60 23 02 00    	mov    $0x22360,%ebx
{
    78cf:	8b 54 24 0c          	mov    0xc(%esp),%edx
    78d3:	8b 4c 24 10          	mov    0x10(%esp),%ecx
	if (last_task_used_math != current)
    78d7:	8b 1b                	mov    (%ebx),%ebx
    78d9:	39 1e                	cmp    %ebx,(%esi)
    78db:	75 0d                	jne    78ea <do_coprocessor_error+0x33>
		return;
	die("coprocessor error", esp, error_code);
}
    78dd:	5b                   	pop    %ebx
    78de:	5e                   	pop    %esi
	die("coprocessor error", esp, error_code);
    78df:	8d 80 29 69 ff ff    	lea    -0x96d7(%eax),%eax
    78e5:	e9 45 fc ff ff       	jmp    752f <die>
}
    78ea:	5b                   	pop    %ebx
    78eb:	5e                   	pop    %esi
    78ec:	c3                   	ret    

000078ed <do_reserved>:

void do_reserved(long esp, long error_code)
{
    78ed:	e8 88 25 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    78f2:	05 0e 97 01 00       	add    $0x1970e,%eax
	die("reserved (15,17-47) error", esp, error_code);
    78f7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    78fb:	8b 54 24 04          	mov    0x4(%esp),%edx
    78ff:	8d 80 3b 69 ff ff    	lea    -0x96c5(%eax),%eax
    7905:	e9 25 fc ff ff       	jmp    752f <die>

0000790a <trap_init>:
// 下面是异常(陷阱)中断程序初始化子程序.设置它们的中断调用门(中断向量).
// set_trap_gate()与set_system_gate()都使用了中断描述符表IDT中的陷阱门(Trap Gate),它们之间的主要区别在于前者设置的特权级为0,
// 后者是3.因此断点陷阱中断int3,溢出中断overflow和边界出错中断bounds可以由任何程序调用.这两个函数均是嵌入式汇编宏程序,参见
// include/asm/system.h
void trap_init(void)
{
    790a:	55                   	push   %ebp
    790b:	57                   	push   %edi
	int i;

	set_trap_gate(0, &divide_error);							// 设置除操作出错的中断向量值.
    790c:	b8 00 00 08 00       	mov    $0x80000,%eax
{
    7911:	56                   	push   %esi
    7912:	53                   	push   %ebx
    7913:	e8 14 f1 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    7918:	81 c3 e8 96 01 00    	add    $0x196e8,%ebx
	set_trap_gate(0, &divide_error);							// 设置除操作出错的中断向量值.
    791e:	c7 c1 88 57 00 00    	mov    $0x5788,%ecx
    7924:	c7 c2 0f 7b 00 00    	mov    $0x7b0f,%edx
    792a:	66 89 d0             	mov    %dx,%ax
    792d:	66 ba 00 8f          	mov    $0x8f00,%dx
    7931:	89 01                	mov    %eax,(%ecx)
    7933:	89 51 04             	mov    %edx,0x4(%ecx)
	set_trap_gate(1, &debug);
    7936:	c7 c2 44 7b 00 00    	mov    $0x7b44,%edx
    793c:	66 89 d0             	mov    %dx,%ax
    793f:	66 ba 00 8f          	mov    $0x8f00,%dx
    7943:	89 41 08             	mov    %eax,0x8(%ecx)
    7946:	89 51 0c             	mov    %edx,0xc(%ecx)
	set_trap_gate(2, &nmi);
    7949:	c7 c2 4b 7b 00 00    	mov    $0x7b4b,%edx
    794f:	66 89 d0             	mov    %dx,%ax
    7952:	66 ba 00 8f          	mov    $0x8f00,%dx
    7956:	89 41 10             	mov    %eax,0x10(%ecx)
    7959:	89 51 14             	mov    %edx,0x14(%ecx)
	set_system_gate(3, &int3);									/* int3-5 can be called from all */
    795c:	c7 c2 52 7b 00 00    	mov    $0x7b52,%edx
    7962:	66 89 d0             	mov    %dx,%ax
    7965:	66 ba 00 ef          	mov    $0xef00,%dx
    7969:	89 41 18             	mov    %eax,0x18(%ecx)
    796c:	89 51 1c             	mov    %edx,0x1c(%ecx)
	set_system_gate(4, &overflow);
    796f:	c7 c2 59 7b 00 00    	mov    $0x7b59,%edx
    7975:	66 89 d0             	mov    %dx,%ax
    7978:	66 ba 00 ef          	mov    $0xef00,%dx
    797c:	89 41 20             	mov    %eax,0x20(%ecx)
    797f:	89 51 24             	mov    %edx,0x24(%ecx)
	set_system_gate(5, &bounds);
    7982:	c7 c2 60 7b 00 00    	mov    $0x7b60,%edx
    7988:	66 89 d0             	mov    %dx,%ax
    798b:	66 ba 00 ef          	mov    $0xef00,%dx
    798f:	89 41 28             	mov    %eax,0x28(%ecx)
    7992:	89 51 2c             	mov    %edx,0x2c(%ecx)
	set_trap_gate(6, &invalid_op);
    7995:	c7 c2 67 7b 00 00    	mov    $0x7b67,%edx
    799b:	66 89 d0             	mov    %dx,%ax
    799e:	66 ba 00 8f          	mov    $0x8f00,%dx
    79a2:	89 41 30             	mov    %eax,0x30(%ecx)
    79a5:	89 51 34             	mov    %edx,0x34(%ecx)
	set_trap_gate(7, &device_not_available);					// 函数未实现
    79a8:	c7 c2 0c 74 00 00    	mov    $0x740c,%edx
    79ae:	66 89 d0             	mov    %dx,%ax
    79b1:	66 ba 00 8f          	mov    $0x8f00,%dx
    79b5:	89 41 38             	mov    %eax,0x38(%ecx)
    79b8:	89 51 3c             	mov    %edx,0x3c(%ecx)
	set_trap_gate(8, &double_fault);
    79bb:	c7 c2 91 7b 00 00    	mov    $0x7b91,%edx
    79c1:	66 89 d0             	mov    %dx,%ax
    79c4:	66 ba 00 8f          	mov    $0x8f00,%dx
    79c8:	89 41 40             	mov    %eax,0x40(%ecx)
    79cb:	89 51 44             	mov    %edx,0x44(%ecx)
	set_trap_gate(9, &coprocessor_segment_overrun);
    79ce:	c7 c2 6e 7b 00 00    	mov    $0x7b6e,%edx
    79d4:	66 89 d0             	mov    %dx,%ax
    79d7:	66 ba 00 8f          	mov    $0x8f00,%dx
    79db:	89 41 48             	mov    %eax,0x48(%ecx)
    79de:	89 51 4c             	mov    %edx,0x4c(%ecx)
	set_trap_gate(10, &invalid_TSS);
    79e1:	c7 c2 c8 7b 00 00    	mov    $0x7bc8,%edx
    79e7:	66 89 d0             	mov    %dx,%ax
    79ea:	66 ba 00 8f          	mov    $0x8f00,%dx
    79ee:	89 41 50             	mov    %eax,0x50(%ecx)
    79f1:	89 51 54             	mov    %edx,0x54(%ecx)
	set_trap_gate(11, &segment_not_present);
    79f4:	c7 c2 cf 7b 00 00    	mov    $0x7bcf,%edx
    79fa:	66 89 d0             	mov    %dx,%ax
    79fd:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a01:	89 41 58             	mov    %eax,0x58(%ecx)
    7a04:	89 51 5c             	mov    %edx,0x5c(%ecx)
	set_trap_gate(12, &stack_segment);
    7a07:	c7 c2 d6 7b 00 00    	mov    $0x7bd6,%edx
    7a0d:	66 89 d0             	mov    %dx,%ax
    7a10:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a14:	89 41 60             	mov    %eax,0x60(%ecx)
    7a17:	89 51 64             	mov    %edx,0x64(%ecx)
	set_trap_gate(13, &general_protection);
    7a1a:	c7 c2 dd 7b 00 00    	mov    $0x7bdd,%edx
    7a20:	66 89 d0             	mov    %dx,%ax
    7a23:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a27:	89 41 68             	mov    %eax,0x68(%ecx)
    7a2a:	89 51 6c             	mov    %edx,0x6c(%ecx)
	set_trap_gate(14, &page_fault);
    7a2d:	c7 c2 ac ad 00 00    	mov    $0xadac,%edx
    7a33:	66 89 d0             	mov    %dx,%ax
    7a36:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a3a:	89 41 70             	mov    %eax,0x70(%ecx)
    7a3d:	89 51 74             	mov    %edx,0x74(%ecx)
	set_trap_gate(15, &reserved);
    7a40:	c7 c7 75 7b 00 00    	mov    $0x7b75,%edi
    7a46:	89 fa                	mov    %edi,%edx
    7a48:	66 89 d0             	mov    %dx,%ax
    7a4b:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a4f:	89 41 78             	mov    %eax,0x78(%ecx)
    7a52:	89 51 7c             	mov    %edx,0x7c(%ecx)
	set_trap_gate(16, &coprocessor_error);						// 函数未实现
    7a55:	c7 c2 e8 73 00 00    	mov    $0x73e8,%edx
    7a5b:	66 89 d0             	mov    %dx,%ax
    7a5e:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a62:	89 81 80 00 00 00    	mov    %eax,0x80(%ecx)
    7a68:	89 91 84 00 00 00    	mov    %edx,0x84(%ecx)
	set_trap_gate(17, &alignment_check);
    7a6e:	c7 c2 e4 7b 00 00    	mov    $0x7be4,%edx
    7a74:	66 89 d0             	mov    %dx,%ax
    7a77:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a7b:	89 81 88 00 00 00    	mov    %eax,0x88(%ecx)
    7a81:	89 91 8c 00 00 00    	mov    %edx,0x8c(%ecx)
    7a87:	31 f6                	xor    %esi,%esi
	// 下面把int17-47的陷阱门先均设置为reserved,以后各硬件初始化时会重新设置自己的陷阱门.
	for (i = 18; i < 48; i++)
		set_trap_gate(i, &reserved);
    7a89:	bd 00 00 08 00       	mov    $0x80000,%ebp
    7a8e:	89 fa                	mov    %edi,%edx
    7a90:	89 e8                	mov    %ebp,%eax
    7a92:	66 89 d0             	mov    %dx,%ax
    7a95:	66 ba 00 8f          	mov    $0x8f00,%dx
    7a99:	89 84 31 90 00 00 00 	mov    %eax,0x90(%ecx,%esi,1)
    7aa0:	89 94 31 94 00 00 00 	mov    %edx,0x94(%ecx,%esi,1)
    7aa7:	83 c6 08             	add    $0x8,%esi
	for (i = 18; i < 48; i++)
    7aaa:	81 fe f0 00 00 00    	cmp    $0xf0,%esi
    7ab0:	75 dc                	jne    7a8e <trap_init+0x184>
	// 设置协处理器中断0x2d(45)陷阱门描述符,并允许其产生中断请求.设置并行口中断描述符.
	set_trap_gate(45, &irq13);
    7ab2:	c7 c2 7c 7b 00 00    	mov    $0x7b7c,%edx
    7ab8:	66 89 d0             	mov    %dx,%ax
    7abb:	66 ba 00 8f          	mov    $0x8f00,%dx
    7abf:	89 81 68 01 00 00    	mov    %eax,0x168(%ecx)
    7ac5:	89 91 6c 01 00 00    	mov    %edx,0x16c(%ecx)
	outb_p(inb_p(0x21)&0xfb, 0x21);								// 允许8259A主芯片的IRQ2中断请求(连接从芯片)
    7acb:	ba 21 00 00 00       	mov    $0x21,%edx
    7ad0:	ec                   	in     (%dx),%al
    7ad1:	eb 00                	jmp    7ad3 <trap_init+0x1c9>
    7ad3:	eb 00                	jmp    7ad5 <trap_init+0x1cb>
    7ad5:	25 fb 00 00 00       	and    $0xfb,%eax
    7ada:	ee                   	out    %al,(%dx)
    7adb:	eb 00                	jmp    7add <trap_init+0x1d3>
    7add:	eb 00                	jmp    7adf <trap_init+0x1d5>
	outb(inb_p(0xA1)&0xdf, 0xA1);								// 允许8259A从芯片的IRQ13中断请求(协处理器中断)
    7adf:	ba a1 00 00 00       	mov    $0xa1,%edx
    7ae4:	ec                   	in     (%dx),%al
    7ae5:	eb 00                	jmp    7ae7 <trap_init+0x1dd>
    7ae7:	eb 00                	jmp    7ae9 <trap_init+0x1df>
    7ae9:	25 df 00 00 00       	and    $0xdf,%eax
    7aee:	ee                   	out    %al,(%dx)
	set_trap_gate(39, &parallel_interrupt);						// 设置并行口1的中断0x27陷阱门描述符.
    7aef:	c7 c2 28 75 00 00    	mov    $0x7528,%edx
    7af5:	89 e8                	mov    %ebp,%eax
    7af7:	66 89 d0             	mov    %dx,%ax
    7afa:	66 ba 00 8f          	mov    $0x8f00,%dx
    7afe:	89 81 38 01 00 00    	mov    %eax,0x138(%ecx)
    7b04:	89 91 3c 01 00 00    	mov    %edx,0x13c(%ecx)
}
    7b0a:	5b                   	pop    %ebx
    7b0b:	5e                   	pop    %esi
    7b0c:	5f                   	pop    %edi
    7b0d:	5d                   	pop    %ebp
    7b0e:	c3                   	ret    

00007b0f <divide_error>:
    7b0f:	68 e7 76 00 00       	push   $0x76e7

00007b14 <no_error_code>:
    7b14:	87 04 24             	xchg   %eax,(%esp)
    7b17:	53                   	push   %ebx
    7b18:	51                   	push   %ecx
    7b19:	52                   	push   %edx
    7b1a:	57                   	push   %edi
    7b1b:	56                   	push   %esi
    7b1c:	55                   	push   %ebp
    7b1d:	1e                   	push   %ds
    7b1e:	06                   	push   %es
    7b1f:	0f a0                	push   %fs
    7b21:	6a 00                	push   $0x0
    7b23:	8d 54 24 2c          	lea    0x2c(%esp),%edx
    7b27:	52                   	push   %edx
    7b28:	ba 10 00 00 00       	mov    $0x10,%edx
    7b2d:	8e da                	mov    %edx,%ds
    7b2f:	8e c2                	mov    %edx,%es
    7b31:	8e e2                	mov    %edx,%fs
    7b33:	ff d0                	call   *%eax
    7b35:	83 c4 08             	add    $0x8,%esp
    7b38:	0f a1                	pop    %fs
    7b3a:	07                   	pop    %es
    7b3b:	1f                   	pop    %ds
    7b3c:	5d                   	pop    %ebp
    7b3d:	5e                   	pop    %esi
    7b3e:	5f                   	pop    %edi
    7b3f:	5a                   	pop    %edx
    7b40:	59                   	pop    %ecx
    7b41:	5b                   	pop    %ebx
    7b42:	58                   	pop    %eax
    7b43:	cf                   	iret   

00007b44 <debug>:
    7b44:	68 04 77 00 00       	push   $0x7704
    7b49:	eb c9                	jmp    7b14 <no_error_code>

00007b4b <nmi>:
    7b4b:	68 95 77 00 00       	push   $0x7795
    7b50:	eb c2                	jmp    7b14 <no_error_code>

00007b52 <int3>:
    7b52:	68 04 77 00 00       	push   $0x7704
    7b57:	eb bb                	jmp    7b14 <no_error_code>

00007b59 <overflow>:
    7b59:	68 cf 77 00 00       	push   $0x77cf
    7b5e:	eb b4                	jmp    7b14 <no_error_code>

00007b60 <bounds>:
    7b60:	68 ec 77 00 00       	push   $0x77ec
    7b65:	eb ad                	jmp    7b14 <no_error_code>

00007b67 <invalid_op>:
    7b67:	68 09 78 00 00       	push   $0x7809
    7b6c:	eb a6                	jmp    7b14 <no_error_code>

00007b6e <coprocessor_segment_overrun>:
    7b6e:	68 43 78 00 00       	push   $0x7843
    7b73:	eb 9f                	jmp    7b14 <no_error_code>

00007b75 <reserved>:
    7b75:	68 ed 78 00 00       	push   $0x78ed
    7b7a:	eb 98                	jmp    7b14 <no_error_code>

00007b7c <irq13>:
    7b7c:	50                   	push   %eax
    7b7d:	30 c0                	xor    %al,%al
    7b7f:	e6 f0                	out    %al,$0xf0
    7b81:	b0 20                	mov    $0x20,%al
    7b83:	e6 20                	out    %al,$0x20
    7b85:	eb 00                	jmp    7b87 <irq13+0xb>
    7b87:	eb 00                	jmp    7b89 <irq13+0xd>
    7b89:	e6 a0                	out    %al,$0xa0
    7b8b:	58                   	pop    %eax
    7b8c:	e9 57 f8 ff ff       	jmp    73e8 <coprocessor_error>

00007b91 <double_fault>:
    7b91:	68 90 76 00 00       	push   $0x7690

00007b96 <error_code>:
    7b96:	87 44 24 04          	xchg   %eax,0x4(%esp)
    7b9a:	87 1c 24             	xchg   %ebx,(%esp)
    7b9d:	51                   	push   %ecx
    7b9e:	52                   	push   %edx
    7b9f:	57                   	push   %edi
    7ba0:	56                   	push   %esi
    7ba1:	55                   	push   %ebp
    7ba2:	1e                   	push   %ds
    7ba3:	06                   	push   %es
    7ba4:	0f a0                	push   %fs
    7ba6:	50                   	push   %eax
    7ba7:	8d 44 24 2c          	lea    0x2c(%esp),%eax
    7bab:	50                   	push   %eax
    7bac:	b8 10 00 00 00       	mov    $0x10,%eax
    7bb1:	8e d8                	mov    %eax,%ds
    7bb3:	8e c0                	mov    %eax,%es
    7bb5:	8e e0                	mov    %eax,%fs
    7bb7:	ff d3                	call   *%ebx
    7bb9:	83 c4 08             	add    $0x8,%esp
    7bbc:	0f a1                	pop    %fs
    7bbe:	07                   	pop    %es
    7bbf:	1f                   	pop    %ds
    7bc0:	5d                   	pop    %ebp
    7bc1:	5e                   	pop    %esi
    7bc2:	5f                   	pop    %edi
    7bc3:	5a                   	pop    %edx
    7bc4:	59                   	pop    %ecx
    7bc5:	5b                   	pop    %ebx
    7bc6:	58                   	pop    %eax
    7bc7:	cf                   	iret   

00007bc8 <invalid_TSS>:
    7bc8:	68 60 78 00 00       	push   $0x7860
    7bcd:	eb c7                	jmp    7b96 <error_code>

00007bcf <segment_not_present>:
    7bcf:	68 7d 78 00 00       	push   $0x787d
    7bd4:	eb c0                	jmp    7b96 <error_code>

00007bd6 <stack_segment>:
    7bd6:	68 9a 78 00 00       	push   $0x789a
    7bdb:	eb b9                	jmp    7b96 <error_code>

00007bdd <general_protection>:
    7bdd:	68 ad 76 00 00       	push   $0x76ad
    7be2:	eb b2                	jmp    7b96 <error_code>

00007be4 <alignment_check>:
    7be4:	68 ca 76 00 00       	push   $0x76ca
    7be9:	eb ab                	jmp    7b96 <error_code>

00007beb <verify_area>:
// 可以通过设置该标志来达到使用本函数同样的目的.该函数对当前进程逻辑地址从addr到addr + size这一段范围以页为单位执行写操作前
// 的检测操作.由于检测判断是以页面为单位进行操作,因此程序首先需要找出addr所在页面开始地址start,然后start加上进程数据段基址,
// 使这个start变换成CPU 4GB线性空间中的地址.最后循环调用write_verify()对指定大小的内存空间进行写前验证.若页面是只读的,
// 则执行共享检验和复制页面操作(写时复制).
void verify_area(void * addr, int size)
{
    7beb:	55                   	push   %ebp
    7bec:	57                   	push   %edi
    7bed:	56                   	push   %esi
    7bee:	53                   	push   %ebx
    7bef:	e8 38 ee ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    7bf4:	81 c3 0c 94 01 00    	add    $0x1940c,%ebx
    7bfa:	83 ec 0c             	sub    $0xc,%esp
    7bfd:	8b 74 24 20          	mov    0x20(%esp),%esi
	start = (unsigned long) addr;
	size += start & 0xfff;
	start &= 0xfffff000;					// 此时start是当前进程空间中的逻辑地址.
	// 下面把start加上进程数据段在线性地址空间中的起始基址,变成系统整个线性空间中的地址位置.对于Linux0.1x内核,其数据段和代码段在
	// 线性地址空间中的基址和限长均相同.然后循环进行写页面验证.若页面不可写,则复制页面.(mm/memory.c)
	start += get_base(current->ldt[2]);
    7c01:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	size += start & 0xfff;
    7c07:	89 f5                	mov    %esi,%ebp
	start &= 0xfffff000;					// 此时start是当前进程空间中的逻辑地址.
    7c09:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	start += get_base(current->ldt[2]);
    7c0f:	8b 00                	mov    (%eax),%eax
	size += start & 0xfff;
    7c11:	81 e5 ff 0f 00 00    	and    $0xfff,%ebp
    7c17:	03 6c 24 24          	add    0x24(%esp),%ebp
	start += get_base(current->ldt[2]);
    7c1b:	8a b0 af 03 00 00    	mov    0x3af(%eax),%dh
    7c21:	8a 90 ac 03 00 00    	mov    0x3ac(%eax),%dl
    7c27:	c1 e2 10             	shl    $0x10,%edx
    7c2a:	66 8b 90 aa 03 00 00 	mov    0x3aa(%eax),%dx
    7c31:	01 d6                	add    %edx,%esi
	size += start & 0xfff;
    7c33:	89 ef                	mov    %ebp,%edi
    7c35:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
    7c39:	29 f8                	sub    %edi,%eax
	while (size > 0) {
    7c3b:	85 ff                	test   %edi,%edi
    7c3d:	7e 14                	jle    7c53 <verify_area+0x68>
		size -= 4096;
		write_verify(start);				// include/linux/sched.h
    7c3f:	83 ec 0c             	sub    $0xc,%esp
		size -= 4096;
    7c42:	81 ef 00 10 00 00    	sub    $0x1000,%edi
		write_verify(start);				// include/linux/sched.h
    7c48:	50                   	push   %eax
    7c49:	e8 7f 27 00 00       	call   a3cd <write_verify>
    7c4e:	83 c4 10             	add    $0x10,%esp
    7c51:	eb e2                	jmp    7c35 <verify_area+0x4a>
		start += 4096;
	}
}
    7c53:	83 c4 0c             	add    $0xc,%esp
    7c56:	5b                   	pop    %ebx
    7c57:	5e                   	pop    %esi
    7c58:	5f                   	pop    %edi
    7c59:	5d                   	pop    %ebp
    7c5a:	c3                   	ret    

00007c5b <copy_mem>:
// 复制内存页表.
// 参数nr是新任务号;p是新任务数据结构指针.该函数为新任务在线性地址空间中设置代码段和数据段基址,限长,并复制页表.由于Linux系统采用写时
// 复制(copy on write)技术,因此这里仅为新进程设置自己的页目录表项和页表项,而没有实际为新进程分配物理内存页面.此时新进程与其父进程
// 共享所有内存页面.操作成功返回0,否则返回出错号.
int copy_mem(int nr, struct task_struct * p)
{
    7c5b:	55                   	push   %ebp
    7c5c:	57                   	push   %edi

	// 首先取当前进程局部描述符表中代码段描述符和数据段描述符项中的段限长(字节数).
	// 0x0f是代码段选择符;0x17是数据段选择符.然后取当前进程代码段和数据段的线性地址空间中的基地址.由于Linux0.12内核还不支持代码和数据段分立的情况,
	// 因此这里需要检查代码段和数据段基址是否都相同,并且要求数据段的长度至少不小于代码段的长度,否则内核显示出错信息,并停止运行.
	// get_limit()和get_base()定义在include/linux/sched.h.
	code_limit = get_limit(0x0f);
    7c5d:	bf 0f 00 00 00       	mov    $0xf,%edi
{
    7c62:	56                   	push   %esi
    7c63:	53                   	push   %ebx
	data_limit = get_limit(0x17);
    7c64:	be 17 00 00 00       	mov    $0x17,%esi
    7c69:	e8 be ed ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    7c6e:	81 c3 92 93 01 00    	add    $0x19392,%ebx
{
    7c74:	83 ec 1c             	sub    $0x1c,%esp
	old_code_base = get_base(current->ldt[1]);
    7c77:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
{
    7c7d:	8b 44 24 34          	mov    0x34(%esp),%eax
	code_limit = get_limit(0x0f);
    7c81:	0f 03 ff             	lsl    %di,%edi
    7c84:	47                   	inc    %edi
	data_limit = get_limit(0x17);
    7c85:	0f 03 f6             	lsl    %si,%esi
    7c88:	46                   	inc    %esi
	old_code_base = get_base(current->ldt[1]);
    7c89:	8b 2a                	mov    (%edx),%ebp
    7c8b:	8a b5 a7 03 00 00    	mov    0x3a7(%ebp),%dh
    7c91:	8a 95 a4 03 00 00    	mov    0x3a4(%ebp),%dl
    7c97:	c1 e2 10             	shl    $0x10,%edx
    7c9a:	66 8b 95 a2 03 00 00 	mov    0x3a2(%ebp),%dx
    7ca1:	89 d1                	mov    %edx,%ecx
	old_data_base = get_base(current->ldt[2]);
    7ca3:	8a b5 af 03 00 00    	mov    0x3af(%ebp),%dh
    7ca9:	8a 95 ac 03 00 00    	mov    0x3ac(%ebp),%dl
    7caf:	c1 e2 10             	shl    $0x10,%edx
    7cb2:	66 8b 95 aa 03 00 00 	mov    0x3aa(%ebp),%dx
	if (old_data_base != old_code_base)
    7cb9:	39 d1                	cmp    %edx,%ecx
	old_data_base = get_base(current->ldt[2]);
    7cbb:	89 d5                	mov    %edx,%ebp
	if (old_data_base != old_code_base)
    7cbd:	74 1a                	je     7cd9 <copy_mem+0x7e>
		panic("We don't support separate I&D");
    7cbf:	8d 93 55 69 ff ff    	lea    -0x96ab(%ebx),%edx
    7cc5:	89 44 24 0c          	mov    %eax,0xc(%esp)
    7cc9:	83 ec 0c             	sub    $0xc,%esp
    7ccc:	52                   	push   %edx
    7ccd:	e8 00 04 00 00       	call   80d2 <panic>
    7cd2:	83 c4 10             	add    $0x10,%esp
    7cd5:	8b 44 24 0c          	mov    0xc(%esp),%eax
	if (data_limit < code_limit)
    7cd9:	39 f7                	cmp    %esi,%edi
    7cdb:	76 1a                	jbe    7cf7 <copy_mem+0x9c>
		panic("Bad data_limit");
    7cdd:	8d 93 73 69 ff ff    	lea    -0x968d(%ebx),%edx
    7ce3:	89 44 24 0c          	mov    %eax,0xc(%esp)
    7ce7:	83 ec 0c             	sub    $0xc,%esp
    7cea:	52                   	push   %edx
    7ceb:	e8 e2 03 00 00       	call   80d2 <panic>
    7cf0:	83 c4 10             	add    $0x10,%esp
    7cf3:	8b 44 24 0c          	mov    0xc(%esp),%eax
	// 然后设置创建中的新进程在线性地址空间中的基地址等于(64MB*其任务号),并用该值设置新进程局部描述符表中段描述符中的基地址.接着设置新进程的页目录
	// 表项和页表项,即复制当前进程(父进程)的页目录表项和页表项.此时子进程共享父进程的内存页面.
	// 正常情况下copy_page_tables()返回0,否则表示出错,则释放刚申请的页表项.
	new_data_base = new_code_base = nr * TASK_SIZE;
    7cf7:	8b 7c 24 30          	mov    0x30(%esp),%edi
    7cfb:	c1 e7 1a             	shl    $0x1a,%edi
	p->start_code = new_code_base;
    7cfe:	89 b8 18 02 00 00    	mov    %edi,0x218(%eax)
	set_base(p->ldt[1], new_code_base);
    7d04:	89 fa                	mov    %edi,%edx
    7d06:	66 89 90 a2 03 00 00 	mov    %dx,0x3a2(%eax)
    7d0d:	c1 ca 10             	ror    $0x10,%edx
    7d10:	88 90 a4 03 00 00    	mov    %dl,0x3a4(%eax)
    7d16:	88 b0 a7 03 00 00    	mov    %dh,0x3a7(%eax)
	set_base(p->ldt[2], new_data_base);
    7d1c:	89 fa                	mov    %edi,%edx
    7d1e:	66 89 90 aa 03 00 00 	mov    %dx,0x3aa(%eax)
    7d25:	c1 ca 10             	ror    $0x10,%edx
    7d28:	88 90 ac 03 00 00    	mov    %dl,0x3ac(%eax)
    7d2e:	88 b0 af 03 00 00    	mov    %dh,0x3af(%eax)
	if (copy_page_tables(old_data_base, new_data_base, data_limit)) {
    7d34:	52                   	push   %edx
    7d35:	56                   	push   %esi
    7d36:	57                   	push   %edi
    7d37:	55                   	push   %ebp
    7d38:	e8 54 23 00 00       	call   a091 <copy_page_tables>
    7d3d:	83 c4 10             	add    $0x10,%esp
    7d40:	85 c0                	test   %eax,%eax
    7d42:	74 11                	je     7d55 <copy_mem+0xfa>
		free_page_tables(new_data_base, data_limit);
    7d44:	50                   	push   %eax
    7d45:	50                   	push   %eax
    7d46:	56                   	push   %esi
    7d47:	57                   	push   %edi
    7d48:	e8 6e 22 00 00       	call   9fbb <free_page_tables>
		return -ENOMEM;
    7d4d:	83 c4 10             	add    $0x10,%esp
    7d50:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
	}
	return 0;
}
    7d55:	83 c4 1c             	add    $0x1c,%esp
    7d58:	5b                   	pop    %ebx
    7d59:	5e                   	pop    %esi
    7d5a:	5f                   	pop    %edi
    7d5b:	5d                   	pop    %ebp
    7d5c:	c3                   	ret    

00007d5d <copy_process>:
// 其中参数nr是调用find_empty_process()分配的任务数组项号.
int copy_process(int nr, long ebp, long edi, long esi, long gs, long none,
		long ebx, long ecx, long edx, long orig_eax,
		long fs, long es, long ds,
		long eip, long cs, long eflags, long esp, long ss)
{
    7d5d:	55                   	push   %ebp
    7d5e:	57                   	push   %edi
    7d5f:	56                   	push   %esi
    7d60:	53                   	push   %ebx
    7d61:	e8 c6 ec ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    7d66:	81 c3 9a 92 01 00    	add    $0x1929a,%ebx
    7d6c:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	struct file *f;

	// 首先为新任务数据结构分配内存.如果内存分配出错,则返回出错码并退出.然后将新任务结构指针放入任务数组的nr项中.其中nr为任务号,由前面
	// find_empty_process()返回.接着把当前进程任务结构复制到刚申请到的内存页面p开始处.
	p = (struct task_struct *) get_free_page();
    7d6f:	e8 91 2d 00 00       	call   ab05 <get_free_page>
    7d74:	89 c5                	mov    %eax,%ebp
	if (!p)
		return -EAGAIN;
    7d76:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
	if (!p)
    7d7b:	85 ed                	test   %ebp,%ebp
    7d7d:	0f 84 e7 02 00 00    	je     806a <copy_process+0x30d>
	task[nr] = p;
    7d83:	8b 44 24 30          	mov    0x30(%esp),%eax
    7d87:	c7 c2 60 22 02 00    	mov    $0x22260,%edx
	*p = *current;							/* NOTE! this doesn't copy the supervisor stack */	/* 注意!这样不会复制超级用户堆栈(只复制进程结构) */
    7d8d:	b9 21 01 00 00       	mov    $0x121,%ecx
    7d92:	89 ef                	mov    %ebp,%edi
	task[nr] = p;
    7d94:	89 2c 82             	mov    %ebp,(%edx,%eax,4)
	*p = *current;							/* NOTE! this doesn't copy the supervisor stack */	/* 注意!这样不会复制超级用户堆栈(只复制进程结构) */
    7d97:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    7d9d:	89 44 24 08          	mov    %eax,0x8(%esp)
    7da1:	8b 00                	mov    (%eax),%eax
    7da3:	89 c6                	mov    %eax,%esi
    7da5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	//	memcpy(p, current, sizeof(struct task_struct));
	// 随后对复制来的进程结构内容进行一些修改,作为新进程的任务结构.先将新进程的状态置为不可中断等待状态,以防止内核调试其执行.然后设置新进程
	// 的进程号pid,并初始化进程运行时间片值等于其priorty值(一般为16个嘀嗒).接着复位新进程的信号位图,报警定时值,会话(session)领导标志
	// leader,进程及其子进程在内核和用户态运行时间统计值,还设置进程开始运行的系统时间start_time.
	p->state = TASK_UNINTERRUPTIBLE;
	p->pid = last_pid;						// 新进程号.也由find_empty_process()得到.
    7da7:	8b 8b b0 1d 00 00    	mov    0x1db0(%ebx),%ecx
	p->state = TASK_UNINTERRUPTIBLE;
    7dad:	c7 45 00 02 00 00 00 	movl   $0x2,0x0(%ebp)
	p->counter = p->priority;				// 运行时间片值(嘀嗒数).
	p->signal = 0;							// 信号位图.
    7db4:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
	p->alarm = 0;							// 报警定时值(嘀嗒数).
    7dbb:	c7 85 dc 02 00 00 00 	movl   $0x0,0x2dc(%ebp)
    7dc2:	00 00 00 
	p->leader = 0;							/* process leadership doesn't inherit */	/* 进程的领导权是不能继承的 */
    7dc5:	c7 85 38 02 00 00 00 	movl   $0x0,0x238(%ebp)
    7dcc:	00 00 00 
	p->utime = p->stime = 0;				// 用户态时间和核心态运行时间.
    7dcf:	c7 85 e4 02 00 00 00 	movl   $0x0,0x2e4(%ebp)
    7dd6:	00 00 00 
	p->pid = last_pid;						// 新进程号.也由find_empty_process()得到.
    7dd9:	89 8d 2c 02 00 00    	mov    %ecx,0x22c(%ebp)
	p->counter = p->priority;				// 运行时间片值(嘀嗒数).
    7ddf:	8b 4d 08             	mov    0x8(%ebp),%ecx
	p->utime = p->stime = 0;				// 用户态时间和核心态运行时间.
    7de2:	c7 85 e0 02 00 00 00 	movl   $0x0,0x2e0(%ebp)
    7de9:	00 00 00 
	p->cutime = p->cstime = 0;				// 子进程用户态和核心态运行时间.
    7dec:	c7 85 ec 02 00 00 00 	movl   $0x0,0x2ec(%ebp)
    7df3:	00 00 00 
    7df6:	c7 85 e8 02 00 00 00 	movl   $0x0,0x2e8(%ebp)
    7dfd:	00 00 00 
	p->start_time = jiffies;				// 进程开始运行时间(当前时间滴答数).
	// 再修改任务状态段TSS数据.由于系统给任务结构p分配了1页新内存,所以(PAGE_SIZE + (long) p)让esp0正好指向该页顶端.ss0:esp0用作程序在内核
	// 态执行时的栈.另外,在第3章中我们已经知道,每个任务在GDT表中都有两个段描述符,一个是任务的TSS段描述符,另一个是任务的LDT表段描述符.下面语句就是
	// 把GDT中本任务LDT段描述符的选择符保存在本任务的TSS段.当CPU执行切换任务时,会自动从TSS中把LDT段描述符的选择符加载到ldtr寄存器中.
	p->tss.back_link = 0;
    7e00:	c7 85 b0 03 00 00 00 	movl   $0x0,0x3b0(%ebp)
    7e07:	00 00 00 
	p->counter = p->priority;				// 运行时间片值(嘀嗒数).
    7e0a:	89 4d 04             	mov    %ecx,0x4(%ebp)
	p->start_time = jiffies;				// 进程开始运行时间(当前时间滴答数).
    7e0d:	c7 c1 6c 2a 02 00    	mov    $0x22a6c,%ecx
	p->tss.esp0 = PAGE_SIZE + (long) p;		// 任务内核态栈指针.
	p->tss.ss0 = 0x10;              		// 内核态栈的段选择符(与内核数据段相同).
    7e13:	c7 85 b8 03 00 00 10 	movl   $0x10,0x3b8(%ebp)
    7e1a:	00 00 00 
	p->tss.eip = eip;						// 指令代码指针.
	p->tss.eflags = eflags;					// 标志寄存器.
	p->tss.eax = 0;							// 这是当fork()返回时新进程会返回0的原因所在.
    7e1d:	c7 85 d8 03 00 00 00 	movl   $0x0,0x3d8(%ebp)
    7e24:	00 00 00 
	p->start_time = jiffies;				// 进程开始运行时间(当前时间滴答数).
    7e27:	8b 09                	mov    (%ecx),%ecx
    7e29:	89 8d f0 02 00 00    	mov    %ecx,0x2f0(%ebp)
	p->tss.esp0 = PAGE_SIZE + (long) p;		// 任务内核态栈指针.
    7e2f:	8d 8d 00 10 00 00    	lea    0x1000(%ebp),%ecx
    7e35:	89 8d b4 03 00 00    	mov    %ecx,0x3b4(%ebp)
	p->tss.eip = eip;						// 指令代码指针.
    7e3b:	8b 4c 24 64          	mov    0x64(%esp),%ecx
    7e3f:	89 8d d0 03 00 00    	mov    %ecx,0x3d0(%ebp)
	p->tss.eflags = eflags;					// 标志寄存器.
    7e45:	8b 4c 24 6c          	mov    0x6c(%esp),%ecx
    7e49:	89 8d d4 03 00 00    	mov    %ecx,0x3d4(%ebp)
	p->tss.ecx = ecx;
    7e4f:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
    7e53:	89 8d dc 03 00 00    	mov    %ecx,0x3dc(%ebp)
	p->tss.edx = edx;
    7e59:	8b 4c 24 50          	mov    0x50(%esp),%ecx
	p->tss.ss = ss & 0xffff;
	p->tss.ds = ds & 0xffff;
	p->tss.fs = fs & 0xffff;
	p->tss.gs = gs & 0xffff;
	p->tss.ldt = _LDT(nr);					// 任务局部表描述符的选择符(LDT描述符在GET中).
	p->tss.trace_bitmap = 0x80000000;		// (高16位有效).
    7e5d:	c7 85 14 04 00 00 00 	movl   $0x80000000,0x414(%ebp)
    7e64:	00 00 80 
	p->tss.edx = edx;
    7e67:	89 8d e0 03 00 00    	mov    %ecx,0x3e0(%ebp)
	p->tss.ebx = ebx;
    7e6d:	8b 4c 24 48          	mov    0x48(%esp),%ecx
    7e71:	89 8d e4 03 00 00    	mov    %ecx,0x3e4(%ebp)
	p->tss.esp = esp;
    7e77:	8b 4c 24 70          	mov    0x70(%esp),%ecx
    7e7b:	89 8d e8 03 00 00    	mov    %ecx,0x3e8(%ebp)
	p->tss.ebp = ebp;
    7e81:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    7e85:	89 8d ec 03 00 00    	mov    %ecx,0x3ec(%ebp)
	p->tss.esi = esi;
    7e8b:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
    7e8f:	89 8d f0 03 00 00    	mov    %ecx,0x3f0(%ebp)
	p->tss.edi = edi;
    7e95:	8b 4c 24 38          	mov    0x38(%esp),%ecx
    7e99:	89 8d f4 03 00 00    	mov    %ecx,0x3f4(%ebp)
	p->tss.es = es & 0xffff;				// 段寄存器仅16位有效.
    7e9f:	0f b7 4c 24 5c       	movzwl 0x5c(%esp),%ecx
    7ea4:	89 8d f8 03 00 00    	mov    %ecx,0x3f8(%ebp)
	p->tss.cs = cs & 0xffff;
    7eaa:	0f b7 4c 24 68       	movzwl 0x68(%esp),%ecx
    7eaf:	89 8d fc 03 00 00    	mov    %ecx,0x3fc(%ebp)
	p->tss.ss = ss & 0xffff;
    7eb5:	0f b7 4c 24 74       	movzwl 0x74(%esp),%ecx
    7eba:	89 8d 00 04 00 00    	mov    %ecx,0x400(%ebp)
	p->tss.ds = ds & 0xffff;
    7ec0:	0f b7 4c 24 60       	movzwl 0x60(%esp),%ecx
    7ec5:	89 8d 04 04 00 00    	mov    %ecx,0x404(%ebp)
	p->tss.fs = fs & 0xffff;
    7ecb:	0f b7 4c 24 58       	movzwl 0x58(%esp),%ecx
    7ed0:	89 8d 08 04 00 00    	mov    %ecx,0x408(%ebp)
	p->tss.gs = gs & 0xffff;
    7ed6:	0f b7 4c 24 40       	movzwl 0x40(%esp),%ecx
    7edb:	89 8d 0c 04 00 00    	mov    %ecx,0x40c(%ebp)
	p->tss.ldt = _LDT(nr);					// 任务局部表描述符的选择符(LDT描述符在GET中).
    7ee1:	8b 4c 24 30          	mov    0x30(%esp),%ecx
    7ee5:	c1 e1 04             	shl    $0x4,%ecx
    7ee8:	83 c1 28             	add    $0x28,%ecx
    7eeb:	89 8d 10 04 00 00    	mov    %ecx,0x410(%ebp)
	// 如果当前任务使用了协处理器,就保存其上下文.汇编指令clts用于清除控制寄存器CR0中的任务已交换(TS)标志.每当发生任务切换,CPU都会设置该标志.该标志用于管理
	// 数学协处理器:如果该标志置位,那么每个ESC指令都会被捕获(异常7).如果协处理器存在标志MP也同时置位的话,那么WAIT指令也会捕获.因此,如果任务切换发生在一个
	// ESC指令开始执行之后,则协处理器中的内容就可能需要在执行新的ESC指令之前保存起来.捕获处理句柄会保存协处理器的内容并复位TS标志.指令fnsave用于把协处理器的
	// 所有状态保存到目的操作数指定的内存区域中(tss.i387).
	if (last_task_used_math == current)
    7ef1:	c7 c1 60 2a 02 00    	mov    $0x22a60,%ecx
    7ef7:	3b 01                	cmp    (%ecx),%eax
    7ef9:	75 0e                	jne    7f09 <copy_process+0x1ac>
		__asm__("clts ; fnsave %0 ; frstor %0"::"m" (p->tss.i387));
    7efb:	0f 06                	clts   
    7efd:	dd b5 18 04 00 00    	fnsave 0x418(%ebp)
    7f03:	dd a5 18 04 00 00    	frstor 0x418(%ebp)
    7f09:	89 54 24 0c          	mov    %edx,0xc(%esp)
	// 接下来复制进程页表.即在线性地址空间设置新任务代码段和数据段描述符中的基址和限长,并复制页表.如果出错(返回值不是0),则复位任务数组中相应项并
	// 释放为该新任务分配的用于任务结构的内存页.
	if (copy_mem(nr, p)) {					// 返回不为0示出错.
    7f0d:	50                   	push   %eax
    7f0e:	50                   	push   %eax
    7f0f:	55                   	push   %ebp
    7f10:	ff 74 24 3c          	pushl  0x3c(%esp)
    7f14:	e8 42 fd ff ff       	call   7c5b <copy_mem>
    7f19:	83 c4 10             	add    $0x10,%esp
    7f1c:	85 c0                	test   %eax,%eax
    7f1e:	8b 54 24 0c          	mov    0xc(%esp),%edx
    7f22:	74 27                	je     7f4b <copy_process+0x1ee>
		task[nr] = NULL;
    7f24:	8b 44 24 30          	mov    0x30(%esp),%eax
		free_page((long) p);
    7f28:	83 ec 0c             	sub    $0xc,%esp
		task[nr] = NULL;
    7f2b:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
		free_page((long) p);
    7f32:	55                   	push   %ebp
    7f33:	e8 1b 20 00 00       	call   9f53 <free_page>
		return -EAGAIN;
    7f38:	83 c4 10             	add    $0x10,%esp
    7f3b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    7f40:	e9 25 01 00 00       	jmp    806a <copy_process+0x30d>
	}
	// 如果父进程中有文件是打开的,则将对应文件的打开次数增1.因为这里创建的子进程会与父进程共享这些打开的文件.将当前进程(父进程)的pwd,root和
	// executable引用次数均增1.与上面同样的道理,子进程也引用了这些i节点.
	for (i = 0; i < NR_OPEN; i++)
    7f45:	40                   	inc    %eax
    7f46:	83 f8 14             	cmp    $0x14,%eax
    7f49:	74 11                	je     7f5c <copy_process+0x1ff>
		if (f = p->filp[i])
    7f4b:	8b 94 85 48 03 00 00 	mov    0x348(%ebp,%eax,4),%edx
    7f52:	85 d2                	test   %edx,%edx
    7f54:	74 ef                	je     7f45 <copy_process+0x1e8>
			f->f_count++;
    7f56:	66 ff 42 04          	incw   0x4(%edx)
    7f5a:	eb e9                	jmp    7f45 <copy_process+0x1e8>
	if (current->pwd)
    7f5c:	8b 44 24 08          	mov    0x8(%esp),%eax
    7f60:	8b 30                	mov    (%eax),%esi
    7f62:	8b 86 34 03 00 00    	mov    0x334(%esi),%eax
    7f68:	85 c0                	test   %eax,%eax
    7f6a:	74 04                	je     7f70 <copy_process+0x213>
		current->pwd->i_count++;
    7f6c:	66 ff 40 34          	incw   0x34(%eax)
	if (current->root)
    7f70:	8b 86 38 03 00 00    	mov    0x338(%esi),%eax
    7f76:	85 c0                	test   %eax,%eax
    7f78:	74 04                	je     7f7e <copy_process+0x221>
		current->root->i_count++;
    7f7a:	66 ff 40 34          	incw   0x34(%eax)
	if (current->executable)
    7f7e:	8b 86 3c 03 00 00    	mov    0x33c(%esi),%eax
    7f84:	85 c0                	test   %eax,%eax
    7f86:	74 04                	je     7f8c <copy_process+0x22f>
		current->executable->i_count++;
    7f88:	66 ff 40 34          	incw   0x34(%eax)
	if (current->library)
    7f8c:	8b 86 40 03 00 00    	mov    0x340(%esi),%eax
    7f92:	85 c0                	test   %eax,%eax
    7f94:	74 04                	je     7f9a <copy_process+0x23d>
		current->library->i_count++;
    7f96:	66 ff 40 34          	incw   0x34(%eax)
	// 设置等于父进程的最新子进程指针.若当前进程确实还有其他子进程,则让比邻老兄进程的最年轻进程指针p_yspter指向新进程.最后把当前进程的最新子进程指针指向这个新进程.
	// 然后把新进程设置成就绪态.最后返回新进程号.
	// 另外,set_tss_desc()和set_ldt_desc()定义在include/asm/system.h文件中."gdt+(nr<<1)+FIRST_TSS_ENTRY"是任务nr的TSS描述符项在全局表中的地址.
	// 因为每个任务占用GDT表中2项,因此上式中要包括'(nr<<1)'.
	// 请注意,在任务切换时,任务寄存器tr会由CPU自动加载.
	set_tss_desc(gdt + (nr << 1) + FIRST_TSS_ENTRY, &(p->tss));
    7f9a:	8b 7c 24 30          	mov    0x30(%esp),%edi
    7f9e:	8d 85 b0 03 00 00    	lea    0x3b0(%ebp),%eax
    7fa4:	c7 c2 88 5f 00 00    	mov    $0x5f88,%edx
    7faa:	01 ff                	add    %edi,%edi
    7fac:	83 c7 04             	add    $0x4,%edi
    7faf:	8d 0c fd 00 00 00 00 	lea    0x0(,%edi,8),%ecx
    7fb6:	66 c7 04 fa 68 00    	movw   $0x68,(%edx,%edi,8)
    7fbc:	66 89 44 11 02       	mov    %ax,0x2(%ecx,%edx,1)
    7fc1:	c1 c8 10             	ror    $0x10,%eax
    7fc4:	88 44 11 04          	mov    %al,0x4(%ecx,%edx,1)
    7fc8:	c6 44 11 05 89       	movb   $0x89,0x5(%ecx,%edx,1)
    7fcd:	c6 44 11 06 00       	movb   $0x0,0x6(%ecx,%edx,1)
    7fd2:	88 64 11 07          	mov    %ah,0x7(%ecx,%edx,1)
    7fd6:	c1 c8 10             	ror    $0x10,%eax
	set_ldt_desc(gdt + (nr << 1) + FIRST_LDT_ENTRY, &(p->ldt));
    7fd9:	8d 85 98 03 00 00    	lea    0x398(%ebp),%eax
    7fdf:	66 c7 44 11 08 68 00 	movw   $0x68,0x8(%ecx,%edx,1)
    7fe6:	66 89 44 11 0a       	mov    %ax,0xa(%ecx,%edx,1)
    7feb:	c1 c8 10             	ror    $0x10,%eax
    7fee:	88 44 11 0c          	mov    %al,0xc(%ecx,%edx,1)
    7ff2:	c6 44 11 0d 82       	movb   $0x82,0xd(%ecx,%edx,1)
    7ff7:	c6 44 11 0e 00       	movb   $0x0,0xe(%ecx,%edx,1)
    7ffc:	88 64 11 0f          	mov    %ah,0xf(%ecx,%edx,1)
    8000:	c1 c8 10             	ror    $0x10,%eax
	p->p_pptr = current;				// 设置新进程的父进程指针.
	p->p_cptr = 0;						// 复位新进程的最新子进程指针.
    8003:	c7 85 c0 02 00 00 00 	movl   $0x0,0x2c0(%ebp)
    800a:	00 00 00 
	p->p_ysptr = 0;						// 复位新进程的比邻年轻兄弟进程指针.
	p->p_osptr = current->p_cptr;		// 设置新进程的比邻老兄兄弟进程指针.
    800d:	8b 86 c0 02 00 00    	mov    0x2c0(%esi),%eax
	p->p_pptr = current;				// 设置新进程的父进程指针.
    8013:	89 b5 bc 02 00 00    	mov    %esi,0x2bc(%ebp)
	p->p_ysptr = 0;						// 复位新进程的比邻年轻兄弟进程指针.
    8019:	c7 85 c4 02 00 00 00 	movl   $0x0,0x2c4(%ebp)
    8020:	00 00 00 
	if (p->p_osptr)						// 若新进程有老兄兄弟进程,则让其年轻进程兄弟指针指向新进程
    8023:	85 c0                	test   %eax,%eax
	p->p_osptr = current->p_cptr;		// 设置新进程的比邻老兄兄弟进程指针.
    8025:	89 85 c8 02 00 00    	mov    %eax,0x2c8(%ebp)
	if (p->p_osptr)						// 若新进程有老兄兄弟进程,则让其年轻进程兄弟指针指向新进程
    802b:	74 06                	je     8033 <copy_process+0x2d6>
		p->p_osptr->p_ysptr = p;
    802d:	89 a8 c4 02 00 00    	mov    %ebp,0x2c4(%eax)
	current->p_cptr = p;				// 让当前进程最新子进程指针指向新进程.
	p->state = TASK_RUNNING;			/* do this last, just in case */        /* 设置进程状态为待运行状态栏 */
	Log(LOG_INFO_TYPE, "<<<<< fork new process current_pid = %d, child_pid = %d, nr = %d >>>>>\n", current->pid, p->pid, nr);
    8033:	8d 83 82 69 ff ff    	lea    -0x967e(%ebx),%eax
    8039:	83 ec 0c             	sub    $0xc,%esp
	current->p_cptr = p;				// 让当前进程最新子进程指针指向新进程.
    803c:	89 ae c0 02 00 00    	mov    %ebp,0x2c0(%esi)
	p->state = TASK_RUNNING;			/* do this last, just in case */        /* 设置进程状态为待运行状态栏 */
    8042:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
	Log(LOG_INFO_TYPE, "<<<<< fork new process current_pid = %d, child_pid = %d, nr = %d >>>>>\n", current->pid, p->pid, nr);
    8049:	ff 74 24 3c          	pushl  0x3c(%esp)
    804d:	ff b5 2c 02 00 00    	pushl  0x22c(%ebp)
    8053:	ff b6 2c 02 00 00    	pushl  0x22c(%esi)
    8059:	50                   	push   %eax
    805a:	6a 00                	push   $0x0
    805c:	e8 2e f4 00 00       	call   1748f <Log>
	return last_pid;        			// 返回新进程号
    8061:	8b 83 b0 1d 00 00    	mov    0x1db0(%ebx),%eax
    8067:	83 c4 20             	add    $0x20,%esp
}
    806a:	83 c4 1c             	add    $0x1c,%esp
    806d:	5b                   	pop    %ebx
    806e:	5e                   	pop    %esi
    806f:	5f                   	pop    %edi
    8070:	5d                   	pop    %ebp
    8071:	c3                   	ret    

00008072 <find_empty_process>:

// 为新进程取得不重复的进程号last_pid.函数返回在任务数组中的任务号(数组项).
int find_empty_process(void)
{
    8072:	e8 07 1e 00 00       	call   9e7e <__x86.get_pc_thunk.cx>
    8077:	81 c1 89 8f 01 00    	add    $0x18f89,%ecx
    807d:	56                   	push   %esi
    807e:	53                   	push   %ebx
    807f:	8b 81 b0 1d 00 00    	mov    0x1db0(%ecx),%eax
	// 否已经被任何任务使用.如果是则跳转到函数开始处理重新获得一个pid号.接着在任务数组中为新任务寻找一个空闲项,并返回项号.last_pid是一
	// 个全局变量,不用返回.如果此时任务数组中64个项已经被全部占用,则返回出错码.
	repeat:
		if ((++last_pid) < 0) last_pid = 1;
		for(i = 0 ; i < NR_TASKS ; i++)
			if (task[i] && ((task[i]->pid == last_pid) ||
    8085:	c7 c6 60 22 02 00    	mov    $0x22260,%esi
		if ((++last_pid) < 0) last_pid = 1;
    808b:	40                   	inc    %eax
    808c:	ba 01 00 00 00       	mov    $0x1,%edx
    8091:	0f 48 c2             	cmovs  %edx,%eax
		for(i = 0 ; i < NR_TASKS ; i++)
    8094:	31 d2                	xor    %edx,%edx
			if (task[i] && ((task[i]->pid == last_pid) ||
    8096:	8b 1c 96             	mov    (%esi,%edx,4),%ebx
    8099:	85 db                	test   %ebx,%ebx
    809b:	74 10                	je     80ad <find_empty_process+0x3b>
    809d:	39 83 2c 02 00 00    	cmp    %eax,0x22c(%ebx)
    80a3:	74 e6                	je     808b <find_empty_process+0x19>
    80a5:	39 83 30 02 00 00    	cmp    %eax,0x230(%ebx)
    80ab:	74 de                	je     808b <find_empty_process+0x19>
		for(i = 0 ; i < NR_TASKS ; i++)
    80ad:	42                   	inc    %edx
    80ae:	83 fa 40             	cmp    $0x40,%edx
    80b1:	75 e3                	jne    8096 <find_empty_process+0x24>
    80b3:	89 81 b0 1d 00 00    	mov    %eax,0x1db0(%ecx)
				        (task[i]->pgrp == last_pid)))
				goto repeat;
	for(i = 1 ; i < NR_TASKS ; i++)
    80b9:	b8 01 00 00 00       	mov    $0x1,%eax
		if (!task[i])
    80be:	83 3c 86 00          	cmpl   $0x0,(%esi,%eax,4)
    80c2:	74 0b                	je     80cf <find_empty_process+0x5d>
	for(i = 1 ; i < NR_TASKS ; i++)
    80c4:	40                   	inc    %eax
    80c5:	83 f8 40             	cmp    $0x40,%eax
    80c8:	75 f4                	jne    80be <find_empty_process+0x4c>
			return i;
	return -EAGAIN;
    80ca:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
    80cf:	5b                   	pop    %ebx
    80d0:	5e                   	pop    %esi
    80d1:	c3                   	ret    

000080d2 <panic>:
// 如果当前进程是任务0的话,还说明是交换任务出错,并且还没有运行文件系统同步函数.
// 函数名前的关键字volatile用于告诉编译器gcc该函数不会返回.这样可让gcc产生更好一些的代码,更重要的是使用这个关键字
// 以避免产生某些(未初始化变量的)假警告信息.
// 等同于现在gcc的函数属性说明:void panic(const char *s) __attribute__((noreturn));
void panic(const char * s)
{
    80d2:	53                   	push   %ebx
    80d3:	e8 54 e9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    80d8:	81 c3 28 8f 01 00    	add    $0x18f28,%ebx
    80de:	83 ec 10             	sub    $0x10,%esp
	printk("Kernel panic: %s\n\r", s);
    80e1:	8d 83 ca 69 ff ff    	lea    -0x9636(%ebx),%eax
    80e7:	ff 74 24 18          	pushl  0x18(%esp)
    80eb:	50                   	push   %eax
    80ec:	e8 30 00 00 00       	call   8121 <printk>
	if (current == task[0])
    80f1:	c7 c2 60 22 02 00    	mov    $0x22260,%edx
    80f7:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    80fd:	83 c4 10             	add    $0x10,%esp
    8100:	8b 00                	mov    (%eax),%eax
    8102:	39 02                	cmp    %eax,(%edx)
    8104:	75 14                	jne    811a <panic+0x48>
		printk("In swapper task - not syncing\n\r");
    8106:	8d 83 dd 69 ff ff    	lea    -0x9623(%ebx),%eax
    810c:	83 ec 0c             	sub    $0xc,%esp
    810f:	50                   	push   %eax
    8110:	e8 0c 00 00 00       	call   8121 <printk>
    8115:	83 c4 10             	add    $0x10,%esp
    8118:	eb 05                	jmp    811f <panic+0x4d>
	else
		sys_sync();
    811a:	e8 a7 3e 00 00       	call   bfc6 <sys_sync>
    811f:	eb fe                	jmp    811f <panic+0x4d>

00008121 <printk>:
// 函数vsprintf()定义在linux/kernel/vsprintf.c中
extern int vsprintf(char * buf, const char * fmt, va_list args);

// 内核使用的显示函数.
int printk(const char *fmt, ...)
{
    8121:	56                   	push   %esi
    8122:	53                   	push   %ebx
    8123:	e8 04 e9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8128:	81 c3 d8 8e 01 00    	add    $0x18ed8,%ebx
    812e:	83 ec 18             	sub    $0x18,%esp
	int i;

	// 运行参数处理开始函数.然后使用格式串fmt将参数列表args输出到buf中.返回值i等于输出字符串的长度.再运行参数处理结束函数.最后调用控制台显示
	// 函数并返回显示字符数.
	va_start(args, fmt);
	i = vsprintf(buf, fmt, args);
    8131:	8d 44 24 28          	lea    0x28(%esp),%eax
    8135:	8d b3 c0 1d 00 00    	lea    0x1dc0(%ebx),%esi
    813b:	50                   	push   %eax
    813c:	ff 74 24 28          	pushl  0x28(%esp)
    8140:	56                   	push   %esi
    8141:	e8 00 02 00 00       	call   8346 <vsprintf>
	va_end(args);
	console_print(buf);						// chr_drv/console.c
    8146:	89 34 24             	mov    %esi,(%esp)
	i = vsprintf(buf, fmt, args);
    8149:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	console_print(buf);						// chr_drv/console.c
    814d:	e8 83 c2 00 00       	call   143d5 <console_print>
	return i;
}
    8152:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    8156:	83 c4 24             	add    $0x24,%esp
    8159:	5b                   	pop    %ebx
    815a:	5e                   	pop    %esi
    815b:	c3                   	ret    

0000815c <number>:
// 将整数转换为指定进制的字符串.
// 输入: num-整数; base-进制; size-字符串长度;precision-数字长度(精度);type-类型选项.
// 输出: 数字转换成字符串后指向该字符串末端后面的指针.
static char * number(char * str, int num, int base, int size, int precision
	,int type)
{
    815c:	55                   	push   %ebp
    815d:	57                   	push   %edi
    815e:	56                   	push   %esi
    815f:	53                   	push   %ebx
    8160:	89 c3                	mov    %eax,%ebx
    8162:	e8 1b 1d 00 00       	call   9e82 <__x86.get_pc_thunk.si>
    8167:	81 c6 99 8e 01 00    	add    $0x18e99,%esi
    816d:	83 ec 48             	sub    $0x48,%esp
    8170:	89 d0                	mov    %edx,%eax
    8172:	8b 6c 24 64          	mov    0x64(%esp),%ebp
    8176:	89 4c 24 04          	mov    %ecx,0x4(%esp)
	int i;

	// 如果类型type指出用小写字母,则定义小写字母集.
	// 如果类型指出要左调整(靠左边界),则屏蔽类型中的填零标志.
	// 如果进制基数小于2或大于36,则退出处理,即本程序只能处理基数在2-36之间的数.
	if (type & SMALL) digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    817a:	8d be 22 6a ff ff    	lea    -0x95de(%esi),%edi
    8180:	f7 c5 40 00 00 00    	test   $0x40,%ebp
    8186:	75 06                	jne    818e <number+0x32>
    8188:	8d be fd 69 ff ff    	lea    -0x9603(%esi),%edi
	if (type & LEFT) type &= ~ZEROPAD;
    818e:	f7 c5 10 00 00 00    	test   $0x10,%ebp
    8194:	74 03                	je     8199 <number+0x3d>
    8196:	83 e5 fe             	and    $0xfffffffe,%ebp
	if (base < 2 || base > 36)
		return 0;
	// 如果类型指出要填零,则置字符变量c='0',否则c等于空格字符.
	// 如果类型指出是带符号数并且数值num小于0,则置符号变量sign=负号,并使num取绝对值.
	// 否则如果类型指出是加号,则置sign=加号,否则若类型带空格标志则sign=空格,否则置0.
	c = (type & ZEROPAD) ? '0' : ' ' ;
    8199:	89 ea                	mov    %ebp,%edx
    819b:	83 e2 01             	and    $0x1,%edx
    819e:	83 fa 01             	cmp    $0x1,%edx
    81a1:	19 c9                	sbb    %ecx,%ecx
    81a3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    81a7:	80 64 24 0c f0       	andb   $0xf0,0xc(%esp)
    81ac:	80 44 24 0c 30       	addb   $0x30,0xc(%esp)
	if (type & SIGN && num < 0) {
    81b1:	f7 c5 02 00 00 00    	test   $0x2,%ebp
    81b7:	74 0d                	je     81c6 <number+0x6a>
    81b9:	85 c0                	test   %eax,%eax
    81bb:	79 09                	jns    81c6 <number+0x6a>
		sign = '-';
		num = -num;
    81bd:	f7 d8                	neg    %eax
		sign = '-';
    81bf:	c6 44 24 0b 2d       	movb   $0x2d,0xb(%esp)
    81c4:	eb 21                	jmp    81e7 <number+0x8b>
	} else
		sign = (type & PLUS) ? '+' : ((type & SPACE) ? ' ' : 0);
    81c6:	f7 c5 04 00 00 00    	test   $0x4,%ebp
    81cc:	75 14                	jne    81e2 <number+0x86>
    81ce:	8d 14 ad 00 00 00 00 	lea    0x0(,%ebp,4),%edx
	// 若带符号,则宽度值减1.若类型指出是特殊转换,则对十六进制宽度再减少2位(用于0x),对于八进制宽度减1(用于八进制转换结果前放一个零).
	if (sign) size--;
    81d5:	88 d1                	mov    %dl,%cl
    81d7:	80 e1 20             	and    $0x20,%cl
    81da:	88 4c 24 0b          	mov    %cl,0xb(%esp)
    81de:	74 0b                	je     81eb <number+0x8f>
    81e0:	eb 05                	jmp    81e7 <number+0x8b>
		sign = (type & PLUS) ? '+' : ((type & SPACE) ? ' ' : 0);
    81e2:	c6 44 24 0b 2b       	movb   $0x2b,0xb(%esp)
	if (sign) size--;
    81e7:	ff 4c 24 5c          	decl   0x5c(%esp)
	if (type & SPECIAL)
    81eb:	89 e9                	mov    %ebp,%ecx
    81ed:	83 e1 20             	and    $0x20,%ecx
    81f0:	89 4c 24 14          	mov    %ecx,0x14(%esp)
    81f4:	74 19                	je     820f <number+0xb3>
		if (base == 16) size -= 2;
    81f6:	83 7c 24 04 10       	cmpl   $0x10,0x4(%esp)
    81fb:	75 07                	jne    8204 <number+0xa8>
    81fd:	83 6c 24 5c 02       	subl   $0x2,0x5c(%esp)
    8202:	eb 0b                	jmp    820f <number+0xb3>
		else if (base == 8) size--;
    8204:	83 7c 24 04 08       	cmpl   $0x8,0x4(%esp)
    8209:	75 04                	jne    820f <number+0xb3>
    820b:	ff 4c 24 5c          	decl   0x5c(%esp)
	// 如果数值num为0,则临时字符串='0';否则根据给定的基数将数值num转换成字符形式.
	i = 0;
	if (num == 0)
    820f:	85 c0                	test   %eax,%eax
    8211:	75 0e                	jne    8221 <number+0xc5>
		tmp[i++] = '0';
    8213:	c6 44 24 24 30       	movb   $0x30,0x24(%esp)
    8218:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
    821f:	eb 23                	jmp    8244 <number+0xe8>
	else while (num != 0)
		tmp[i++] = digits[do_div(num, base)];
    8221:	8d 74 24 23          	lea    0x23(%esp),%esi
	i = 0;
    8225:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
		tmp[i++] = digits[do_div(num, base)];
    822c:	ff 04 24             	incl   (%esp)
    822f:	31 d2                	xor    %edx,%edx
    8231:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    8235:	f7 f1                	div    %ecx
    8237:	8b 0c 24             	mov    (%esp),%ecx
    823a:	8a 14 17             	mov    (%edi,%edx,1),%dl
	else while (num != 0)
    823d:	85 c0                	test   %eax,%eax
		tmp[i++] = digits[do_div(num, base)];
    823f:	88 14 0e             	mov    %dl,(%esi,%ecx,1)
	else while (num != 0)
    8242:	75 e8                	jne    822c <number+0xd0>
    8244:	8b 04 24             	mov    (%esp),%eax
    8247:	3b 44 24 60          	cmp    0x60(%esp),%eax
    824b:	0f 4c 44 24 60       	cmovl  0x60(%esp),%eax
	// 若数值字符个数大于精度值,则精度值扩展为数字个数值.
	// 宽度值size减去用于存放数值字符的个数.
	if (i > precision) precision = i;
	size -= precision;
    8250:	8b 54 24 5c          	mov    0x5c(%esp),%edx
    8254:	29 c2                	sub    %eax,%edx
	// 从这里真正开始形成所需要的转换结果,并暂时放在字符串str中.
	// 若类型中没有填零(ZEROPAD)和左靠齐(左调整)标志,则在str中首先填放剩余宽度值指出的空格数.若需带符号位,则存入符号.
	if (!(type & (ZEROPAD + LEFT)))
    8256:	f7 c5 11 00 00 00    	test   $0x11,%ebp
    825c:	89 44 24 10          	mov    %eax,0x10(%esp)
    8260:	75 20                	jne    8282 <number+0x126>
    8262:	31 c0                	xor    %eax,%eax
    8264:	89 d6                	mov    %edx,%esi
    8266:	29 c6                	sub    %eax,%esi
		while(size-- > 0)
    8268:	85 f6                	test   %esi,%esi
    826a:	7e 07                	jle    8273 <number+0x117>
			*str++ = ' ';
    826c:	c6 04 03 20          	movb   $0x20,(%ebx,%eax,1)
    8270:	40                   	inc    %eax
    8271:	eb f1                	jmp    8264 <number+0x108>
    8273:	85 d2                	test   %edx,%edx
    8275:	be 00 00 00 00       	mov    $0x0,%esi
    827a:	0f 49 f2             	cmovns %edx,%esi
    827d:	4a                   	dec    %edx
    827e:	01 f3                	add    %esi,%ebx
    8280:	29 f2                	sub    %esi,%edx
	if (sign)
    8282:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
    8287:	74 08                	je     8291 <number+0x135>
		*str++ = sign;
    8289:	8a 44 24 0b          	mov    0xb(%esp),%al
    828d:	43                   	inc    %ebx
    828e:	88 43 ff             	mov    %al,-0x1(%ebx)
	// 若类型指出是特殊转换,则对于八进制转换结果头一位放置一个'0';而对于十六进制则存放'0x'.
	if (type & SPECIAL)
    8291:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    8296:	74 20                	je     82b8 <number+0x15c>
		if (base == 8)
    8298:	83 7c 24 04 08       	cmpl   $0x8,0x4(%esp)
    829d:	75 06                	jne    82a5 <number+0x149>
			*str++ = '0';
    829f:	c6 03 30             	movb   $0x30,(%ebx)
    82a2:	43                   	inc    %ebx
    82a3:	eb 13                	jmp    82b8 <number+0x15c>
		else if (base == 16) {
    82a5:	83 7c 24 04 10       	cmpl   $0x10,0x4(%esp)
    82aa:	75 0c                	jne    82b8 <number+0x15c>
			*str++ = '0';
			*str++ = digits[33];						// 'X'或'x'
    82ac:	8a 47 21             	mov    0x21(%edi),%al
			*str++ = '0';
    82af:	c6 03 30             	movb   $0x30,(%ebx)
			*str++ = digits[33];						// 'X'或'x'
    82b2:	83 c3 02             	add    $0x2,%ebx
    82b5:	88 43 ff             	mov    %al,-0x1(%ebx)
		}
	// 若类型中没有左调整(左靠齐)标志,则在剩余宽度中存放c字符('0'或空格)
	if (!(type & LEFT))
    82b8:	83 e5 10             	and    $0x10,%ebp
    82bb:	75 23                	jne    82e0 <number+0x184>
    82bd:	31 c0                	xor    %eax,%eax
    82bf:	89 d6                	mov    %edx,%esi
    82c1:	29 c6                	sub    %eax,%esi
		while(size-- > 0)
    82c3:	85 f6                	test   %esi,%esi
    82c5:	7e 0a                	jle    82d1 <number+0x175>
			*str++ = c;
    82c7:	8a 4c 24 0c          	mov    0xc(%esp),%cl
    82cb:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    82ce:	40                   	inc    %eax
    82cf:	eb ee                	jmp    82bf <number+0x163>
    82d1:	85 d2                	test   %edx,%edx
    82d3:	be 00 00 00 00       	mov    $0x0,%esi
    82d8:	0f 49 f2             	cmovns %edx,%esi
    82db:	4a                   	dec    %edx
    82dc:	01 f3                	add    %esi,%ebx
    82de:	29 f2                	sub    %esi,%edx
    82e0:	8b 7c 24 10          	mov    0x10(%esp),%edi
    82e4:	01 df                	add    %ebx,%edi
    82e6:	89 f8                	mov    %edi,%eax
    82e8:	29 d8                	sub    %ebx,%eax
	// 此时i存有数值num的数字个数.若数字个数小于精度值,则str中放入(精度值-i)个'0'.
	while(i < precision--)
    82ea:	39 04 24             	cmp    %eax,(%esp)
    82ed:	7d 07                	jge    82f6 <number+0x19a>
		*str++ = '0';
    82ef:	43                   	inc    %ebx
    82f0:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
    82f4:	eb f0                	jmp    82e6 <number+0x18a>
	while(i < precision--)
    82f6:	8b 04 24             	mov    (%esp),%eax
	// 将数值转换好的数字字符填入str中.共i个.
	while(i-- > 0)
		*str++ = tmp[i];
    82f9:	8d 7c 24 23          	lea    0x23(%esp),%edi
    82fd:	8d 34 03             	lea    (%ebx,%eax,1),%esi
	while(i-- > 0)
    8300:	85 c0                	test   %eax,%eax
    8302:	7e 0d                	jle    8311 <number+0x1b5>
		*str++ = tmp[i];
    8304:	8a 0c 07             	mov    (%edi,%eax,1),%cl
    8307:	89 c5                	mov    %eax,%ebp
    8309:	48                   	dec    %eax
    830a:	f7 dd                	neg    %ebp
    830c:	88 0c 2e             	mov    %cl,(%esi,%ebp,1)
    830f:	eb ef                	jmp    8300 <number+0x1a4>
    8311:	83 3c 24 00          	cmpl   $0x0,(%esp)
    8315:	8b 0c 24             	mov    (%esp),%ecx
    8318:	b8 00 00 00 00       	mov    $0x0,%eax
    831d:	0f 48 c8             	cmovs  %eax,%ecx
    8320:	01 cb                	add    %ecx,%ebx
    8322:	89 d1                	mov    %edx,%ecx
    8324:	29 c1                	sub    %eax,%ecx
	// 若宽度值仍大于零,则表示类型标志中有左靠齐标志.则在剩余宽度中放入空格.
	while(size-- > 0)
    8326:	85 c9                	test   %ecx,%ecx
    8328:	7e 07                	jle    8331 <number+0x1d5>
		*str++ = ' ';
    832a:	c6 04 03 20          	movb   $0x20,(%ebx,%eax,1)
    832e:	40                   	inc    %eax
    832f:	eb f1                	jmp    8322 <number+0x1c6>
    8331:	85 d2                	test   %edx,%edx
    8333:	b8 00 00 00 00       	mov    $0x0,%eax
    8338:	0f 48 d0             	cmovs  %eax,%edx
	return str;											// 返回转换好的指向字符串末端后的指针.
}
    833b:	83 c4 48             	add    $0x48,%esp
    833e:	8d 04 13             	lea    (%ebx,%edx,1),%eax
    8341:	5b                   	pop    %ebx
    8342:	5e                   	pop    %esi
    8343:	5f                   	pop    %edi
    8344:	5d                   	pop    %ebp
    8345:	c3                   	ret    

00008346 <vsprintf>:

// 下面函数是送格式化输出到字符串中.
// 为了能在内核中使用格式化的输出,Linus在内核实现了该C标准函数.
// 其中参数fmt是格式字符串;args是个数变化的值;buf是输出字符串缓冲区.
int vsprintf(char *buf, const char *fmt, va_list args)
{
    8346:	55                   	push   %ebp
    8347:	57                   	push   %edi
    8348:	56                   	push   %esi
    8349:	53                   	push   %ebx
    834a:	83 ec 08             	sub    $0x8,%esp
    834d:	8b 74 24 20          	mov    0x20(%esp),%esi
    8351:	8b 7c 24 24          	mov    0x24(%esp),%edi
				   											number of chars for from string */
														/* min.整数数字个数;max.字符串中字符个数 */
	int qualifier;										/* 'h', 'l', or 'L' for integer fields */	/* 'h','l',或 'L'用于整数字段 */

	// 首先将字符指针指向buf,然后扫描格式字符串,对各个格式转换指示进行相应的处理.
	for (str=buf ; *fmt ; ++fmt) {
    8355:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
    8359:	8a 06                	mov    (%esi),%al
    835b:	84 c0                	test   %al,%al
    835d:	0f 84 7b 02 00 00    	je     85de <vsprintf+0x298>
		// 格式转换指示字符串均'%'开始,这里从fmt格式字符串中扫描'%',寻找格式转换字符串的开始.不是格式指示的一般字符均被依次存入str.
		if (*fmt != '%') {
    8363:	3c 25                	cmp    $0x25,%al
    8365:	0f 85 5f 02 00 00    	jne    85ca <vsprintf+0x284>
			continue;
		}

		// 下面取得格式指示字符串中的标志域,并将标志常量放入flags变量中.
		/* process flags */
		flags = 0;
    836b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
    8372:	8a 46 01             	mov    0x1(%esi),%al
			++fmt;		/* this also skips first '%' */
    8375:	8d 4e 01             	lea    0x1(%esi),%ecx
			switch (*fmt) {
    8378:	3c 2b                	cmp    $0x2b,%al
    837a:	74 26                	je     83a2 <vsprintf+0x5c>
    837c:	7f 10                	jg     838e <vsprintf+0x48>
    837e:	3c 20                	cmp    $0x20,%al
    8380:	74 26                	je     83a8 <vsprintf+0x62>
    8382:	3c 23                	cmp    $0x23,%al
    8384:	75 28                	jne    83ae <vsprintf+0x68>
				case '-': flags |= LEFT; goto repeat;		// 左靠齐调整
				case '+': flags |= PLUS; goto repeat;		// 放加号
				case ' ': flags |= SPACE; goto repeat;		// 放空格
				case '#': flags |= SPECIAL; goto repeat;	// 是特殊转换
    8386:	83 0c 24 20          	orl    $0x20,(%esp)
{
    838a:	89 ce                	mov    %ecx,%esi
    838c:	eb e4                	jmp    8372 <vsprintf+0x2c>
			switch (*fmt) {
    838e:	3c 2d                	cmp    $0x2d,%al
    8390:	74 0a                	je     839c <vsprintf+0x56>
    8392:	3c 30                	cmp    $0x30,%al
    8394:	75 18                	jne    83ae <vsprintf+0x68>
				case '0': flags |= ZEROPAD; goto repeat;	// 要填零(即'0')
    8396:	83 0c 24 01          	orl    $0x1,(%esp)
    839a:	eb ee                	jmp    838a <vsprintf+0x44>
				case '-': flags |= LEFT; goto repeat;		// 左靠齐调整
    839c:	83 0c 24 10          	orl    $0x10,(%esp)
    83a0:	eb e8                	jmp    838a <vsprintf+0x44>
				case '+': flags |= PLUS; goto repeat;		// 放加号
    83a2:	83 0c 24 04          	orl    $0x4,(%esp)
    83a6:	eb e2                	jmp    838a <vsprintf+0x44>
				case ' ': flags |= SPACE; goto repeat;		// 放空格
    83a8:	83 0c 24 08          	orl    $0x8,(%esp)
    83ac:	eb dc                	jmp    838a <vsprintf+0x44>

		// 取当前参数字段宽度域值,放入field_width变量中.如果宽度域中是数值则直接其为宽度值.如果宽度域中是字符'*',表示下一个参数指定宽度.因此
		// 调用va_arg取宽度值.若此时宽度值小于0,则该负数表示其带有标志域'-'标志(左靠齐),因此还需在标志变量中添入该标志,并将字段宽度值取为其绝对值.
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
    83ae:	8d 50 d0             	lea    -0x30(%eax),%edx
    83b1:	80 fa 09             	cmp    $0x9,%dl
    83b4:	77 1d                	ja     83d3 <vsprintf+0x8d>
	int i = 0;
    83b6:	31 d2                	xor    %edx,%edx
	while (is_digit(**s))
    83b8:	0f b6 29             	movzbl (%ecx),%ebp
    83bb:	8d 75 d0             	lea    -0x30(%ebp),%esi
    83be:	89 f0                	mov    %esi,%eax
    83c0:	3c 09                	cmp    $0x9,%al
    83c2:	77 28                	ja     83ec <vsprintf+0xa6>
		i = i*10 + *((*s)++) - '0';
    83c4:	6b d2 0a             	imul   $0xa,%edx,%edx
    83c7:	89 e8                	mov    %ebp,%eax
    83c9:	41                   	inc    %ecx
    83ca:	0f be c0             	movsbl %al,%eax
    83cd:	8d 54 02 d0          	lea    -0x30(%edx,%eax,1),%edx
    83d1:	eb e5                	jmp    83b8 <vsprintf+0x72>
		field_width = -1;
    83d3:	83 ca ff             	or     $0xffffffff,%edx
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
    83d6:	3c 2a                	cmp    $0x2a,%al
    83d8:	75 12                	jne    83ec <vsprintf+0xa6>
			/* it's the next argument */
			++fmt;
			field_width = va_arg(args, int);
    83da:	8b 17                	mov    (%edi),%edx
    83dc:	83 c7 04             	add    $0x4,%edi
			++fmt;
    83df:	8d 4e 02             	lea    0x2(%esi),%ecx
			if (field_width < 0) {
    83e2:	85 d2                	test   %edx,%edx
    83e4:	79 06                	jns    83ec <vsprintf+0xa6>
				field_width = -field_width;
				flags |= LEFT;
    83e6:	83 0c 24 10          	orl    $0x10,(%esp)
				field_width = -field_width;
    83ea:	f7 da                	neg    %edx

	// 下面这段代码,取格式转换串的精度域,并放入precision变量中.精度域开始的标志是'.'.其处理过程与上面宽度域的类似.如果精度域中是数值则直接取其为
	// 精度值.如果精度域中是字符'*',表示下一个参数指定精度.因此调用va_arg取精度值.若此时宽度值小于0,则将字段精度值取为0.
		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
    83ec:	80 39 2e             	cmpb   $0x2e,(%ecx)
    83ef:	75 41                	jne    8432 <vsprintf+0xec>
			++fmt;
			if (is_digit(*fmt))
    83f1:	8a 41 01             	mov    0x1(%ecx),%al
			++fmt;
    83f4:	8d 71 01             	lea    0x1(%ecx),%esi
			if (is_digit(*fmt))
    83f7:	8d 68 d0             	lea    -0x30(%eax),%ebp
    83fa:	88 44 24 04          	mov    %al,0x4(%esp)
    83fe:	89 e8                	mov    %ebp,%eax
    8400:	3c 09                	cmp    $0x9,%al
    8402:	77 17                	ja     841b <vsprintf+0xd5>
	int i = 0;
    8404:	31 ed                	xor    %ebp,%ebp
	while (is_digit(**s))
    8406:	0f be 06             	movsbl (%esi),%eax
    8409:	8d 48 d0             	lea    -0x30(%eax),%ecx
    840c:	80 f9 09             	cmp    $0x9,%cl
    840f:	77 26                	ja     8437 <vsprintf+0xf1>
		i = i*10 + *((*s)++) - '0';
    8411:	6b ed 0a             	imul   $0xa,%ebp,%ebp
    8414:	46                   	inc    %esi
    8415:	8d 6c 05 d0          	lea    -0x30(%ebp,%eax,1),%ebp
    8419:	eb eb                	jmp    8406 <vsprintf+0xc0>
				/* it's the next argument */
                                ++fmt;
				precision = va_arg(args, int);
			}
			if (precision < 0)
				precision = 0;
    841b:	31 ed                	xor    %ebp,%ebp
			else if (*fmt == '*') {
    841d:	80 7c 24 04 2a       	cmpb   $0x2a,0x4(%esp)
    8422:	75 13                	jne    8437 <vsprintf+0xf1>
    8424:	83 3f 00             	cmpl   $0x0,(%edi)
                                ++fmt;
    8427:	8d 71 02             	lea    0x2(%ecx),%esi
    842a:	0f 49 2f             	cmovns (%edi),%ebp
				precision = va_arg(args, int);
    842d:	83 c7 04             	add    $0x4,%edi
    8430:	eb 05                	jmp    8437 <vsprintf+0xf1>
    8432:	89 ce                	mov    %ecx,%esi
		precision = -1;
    8434:	83 cd ff             	or     $0xffffffff,%ebp
		}

		// 下面这段代码分析长度修饰符,并将其存入qualifer变量.
		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
    8437:	8a 06                	mov    (%esi),%al
    8439:	88 c1                	mov    %al,%cl
    843b:	83 e1 df             	and    $0xffffffdf,%ecx
    843e:	80 f9 4c             	cmp    $0x4c,%cl
    8441:	74 04                	je     8447 <vsprintf+0x101>
    8443:	3c 68                	cmp    $0x68,%al
    8445:	75 01                	jne    8448 <vsprintf+0x102>
			qualifier = *fmt;
			++fmt;
    8447:	46                   	inc    %esi
		}

		// 下面分析转换指示符.
		switch (*fmt) {
    8448:	8a 06                	mov    (%esi),%al
    844a:	3c 6e                	cmp    $0x6e,%al
    844c:	0f 84 57 01 00 00    	je     85a9 <vsprintf+0x263>
    8452:	7f 1f                	jg     8473 <vsprintf+0x12d>
    8454:	3c 63                	cmp    $0x63,%al
    8456:	74 4f                	je     84a7 <vsprintf+0x161>
    8458:	7f 04                	jg     845e <vsprintf+0x118>
    845a:	3c 58                	cmp    $0x58,%al
    845c:	eb 3e                	jmp    849c <vsprintf+0x156>
    845e:	3c 64                	cmp    $0x64,%al
    8460:	0f 84 2c 01 00 00    	je     8592 <vsprintf+0x24c>
    8466:	3c 69                	cmp    $0x69,%al
    8468:	0f 84 24 01 00 00    	je     8592 <vsprintf+0x24c>
    846e:	e9 49 01 00 00       	jmp    85bc <vsprintf+0x276>
    8473:	3c 73                	cmp    $0x73,%al
    8475:	74 75                	je     84ec <vsprintf+0x1a6>
    8477:	7f 15                	jg     848e <vsprintf+0x148>
    8479:	3c 6f                	cmp    $0x6f,%al
    847b:	0f 84 cf 00 00 00    	je     8550 <vsprintf+0x20a>
    8481:	3c 70                	cmp    $0x70,%al
    8483:	0f 84 da 00 00 00    	je     8563 <vsprintf+0x21d>
    8489:	e9 2e 01 00 00       	jmp    85bc <vsprintf+0x276>
    848e:	3c 75                	cmp    $0x75,%al
    8490:	0f 84 00 01 00 00    	je     8596 <vsprintf+0x250>
				field_width, precision, flags);
			break;

		// 如果格式转换指示是'x'或'X',则表示对应参数需要打印成十六进制数输出.'x'表示用定字母表示.
		case 'x':
			flags |= SMALL;
    8496:	83 0c 24 40          	orl    $0x40,(%esp)
		switch (*fmt) {
    849a:	3c 78                	cmp    $0x78,%al
    849c:	0f 84 cf 00 00 00    	je     8571 <vsprintf+0x22b>
    84a2:	e9 15 01 00 00       	jmp    85bc <vsprintf+0x276>
			if (!(flags & LEFT))
    84a7:	f6 04 24 10          	testb  $0x10,(%esp)
    84ab:	75 22                	jne    84cf <vsprintf+0x189>
    84ad:	8d 2c 13             	lea    (%ebx,%edx,1),%ebp
    84b0:	8d 43 01             	lea    0x1(%ebx),%eax
    84b3:	89 e9                	mov    %ebp,%ecx
    84b5:	29 c1                	sub    %eax,%ecx
				while (--field_width > 0)
    84b7:	85 c9                	test   %ecx,%ecx
    84b9:	7e 08                	jle    84c3 <vsprintf+0x17d>
					*str++ = ' ';
    84bb:	c6 40 ff 20          	movb   $0x20,-0x1(%eax)
    84bf:	89 c3                	mov    %eax,%ebx
    84c1:	eb ed                	jmp    84b0 <vsprintf+0x16a>
    84c3:	85 d2                	test   %edx,%edx
    84c5:	b8 01 00 00 00       	mov    $0x1,%eax
    84ca:	0f 4f c2             	cmovg  %edx,%eax
    84cd:	29 c2                	sub    %eax,%edx
			*str++ = (unsigned char) va_arg(args, int);
    84cf:	8d 47 04             	lea    0x4(%edi),%eax
    84d2:	43                   	inc    %ebx
    84d3:	89 44 24 04          	mov    %eax,0x4(%esp)
    84d7:	8b 07                	mov    (%edi),%eax
    84d9:	88 43 ff             	mov    %al,-0x1(%ebx)
			while (--field_width > 0)
    84dc:	4a                   	dec    %edx
    84dd:	85 d2                	test   %edx,%edx
    84df:	0f 8e ef 00 00 00    	jle    85d4 <vsprintf+0x28e>
				*str++ = ' ';
    84e5:	43                   	inc    %ebx
    84e6:	c6 43 ff 20          	movb   $0x20,-0x1(%ebx)
    84ea:	eb f0                	jmp    84dc <vsprintf+0x196>
			s = va_arg(args, char *);
    84ec:	8d 47 04             	lea    0x4(%edi),%eax
// %0 - ecx(__res),%1 - edi(字符串指针s),%2 - eax(0),%3 - ecx(0xffffffff).
// 返回:返回字符串长度.
static inline int strlen(const char * s)
{
register int __res __asm__("cx");       					// __res是寄存器变量(ecx).
__asm__(
    84ef:	83 c9 ff             	or     $0xffffffff,%ecx
    84f2:	8b 3f                	mov    (%edi),%edi
    84f4:	89 44 24 04          	mov    %eax,0x4(%esp)
    84f8:	31 c0                	xor    %eax,%eax
    84fa:	fc                   	cld    
    84fb:	f2 ae                	repnz scas %es:(%edi),%al
    84fd:	f7 d1                	not    %ecx
    84ff:	49                   	dec    %ecx
			else if (len > precision)
    8500:	83 fd ff             	cmp    $0xffffffff,%ebp
    8503:	74 04                	je     8509 <vsprintf+0x1c3>
    8505:	39 cd                	cmp    %ecx,%ebp
    8507:	7c 02                	jl     850b <vsprintf+0x1c5>
	"repne\n\t"												// al(0)与字符串中字符es:[edi比较,
	"scasb\n\t"												// 若不相等就一直比较.
	"notl %0\n\t"											// ecx取反.
	"decl %0"												// ecx--,得字符串的长度值.
	:"=c" (__res):"D" (s), "a" (0), "0" (0xffffffff));
return __res;												// 返回字符串长度值.
    8509:	89 cd                	mov    %ecx,%ebp
			if (!(flags & LEFT))
    850b:	f6 04 24 10          	testb  $0x10,(%esp)
    850f:	75 0f                	jne    8520 <vsprintf+0x1da>
				while (len < field_width--)
    8511:	4a                   	dec    %edx
    8512:	8d 42 01             	lea    0x1(%edx),%eax
    8515:	39 c5                	cmp    %eax,%ebp
    8517:	7d 07                	jge    8520 <vsprintf+0x1da>
					*str++ = ' ';
    8519:	43                   	inc    %ebx
    851a:	c6 43 ff 20          	movb   $0x20,-0x1(%ebx)
    851e:	eb f1                	jmp    8511 <vsprintf+0x1cb>
			for (i = 0; i < len; ++i)
    8520:	31 c0                	xor    %eax,%eax
    8522:	39 c5                	cmp    %eax,%ebp
    8524:	7e 09                	jle    852f <vsprintf+0x1e9>
				*str++ = *s++;
    8526:	8a 0c 07             	mov    (%edi,%eax,1),%cl
    8529:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
			for (i = 0; i < len; ++i)
    852c:	40                   	inc    %eax
    852d:	eb f3                	jmp    8522 <vsprintf+0x1dc>
    852f:	85 ed                	test   %ebp,%ebp
    8531:	b8 00 00 00 00       	mov    $0x0,%eax
    8536:	0f 49 c5             	cmovns %ebp,%eax
    8539:	01 c3                	add    %eax,%ebx
    853b:	01 da                	add    %ebx,%edx
    853d:	89 d0                	mov    %edx,%eax
    853f:	29 d8                	sub    %ebx,%eax
			while (len < field_width--)
    8541:	39 c5                	cmp    %eax,%ebp
    8543:	0f 8d 8b 00 00 00    	jge    85d4 <vsprintf+0x28e>
				*str++ = ' ';
    8549:	43                   	inc    %ebx
    854a:	c6 43 ff 20          	movb   $0x20,-0x1(%ebx)
    854e:	eb ed                	jmp    853d <vsprintf+0x1f7>
			str = number(str, va_arg(args, unsigned long), 8,
    8550:	8d 47 04             	lea    0x4(%edi),%eax
    8553:	b9 08 00 00 00       	mov    $0x8,%ecx
    8558:	89 44 24 04          	mov    %eax,0x4(%esp)
    855c:	ff 34 24             	pushl  (%esp)
    855f:	55                   	push   %ebp
    8560:	52                   	push   %edx
    8561:	eb 1f                	jmp    8582 <vsprintf+0x23c>
			if (field_width == -1) {
    8563:	83 fa ff             	cmp    $0xffffffff,%edx
    8566:	75 09                	jne    8571 <vsprintf+0x22b>
				flags |= ZEROPAD;
    8568:	83 0c 24 01          	orl    $0x1,(%esp)
				field_width = 8;
    856c:	ba 08 00 00 00       	mov    $0x8,%edx
				(unsigned long) va_arg(args, void *), 16,
    8571:	8d 47 04             	lea    0x4(%edi),%eax
			str = number(str,
    8574:	b9 10 00 00 00       	mov    $0x10,%ecx
				(unsigned long) va_arg(args, void *), 16,
    8579:	89 44 24 04          	mov    %eax,0x4(%esp)
			str = number(str,
    857d:	ff 34 24             	pushl  (%esp)
    8580:	55                   	push   %ebp
    8581:	52                   	push   %edx
    8582:	8b 17                	mov    (%edi),%edx
    8584:	89 d8                	mov    %ebx,%eax
    8586:	e8 d1 fb ff ff       	call   815c <number>
			break;
    858b:	83 c4 0c             	add    $0xc,%esp
			str = number(str,
    858e:	89 c3                	mov    %eax,%ebx
			break;
    8590:	eb 42                	jmp    85d4 <vsprintf+0x28e>
			break;

		// 如果格式转换字符是'd','i'或'u',则表示对应参数是整数,'d','i'代表符号整数,因此需要加上带符号标志.'u'代表无符号整数.
		case 'd':
		case 'i':
			flags |= SIGN;
    8592:	83 0c 24 02          	orl    $0x2,(%esp)
		case 'u':
			str = number(str, va_arg(args, unsigned long), 10,
    8596:	8d 47 04             	lea    0x4(%edi),%eax
    8599:	b9 0a 00 00 00       	mov    $0xa,%ecx
    859e:	89 44 24 04          	mov    %eax,0x4(%esp)
    85a2:	ff 34 24             	pushl  (%esp)
    85a5:	55                   	push   %ebp
    85a6:	52                   	push   %edx
    85a7:	eb d9                	jmp    8582 <vsprintf+0x23c>
			break;

		// 若格式转换指示符是'n',则表示要把目前为止转换输出字符数保存到对应参数指针指定的位置中.首先利用va_arg()取得该参数指针,然后将已经转换好
		// 的字符数存入该指示的位置.
		case 'n':
			ip = va_arg(args, int *);
    85a9:	8d 47 04             	lea    0x4(%edi),%eax
			*ip = (str - buf);
    85ac:	89 da                	mov    %ebx,%edx
    85ae:	2b 54 24 1c          	sub    0x1c(%esp),%edx
			ip = va_arg(args, int *);
    85b2:	89 44 24 04          	mov    %eax,0x4(%esp)
			*ip = (str - buf);
    85b6:	8b 07                	mov    (%edi),%eax
    85b8:	89 10                	mov    %edx,(%eax)
			break;
    85ba:	eb 18                	jmp    85d4 <vsprintf+0x28e>

		// 若格式转换符不是'%',则表示格式字符串有错,直接将一个'%'写入输出串中.
		// 如果格式转换符的位置处还有字符,则也直接将该字符写入输出串中,并返回前面继续处理格式字符串.否则表示已经处理到格式字符串的结尾处,则退出循环.
		default:
			if (*fmt != '%')
    85bc:	3c 25                	cmp    $0x25,%al
    85be:	74 04                	je     85c4 <vsprintf+0x27e>
				*str++ = '%';
    85c0:	c6 03 25             	movb   $0x25,(%ebx)
    85c3:	43                   	inc    %ebx
			if (*fmt)
    85c4:	8a 06                	mov    (%esi),%al
    85c6:	84 c0                	test   %al,%al
    85c8:	74 05                	je     85cf <vsprintf+0x289>
				*str++ = *fmt;
    85ca:	88 03                	mov    %al,(%ebx)
    85cc:	43                   	inc    %ebx
    85cd:	eb 01                	jmp    85d0 <vsprintf+0x28a>
			else
				--fmt;
    85cf:	4e                   	dec    %esi
    85d0:	89 7c 24 04          	mov    %edi,0x4(%esp)
	for (str=buf ; *fmt ; ++fmt) {
    85d4:	46                   	inc    %esi
    85d5:	8b 7c 24 04          	mov    0x4(%esp),%edi
    85d9:	e9 7b fd ff ff       	jmp    8359 <vsprintf+0x13>
			break;
		}
	}
	*str = '\0';										// 最后在转换好的字符串结尾处添上null.
    85de:	c6 03 00             	movb   $0x0,(%ebx)
	return str - buf;									// 返回转换好的字符串长度值.
    85e1:	89 d8                	mov    %ebx,%eax
    85e3:	2b 44 24 1c          	sub    0x1c(%esp),%eax
}
    85e7:	83 c4 08             	add    $0x8,%esp
    85ea:	5b                   	pop    %ebx
    85eb:	5e                   	pop    %esi
    85ec:	5f                   	pop    %edi
    85ed:	5d                   	pop    %ebp
    85ee:	c3                   	ret    

000085ef <sys_ftime>:
// 返回日期和时间（ftime - Fetch time）。
// 以下返回值是-ENOSYS的系统调用函数均表示在本版本内核中还未实现。
int sys_ftime()
{
	return -ENOSYS;
}
    85ef:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    85f4:	c3                   	ret    

000085f5 <sys_break>:
    85f5:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    85fa:	c3                   	ret    

000085fb <sys_ptrace>:
    85fb:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8600:	c3                   	ret    

00008601 <sys_stty>:
    8601:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8606:	c3                   	ret    

00008607 <sys_gtty>:
    8607:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    860c:	c3                   	ret    

0000860d <sys_rename>:
    860d:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8612:	c3                   	ret    

00008613 <sys_prof>:
    8613:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8618:	c3                   	ret    

00008619 <sys_setregid>:
 */
// 设置当前任务的实际以及/或者有效组ID（gid）。如果任务没有超级用户特权，那么只能互换其实际组ID和有效组ID。
// 如果任务具有超级用户特权，就能任意设置有效的和实际的组ID。保留的gid（saved gid）被设置成与有效gid。实际
// 组ID是指进程当前的gid。
int sys_setregid(int rgid, int egid)
{
    8619:	56                   	push   %esi
    861a:	53                   	push   %ebx
    861b:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    861f:	8b 54 24 10          	mov    0x10(%esp),%edx
    8623:	e8 04 e4 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8628:	81 c3 d8 89 01 00    	add    $0x189d8,%ebx
	if (rgid > 0) {
    862e:	85 c9                	test   %ecx,%ecx
    8630:	7e 29                	jle    865b <sys_setregid+0x42>
		if ((current->gid == rgid) ||
    8632:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8638:	8b 00                	mov    (%eax),%eax
    863a:	0f b7 b0 d2 02 00 00 	movzwl 0x2d2(%eax),%esi
    8641:	39 ce                	cmp    %ecx,%esi
    8643:	74 0f                	je     8654 <sys_setregid+0x3b>
    8645:	66 83 b8 ce 02 00 00 	cmpw   $0x0,0x2ce(%eax)
    864c:	00 
    864d:	74 05                	je     8654 <sys_setregid+0x3b>
		    suser())
			current->gid = rgid;
		else
			return(-EPERM);
    864f:	83 c8 ff             	or     $0xffffffff,%eax
    8652:	eb 45                	jmp    8699 <sys_setregid+0x80>
			current->gid = rgid;
    8654:	66 89 88 d2 02 00 00 	mov    %cx,0x2d2(%eax)
			current->egid = egid;
			current->sgid = egid;
		} else
			return(-EPERM);
	}
	return 0;
    865b:	31 c0                	xor    %eax,%eax
	if (egid > 0) {
    865d:	85 d2                	test   %edx,%edx
    865f:	7e 38                	jle    8699 <sys_setregid+0x80>
		if ((current->gid == egid) ||
    8661:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8667:	8b 00                	mov    (%eax),%eax
    8669:	0f b7 88 d2 02 00 00 	movzwl 0x2d2(%eax),%ecx
    8670:	39 d1                	cmp    %edx,%ecx
    8672:	74 15                	je     8689 <sys_setregid+0x70>
		    (current->egid == egid) ||
    8674:	0f b7 88 d4 02 00 00 	movzwl 0x2d4(%eax),%ecx
		if ((current->gid == egid) ||
    867b:	39 d1                	cmp    %edx,%ecx
    867d:	74 0a                	je     8689 <sys_setregid+0x70>
		    (current->egid == egid) ||
    867f:	66 83 b8 ce 02 00 00 	cmpw   $0x0,0x2ce(%eax)
    8686:	00 
    8687:	75 c6                	jne    864f <sys_setregid+0x36>
			current->egid = egid;
    8689:	66 89 90 d4 02 00 00 	mov    %dx,0x2d4(%eax)
			current->sgid = egid;
    8690:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%eax)
	return 0;
    8697:	31 c0                	xor    %eax,%eax
}
    8699:	5b                   	pop    %ebx
    869a:	5e                   	pop    %esi
    869b:	c3                   	ret    

0000869c <sys_setgid>:
 */
// 设置进程组号（gid）。如果任务没有超级用户特权，它可以使用setgid()将其有效gid（effective gid）设置为成其保留
// gid（saved git）或其实际git（real gid）。如果任务有超级用户特权，则实际gid、有效gid和保留gid都被设置成参数
// 指定的gid。
int sys_setgid(int gid)
{
    869c:	e8 d9 17 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    86a1:	05 5f 89 01 00       	add    $0x1895f,%eax
    86a6:	53                   	push   %ebx
    86a7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	if (suser())
    86ab:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    86b1:	8b 10                	mov    (%eax),%edx
    86b3:	66 83 ba ce 02 00 00 	cmpw   $0x0,0x2ce(%edx)
    86ba:	00 
    86bb:	75 17                	jne    86d4 <sys_setgid+0x38>
		current->gid = current->egid = current->sgid = gid;
    86bd:	66 89 8a d6 02 00 00 	mov    %cx,0x2d6(%edx)
    86c4:	66 89 8a d4 02 00 00 	mov    %cx,0x2d4(%edx)
    86cb:	66 89 8a d2 02 00 00 	mov    %cx,0x2d2(%edx)
    86d2:	eb 20                	jmp    86f4 <sys_setgid+0x58>
	else if ((gid == current->gid) || (gid == current->sgid))
    86d4:	0f b7 82 d2 02 00 00 	movzwl 0x2d2(%edx),%eax
    86db:	39 c8                	cmp    %ecx,%eax
    86dd:	74 0e                	je     86ed <sys_setgid+0x51>
    86df:	0f b7 9a d6 02 00 00 	movzwl 0x2d6(%edx),%ebx
		current->egid = gid;
	else
		return -EPERM;
    86e6:	83 c8 ff             	or     $0xffffffff,%eax
	else if ((gid == current->gid) || (gid == current->sgid))
    86e9:	39 cb                	cmp    %ecx,%ebx
    86eb:	75 09                	jne    86f6 <sys_setgid+0x5a>
		current->egid = gid;
    86ed:	66 89 8a d4 02 00 00 	mov    %cx,0x2d4(%edx)
	return 0;
    86f4:	31 c0                	xor    %eax,%eax
}
    86f6:	5b                   	pop    %ebx
    86f7:	c3                   	ret    

000086f8 <sys_acct>:
    86f8:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    86fd:	c3                   	ret    

000086fe <sys_phys>:
    86fe:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8703:	c3                   	ret    

00008704 <sys_lock>:
    8704:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8709:	c3                   	ret    

0000870a <sys_mpx>:
    870a:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    870f:	c3                   	ret    

00008710 <sys_ulimit>:
    8710:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    8715:	c3                   	ret    

00008716 <sys_time>:

// 返回从1970年1月1日00:00:00 GMT开始计时的时间值（秒）。如果tloc不为null，则时间值也存储在那里。
// 由于参数是一个指针，而其所指位置在用户空间，因此需要使用函数put_fs_long()来访问该值。在进入内核中运行时，段
// 寄存器fs默认地指向当前用户数据空间。因此该函数就可利用fs来访问用户空间中的值。
int sys_time(long * tloc)
{
    8716:	56                   	push   %esi
    8717:	53                   	push   %ebx
	int i;

	i = CURRENT_TIME;
    8718:	b9 64 00 00 00       	mov    $0x64,%ecx
    871d:	e8 0a e3 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8722:	81 c3 de 88 01 00    	add    $0x188de,%ebx
{
    8728:	83 ec 14             	sub    $0x14,%esp
	i = CURRENT_TIME;
    872b:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    8731:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
{
    8737:	8b 74 24 20          	mov    0x20(%esp),%esi
	i = CURRENT_TIME;
    873b:	8b 00                	mov    (%eax),%eax
    873d:	03 02                	add    (%edx),%eax
    873f:	31 d2                	xor    %edx,%edx
    8741:	f7 f1                	div    %ecx
    8743:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    8749:	03 02                	add    (%edx),%eax
	if (tloc) {
    874b:	85 f6                	test   %esi,%esi
    874d:	74 18                	je     8767 <sys_time+0x51>
    874f:	89 44 24 0c          	mov    %eax,0xc(%esp)
		verify_area(tloc,4);            				// 验证内存容量是否够（这里是4字节）。
    8753:	50                   	push   %eax
    8754:	50                   	push   %eax
    8755:	6a 04                	push   $0x4
    8757:	56                   	push   %esi
    8758:	e8 8e f4 ff ff       	call   7beb <verify_area>
//// 将一长字存放在fs段中指定内存地址处.
// 参数:val - 长字值;addr - 内存地址.
// %0 - 寄存器(长字值val);%1 - (内存地址addr).
static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    875d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    8761:	64 89 06             	mov    %eax,%fs:(%esi)
    8764:	83 c4 10             	add    $0x10,%esp
		put_fs_long(i,(unsigned long *)tloc);   		// 放入用户数据段tloc处。
	}
	return i;
}
    8767:	83 c4 14             	add    $0x14,%esp
    876a:	5b                   	pop    %ebx
    876b:	5e                   	pop    %esi
    876c:	c3                   	ret    

0000876d <sys_setreuid>:
 * 用setuid()和保存的gid的程序将会与POSIX 100%兼容。
 */
// 设置任务的实际以及/或者有效的用户ID（uid）。如果任务没有超级用户特权，那么只能互换其实际的uid和有效的uid。如果
// 任务具有超级用户特权，就能任意设置有效的和实际的用户ID。保存的uid（saved uid）被设置成与有效uid同值。
int sys_setreuid(int ruid, int euid)
{
    876d:	e8 08 17 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8772:	05 8e 88 01 00       	add    $0x1888e,%eax
    8777:	55                   	push   %ebp
    8778:	57                   	push   %edi
	int old_ruid = current->uid;
    8779:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
{
    877f:	56                   	push   %esi
    8780:	53                   	push   %ebx

	if (ruid > 0) {
    8781:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
{
    8786:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	int old_ruid = current->uid;
    878a:	8b 10                	mov    (%eax),%edx
    878c:	0f b7 ba cc 02 00 00 	movzwl 0x2cc(%edx),%edi
    8793:	89 fe                	mov    %edi,%esi
	if (ruid > 0) {
    8795:	7e 31                	jle    87c8 <sys_setreuid+0x5b>
		if ((current->euid == ruid) ||
    8797:	3b 7c 24 14          	cmp    0x14(%esp),%edi
    879b:	66 8b aa ce 02 00 00 	mov    0x2ce(%edx),%bp
    87a2:	0f 94 c0             	sete   %al
    87a5:	88 c3                	mov    %al,%bl
    87a7:	0f b7 c5             	movzwl %bp,%eax
    87aa:	3b 44 24 14          	cmp    0x14(%esp),%eax
    87ae:	0f 94 c0             	sete   %al
                    (old_ruid == ruid) ||
    87b1:	08 c3                	or     %al,%bl
    87b3:	75 08                	jne    87bd <sys_setreuid+0x50>
		    suser())
			current->uid = ruid;
		else
			return(-EPERM);
    87b5:	83 c8 ff             	or     $0xffffffff,%eax
                    (old_ruid == ruid) ||
    87b8:	66 85 ed             	test   %bp,%bp
    87bb:	75 41                	jne    87fe <sys_setreuid+0x91>
			current->uid = ruid;
    87bd:	8b 44 24 14          	mov    0x14(%esp),%eax
    87c1:	66 89 82 cc 02 00 00 	mov    %ax,0x2cc(%edx)
		} else {
			current->uid = old_ruid;
			return(-EPERM);
		}
	}
	return 0;
    87c8:	31 c0                	xor    %eax,%eax
	if (euid > 0) {
    87ca:	85 c9                	test   %ecx,%ecx
    87cc:	7e 30                	jle    87fe <sys_setreuid+0x91>
		if ((old_ruid == euid) ||
    87ce:	39 cf                	cmp    %ecx,%edi
    87d0:	74 10                	je     87e2 <sys_setreuid+0x75>
                    (current->euid == euid) ||
    87d2:	0f b7 9a ce 02 00 00 	movzwl 0x2ce(%edx),%ebx
    87d9:	39 cb                	cmp    %ecx,%ebx
    87db:	74 05                	je     87e2 <sys_setreuid+0x75>
    87dd:	66 85 db             	test   %bx,%bx
    87e0:	75 12                	jne    87f4 <sys_setreuid+0x87>
			current->euid = euid;
    87e2:	66 89 8a ce 02 00 00 	mov    %cx,0x2ce(%edx)
			current->suid = euid;
    87e9:	66 89 8a d0 02 00 00 	mov    %cx,0x2d0(%edx)
	return 0;
    87f0:	31 c0                	xor    %eax,%eax
			current->suid = euid;
    87f2:	eb 0a                	jmp    87fe <sys_setreuid+0x91>
			current->uid = old_ruid;
    87f4:	66 89 b2 cc 02 00 00 	mov    %si,0x2cc(%edx)
			return(-EPERM);
    87fb:	83 c8 ff             	or     $0xffffffff,%eax
}
    87fe:	5b                   	pop    %ebx
    87ff:	5e                   	pop    %esi
    8800:	5f                   	pop    %edi
    8801:	5d                   	pop    %ebp
    8802:	c3                   	ret    

00008803 <sys_setuid>:
 */
// 设置任务用户ID（uid）。如果任务没有超级用户特权，它可以使用setuid()将其有效的uid（effective uid）设置成其保存
// 的uid（saved uid）或其实际的uid（real uid）。如果用户有超级用户特权，则实际的uid、有效的uid和保存的uid都会被
// 设置成参数指定的uid。
int sys_setuid(int uid)
{
    8803:	e8 72 16 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8808:	05 f8 87 01 00       	add    $0x187f8,%eax
    880d:	53                   	push   %ebx
    880e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	if (suser())
    8812:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8818:	8b 10                	mov    (%eax),%edx
    881a:	66 83 ba ce 02 00 00 	cmpw   $0x0,0x2ce(%edx)
    8821:	00 
    8822:	75 17                	jne    883b <sys_setuid+0x38>
		current->uid = current->euid = current->suid = uid;
    8824:	66 89 8a d0 02 00 00 	mov    %cx,0x2d0(%edx)
    882b:	66 89 8a ce 02 00 00 	mov    %cx,0x2ce(%edx)
    8832:	66 89 8a cc 02 00 00 	mov    %cx,0x2cc(%edx)
    8839:	eb 20                	jmp    885b <sys_setuid+0x58>
	else if ((uid == current->uid) || (uid == current->suid))
    883b:	0f b7 82 cc 02 00 00 	movzwl 0x2cc(%edx),%eax
    8842:	39 c8                	cmp    %ecx,%eax
    8844:	74 0e                	je     8854 <sys_setuid+0x51>
    8846:	0f b7 9a d0 02 00 00 	movzwl 0x2d0(%edx),%ebx
		current->euid = uid;
	else
		return -EPERM;
    884d:	83 c8 ff             	or     $0xffffffff,%eax
	else if ((uid == current->uid) || (uid == current->suid))
    8850:	39 cb                	cmp    %ecx,%ebx
    8852:	75 09                	jne    885d <sys_setuid+0x5a>
		current->euid = uid;
    8854:	66 89 8a ce 02 00 00 	mov    %cx,0x2ce(%edx)
	return(0);
    885b:	31 c0                	xor    %eax,%eax
}
    885d:	5b                   	pop    %ebx
    885e:	c3                   	ret    

0000885f <sys_stime>:
// 调用进程必须具有超级用户权限。其中HZ=100,是内核系统运行频率。
// 由于参数是一个指针，而其所指位置在用户空间，因此需要使用函数get_fs_long()来访问该值。在进入内核中运行时，段
// 寄存器fs被默认地指向当前用户数据空间。因此该函数就可利用fs来访问用户空间中的值。函数参数提供的当前时间值减去
// 系统已经运行的时间秒值（jiffies/HZ）即是开机时间秒值。
int sys_stime(long * tptr)
{
    885f:	e8 1a 16 00 00       	call   9e7e <__x86.get_pc_thunk.cx>
    8864:	81 c1 9c 87 01 00    	add    $0x1879c,%ecx
	if (!suser())
    886a:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8870:	8b 10                	mov    (%eax),%edx
    8872:	66 83 ba ce 02 00 00 	cmpw   $0x0,0x2ce(%edx)
    8879:	00 
    887a:	75 35                	jne    88b1 <sys_stime+0x52>
{
    887c:	56                   	push   %esi
    887d:	53                   	push   %ebx
		return -EPERM;          					// 如果不是超级用户则出错返回（许可）。
	startup_time = get_fs_long((unsigned long *)tptr) - jiffies / HZ;
    887e:	be 64 00 00 00       	mov    $0x64,%esi
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    8883:	8b 44 24 0c          	mov    0xc(%esp),%eax
    8887:	31 d2                	xor    %edx,%edx
    8889:	64 8b 18             	mov    %fs:(%eax),%ebx
    888c:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    8892:	8b 00                	mov    (%eax),%eax
    8894:	f7 f6                	div    %esi
    8896:	29 c3                	sub    %eax,%ebx
    8898:	c7 c0 68 2a 02 00    	mov    $0x22a68,%eax
    889e:	89 18                	mov    %ebx,(%eax)
	jiffies_offset = 0;
    88a0:	c7 c0 64 2a 02 00    	mov    $0x22a64,%eax
    88a6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 0;
    88ac:	31 c0                	xor    %eax,%eax
}
    88ae:	5b                   	pop    %ebx
    88af:	5e                   	pop    %esi
    88b0:	c3                   	ret    
    88b1:	83 c8 ff             	or     $0xffffffff,%eax
    88b4:	c3                   	ret    

000088b5 <sys_times>:

// 获取当前任务运行时间统计值。
// 在tbuf所指用户数据空间处返回tms结构的任务运行时间统计值。tms结构中包括进程用户运行时间、内核（系统）时间、子进
// 程用户运行时间、子进程系统运行时间。函数返回值是系统运行到当前的嘀嗒数。
int sys_times(struct tms * tbuf)
{
    88b5:	56                   	push   %esi
    88b6:	53                   	push   %ebx
    88b7:	53                   	push   %ebx
    88b8:	8b 74 24 10          	mov    0x10(%esp),%esi
    88bc:	e8 6b e1 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    88c1:	81 c3 3f 87 01 00    	add    $0x1873f,%ebx
	if (tbuf) {
    88c7:	85 f6                	test   %esi,%esi
    88c9:	74 3c                	je     8907 <sys_times+0x52>
		verify_area(tbuf,sizeof *tbuf);
    88cb:	51                   	push   %ecx
    88cc:	51                   	push   %ecx
    88cd:	6a 10                	push   $0x10
    88cf:	56                   	push   %esi
    88d0:	e8 16 f3 ff ff       	call   7beb <verify_area>
		put_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);
    88d5:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    88db:	8b 00                	mov    (%eax),%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    88dd:	8b 90 e0 02 00 00    	mov    0x2e0(%eax),%edx
    88e3:	64 89 16             	mov    %edx,%fs:(%esi)
    88e6:	8b 90 e4 02 00 00    	mov    0x2e4(%eax),%edx
    88ec:	64 89 56 04          	mov    %edx,%fs:0x4(%esi)
    88f0:	8b 90 e8 02 00 00    	mov    0x2e8(%eax),%edx
    88f6:	64 89 56 08          	mov    %edx,%fs:0x8(%esi)
    88fa:	8b 80 ec 02 00 00    	mov    0x2ec(%eax),%eax
    8900:	64 89 46 0c          	mov    %eax,%fs:0xc(%esi)
    8904:	83 c4 10             	add    $0x10,%esp
		put_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);
		put_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);
		put_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);
	}
	return jiffies;
    8907:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    890d:	8b 00                	mov    (%eax),%eax
}
    890f:	5a                   	pop    %edx
    8910:	5b                   	pop    %ebx
    8911:	5e                   	pop    %esi
    8912:	c3                   	ret    

00008913 <sys_brk>:

// 当参数end_data_seg数值合理，并且系统确实有足够内存，而且进程没有超越其最大数据段大小时，该函数设置数据段末尾为
// end_data_seg指定的值。该值必须大于代码结尾并且要小于堆栈结尾16KB。返回值是数据段的新结尾值（如果返回值与要求不
// 同，则表明有错误发生)。该函数并不被用户直接调用，而由libc库函数进行包装，并且返回值也不一样。
int sys_brk(unsigned long end_data_seg)
{
    8913:	e8 62 15 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8918:	05 e8 86 01 00       	add    $0x186e8,%eax
    891d:	8b 54 24 04          	mov    0x4(%esp),%edx
	// 如果参数值大于代码结尾，并且小于（堆栈 - 16KB），则设置新数据段结尾值。
	if (end_data_seg >= current->end_code &&
    8921:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8927:	8b 00                	mov    (%eax),%eax
    8929:	39 90 1c 02 00 00    	cmp    %edx,0x21c(%eax)
    892f:	77 16                	ja     8947 <sys_brk+0x34>
	    end_data_seg < current->start_stack - 16384)
    8931:	8b 88 28 02 00 00    	mov    0x228(%eax),%ecx
    8937:	81 e9 00 40 00 00    	sub    $0x4000,%ecx
	if (end_data_seg >= current->end_code &&
    893d:	39 d1                	cmp    %edx,%ecx
    893f:	76 06                	jbe    8947 <sys_brk+0x34>
		current->brk = end_data_seg;
    8941:	89 90 24 02 00 00    	mov    %edx,0x224(%eax)
	return current->brk;            			// 返回进程当前的数据段结尾值。
    8947:	8b 80 24 02 00 00    	mov    0x224(%eax),%eax
}
    894d:	c3                   	ret    

0000894e <sys_setpgid>:
// 设置指定进程pid的进程组号为pgid。
// 参数pid是指定进程的进程号。如果它为0,则让pid等于当前进程的进程号。参数pgid是指定的进程组号。如果它为0,则让它等于
// 进程组号。如果该函数用于将进程从一个进程组移到另一个进程组，则这两个进程组必须属于同一个会话（session）。在这种情
// 况下，参数pgid指定了要加入的现在进程组ID，此时该组的会话ID必须与将要加入进程的相同。
int sys_setpgid(int pid, int pgid)
{
    894e:	55                   	push   %ebp
    894f:	57                   	push   %edi
    8950:	56                   	push   %esi
    8951:	53                   	push   %ebx
    8952:	e8 d5 e0 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8957:	81 c3 a9 86 01 00    	add    $0x186a9,%ebx
    895d:	83 ec 1c             	sub    $0x1c,%esp
	int i;

	// 如果参数pid为0,则pid取值为当前进程的进程号pid。如果参数pgid为0,则pgid也取值为当前进程的pid。[??这里与POSIX标
	// 准的描述有出入]。若pgid小于0,则返回无效错误码。
	if (!pid)
    8960:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
{
    8965:	8b 74 24 34          	mov    0x34(%esp),%esi
	if (!pid)
    8969:	75 12                	jne    897d <sys_setpgid+0x2f>
		pid = current->pid;
    896b:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8971:	8b 00                	mov    (%eax),%eax
    8973:	8b 80 2c 02 00 00    	mov    0x22c(%eax),%eax
    8979:	89 44 24 30          	mov    %eax,0x30(%esp)
	if (!pgid)
    897d:	85 f6                	test   %esi,%esi
    897f:	75 0e                	jne    898f <sys_setpgid+0x41>
		pgid = current->pid;
    8981:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8987:	8b 00                	mov    (%eax),%eax
    8989:	8b b0 2c 02 00 00    	mov    0x22c(%eax),%esi
	if (pgid < 0)
    898f:	85 f6                	test   %esi,%esi
		return -EINVAL;
    8991:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (pgid < 0)
    8996:	0f 88 8d 00 00 00    	js     8a29 <sys_setpgid+0xdb>
	// 扫描任务数组，查找指定进程号pid的任务。如果找到了进程号是pid的进程，并且该进程的父进程就是当前进程或者该进程就是当
	// 前进程，那么若该任务已经是会话首领，则出错返回。若该任务的会话号（session）与当前进程的不同，或者指定的进程组号pgid
	// 与pid不同并且pgid进程组所属会话号与当前进程所属会话号不同，则也出错返回。否则把查找到的进程的pgrp设置为pgid，并
	// 返回0。若没有找到指定pid的进程，则返回进程不存在出错码。
	for (i = 0 ; i < NR_TASKS ; i++)
		if (task[i] && (task[i]->pid == pid) && ((task[i]->p_pptr == current) || (task[i] == current))) {
    899c:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
    89a2:	c7 c0 60 22 02 00    	mov    $0x22260,%eax
	for (i = 0 ; i < NR_TASKS ; i++)
    89a8:	31 ff                	xor    %edi,%edi
		if (task[i] && (task[i]->pid == pid) && ((task[i]->p_pptr == current) || (task[i] == current))) {
    89aa:	8b 4d 00             	mov    0x0(%ebp),%ecx
    89ad:	89 44 24 0c          	mov    %eax,0xc(%esp)
    89b1:	8b 44 24 0c          	mov    0xc(%esp),%eax
    89b5:	8b 04 b8             	mov    (%eax,%edi,4),%eax
    89b8:	85 c0                	test   %eax,%eax
    89ba:	74 62                	je     8a1e <sys_setpgid+0xd0>
    89bc:	8b 90 2c 02 00 00    	mov    0x22c(%eax),%edx
    89c2:	3b 54 24 30          	cmp    0x30(%esp),%edx
    89c6:	75 56                	jne    8a1e <sys_setpgid+0xd0>
    89c8:	39 88 bc 02 00 00    	cmp    %ecx,0x2bc(%eax)
    89ce:	74 04                	je     89d4 <sys_setpgid+0x86>
    89d0:	39 c8                	cmp    %ecx,%eax
    89d2:	75 4a                	jne    8a1e <sys_setpgid+0xd0>
			if (task[i]->leader)
    89d4:	83 b8 38 02 00 00 00 	cmpl   $0x0,0x238(%eax)
    89db:	74 05                	je     89e2 <sys_setpgid+0x94>
				return -EPERM;
    89dd:	83 c8 ff             	or     $0xffffffff,%eax
    89e0:	eb 47                	jmp    8a29 <sys_setpgid+0xdb>
			if ((task[i]->session != current->session) ||
    89e2:	8b 89 34 02 00 00    	mov    0x234(%ecx),%ecx
    89e8:	39 88 34 02 00 00    	cmp    %ecx,0x234(%eax)
    89ee:	75 ed                	jne    89dd <sys_setpgid+0x8f>
    89f0:	39 f2                	cmp    %esi,%edx
    89f2:	75 11                	jne    8a05 <sys_setpgid+0xb7>
			    ((pgid != pid) &&
			     (session_of_pgrp(pgid) != current->session)))
				return -EPERM;
			task[i]->pgrp = pgid;
    89f4:	8b 44 24 0c          	mov    0xc(%esp),%eax
    89f8:	8b 04 b8             	mov    (%eax,%edi,4),%eax
    89fb:	89 b0 30 02 00 00    	mov    %esi,0x230(%eax)
			return 0;
    8a01:	31 c0                	xor    %eax,%eax
    8a03:	eb 24                	jmp    8a29 <sys_setpgid+0xdb>
			     (session_of_pgrp(pgid) != current->session)))
    8a05:	83 ec 0c             	sub    $0xc,%esp
    8a08:	56                   	push   %esi
    8a09:	e8 ee 09 00 00       	call   93fc <session_of_pgrp>
    8a0e:	8b 4d 00             	mov    0x0(%ebp),%ecx
			    ((pgid != pid) &&
    8a11:	83 c4 10             	add    $0x10,%esp
    8a14:	3b 81 34 02 00 00    	cmp    0x234(%ecx),%eax
    8a1a:	74 d8                	je     89f4 <sys_setpgid+0xa6>
    8a1c:	eb bf                	jmp    89dd <sys_setpgid+0x8f>
	for (i = 0 ; i < NR_TASKS ; i++)
    8a1e:	47                   	inc    %edi
    8a1f:	83 ff 40             	cmp    $0x40,%edi
    8a22:	75 8d                	jne    89b1 <sys_setpgid+0x63>
		}
	return -ESRCH;
    8a24:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
    8a29:	83 c4 1c             	add    $0x1c,%esp
    8a2c:	5b                   	pop    %ebx
    8a2d:	5e                   	pop    %esi
    8a2e:	5f                   	pop    %edi
    8a2f:	5d                   	pop    %ebp
    8a30:	c3                   	ret    

00008a31 <sys_getpgrp>:

// 返回当前进程的进程组号。与getpgid(0)等同。
int sys_getpgrp(void)
{
    8a31:	e8 44 14 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8a36:	05 ca 85 01 00       	add    $0x185ca,%eax
	return current->pgrp;
    8a3b:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8a41:	8b 00                	mov    (%eax),%eax
    8a43:	8b 80 30 02 00 00    	mov    0x230(%eax),%eax
}
    8a49:	c3                   	ret    

00008a4a <sys_setsid>:

// 创建一个会话（session）（即设置其leader = 1），并且设置其会话号=其组号=其进程号。
// 如果当前进程已是会话首领并且不是超级用户，则出错返回。否则设置当前进程为新会话首领（leader = 1），并且设置当前进程会话
// 号session和组号pgrp都等于进程号pid，而且设置当前进程没有控制终端。最后系统调用返回会话号。
int sys_setsid(void)
{
    8a4a:	e8 2b 14 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8a4f:	05 b1 85 01 00       	add    $0x185b1,%eax
	if (current->leader && !suser())
    8a54:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8a5a:	8b 10                	mov    (%eax),%edx
    8a5c:	83 ba 38 02 00 00 00 	cmpl   $0x0,0x238(%edx)
    8a63:	74 0d                	je     8a72 <sys_setsid+0x28>
		return -EPERM;
    8a65:	83 c8 ff             	or     $0xffffffff,%eax
	if (current->leader && !suser())
    8a68:	66 83 ba ce 02 00 00 	cmpw   $0x0,0x2ce(%edx)
    8a6f:	00 
    8a70:	75 26                	jne    8a98 <sys_setsid+0x4e>
	current->leader = 1;
	current->session = current->pgrp = current->pid;
    8a72:	8b 82 2c 02 00 00    	mov    0x22c(%edx),%eax
	current->leader = 1;
    8a78:	c7 82 38 02 00 00 01 	movl   $0x1,0x238(%edx)
    8a7f:	00 00 00 
	current->tty = -1;      				// 表示当前进程没有控制终端。
    8a82:	c7 82 2c 03 00 00 ff 	movl   $0xffffffff,0x32c(%edx)
    8a89:	ff ff ff 
	current->session = current->pgrp = current->pid;
    8a8c:	89 82 30 02 00 00    	mov    %eax,0x230(%edx)
    8a92:	89 82 34 02 00 00    	mov    %eax,0x234(%edx)
	return current->pgrp;
}
    8a98:	c3                   	ret    

00008a99 <sys_getgroups>:
// 取当前进程其他辅助用户组号。
// 任务数据结构中groups[]数组保存着进程同时所属的多个用户组号。该数组共NGROUPS个项，若某项值是NOGROUP（即为-1），则
// 表示从该项开始以后所有项都空闲。否则数组项中保存的是用户组号。
// 参数gidsetsize是获取的用户组号个数；grouplist是存储这些用户组号的用户空间缓存。
int sys_getgroups(int gidsetsize, gid_t *grouplist)
{
    8a99:	57                   	push   %edi
    8a9a:	56                   	push   %esi
    8a9b:	53                   	push   %ebx
    8a9c:	8b 74 24 10          	mov    0x10(%esp),%esi
    8aa0:	e8 87 df ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8aa5:	81 c3 5b 85 01 00    	add    $0x1855b,%ebx
    8aab:	8b 7c 24 14          	mov    0x14(%esp),%edi

	// 首先验证grouplist指针所指的用户缓存空间是否足够，然后从当前进程结构的groups[]数组中逐个取得用户组号并复制到用户缓存
	// 中。在复制过程中，如果groups[]中的项数大于给定的参数gitsetsize所指定的个数，则表示用户给出的缓存太小，不能容下当前
	// 进程所有组号，因此此次取组号操作会出错返回。若复制过程正常，则函数最后会返回复制的用户组号个数。（gidsetsize - gid
	// set size，用户组号集大小）。
	if (gidsetsize)
    8aaf:	85 f6                	test   %esi,%esi
    8ab1:	74 0f                	je     8ac2 <sys_getgroups+0x29>
		verify_area(grouplist, sizeof(gid_t) * gidsetsize);
    8ab3:	50                   	push   %eax
    8ab4:	50                   	push   %eax
    8ab5:	8d 04 36             	lea    (%esi,%esi,1),%eax
    8ab8:	50                   	push   %eax
    8ab9:	57                   	push   %edi
    8aba:	e8 2c f1 ff ff       	call   7beb <verify_area>
    8abf:	83 c4 10             	add    $0x10,%esp

	for (i = 0; (i < NGROUPS) && (current->groups[i] != NOGROUP); i++, grouplist++) {
    8ac2:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8ac8:	8b 18                	mov    (%eax),%ebx
    8aca:	31 c0                	xor    %eax,%eax
    8acc:	8b 8c 83 3c 02 00 00 	mov    0x23c(%ebx,%eax,4),%ecx
    8ad3:	8d 14 00             	lea    (%eax,%eax,1),%edx
    8ad6:	01 fa                	add    %edi,%edx
    8ad8:	83 f9 ff             	cmp    $0xffffffff,%ecx
    8adb:	74 19                	je     8af6 <sys_getgroups+0x5d>
		if (gidsetsize) {
    8add:	85 f6                	test   %esi,%esi
    8adf:	74 08                	je     8ae9 <sys_getgroups+0x50>
			if (i >= gidsetsize)
    8ae1:	39 c6                	cmp    %eax,%esi
    8ae3:	7e 0c                	jle    8af1 <sys_getgroups+0x58>
__asm__ ("movw %0,%%fs:%1"::"q" (val),"m" (*addr));
    8ae5:	64 66 89 0a          	mov    %cx,%fs:(%edx)
	for (i = 0; (i < NGROUPS) && (current->groups[i] != NOGROUP); i++, grouplist++) {
    8ae9:	40                   	inc    %eax
    8aea:	83 f8 20             	cmp    $0x20,%eax
    8aed:	75 dd                	jne    8acc <sys_getgroups+0x33>
    8aef:	eb 05                	jmp    8af6 <sys_getgroups+0x5d>
				return -EINVAL;
    8af1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			put_fs_word(current->groups[i], (short *) grouplist);
		}
	}
	return(i);              				// 返回实际含有的用户组号个数。
}
    8af6:	5b                   	pop    %ebx
    8af7:	5e                   	pop    %esi
    8af8:	5f                   	pop    %edi
    8af9:	c3                   	ret    

00008afa <sys_setgroups>:

// 设置当前进程同时所属的其他辅助用户组号。
// 参数gidsetsize是将设置的用户组号个数；grouplist是含有用户组号的用户空间缓存。
int sys_setgroups(int gidsetsize, gid_t *grouplist)
{
    8afa:	e8 7b 13 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8aff:	05 01 85 01 00       	add    $0x18501,%eax
    8b04:	53                   	push   %ebx
    8b05:	8b 54 24 08          	mov    0x8(%esp),%edx
	int	i;

	// 首先查权限和参数的有效性。只有超级用户可以修改或设置当前进程的辅助用户组号，而且设置的项数不能超过进程的groups[NGROUPS]
	// 数组的容量。然后从用户缓冲中逐个复制用户组号，共gidsetsize个。如果复制的个数没有填满group[]，则在随后一项上填上值为-1
	// 的项（NOGROUP）。最后函数返回0。
	if (!suser())
    8b09:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8b0f:	8b 08                	mov    (%eax),%ecx
		return -EPERM;
    8b11:	83 c8 ff             	or     $0xffffffff,%eax
	if (!suser())
    8b14:	66 83 b9 ce 02 00 00 	cmpw   $0x0,0x2ce(%ecx)
    8b1b:	00 
    8b1c:	75 44                	jne    8b62 <sys_setgroups+0x68>
	if (gidsetsize > NGROUPS)
    8b1e:	83 fa 20             	cmp    $0x20,%edx
		return -EINVAL;
    8b21:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (gidsetsize > NGROUPS)
    8b26:	7f 3a                	jg     8b62 <sys_setgroups+0x68>
	for (i = 0; i < gidsetsize; i++, grouplist++) {
    8b28:	31 c0                	xor    %eax,%eax
    8b2a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    8b2d:	03 5c 24 0c          	add    0xc(%esp),%ebx
    8b31:	39 d0                	cmp    %edx,%eax
    8b33:	7d 11                	jge    8b46 <sys_setgroups+0x4c>
	__asm__ ("movw %%fs:%1,%0":"=q" (_v):"m" (*addr));
    8b35:	64 66 8b 1b          	mov    %fs:(%ebx),%bx
		current->groups[i] = get_fs_word((unsigned short *) grouplist);
    8b39:	0f b7 db             	movzwl %bx,%ebx
    8b3c:	89 9c 81 3c 02 00 00 	mov    %ebx,0x23c(%ecx,%eax,4)
	for (i = 0; i < gidsetsize; i++, grouplist++) {
    8b43:	40                   	inc    %eax
    8b44:	eb e4                	jmp    8b2a <sys_setgroups+0x30>
    8b46:	85 d2                	test   %edx,%edx
    8b48:	bb 00 00 00 00       	mov    $0x0,%ebx
    8b4d:	0f 49 da             	cmovns %edx,%ebx
	}
	if (i < NGROUPS)
		current->groups[i] = NOGROUP;
	return 0;
    8b50:	31 c0                	xor    %eax,%eax
	if (i < NGROUPS)
    8b52:	83 fa 20             	cmp    $0x20,%edx
    8b55:	74 0b                	je     8b62 <sys_setgroups+0x68>
		current->groups[i] = NOGROUP;
    8b57:	c7 84 99 3c 02 00 00 	movl   $0xffffffff,0x23c(%ecx,%ebx,4)
    8b5e:	ff ff ff ff 
}
    8b62:	5b                   	pop    %ebx
    8b63:	c3                   	ret    

00008b64 <in_group_p>:

// 检查当前进程是否在指定的用户组grp中.是则返回1,否则返回0.
int in_group_p(gid_t grp)
{
    8b64:	e8 11 13 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8b69:	05 97 84 01 00       	add    $0x18497,%eax
    8b6e:	53                   	push   %ebx
    8b6f:	8b 5c 24 08          	mov    0x8(%esp),%ebx
	int	i;

	// 如果当前进程的有效组号就是grp,则表示进程属于grp进程组.函数返回1.否则就在进程的辅助用户组数组中扫描是否有grp进程组号.若
	// 有则函数也返回1.若扫描到值为NOGROUP的项,表示已扫描完全部有效项没有发现匹配的组号,因此函数返回0.
	if (grp == current->egid)
    8b73:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8b79:	8b 08                	mov    (%eax),%ecx
		return 1;
    8b7b:	b8 01 00 00 00       	mov    $0x1,%eax
	if (grp == current->egid)
    8b80:	66 39 99 d4 02 00 00 	cmp    %bx,0x2d4(%ecx)
    8b87:	74 24                	je     8bad <in_group_p+0x49>
    8b89:	0f b7 d3             	movzwl %bx,%edx

	for (i = 0; i < NGROUPS; i++) {
    8b8c:	31 c0                	xor    %eax,%eax
		if (current->groups[i] == NOGROUP)
    8b8e:	8b 9c 81 3c 02 00 00 	mov    0x23c(%ecx,%eax,4),%ebx
    8b95:	83 fb ff             	cmp    $0xffffffff,%ebx
    8b98:	74 0a                	je     8ba4 <in_group_p+0x40>
			break;
		if (current->groups[i] == grp)
    8b9a:	39 d3                	cmp    %edx,%ebx
    8b9c:	74 0a                	je     8ba8 <in_group_p+0x44>
	for (i = 0; i < NGROUPS; i++) {
    8b9e:	40                   	inc    %eax
    8b9f:	83 f8 20             	cmp    $0x20,%eax
    8ba2:	75 ea                	jne    8b8e <in_group_p+0x2a>
			return 1;
	}
	return 0;
    8ba4:	31 c0                	xor    %eax,%eax
    8ba6:	eb 05                	jmp    8bad <in_group_p+0x49>
		return 1;
    8ba8:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8bad:	5b                   	pop    %ebx
    8bae:	c3                   	ret    

00008baf <sys_uname>:
	UTS_SYSNAME, UTS_NODENAME, UTS_RELEASE, UTS_VERSION, UTS_MACHINE
};

// 获取系统名称等信息。
int sys_uname(struct utsname * name)
{
    8baf:	56                   	push   %esi
    8bb0:	53                   	push   %ebx
    8bb1:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
    8bb6:	53                   	push   %ebx
    8bb7:	8b 74 24 10          	mov    0x10(%esp),%esi
    8bbb:	e8 6c de ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8bc0:	81 c3 40 84 01 00    	add    $0x18440,%ebx
	int i;

	if (!name) return -ERROR;
    8bc6:	85 f6                	test   %esi,%esi
    8bc8:	74 22                	je     8bec <sys_uname+0x3d>
	verify_area(name,sizeof *name);
    8bca:	51                   	push   %ecx
    8bcb:	51                   	push   %ecx
    8bcc:	6a 2d                	push   $0x2d
    8bce:	56                   	push   %esi
    8bcf:	e8 17 f0 ff ff       	call   7beb <verify_area>
    8bd4:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < sizeof *name; i++)
    8bd7:	31 c0                	xor    %eax,%eax
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    8bd9:	8a 94 18 a0 00 00 00 	mov    0xa0(%eax,%ebx,1),%dl
    8be0:	64 88 14 06          	mov    %dl,%fs:(%esi,%eax,1)
    8be4:	40                   	inc    %eax
    8be5:	83 f8 2d             	cmp    $0x2d,%eax
    8be8:	75 ef                	jne    8bd9 <sys_uname+0x2a>
		put_fs_byte(((char *) &thisname)[i], i + (char *) name);
	return 0;
    8bea:	31 c0                	xor    %eax,%eax
}
    8bec:	5a                   	pop    %edx
    8bed:	5b                   	pop    %ebx
    8bee:	5e                   	pop    %esi
    8bef:	c3                   	ret    

00008bf0 <sys_sethostname>:
 * 通过调用uname()只能实现sethostname和gethostname。
 */
// 设置系统主机名（系统的网络节点名）。
// 参数name指针指向用户数据区中含有主机名字符串的缓冲区；len是主机名字符串长度。
int sys_sethostname(char *name, int len)
{
    8bf0:	e8 33 de ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
    8bf5:	81 c2 0b 84 01 00    	add    $0x1840b,%edx
    8bfb:	53                   	push   %ebx
    8bfc:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
	int	i;

	// 系统主机名只能由超级用户设置或修改，并且主机名长度不能超过最大长度MAXHOSTNAMELEN。
	if (!suser())
    8c00:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8c06:	8b 18                	mov    (%eax),%ebx
		return -EPERM;
    8c08:	83 c8 ff             	or     $0xffffffff,%eax
	if (!suser())
    8c0b:	66 83 bb ce 02 00 00 	cmpw   $0x0,0x2ce(%ebx)
    8c12:	00 
    8c13:	75 3b                	jne    8c50 <sys_sethostname+0x60>
	if (len > MAXHOSTNAMELEN)
    8c15:	83 f9 08             	cmp    $0x8,%ecx
		return -EINVAL;
    8c18:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (len > MAXHOSTNAMELEN)
    8c1d:	7f 31                	jg     8c50 <sys_sethostname+0x60>
	for (i = 0; i < len; i++) {
    8c1f:	31 c0                	xor    %eax,%eax
    8c21:	39 c8                	cmp    %ecx,%eax
    8c23:	7d 13                	jge    8c38 <sys_sethostname+0x48>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    8c25:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    8c29:	64 8a 1c 03          	mov    %fs:(%ebx,%eax,1),%bl
		if ((thisname.nodename[i] = get_fs_byte(name + i)) == 0)
    8c2d:	84 db                	test   %bl,%bl
    8c2f:	88 9c 10 a9 00 00 00 	mov    %bl,0xa9(%eax,%edx,1)
    8c36:	75 13                	jne    8c4b <sys_sethostname+0x5b>
			break;
	}
	// 在复制完毕后，如果用户提供的字符串没有包含NULL字符，那么若复制的主机名长度还没有超过MAXHOSTNAMELEN，则在主机名字
	// 符串后添加一个NULL。若已经填满MAXHOSTNAMELEN个字符，则把最后一个字符改成NULL字符。即thisname.nodename[min(
	// i,MAXHOSTNAMELEN)] = 0。
	if (thisname.nodename[i]) {
    8c38:	8d 84 02 a0 00 00 00 	lea    0xa0(%edx,%eax,1),%eax
    8c3f:	80 78 09 00          	cmpb   $0x0,0x9(%eax)
    8c43:	74 09                	je     8c4e <sys_sethostname+0x5e>
		thisname.nodename[i > MAXHOSTNAMELEN ? MAXHOSTNAMELEN : i] = 0;
    8c45:	c6 40 09 00          	movb   $0x0,0x9(%eax)
    8c49:	eb 03                	jmp    8c4e <sys_sethostname+0x5e>
	for (i = 0; i < len; i++) {
    8c4b:	40                   	inc    %eax
    8c4c:	eb d3                	jmp    8c21 <sys_sethostname+0x31>
	}
	return 0;
    8c4e:	31 c0                	xor    %eax,%eax
}
    8c50:	5b                   	pop    %ebx
    8c51:	c3                   	ret    

00008c52 <sys_getrlimit>:
// 界限（hard limit，即硬限制）。rlim[]数组的每一项对应系统对当前进程一种资源的界限信息。Linux 0.12系统共对6种资源
// 规定了界限，即RLIM_NLIMITS=6。请参考头文件include/sys/resource.h说明。
// 参数resource指定我们咨询的资源名称，实际上它是任务结构中rlim[]数组的索引项值。
// 参数rlim是指向rlimit结构的用户缓冲区指针，用于存放取得的资源界限信息。
int sys_getrlimit(int resource, struct rlimit *rlim)
{
    8c52:	57                   	push   %edi
    8c53:	56                   	push   %esi
    8c54:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    8c59:	53                   	push   %ebx
    8c5a:	8b 7c 24 10          	mov    0x10(%esp),%edi
    8c5e:	e8 c9 dd ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8c63:	81 c3 9d 83 01 00    	add    $0x1839d,%ebx
    8c69:	8b 74 24 14          	mov    0x14(%esp),%esi
	// 所咨询的资源resource实际上是进程任务结构中rlim[]数组的索引项值。该索引值当然不能大于数组的最大项数RLIM_NLIMITS。
	// 在验证过rlim指针所指用户缓冲足够以后，这里就把参数指定的资源resource结构信息复制到用户缓冲区中，并返回0。
	if (resource >= RLIM_NLIMITS)
    8c6d:	83 ff 05             	cmp    $0x5,%edi
    8c70:	7f 2d                	jg     8c9f <sys_getrlimit+0x4d>
		return -EINVAL;
	verify_area(rlim, sizeof *rlim);
    8c72:	50                   	push   %eax
    8c73:	50                   	push   %eax
    8c74:	6a 08                	push   $0x8
    8c76:	56                   	push   %esi
    8c77:	e8 6f ef ff ff       	call   7beb <verify_area>
    8c7c:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8c82:	8b 00                	mov    (%eax),%eax
    8c84:	8d 04 f8             	lea    (%eax,%edi,8),%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    8c87:	8b 90 f4 02 00 00    	mov    0x2f4(%eax),%edx
    8c8d:	64 89 16             	mov    %edx,%fs:(%esi)
    8c90:	8b 80 f8 02 00 00    	mov    0x2f8(%eax),%eax
    8c96:	64 89 46 04          	mov    %eax,%fs:0x4(%esi)
	put_fs_long(current->rlim[resource].rlim_cur,           // 当前（软）限制值。
		    (unsigned long *) rlim);
	put_fs_long(current->rlim[resource].rlim_max,           // 系统（硬）限制值。
		    ((unsigned long *) rlim) + 1);
	return 0;
    8c9a:	31 c0                	xor    %eax,%eax
    8c9c:	83 c4 10             	add    $0x10,%esp
}
    8c9f:	5b                   	pop    %ebx
    8ca0:	5e                   	pop    %esi
    8ca1:	5f                   	pop    %edi
    8ca2:	c3                   	ret    

00008ca3 <sys_setrlimit>:

// 设置当前进程指定资源的界限值。
// 参数resource指定我们设置界限的资源名称，实际上它是任务结构中rlim[]数组的索引项值。
// 参数rlim是指向rlimit结构的用户缓冲区指针，用于内核读取新的资源界限信息。
int sys_setrlimit(int resource, struct rlimit *rlim)
{
    8ca3:	56                   	push   %esi
    8ca4:	53                   	push   %ebx
	// 首先判断参数resource（任务结构rlim[]项索引值）有效性。然后先让rlimit结构指针old指向进程任务结构中指定资源的当前
	// rlimit结构信息。接着把用户提供的资源界限信息复制到临时rlimit结构new中。此时如果判断出new结构中的软界限值或硬界限
	// 值大于进程该资源原硬界限值，并且当前不是超级用户的话，就返回许可出错。否则表示new中信息合理或者进程是超级用户进程，
	// 则修改原进程指定资源信息等于new结构中的信息，并成功返回0。
	if (resource >= RLIM_NLIMITS)
		return -EINVAL;
    8ca5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
    8caa:	8b 54 24 0c          	mov    0xc(%esp),%edx
    8cae:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    8cb2:	e8 75 dd ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8cb7:	81 c3 49 83 01 00    	add    $0x18349,%ebx
	if (resource >= RLIM_NLIMITS)
    8cbd:	83 fa 05             	cmp    $0x5,%edx
    8cc0:	7f 35                	jg     8cf7 <sys_setrlimit+0x54>
	old = current->rlim + resource;
    8cc2:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    8cc8:	64 8b 19             	mov    %fs:(%ecx),%ebx
    8ccb:	64 8b 49 04          	mov    %fs:0x4(%ecx),%ecx
    8ccf:	8b 30                	mov    (%eax),%esi
    8cd1:	8d 94 d6 f4 02 00 00 	lea    0x2f4(%esi,%edx,8),%edx
	new.rlim_cur = get_fs_long((unsigned long *) rlim);
	new.rlim_max = get_fs_long(((unsigned long *) rlim) + 1);
	if (((new.rlim_cur > old->rlim_max) || (new.rlim_max > old->rlim_max)) && !suser())
    8cd8:	8b 42 04             	mov    0x4(%edx),%eax
    8cdb:	39 c1                	cmp    %eax,%ecx
    8cdd:	7f 04                	jg     8ce3 <sys_setrlimit+0x40>
    8cdf:	39 c3                	cmp    %eax,%ebx
    8ce1:	7e 0d                	jle    8cf0 <sys_setrlimit+0x4d>
		return -EPERM;
    8ce3:	83 c8 ff             	or     $0xffffffff,%eax
	if (((new.rlim_cur > old->rlim_max) || (new.rlim_max > old->rlim_max)) && !suser())
    8ce6:	66 83 be ce 02 00 00 	cmpw   $0x0,0x2ce(%esi)
    8ced:	00 
    8cee:	75 07                	jne    8cf7 <sys_setrlimit+0x54>
	*old = new;
    8cf0:	89 1a                	mov    %ebx,(%edx)
    8cf2:	89 4a 04             	mov    %ecx,0x4(%edx)
	return 0;
    8cf5:	31 c0                	xor    %eax,%eax
}
    8cf7:	5b                   	pop    %ebx
    8cf8:	5e                   	pop    %esi
    8cf9:	c3                   	ret    

00008cfa <sys_getrusage>:
// 获取指定进程的资源利用信息。
// 本系统调用提供当前进程或其已终止的和等待着的子进程资源使用情况。如果参数who等于RUSAGE_SELF，则返回当前进程的资源利用
// 信息。如果指定进程who是RUSAGE_CHILDREN，则返回当前进程的已终止和等待着的子进程资源利用信息。符号常数RUSAGE_SELF和
// RUSAGE_CHILDREN以及rusage结构都定义在include/sys/resource.h文件中。
int sys_getrusage(int who, struct rusage *ru)
{
    8cfa:	55                   	push   %ebp
    8cfb:	57                   	push   %edi
    8cfc:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    8d01:	56                   	push   %esi
    8d02:	53                   	push   %ebx
    8d03:	e8 24 dd ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8d08:	81 c3 f8 82 01 00    	add    $0x182f8,%ebx
    8d0e:	83 ec 5c             	sub    $0x5c,%esp
    8d11:	8b 74 24 70          	mov    0x70(%esp),%esi
    8d15:	8b 6c 24 74          	mov    0x74(%esp),%ebp
	struct rusage r;
	unsigned long	*lp, *lpend, *dest;

	// 首先判断参数指定进程的有效性。如果who即不是RUSAGE_SELF（指定当前进程），也不是RUSAGE_CHILDREN（指定子进程），则以
	// 无效参数码返回。否则在验证了指针ru指定的用户缓冲区域后，把临时rusage结构区域r清零。
	if (who != RUSAGE_SELF && who != RUSAGE_CHILDREN)
    8d19:	8d 56 01             	lea    0x1(%esi),%edx
    8d1c:	83 fa 01             	cmp    $0x1,%edx
    8d1f:	0f 87 94 00 00 00    	ja     8db9 <sys_getrusage+0xbf>
		return -EINVAL;
	verify_area(ru, sizeof *ru);
    8d25:	50                   	push   %eax
    8d26:	50                   	push   %eax
    8d27:	6a 48                	push   $0x48
    8d29:	55                   	push   %ebp
    8d2a:	e8 bc ee ff ff       	call   7beb <verify_area>
// 用字符填写指定长度内存块.
// 用字符c填写s指向的内存区域,共填count字节.
// %0 - eax(字符c),%1 - edi(内存地址),%2 - ecx(字节数count).
static inline void * memset(void * s, char c, int count)
{
__asm__(
    8d2f:	8d 7c 24 18          	lea    0x18(%esp),%edi
    8d33:	31 c0                	xor    %eax,%eax
    8d35:	b9 48 00 00 00       	mov    $0x48,%ecx
    8d3a:	fc                   	cld    
    8d3b:	57                   	push   %edi
    8d3c:	f3 aa                	rep stos %al,%es:(%edi)
    8d3e:	5f                   	pop    %edi
    8d3f:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	memset((char *) &r, 0, sizeof(r));
	// 若参数who是RUSAGE_SELF，则复制当前进程资源利用信息到r结构中。若指定进程who是RUSAGE_CHILDREN，则复制当前进程的已终止
	// 和等待着的子进程资源利用信息到临时rusage结构r中。宏CT_TO_SECS和CT_TO_USECS用于把系统当前嘀嗒数转换成用秒值加微秒值
	// 表示。它们定义在include/linux/sched.h文件中。jiffies_offset是系统嘀嗒数误差调整数。
	if (who == RUSAGE_SELF) {
    8d45:	83 c4 10             	add    $0x10,%esp
    8d48:	85 f6                	test   %esi,%esi
		r.ru_utime.tv_sec = CT_TO_SECS(current->utime);
    8d4a:	8b 18                	mov    (%eax),%ebx
	if (who == RUSAGE_SELF) {
    8d4c:	75 24                	jne    8d72 <sys_getrusage+0x78>
		r.ru_utime.tv_sec = CT_TO_SECS(current->utime);
    8d4e:	8b 83 e0 02 00 00    	mov    0x2e0(%ebx),%eax
    8d54:	b9 64 00 00 00       	mov    $0x64,%ecx
    8d59:	99                   	cltd   
    8d5a:	f7 f9                	idiv   %ecx
    8d5c:	89 44 24 08          	mov    %eax,0x8(%esp)
		r.ru_utime.tv_usec = CT_TO_USECS(current->utime);
    8d60:	69 c2 10 27 00 00    	imul   $0x2710,%edx,%eax
    8d66:	89 44 24 0c          	mov    %eax,0xc(%esp)
		r.ru_stime.tv_sec = CT_TO_SECS(current->stime);
    8d6a:	8b 83 e4 02 00 00    	mov    0x2e4(%ebx),%eax
    8d70:	eb 22                	jmp    8d94 <sys_getrusage+0x9a>
		r.ru_stime.tv_usec = CT_TO_USECS(current->stime);
	} else {
		r.ru_utime.tv_sec = CT_TO_SECS(current->cutime);
    8d72:	8b 83 e8 02 00 00    	mov    0x2e8(%ebx),%eax
    8d78:	b9 64 00 00 00       	mov    $0x64,%ecx
    8d7d:	99                   	cltd   
    8d7e:	f7 f9                	idiv   %ecx
    8d80:	89 44 24 08          	mov    %eax,0x8(%esp)
		r.ru_utime.tv_usec = CT_TO_USECS(current->cutime);
    8d84:	69 c2 10 27 00 00    	imul   $0x2710,%edx,%eax
    8d8a:	89 44 24 0c          	mov    %eax,0xc(%esp)
		r.ru_stime.tv_sec = CT_TO_SECS(current->cstime);
    8d8e:	8b 83 ec 02 00 00    	mov    0x2ec(%ebx),%eax
    8d94:	99                   	cltd   
    8d95:	f7 f9                	idiv   %ecx
    8d97:	89 44 24 10          	mov    %eax,0x10(%esp)
		r.ru_stime.tv_usec = CT_TO_USECS(current->cstime);
    8d9b:	69 c2 10 27 00 00    	imul   $0x2710,%edx,%eax
    8da1:	89 44 24 14          	mov    %eax,0x14(%esp)
{
    8da5:	31 c0                	xor    %eax,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    8da7:	8b 14 07             	mov    (%edi,%eax,1),%edx
    8daa:	64 89 54 05 00       	mov    %edx,%fs:0x0(%ebp,%eax,1)
    8daf:	83 c0 04             	add    $0x4,%eax
	// 然后让lp指针指向r结构，lpend指向r结构末尾处，而dest指针指向用户空间中的ru结构。最后把r中信息复制到用户空间ru结构中，并
	// 返回0。
	lp = (unsigned long *) &r;
	lpend = (unsigned long *) (&r + 1);
	dest = (unsigned long *) ru;
	for (; lp < lpend; lp++, dest++)
    8db2:	83 f8 48             	cmp    $0x48,%eax
    8db5:	75 f0                	jne    8da7 <sys_getrusage+0xad>
		put_fs_long(*lp, dest);
	return(0);
    8db7:	31 c0                	xor    %eax,%eax
}
    8db9:	83 c4 5c             	add    $0x5c,%esp
    8dbc:	5b                   	pop    %ebx
    8dbd:	5e                   	pop    %esi
    8dbe:	5f                   	pop    %edi
    8dbf:	5d                   	pop    %ebp
    8dc0:	c3                   	ret    

00008dc1 <sys_gettimeofday>:
// 取得系统当前时间，并用指定格式返回。
// timeval结构和timezone结构都定义在include/sys/time.h文件中。timeval结构含有秒和微秒（tv_sec和tv_usec）两个
// 字段。timezone结构含有本地距格林尼治标准时间以西的分钟数（tz_minuteswest）和夏令时间调整类型（tz_dsttime）两上
// 字段。（dst -- Daylight Savings Time）
int sys_gettimeofday(struct timeval *tv, struct timezone *tz)
{
    8dc1:	55                   	push   %ebp
    8dc2:	57                   	push   %edi
    8dc3:	56                   	push   %esi
    8dc4:	53                   	push   %ebx
    8dc5:	e8 62 dc ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8dca:	81 c3 36 82 01 00    	add    $0x18236,%ebx
    8dd0:	83 ec 1c             	sub    $0x1c,%esp
    8dd3:	8b 7c 24 30          	mov    0x30(%esp),%edi
    8dd7:	8b 74 24 34          	mov    0x34(%esp),%esi
	// 如果参数给定的timeval结构指针不空，则在该结构中返回当前时间（秒值和微秒值）;
	// 如果参数给定的用户数据空间中timezone结构的指针不空，则也返回该结构的信息。
	// 程序中startup_time是系统开机时间（秒值）。宏CT_TO_SECS和CT_TO_USECS用于把系统当前嘀嗒数转换成用秒值加微秒值表示。
	// 它们定义在include/linux/sched.h文件中。jiffies_offset是系统嘀嗒数误差调整数。
	if (tv) {
    8ddb:	85 ff                	test   %edi,%edi
    8ddd:	74 51                	je     8e30 <sys_gettimeofday+0x6f>
		verify_area(tv, sizeof *tv);
    8ddf:	52                   	push   %edx
    8de0:	52                   	push   %edx
    8de1:	6a 08                	push   $0x8
    8de3:	57                   	push   %edi
    8de4:	e8 02 ee ff ff       	call   7beb <verify_area>
		put_fs_long(startup_time + CT_TO_SECS(jiffies + jiffies_offset),
    8de9:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    8def:	c7 c5 6c 2a 02 00    	mov    $0x22a6c,%ebp
    8df5:	8b 0a                	mov    (%edx),%ecx
    8df7:	8b 45 00             	mov    0x0(%ebp),%eax
    8dfa:	31 d2                	xor    %edx,%edx
    8dfc:	01 c8                	add    %ecx,%eax
    8dfe:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
    8e02:	b9 64 00 00 00       	mov    $0x64,%ecx
    8e07:	f7 f1                	div    %ecx
    8e09:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    8e0f:	03 02                	add    (%edx),%eax
    8e11:	64 89 07             	mov    %eax,%fs:(%edi)
			    (unsigned long *) tv);
		put_fs_long(CT_TO_USECS(jiffies + jiffies_offset),
    8e14:	8b 45 00             	mov    0x0(%ebp),%eax
    8e17:	03 44 24 1c          	add    0x1c(%esp),%eax
    8e1b:	31 d2                	xor    %edx,%edx
    8e1d:	83 c4 10             	add    $0x10,%esp
    8e20:	f7 f1                	div    %ecx
    8e22:	69 c2 40 42 0f 00    	imul   $0xf4240,%edx,%eax
    8e28:	31 d2                	xor    %edx,%edx
    8e2a:	f7 f1                	div    %ecx
    8e2c:	64 89 47 04          	mov    %eax,%fs:0x4(%edi)
			    ((unsigned long *) tv) + 1);
	}
	if (tz) {
    8e30:	85 f6                	test   %esi,%esi
    8e32:	74 20                	je     8e54 <sys_gettimeofday+0x93>
		verify_area(tz, sizeof *tz);
    8e34:	50                   	push   %eax
    8e35:	50                   	push   %eax
    8e36:	6a 08                	push   $0x8
    8e38:	56                   	push   %esi
    8e39:	e8 ad ed ff ff       	call   7beb <verify_area>
    8e3e:	8b 83 c0 21 00 00    	mov    0x21c0(%ebx),%eax
    8e44:	64 89 06             	mov    %eax,%fs:(%esi)
    8e47:	8b 83 c4 21 00 00    	mov    0x21c4(%ebx),%eax
    8e4d:	64 89 46 04          	mov    %eax,%fs:0x4(%esi)
    8e51:	83 c4 10             	add    $0x10,%esp
		put_fs_long(sys_tz.tz_minuteswest, (unsigned long *) tz);
		put_fs_long(sys_tz.tz_dsttime, ((unsigned long *) tz) + 1);
	}
	return 0;
}
    8e54:	83 c4 1c             	add    $0x1c,%esp
    8e57:	31 c0                	xor    %eax,%eax
    8e59:	5b                   	pop    %ebx
    8e5a:	5e                   	pop    %esi
    8e5b:	5f                   	pop    %edi
    8e5c:	5d                   	pop    %ebp
    8e5d:	c3                   	ret    

00008e5e <adjust_clock>:
 * 法是完全不依赖于CMOS时钟，而是让系统通过NTP（网络时钟协议）或者timed（时间服务器）获得时间，如果机器联上网的话...。
 */
// 把系统启动时间调整为以GMT为标准的时间。
// startup_time是秒值，因此这里需要把时区分钟值乘上60。
void adjust_clock()
{
    8e5e:	e8 c5 db ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
    8e63:	81 c2 9d 81 01 00    	add    $0x1819d,%edx
	startup_time += sys_tz.tz_minuteswest * 60;
    8e69:	c7 c0 68 2a 02 00    	mov    $0x22a68,%eax
    8e6f:	6b 92 c0 21 00 00 3c 	imul   $0x3c,0x21c0(%edx),%edx
    8e76:	01 10                	add    %edx,(%eax)
}
    8e78:	c3                   	ret    

00008e79 <sys_settimeofday>:
{
    8e79:	e8 00 10 00 00       	call   9e7e <__x86.get_pc_thunk.cx>
    8e7e:	81 c1 82 81 01 00    	add    $0x18182,%ecx
    8e84:	55                   	push   %ebp
    8e85:	57                   	push   %edi
	if (!suser())
    8e86:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
{
    8e8c:	56                   	push   %esi
    8e8d:	53                   	push   %ebx
    8e8e:	8b 54 24 14          	mov    0x14(%esp),%edx
    8e92:	8b 5c 24 18          	mov    0x18(%esp),%ebx
	if (!suser())
    8e96:	8b 30                	mov    (%eax),%esi
		return -EPERM;
    8e98:	83 c8 ff             	or     $0xffffffff,%eax
	if (!suser())
    8e9b:	66 83 be ce 02 00 00 	cmpw   $0x0,0x2ce(%esi)
    8ea2:	00 
    8ea3:	0f 85 81 00 00 00    	jne    8f2a <sys_settimeofday+0xb1>
	if (tz) {
    8ea9:	85 db                	test   %ebx,%ebx
    8eab:	74 77                	je     8f24 <sys_settimeofday+0xab>
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    8ead:	64 8b 03             	mov    %fs:(%ebx),%eax
		sys_tz.tz_minuteswest = get_fs_long((unsigned long *) tz);
    8eb0:	89 81 c0 21 00 00    	mov    %eax,0x21c0(%ecx)
    8eb6:	64 8b 43 04          	mov    %fs:0x4(%ebx),%eax
		if (firsttime) {
    8eba:	83 b9 80 00 00 00 00 	cmpl   $0x0,0x80(%ecx)
		sys_tz.tz_dsttime = get_fs_long(((unsigned long *) tz)+1);
    8ec1:	89 81 c4 21 00 00    	mov    %eax,0x21c4(%ecx)
		if (firsttime) {
    8ec7:	74 5b                	je     8f24 <sys_settimeofday+0xab>
			if (!tv)
    8ec9:	85 d2                	test   %edx,%edx
			firsttime = 0;
    8ecb:	c7 81 80 00 00 00 00 	movl   $0x0,0x80(%ecx)
    8ed2:	00 00 00 
			if (!tv)
    8ed5:	74 46                	je     8f1d <sys_settimeofday+0xa4>
		startup_time = sec - jiffies / HZ;
    8ed7:	c7 c5 6c 2a 02 00    	mov    $0x22a6c,%ebp
    8edd:	be 64 00 00 00       	mov    $0x64,%esi
    8ee2:	64 8b 02             	mov    %fs:(%edx),%eax
    8ee5:	89 c7                	mov    %eax,%edi
    8ee7:	8b 45 00             	mov    0x0(%ebp),%eax
    8eea:	64 8b 5a 04          	mov    %fs:0x4(%edx),%ebx
    8eee:	31 d2                	xor    %edx,%edx
    8ef0:	f7 f6                	div    %esi
    8ef2:	29 c7                	sub    %eax,%edi
    8ef4:	c7 c0 68 2a 02 00    	mov    $0x22a68,%eax
    8efa:	89 38                	mov    %edi,(%eax)
		jiffies_offset = usec * HZ / 1000000 - jiffies % HZ;
    8efc:	89 d8                	mov    %ebx,%eax
    8efe:	8b 7d 00             	mov    0x0(%ebp),%edi
    8f01:	99                   	cltd   
    8f02:	bd 10 27 00 00       	mov    $0x2710,%ebp
    8f07:	f7 fd                	idiv   %ebp
    8f09:	31 d2                	xor    %edx,%edx
    8f0b:	89 c3                	mov    %eax,%ebx
    8f0d:	89 f8                	mov    %edi,%eax
    8f0f:	f7 f6                	div    %esi
    8f11:	c7 c0 64 2a 02 00    	mov    $0x22a64,%eax
    8f17:	29 d3                	sub    %edx,%ebx
    8f19:	89 18                	mov    %ebx,(%eax)
    8f1b:	eb 0b                	jmp    8f28 <sys_settimeofday+0xaf>
				adjust_clock();
    8f1d:	e8 3c ff ff ff       	call   8e5e <adjust_clock>
    8f22:	eb 04                	jmp    8f28 <sys_settimeofday+0xaf>
	if (tv) {
    8f24:	85 d2                	test   %edx,%edx
    8f26:	75 af                	jne    8ed7 <sys_settimeofday+0x5e>
	return 0;
    8f28:	31 c0                	xor    %eax,%eax
}
    8f2a:	5b                   	pop    %ebx
    8f2b:	5e                   	pop    %esi
    8f2c:	5f                   	pop    %edi
    8f2d:	5d                   	pop    %ebp
    8f2e:	c3                   	ret    

00008f2f <sys_umask>:

// 设置当前进程创建文件属性屏蔽码为mask & 0777。并返回原屏蔽码。
int sys_umask(int mask)
{
    8f2f:	e8 46 0f 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    8f34:	05 cc 80 01 00       	add    $0x180cc,%eax
	int old = current->umask;

	current->umask = mask & 0777;
    8f39:	8b 54 24 04          	mov    0x4(%esp),%edx
	int old = current->umask;
    8f3d:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	current->umask = mask & 0777;
    8f43:	66 81 e2 ff 01       	and    $0x1ff,%dx
	int old = current->umask;
    8f48:	8b 08                	mov    (%eax),%ecx
    8f4a:	0f b7 81 30 03 00 00 	movzwl 0x330(%ecx),%eax
	current->umask = mask & 0777;
    8f51:	66 89 91 30 03 00 00 	mov    %dx,0x330(%ecx)
	return (old);
}
    8f58:	c3                   	ret    

00008f59 <sys_default>:

// 用于捕获未实现的System Call调用。
int sys_default(unsigned long arg1, unsigned long arg2, unsigned long arg3, unsigned long code){
    8f59:	53                   	push   %ebx
    8f5a:	e8 cd da ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    8f5f:	81 c3 a1 80 01 00    	add    $0x180a1,%ebx
    8f65:	83 ec 10             	sub    $0x10,%esp
    printk("System Call Number:%d\r\n",code);
    8f68:	8d 83 47 6a ff ff    	lea    -0x95b9(%ebx),%eax
    8f6e:	ff 74 24 24          	pushl  0x24(%esp)
    8f72:	50                   	push   %eax
    8f73:	e8 a9 f1 ff ff       	call   8121 <printk>
    printk("Arg1:%X\r\n",arg1);
    8f78:	58                   	pop    %eax
    8f79:	8d 83 5f 6a ff ff    	lea    -0x95a1(%ebx),%eax
    8f7f:	5a                   	pop    %edx
    8f80:	ff 74 24 18          	pushl  0x18(%esp)
    8f84:	50                   	push   %eax
    8f85:	e8 97 f1 ff ff       	call   8121 <printk>
    printk("Arg2:%X\r\n",arg2);
    8f8a:	59                   	pop    %ecx
    8f8b:	58                   	pop    %eax
    8f8c:	8d 83 69 6a ff ff    	lea    -0x9597(%ebx),%eax
    8f92:	ff 74 24 1c          	pushl  0x1c(%esp)
    8f96:	50                   	push   %eax
    8f97:	e8 85 f1 ff ff       	call   8121 <printk>
    printk("Arg3:%X\r\n",arg3);
    8f9c:	58                   	pop    %eax
    8f9d:	8d 83 73 6a ff ff    	lea    -0x958d(%ebx),%eax
    8fa3:	5a                   	pop    %edx
    8fa4:	ff 74 24 20          	pushl  0x20(%esp)
    8fa8:	50                   	push   %eax
    8fa9:	e8 73 f1 ff ff       	call   8121 <printk>
    8fae:	83 c4 10             	add    $0x10,%esp
    8fb1:	eb fe                	jmp    8fb1 <sys_default+0x58>

00008fb3 <send_sig>:

// 向指定任务p发送信号sig，权限为priv。
// 参数：sig - 信号值；p - 指定任务的指针；priv - 强制发送信号的标志。即不需要考虑进程用户属性或级别而能发
// 送信号sig并退出，否则返回未许可错误号。
static inline int send_sig(long sig, struct task_struct * p, int priv)
{
    8fb3:	56                   	push   %esi
    8fb4:	53                   	push   %ebx
    8fb5:	e8 c8 0e 00 00       	call   9e82 <__x86.get_pc_thunk.si>
    8fba:	81 c6 46 80 01 00    	add    $0x18046,%esi
	// 如果没有权限，并且当前进程的有效用户ID与进程p的不同，并且也不是超级用户，则说明没有向p发送信号的权利。suser()
	// 定义为（current->euid==0），用于判断是否为超级用户。
	if (!p)
    8fc0:	85 d2                	test   %edx,%edx
    8fc2:	74 79                	je     903d <send_sig+0x8a>
		return -EINVAL;
	if (!priv && (current->euid != p->euid) && !suser())
    8fc4:	85 c9                	test   %ecx,%ecx
    8fc6:	89 c3                	mov    %eax,%ebx
    8fc8:	75 20                	jne    8fea <send_sig+0x37>
    8fca:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    8fd0:	8b 00                	mov    (%eax),%eax
    8fd2:	66 8b 88 ce 02 00 00 	mov    0x2ce(%eax),%cx
    8fd9:	66 39 8a ce 02 00 00 	cmp    %cx,0x2ce(%edx)
    8fe0:	74 08                	je     8fea <send_sig+0x37>
		return -EPERM;
    8fe2:	83 c8 ff             	or     $0xffffffff,%eax
	if (!priv && (current->euid != p->euid) && !suser())
    8fe5:	66 85 c9             	test   %cx,%cx
    8fe8:	75 58                	jne    9042 <send_sig+0x8f>
	// 若需要发送的信号是SIGKILL或SIGCONT，那么如果此时接收信号的进程p正处于停止状态就置其为就绪（运行）状态。然后
	// 修改进程p的信号位图signal，去掉（复位）会导致进程停止的信号SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU。
	if ((sig == SIGKILL) || (sig == SIGCONT)) {
    8fea:	83 fb 09             	cmp    $0x9,%ebx
    8fed:	74 05                	je     8ff4 <send_sig+0x41>
    8fef:	83 fb 12             	cmp    $0x12,%ebx
    8ff2:	75 1c                	jne    9010 <send_sig+0x5d>
		if (p->state == TASK_STOPPED)
    8ff4:	83 3a 04             	cmpl   $0x4,(%edx)
    8ff7:	75 06                	jne    8fff <send_sig+0x4c>
			p->state = TASK_RUNNING;
    8ff9:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
		p->exit_code = 0;
		p->signal &= ~( (1 << (SIGSTOP - 1)) | (1 << (SIGTSTP - 1)) |
    8fff:	81 62 0c ff ff c3 ff 	andl   $0xffc3ffff,0xc(%edx)
		p->exit_code = 0;
    9006:	c7 82 14 02 00 00 00 	movl   $0x0,0x214(%edx)
    900d:	00 00 00 
				(1 << (SIGTTIN - 1)) | (1 << (SIGTTOU - 1)) );
	}
	/* If the signal will be ignored, don't even post it */
    /* 如果要发送的信号sig将被进程p忽略掉，那么就根本不用发送 */
	if ((int) p->sigaction[sig - 1].sa_handler == 1)
    9010:	89 de                	mov    %ebx,%esi
		return 0;
    9012:	31 c0                	xor    %eax,%eax
	if ((int) p->sigaction[sig - 1].sa_handler == 1)
    9014:	8d 4b ff             	lea    -0x1(%ebx),%ecx
    9017:	c1 e6 04             	shl    $0x4,%esi
    901a:	83 3c 32 01          	cmpl   $0x1,(%edx,%esi,1)
    901e:	74 22                	je     9042 <send_sig+0x8f>
	/* Depends on order SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU */
   	/* 以下判断依赖于SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU */
	// 如果信号是SIGSTOP、SIGTSTP、SIGTTIN和SIGTTOU之一，那么说明要让接收信号的进程p停止运行。因此（若p的信号位图
	// 中有SIGCONT置位）就需要复位位图中继续运行的信号。
	if ((sig >= SIGSTOP) && (sig <= SIGTTOU))
    9020:	83 eb 13             	sub    $0x13,%ebx
    9023:	83 fb 03             	cmp    $0x3,%ebx
    9026:	77 07                	ja     902f <send_sig+0x7c>
		p->signal &= ~(1 << (SIGCONT - 1));
    9028:	81 62 0c ff ff fd ff 	andl   $0xfffdffff,0xc(%edx)
	/* Actually deliver the signal */
    /* 最后，我们向进程p发送信号p */
	p->signal |= (1 << (sig - 1));
    902f:	b8 01 00 00 00       	mov    $0x1,%eax
    9034:	d3 e0                	shl    %cl,%eax
    9036:	09 42 0c             	or     %eax,0xc(%edx)
	return 0;
    9039:	31 c0                	xor    %eax,%eax
    903b:	eb 05                	jmp    9042 <send_sig+0x8f>
		return -EINVAL;
    903d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    9042:	5b                   	pop    %ebx
    9043:	5e                   	pop    %esi
    9044:	c3                   	ret    

00009045 <has_stopped_jobs>:
}

// 判断进程组中是否含有处于停止状态的作业（进程组）。有则返回1；无则返回0.
// 查找方法是扫描整个任务数组。检查属于指定组pgrp的任何进程是否处于停止状态。
static int has_stopped_jobs(int pgrp)
{
    9045:	e8 de d9 ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
    904a:	81 c2 b6 7f 01 00    	add    $0x17fb6,%edx
    9050:	53                   	push   %ebx
	struct task_struct ** p;

	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    9051:	c7 c1 60 22 02 00    	mov    $0x22260,%ecx
    9057:	8d 91 fc 00 00 00    	lea    0xfc(%ecx),%edx
		if ((*p)->pgrp != pgrp)
    905d:	8b 1a                	mov    (%edx),%ebx
    905f:	39 83 30 02 00 00    	cmp    %eax,0x230(%ebx)
    9065:	75 05                	jne    906c <has_stopped_jobs+0x27>
			continue;
		if ((*p)->state == TASK_STOPPED)
    9067:	83 3b 04             	cmpl   $0x4,(%ebx)
    906a:	74 0b                	je     9077 <has_stopped_jobs+0x32>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    906c:	83 ea 04             	sub    $0x4,%edx
    906f:	39 ca                	cmp    %ecx,%edx
    9071:	77 ea                	ja     905d <has_stopped_jobs+0x18>
			return(1);
	}
	return(0);
    9073:	31 c0                	xor    %eax,%eax
    9075:	eb 05                	jmp    907c <has_stopped_jobs+0x37>
			return(1);
    9077:	b8 01 00 00 00       	mov    $0x1,%eax
}
    907c:	5b                   	pop    %ebx
    907d:	c3                   	ret    

0000907e <release>:
{
    907e:	53                   	push   %ebx
    907f:	e8 a8 d9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9084:	81 c3 7c 7f 01 00    	add    $0x17f7c,%ebx
    908a:	83 ec 08             	sub    $0x8,%esp
    908d:	8b 44 24 10          	mov    0x10(%esp),%eax
	if (!p)
    9091:	85 c0                	test   %eax,%eax
    9093:	0f 84 8e 00 00 00    	je     9127 <release+0xa9>
	if (p == current) {
    9099:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    909f:	39 02                	cmp    %eax,(%edx)
    90a1:	74 72                	je     9115 <release+0x97>
		if (task[i] == p) {
    90a3:	c7 c1 60 22 02 00    	mov    $0x22260,%ecx
	for (i = 1 ; i < NR_TASKS ; i++)
    90a9:	ba 01 00 00 00       	mov    $0x1,%edx
		if (task[i] == p) {
    90ae:	3b 04 91             	cmp    (%ecx,%edx,4),%eax
    90b1:	75 4b                	jne    90fe <release+0x80>
			task[i] = NULL;
    90b3:	c7 04 91 00 00 00 00 	movl   $0x0,(%ecx,%edx,4)
			if (p->p_osptr)
    90ba:	8b 90 c8 02 00 00    	mov    0x2c8(%eax),%edx
    90c0:	85 d2                	test   %edx,%edx
    90c2:	74 0c                	je     90d0 <release+0x52>
    90c4:	8b 88 c4 02 00 00    	mov    0x2c4(%eax),%ecx
				p->p_osptr->p_ysptr = p->p_ysptr;
    90ca:	89 8a c4 02 00 00    	mov    %ecx,0x2c4(%edx)
			if (p->p_ysptr)
    90d0:	8b 88 c4 02 00 00    	mov    0x2c4(%eax),%ecx
    90d6:	85 c9                	test   %ecx,%ecx
    90d8:	74 08                	je     90e2 <release+0x64>
				p->p_ysptr->p_osptr = p->p_osptr;
    90da:	89 91 c8 02 00 00    	mov    %edx,0x2c8(%ecx)
    90e0:	eb 0c                	jmp    90ee <release+0x70>
				p->p_pptr->p_cptr = p->p_osptr;
    90e2:	8b 88 bc 02 00 00    	mov    0x2bc(%eax),%ecx
    90e8:	89 91 c0 02 00 00    	mov    %edx,0x2c0(%ecx)
			free_page((long)p);
    90ee:	83 ec 0c             	sub    $0xc,%esp
    90f1:	50                   	push   %eax
    90f2:	e8 5c 0e 00 00       	call   9f53 <free_page>
			schedule();
    90f7:	e8 b0 db ff ff       	call   6cac <schedule>
    90fc:	eb 26                	jmp    9124 <release+0xa6>
	for (i = 1 ; i < NR_TASKS ; i++)
    90fe:	42                   	inc    %edx
    90ff:	83 fa 40             	cmp    $0x40,%edx
    9102:	75 aa                	jne    90ae <release+0x30>
	panic("trying to release non-existent task");
    9104:	8d 83 7d 6a ff ff    	lea    -0x9583(%ebx),%eax
    910a:	83 ec 0c             	sub    $0xc,%esp
    910d:	50                   	push   %eax
    910e:	e8 bf ef ff ff       	call   80d2 <panic>
    9113:	eb 0f                	jmp    9124 <release+0xa6>
		printk("task releasing itself\n\r");
    9115:	8d 83 a1 6a ff ff    	lea    -0x955f(%ebx),%eax
    911b:	83 ec 0c             	sub    $0xc,%esp
    911e:	50                   	push   %eax
    911f:	e8 fd ef ff ff       	call   8121 <printk>
		return;
    9124:	83 c4 10             	add    $0x10,%esp
}
    9127:	83 c4 08             	add    $0x8,%esp
    912a:	5b                   	pop    %ebx
    912b:	c3                   	ret    

0000912c <bad_task_ptr>:
{
    912c:	8b 54 24 04          	mov    0x4(%esp),%edx
		return 0;
    9130:	31 c0                	xor    %eax,%eax
    9132:	e8 47 0d 00 00       	call   9e7e <__x86.get_pc_thunk.cx>
    9137:	81 c1 c9 7e 01 00    	add    $0x17ec9,%ecx
	if (!p)
    913d:	85 d2                	test   %edx,%edx
    913f:	74 19                	je     915a <bad_task_ptr+0x2e>
		if (task[i] == p)
    9141:	c7 c1 60 22 02 00    	mov    $0x22260,%ecx
    9147:	3b 14 81             	cmp    (%ecx,%eax,4),%edx
    914a:	74 0c                	je     9158 <bad_task_ptr+0x2c>
	for (i = 0 ; i < NR_TASKS ; i++)
    914c:	40                   	inc    %eax
    914d:	83 f8 40             	cmp    $0x40,%eax
    9150:	75 f5                	jne    9147 <bad_task_ptr+0x1b>
	return 1;
    9152:	b8 01 00 00 00       	mov    $0x1,%eax
    9157:	c3                   	ret    
		return 0;
    9158:	31 c0                	xor    %eax,%eax
}
    915a:	c3                   	ret    

0000915b <audit_ptree>:
{
    915b:	55                   	push   %ebp
    915c:	57                   	push   %edi
    915d:	56                   	push   %esi
    915e:	53                   	push   %ebx
    915f:	e8 c8 d8 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9164:	81 c3 9c 7e 01 00    	add    $0x17e9c,%ebx
    916a:	83 ec 0c             	sub    $0xc,%esp
    916d:	c7 c6 60 22 02 00    	mov    $0x22260,%esi
    9173:	8d be fc 00 00 00    	lea    0xfc(%esi),%edi
		if (!task[i])
    9179:	8b 6e 04             	mov    0x4(%esi),%ebp
    917c:	85 ed                	test   %ebp,%ebp
    917e:	0f 84 65 02 00 00    	je     93e9 <audit_ptree+0x28e>
		if (bad_task_ptr(task[i]->p_pptr))
    9184:	ff b5 bc 02 00 00    	pushl  0x2bc(%ebp)
    918a:	e8 9d ff ff ff       	call   912c <bad_task_ptr>
    918f:	85 c0                	test   %eax,%eax
    9191:	5a                   	pop    %edx
    9192:	74 17                	je     91ab <audit_ptree+0x50>
			printk("Warning, pid %d's parent link is bad\n",
    9194:	50                   	push   %eax
    9195:	50                   	push   %eax
    9196:	8d 83 b9 6a ff ff    	lea    -0x9547(%ebx),%eax
    919c:	ff b5 2c 02 00 00    	pushl  0x22c(%ebp)
    91a2:	50                   	push   %eax
    91a3:	e8 79 ef ff ff       	call   8121 <printk>
    91a8:	83 c4 10             	add    $0x10,%esp
		if (bad_task_ptr(task[i]->p_cptr))
    91ab:	8b 6e 04             	mov    0x4(%esi),%ebp
    91ae:	83 ec 0c             	sub    $0xc,%esp
    91b1:	ff b5 c0 02 00 00    	pushl  0x2c0(%ebp)
    91b7:	e8 70 ff ff ff       	call   912c <bad_task_ptr>
    91bc:	83 c4 10             	add    $0x10,%esp
    91bf:	85 c0                	test   %eax,%eax
    91c1:	74 17                	je     91da <audit_ptree+0x7f>
			printk("Warning, pid %d's child link is bad\n",
    91c3:	50                   	push   %eax
    91c4:	50                   	push   %eax
    91c5:	8d 83 df 6a ff ff    	lea    -0x9521(%ebx),%eax
    91cb:	ff b5 2c 02 00 00    	pushl  0x22c(%ebp)
    91d1:	50                   	push   %eax
    91d2:	e8 4a ef ff ff       	call   8121 <printk>
    91d7:	83 c4 10             	add    $0x10,%esp
		if (bad_task_ptr(task[i]->p_ysptr))
    91da:	8b 6e 04             	mov    0x4(%esi),%ebp
    91dd:	83 ec 0c             	sub    $0xc,%esp
    91e0:	ff b5 c4 02 00 00    	pushl  0x2c4(%ebp)
    91e6:	e8 41 ff ff ff       	call   912c <bad_task_ptr>
    91eb:	83 c4 10             	add    $0x10,%esp
    91ee:	85 c0                	test   %eax,%eax
    91f0:	74 17                	je     9209 <audit_ptree+0xae>
			printk("Warning, pid %d's ys link is bad\n",
    91f2:	50                   	push   %eax
    91f3:	50                   	push   %eax
    91f4:	8d 83 04 6b ff ff    	lea    -0x94fc(%ebx),%eax
    91fa:	ff b5 2c 02 00 00    	pushl  0x22c(%ebp)
    9200:	50                   	push   %eax
    9201:	e8 1b ef ff ff       	call   8121 <printk>
    9206:	83 c4 10             	add    $0x10,%esp
		if (bad_task_ptr(task[i]->p_osptr))
    9209:	8b 6e 04             	mov    0x4(%esi),%ebp
    920c:	83 ec 0c             	sub    $0xc,%esp
    920f:	ff b5 c8 02 00 00    	pushl  0x2c8(%ebp)
    9215:	e8 12 ff ff ff       	call   912c <bad_task_ptr>
    921a:	83 c4 10             	add    $0x10,%esp
    921d:	85 c0                	test   %eax,%eax
    921f:	74 17                	je     9238 <audit_ptree+0xdd>
			printk("Warning, pid %d's os link is bad\n",
    9221:	50                   	push   %eax
    9222:	50                   	push   %eax
    9223:	8d 83 26 6b ff ff    	lea    -0x94da(%ebx),%eax
    9229:	ff b5 2c 02 00 00    	pushl  0x22c(%ebp)
    922f:	50                   	push   %eax
    9230:	e8 ec ee ff ff       	call   8121 <printk>
    9235:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_pptr == task[i])
    9238:	8b 46 04             	mov    0x4(%esi),%eax
    923b:	3b 80 bc 02 00 00    	cmp    0x2bc(%eax),%eax
    9241:	75 12                	jne    9255 <audit_ptree+0xfa>
			printk("Warning, pid %d parent link points to self\n");
    9243:	8d 83 48 6b ff ff    	lea    -0x94b8(%ebx),%eax
    9249:	83 ec 0c             	sub    $0xc,%esp
    924c:	50                   	push   %eax
    924d:	e8 cf ee ff ff       	call   8121 <printk>
    9252:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_cptr == task[i])
    9255:	8b 46 04             	mov    0x4(%esi),%eax
    9258:	3b 80 c0 02 00 00    	cmp    0x2c0(%eax),%eax
    925e:	75 12                	jne    9272 <audit_ptree+0x117>
			printk("Warning, pid %d child link points to self\n");
    9260:	8d 83 74 6b ff ff    	lea    -0x948c(%ebx),%eax
    9266:	83 ec 0c             	sub    $0xc,%esp
    9269:	50                   	push   %eax
    926a:	e8 b2 ee ff ff       	call   8121 <printk>
    926f:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_ysptr == task[i])
    9272:	8b 46 04             	mov    0x4(%esi),%eax
    9275:	3b 80 c4 02 00 00    	cmp    0x2c4(%eax),%eax
    927b:	75 12                	jne    928f <audit_ptree+0x134>
			printk("Warning, pid %d ys link points to self\n");
    927d:	8d 83 9f 6b ff ff    	lea    -0x9461(%ebx),%eax
    9283:	83 ec 0c             	sub    $0xc,%esp
    9286:	50                   	push   %eax
    9287:	e8 95 ee ff ff       	call   8121 <printk>
    928c:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_osptr == task[i])
    928f:	8b 46 04             	mov    0x4(%esi),%eax
    9292:	3b 80 c8 02 00 00    	cmp    0x2c8(%eax),%eax
    9298:	75 12                	jne    92ac <audit_ptree+0x151>
			printk("Warning, pid %d os link points to self\n");
    929a:	8d 83 c7 6b ff ff    	lea    -0x9439(%ebx),%eax
    92a0:	83 ec 0c             	sub    $0xc,%esp
    92a3:	50                   	push   %eax
    92a4:	e8 78 ee ff ff       	call   8121 <printk>
    92a9:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_osptr) {
    92ac:	8b 46 04             	mov    0x4(%esi),%eax
    92af:	8b 90 c8 02 00 00    	mov    0x2c8(%eax),%edx
    92b5:	85 d2                	test   %edx,%edx
    92b7:	74 5c                	je     9315 <audit_ptree+0x1ba>
			if (task[i]->p_pptr != task[i]->p_osptr->p_pptr)
    92b9:	8b 8a bc 02 00 00    	mov    0x2bc(%edx),%ecx
    92bf:	39 88 bc 02 00 00    	cmp    %ecx,0x2bc(%eax)
    92c5:	74 21                	je     92e8 <audit_ptree+0x18d>
				printk(
    92c7:	ff b1 2c 02 00 00    	pushl  0x22c(%ecx)
    92cd:	ff b2 2c 02 00 00    	pushl  0x22c(%edx)
    92d3:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    92d9:	8d 83 ef 6b ff ff    	lea    -0x9411(%ebx),%eax
    92df:	50                   	push   %eax
    92e0:	e8 3c ee ff ff       	call   8121 <printk>
    92e5:	83 c4 10             	add    $0x10,%esp
			if (task[i]->p_osptr->p_ysptr != task[i])
    92e8:	8b 46 04             	mov    0x4(%esi),%eax
    92eb:	8b 90 c8 02 00 00    	mov    0x2c8(%eax),%edx
    92f1:	3b 82 c4 02 00 00    	cmp    0x2c4(%edx),%eax
    92f7:	74 1c                	je     9315 <audit_ptree+0x1ba>
				printk(
    92f9:	55                   	push   %ebp
    92fa:	ff b2 2c 02 00 00    	pushl  0x22c(%edx)
    9300:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    9306:	8d 83 1e 6c ff ff    	lea    -0x93e2(%ebx),%eax
    930c:	50                   	push   %eax
    930d:	e8 0f ee ff ff       	call   8121 <printk>
    9312:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_ysptr) {
    9315:	8b 46 04             	mov    0x4(%esi),%eax
    9318:	8b 90 c4 02 00 00    	mov    0x2c4(%eax),%edx
    931e:	85 d2                	test   %edx,%edx
    9320:	74 68                	je     938a <audit_ptree+0x22f>
			if (task[i]->p_pptr != task[i]->p_ysptr->p_pptr)
    9322:	8b 8a bc 02 00 00    	mov    0x2bc(%edx),%ecx
    9328:	39 88 bc 02 00 00    	cmp    %ecx,0x2bc(%eax)
    932e:	74 2d                	je     935d <audit_ptree+0x202>
				task[i]->p_osptr->p_pptr->pid);
    9330:	8b 90 c8 02 00 00    	mov    0x2c8(%eax),%edx
				printk(
    9336:	8b 8a bc 02 00 00    	mov    0x2bc(%edx),%ecx
    933c:	ff b1 2c 02 00 00    	pushl  0x22c(%ecx)
    9342:	ff b2 2c 02 00 00    	pushl  0x22c(%edx)
    9348:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    934e:	8d 83 57 6c ff ff    	lea    -0x93a9(%ebx),%eax
    9354:	50                   	push   %eax
    9355:	e8 c7 ed ff ff       	call   8121 <printk>
    935a:	83 c4 10             	add    $0x10,%esp
			if (task[i]->p_ysptr->p_osptr != task[i])
    935d:	8b 46 04             	mov    0x4(%esi),%eax
    9360:	8b 90 c4 02 00 00    	mov    0x2c4(%eax),%edx
    9366:	3b 82 c8 02 00 00    	cmp    0x2c8(%edx),%eax
    936c:	74 1c                	je     938a <audit_ptree+0x22f>
				printk(
    936e:	51                   	push   %ecx
    936f:	ff b2 2c 02 00 00    	pushl  0x22c(%edx)
    9375:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    937b:	8d 83 88 6c ff ff    	lea    -0x9378(%ebx),%eax
    9381:	50                   	push   %eax
    9382:	e8 9a ed ff ff       	call   8121 <printk>
    9387:	83 c4 10             	add    $0x10,%esp
		if (task[i]->p_cptr) {
    938a:	8b 46 04             	mov    0x4(%esi),%eax
    938d:	8b 90 c0 02 00 00    	mov    0x2c0(%eax),%edx
    9393:	85 d2                	test   %edx,%edx
    9395:	74 52                	je     93e9 <audit_ptree+0x28e>
			if (task[i]->p_cptr->p_pptr != task[i])
    9397:	3b 82 bc 02 00 00    	cmp    0x2bc(%edx),%eax
    939d:	74 1c                	je     93bb <audit_ptree+0x260>
				printk(
    939f:	55                   	push   %ebp
    93a0:	ff b2 2c 02 00 00    	pushl  0x22c(%edx)
    93a6:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    93ac:	8d 83 c3 6c ff ff    	lea    -0x933d(%ebx),%eax
    93b2:	50                   	push   %eax
    93b3:	e8 69 ed ff ff       	call   8121 <printk>
    93b8:	83 c4 10             	add    $0x10,%esp
			if (task[i]->p_cptr->p_ysptr)
    93bb:	8b 46 04             	mov    0x4(%esi),%eax
    93be:	8b 90 c0 02 00 00    	mov    0x2c0(%eax),%edx
    93c4:	83 ba c4 02 00 00 00 	cmpl   $0x0,0x2c4(%edx)
    93cb:	74 1c                	je     93e9 <audit_ptree+0x28e>
				printk(
    93cd:	51                   	push   %ecx
    93ce:	ff b2 2c 02 00 00    	pushl  0x22c(%edx)
    93d4:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    93da:	8d 83 01 6d ff ff    	lea    -0x92ff(%ebx),%eax
    93e0:	50                   	push   %eax
    93e1:	e8 3b ed ff ff       	call   8121 <printk>
    93e6:	83 c4 10             	add    $0x10,%esp
    93e9:	83 c6 04             	add    $0x4,%esi
	for (i = 1 ; i < NR_TASKS ; i++) {
    93ec:	39 f7                	cmp    %esi,%edi
    93ee:	0f 85 85 fd ff ff    	jne    9179 <audit_ptree+0x1e>
}
    93f4:	83 c4 0c             	add    $0xc,%esp
    93f7:	5b                   	pop    %ebx
    93f8:	5e                   	pop    %esi
    93f9:	5f                   	pop    %edi
    93fa:	5d                   	pop    %ebp
    93fb:	c3                   	ret    

000093fc <session_of_pgrp>:
{
    93fc:	e8 79 0a 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    9401:	05 ff 7b 01 00       	add    $0x17bff,%eax
    9406:	53                   	push   %ebx
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    9407:	c7 c2 60 22 02 00    	mov    $0x22260,%edx
    940d:	8d 82 fc 00 00 00    	lea    0xfc(%edx),%eax
		if ((*p)->pgrp == pgrp)
    9413:	8b 08                	mov    (%eax),%ecx
    9415:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    9419:	39 99 30 02 00 00    	cmp    %ebx,0x230(%ecx)
    941f:	75 08                	jne    9429 <session_of_pgrp+0x2d>
			return((*p)->session);
    9421:	8b 81 34 02 00 00    	mov    0x234(%ecx),%eax
    9427:	eb 0a                	jmp    9433 <session_of_pgrp+0x37>
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    9429:	83 e8 04             	sub    $0x4,%eax
    942c:	39 d0                	cmp    %edx,%eax
    942e:	77 e3                	ja     9413 <session_of_pgrp+0x17>
	return -1;
    9430:	83 c8 ff             	or     $0xffffffff,%eax
}
    9433:	5b                   	pop    %ebx
    9434:	c3                   	ret    

00009435 <kill_pg>:
{
    9435:	55                   	push   %ebp
    9436:	57                   	push   %edi
    9437:	56                   	push   %esi
    9438:	53                   	push   %ebx
	if (sig < 1 || sig > 32 || pgrp <= 0)
    9439:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    943d:	e8 38 0a 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    9442:	05 be 7b 01 00       	add    $0x17bbe,%eax
    9447:	8d 51 ff             	lea    -0x1(%ecx),%edx
    944a:	83 fa 1f             	cmp    $0x1f,%edx
    944d:	77 51                	ja     94a0 <kill_pg+0x6b>
    944f:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    9454:	7e 4a                	jle    94a0 <kill_pg+0x6b>
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    9456:	c7 c5 60 22 02 00    	mov    $0x22260,%ebp
	int err,retval = -ESRCH;                // -ESRCH表示指定的进程不存在。
    945c:	bb fd ff ff ff       	mov    $0xfffffffd,%ebx
	int found = 0;
    9461:	31 ff                	xor    %edi,%edi
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    9463:	8d b5 fc 00 00 00    	lea    0xfc(%ebp),%esi
		if ((*p)->pgrp == pgrp) {
    9469:	8b 16                	mov    (%esi),%edx
    946b:	8b 82 30 02 00 00    	mov    0x230(%edx),%eax
    9471:	39 44 24 14          	cmp    %eax,0x14(%esp)
    9475:	75 16                	jne    948d <kill_pg+0x58>
			if (sig && (err = send_sig(sig, *p, priv)))
    9477:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    947b:	8b 44 24 18          	mov    0x18(%esp),%eax
    947f:	e8 2f fb ff ff       	call   8fb3 <send_sig>
    9484:	85 c0                	test   %eax,%eax
    9486:	75 03                	jne    948b <kill_pg+0x56>
				found++;
    9488:	47                   	inc    %edi
    9489:	eb 02                	jmp    948d <kill_pg+0x58>
			if (sig && (err = send_sig(sig, *p, priv)))
    948b:	89 c3                	mov    %eax,%ebx
 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    948d:	83 ee 04             	sub    $0x4,%esi
    9490:	39 ee                	cmp    %ebp,%esi
    9492:	77 d5                	ja     9469 <kill_pg+0x34>
	return(found ? 0 : retval);
    9494:	85 ff                	test   %edi,%edi
    9496:	b8 00 00 00 00       	mov    $0x0,%eax
    949b:	0f 45 d8             	cmovne %eax,%ebx
    949e:	eb 05                	jmp    94a5 <kill_pg+0x70>
		return -EINVAL;
    94a0:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
}
    94a5:	89 d8                	mov    %ebx,%eax
    94a7:	5b                   	pop    %ebx
    94a8:	5e                   	pop    %esi
    94a9:	5f                   	pop    %edi
    94aa:	5d                   	pop    %ebp
    94ab:	c3                   	ret    

000094ac <kill_proc>:
{
    94ac:	57                   	push   %edi
    94ad:	56                   	push   %esi
    94ae:	53                   	push   %ebx
    94af:	8b 44 24 14          	mov    0x14(%esp),%eax
    94b3:	e8 70 d5 ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
    94b8:	81 c2 48 7b 01 00    	add    $0x17b48,%edx
    94be:	8b 7c 24 10          	mov    0x10(%esp),%edi
    94c2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	if (sig < 1 || sig > 32)
    94c6:	8d 58 ff             	lea    -0x1(%eax),%ebx
    94c9:	83 fb 1f             	cmp    $0x1f,%ebx
    94cc:	77 2c                	ja     94fa <kill_proc+0x4e>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    94ce:	c7 c6 60 22 02 00    	mov    $0x22260,%esi
    94d4:	8d 9e fc 00 00 00    	lea    0xfc(%esi),%ebx
		if ((*p)->pid == pid)
    94da:	8b 13                	mov    (%ebx),%edx
    94dc:	3b ba 2c 02 00 00    	cmp    0x22c(%edx),%edi
    94e2:	75 08                	jne    94ec <kill_proc+0x40>
}
    94e4:	5b                   	pop    %ebx
    94e5:	5e                   	pop    %esi
    94e6:	5f                   	pop    %edi
			return(sig ? send_sig(sig, *p, priv) : 0);
    94e7:	e9 c7 fa ff ff       	jmp    8fb3 <send_sig>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    94ec:	83 eb 04             	sub    $0x4,%ebx
    94ef:	39 f3                	cmp    %esi,%ebx
    94f1:	77 e7                	ja     94da <kill_proc+0x2e>
	return(-ESRCH);
    94f3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    94f8:	eb 05                	jmp    94ff <kill_proc+0x53>
		return -EINVAL;
    94fa:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    94ff:	5b                   	pop    %ebx
    9500:	5e                   	pop    %esi
    9501:	5f                   	pop    %edi
    9502:	c3                   	ret    

00009503 <sys_kill>:
{
    9503:	55                   	push   %ebp
    9504:	57                   	push   %edi
    9505:	56                   	push   %esi
    9506:	53                   	push   %ebx
    9507:	8b 44 24 14          	mov    0x14(%esp),%eax
    950b:	8b 74 24 18          	mov    0x18(%esp),%esi
    950f:	e8 14 d5 ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
    9514:	81 c2 ec 7a 01 00    	add    $0x17aec,%edx
	if (!pid)
    951a:	85 c0                	test   %eax,%eax
    951c:	75 13                	jne    9531 <sys_kill+0x2e>
		return(kill_pg(current->pid, sig, 0));
    951e:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    9524:	6a 00                	push   $0x0
    9526:	56                   	push   %esi
    9527:	8b 00                	mov    (%eax),%eax
    9529:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    952f:	eb 36                	jmp    9567 <sys_kill+0x64>
	if (pid == -1) {
    9531:	83 f8 ff             	cmp    $0xffffffff,%eax
    9534:	75 27                	jne    955d <sys_kill+0x5a>
	struct task_struct **p = NR_TASKS + task;       // p指向任务数组最后一项。
    9536:	c7 c5 60 22 02 00    	mov    $0x22260,%ebp
	int err, retval = 0;
    953c:	31 db                	xor    %ebx,%ebx
	struct task_struct **p = NR_TASKS + task;       // p指向任务数组最后一项。
    953e:	8d bd 00 01 00 00    	lea    0x100(%ebp),%edi
		while (--p > &FIRST_TASK)
    9544:	83 ef 04             	sub    $0x4,%edi
    9547:	39 ef                	cmp    %ebp,%edi
    9549:	76 31                	jbe    957c <sys_kill+0x79>
			if (err = send_sig(sig, *p, 0))
    954b:	8b 17                	mov    (%edi),%edx
    954d:	31 c9                	xor    %ecx,%ecx
    954f:	89 f0                	mov    %esi,%eax
    9551:	e8 5d fa ff ff       	call   8fb3 <send_sig>
    9556:	85 c0                	test   %eax,%eax
    9558:	0f 45 d8             	cmovne %eax,%ebx
    955b:	eb e7                	jmp    9544 <sys_kill+0x41>
	if (pid < 0)
    955d:	85 c0                	test   %eax,%eax
    955f:	79 0d                	jns    956e <sys_kill+0x6b>
		return(kill_pg(-pid, sig, 0));
    9561:	f7 d8                	neg    %eax
    9563:	6a 00                	push   $0x0
    9565:	56                   	push   %esi
    9566:	50                   	push   %eax
    9567:	e8 c9 fe ff ff       	call   9435 <kill_pg>
    956c:	eb 09                	jmp    9577 <sys_kill+0x74>
	return(kill_proc(pid, sig, 0));
    956e:	6a 00                	push   $0x0
    9570:	56                   	push   %esi
    9571:	50                   	push   %eax
    9572:	e8 35 ff ff ff       	call   94ac <kill_proc>
    9577:	89 c3                	mov    %eax,%ebx
    9579:	83 c4 0c             	add    $0xc,%esp
}
    957c:	89 d8                	mov    %ebx,%eax
    957e:	5b                   	pop    %ebx
    957f:	5e                   	pop    %esi
    9580:	5f                   	pop    %edi
    9581:	5d                   	pop    %ebp
    9582:	c3                   	ret    

00009583 <is_orphaned_pgrp>:
{
    9583:	e8 f2 08 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    9588:	05 78 7a 01 00       	add    $0x17a78,%eax
    958d:	56                   	push   %esi
    958e:	53                   	push   %ebx
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    958f:	c7 c3 60 22 02 00    	mov    $0x22260,%ebx
{
    9595:	8b 74 24 0c          	mov    0xc(%esp),%esi
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    9599:	8d 93 fc 00 00 00    	lea    0xfc(%ebx),%edx
		if (!(*p) ||
    959f:	8b 02                	mov    (%edx),%eax
    95a1:	85 c0                	test   %eax,%eax
    95a3:	74 32                	je     95d7 <is_orphaned_pgrp+0x54>
    95a5:	39 b0 30 02 00 00    	cmp    %esi,0x230(%eax)
    95ab:	75 2a                	jne    95d7 <is_orphaned_pgrp+0x54>
		    ((*p)->pgrp != pgrp) ||
    95ad:	83 38 03             	cmpl   $0x3,(%eax)
    95b0:	74 25                	je     95d7 <is_orphaned_pgrp+0x54>
		    ((*p)->p_pptr->pid == 1))
    95b2:	8b 88 bc 02 00 00    	mov    0x2bc(%eax),%ecx
		    ((*p)->state == TASK_ZOMBIE) ||
    95b8:	83 b9 2c 02 00 00 01 	cmpl   $0x1,0x22c(%ecx)
    95bf:	74 16                	je     95d7 <is_orphaned_pgrp+0x54>
		if (((*p)->p_pptr->pgrp != pgrp) &&
    95c1:	3b b1 30 02 00 00    	cmp    0x230(%ecx),%esi
    95c7:	74 0e                	je     95d7 <is_orphaned_pgrp+0x54>
    95c9:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    95cf:	39 81 34 02 00 00    	cmp    %eax,0x234(%ecx)
    95d5:	74 0e                	je     95e5 <is_orphaned_pgrp+0x62>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    95d7:	83 ea 04             	sub    $0x4,%edx
    95da:	39 da                	cmp    %ebx,%edx
    95dc:	77 c1                	ja     959f <is_orphaned_pgrp+0x1c>
	return(1);	/* (sighing) "Often!" */        /* (唉）是孤儿进程组！ */
    95de:	b8 01 00 00 00       	mov    $0x1,%eax
    95e3:	eb 02                	jmp    95e7 <is_orphaned_pgrp+0x64>
			return 0;
    95e5:	31 c0                	xor    %eax,%eax
}
    95e7:	5b                   	pop    %ebx
    95e8:	5e                   	pop    %esi
    95e9:	c3                   	ret    

000095ea <do_exit>:

// 程序退出处理函数。
// 该函数将根据进程自身的特性对其进行处理，并把当前进程状态设置成僵死状态TASK_ZOMBIE，最后调用调度函数schedule()去
// 执行其他进程，不再返回。
void do_exit(long code)
{
    95ea:	55                   	push   %ebp
    95eb:	57                   	push   %edi
	// 首先释放当前进程代码段和数据段所占的内存页。函数free_page_tables()的第1个参数（get_base()返回值）指明在CPU线性
	// 地址空间中起始其地址，第2个（get_limit()返回值）说明欲释放的字节长度值。get_base()宏中的current->ldt[1]给出进程
	// 代码段描述符的位置（current->ldt[2]给出进程数据段描述符的位置）；get_limit()中的0x0f是进程代码段的选择符（0x17是
	// 进程数据段的选择符）。即在取段其地址时使用该段的描述符所处地址作为参数，取段长度时使用该段的选择符作为参数。
	// free_page_tables()函数位于mm/memory.c文件；get_base()和get_limit()宏位于include/linux/sched.h头文件。
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
    95ec:	b8 0f 00 00 00       	mov    $0xf,%eax
{
    95f1:	56                   	push   %esi
    95f2:	53                   	push   %ebx
    95f3:	e8 34 d4 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    95f8:	81 c3 08 7a 01 00    	add    $0x17a08,%ebx
    95fe:	83 ec 24             	sub    $0x24,%esp
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
    9601:	c7 c6 60 23 02 00    	mov    $0x22360,%esi
{
    9607:	8b 7c 24 38          	mov    0x38(%esp),%edi
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
    960b:	0f 03 c0             	lsl    %ax,%eax
    960e:	40                   	inc    %eax
    960f:	8b 0e                	mov    (%esi),%ecx
    9611:	8a b1 a7 03 00 00    	mov    0x3a7(%ecx),%dh
    9617:	8a 91 a4 03 00 00    	mov    0x3a4(%ecx),%dl
    961d:	c1 e2 10             	shl    $0x10,%edx
    9620:	66 8b 91 a2 03 00 00 	mov    0x3a2(%ecx),%dx
    9627:	50                   	push   %eax
    9628:	52                   	push   %edx
    9629:	e8 8d 09 00 00       	call   9fbb <free_page_tables>
	free_page_tables(get_base(current->ldt[2]), get_limit(0x17));
    962e:	8b 0e                	mov    (%esi),%ecx
    9630:	b8 17 00 00 00       	mov    $0x17,%eax
    9635:	8a b1 af 03 00 00    	mov    0x3af(%ecx),%dh
    963b:	8a 91 ac 03 00 00    	mov    0x3ac(%ecx),%dl
    9641:	c1 e2 10             	shl    $0x10,%edx
    9644:	66 8b 91 aa 03 00 00 	mov    0x3aa(%ecx),%dx
    964b:	59                   	pop    %ecx
    964c:	5d                   	pop    %ebp
    964d:	0f 03 c0             	lsl    %ax,%eax
    9650:	40                   	inc    %eax
    9651:	50                   	push   %eax
    9652:	52                   	push   %edx
	// 然后关闭当前进程打开着的所有文件。再对当前进程的工作目录pwd、根目录root、执行程序文件的i节点以及库文件进行同步操作，
	// 放回各个i节点并分别置空（释放）。接着把当前进程的状态设置为僵死状态（TASK_ZOMBIE），并设置进程退出码。
	for (i = 0 ; i < NR_OPEN ; i++)
    9653:	31 ed                	xor    %ebp,%ebp
	free_page_tables(get_base(current->ldt[2]), get_limit(0x17));
    9655:	e8 61 09 00 00       	call   9fbb <free_page_tables>
    965a:	83 c4 10             	add    $0x10,%esp
		if (current->filp[i])
    965d:	8b 06                	mov    (%esi),%eax
    965f:	83 bc a8 48 03 00 00 	cmpl   $0x0,0x348(%eax,%ebp,4)
    9666:	00 
    9667:	74 0c                	je     9675 <do_exit+0x8b>
			sys_close(i);
    9669:	83 ec 0c             	sub    $0xc,%esp
    966c:	55                   	push   %ebp
    966d:	e8 7d 1c 00 00       	call   b2ef <sys_close>
    9672:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_OPEN ; i++)
    9675:	45                   	inc    %ebp
    9676:	83 fd 14             	cmp    $0x14,%ebp
    9679:	75 e2                	jne    965d <do_exit+0x73>
	Log(LOG_INFO_TYPE, "<<<<< sys_exit process pid = %d, exit_code = %d >>>>>\n", current->pid, code);
    967b:	8b 06                	mov    (%esi),%eax
    967d:	57                   	push   %edi
    967e:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    9684:	8d 83 39 6d ff ff    	lea    -0x92c7(%ebx),%eax
    968a:	50                   	push   %eax
    968b:	6a 00                	push   $0x0
    968d:	e8 fd dd 00 00       	call   1748f <Log>
	iput(current->pwd);
    9692:	58                   	pop    %eax
    9693:	8b 06                	mov    (%esi),%eax
    9695:	ff b0 34 03 00 00    	pushl  0x334(%eax)
    969b:	e8 88 24 00 00       	call   bb28 <iput>
	current->pwd = NULL;
    96a0:	8b 06                	mov    (%esi),%eax
    96a2:	c7 80 34 03 00 00 00 	movl   $0x0,0x334(%eax)
    96a9:	00 00 00 
	iput(current->root);
    96ac:	5a                   	pop    %edx
    96ad:	ff b0 38 03 00 00    	pushl  0x338(%eax)
    96b3:	e8 70 24 00 00       	call   bb28 <iput>
	current->root = NULL;
    96b8:	8b 06                	mov    (%esi),%eax
    96ba:	c7 80 38 03 00 00 00 	movl   $0x0,0x338(%eax)
    96c1:	00 00 00 
	iput(current->executable);
    96c4:	59                   	pop    %ecx
    96c5:	ff b0 3c 03 00 00    	pushl  0x33c(%eax)
    96cb:	e8 58 24 00 00       	call   bb28 <iput>
	current->executable = NULL;
    96d0:	8b 06                	mov    (%esi),%eax
    96d2:	c7 80 3c 03 00 00 00 	movl   $0x0,0x33c(%eax)
    96d9:	00 00 00 
	iput(current->library);
    96dc:	5d                   	pop    %ebp
    96dd:	ff b0 40 03 00 00    	pushl  0x340(%eax)
    96e3:	e8 40 24 00 00       	call   bb28 <iput>
	current->library = NULL;
    96e8:	8b 06                	mov    (%esi),%eax
     * 组将变成一个孤儿进程组。
     */
	// POSIX 3.2.2.2（1991版）是关于exit()函数的说明。如果父进程所在的进程组与当前进程的不同，但都处于同一个会话
	// （session）中，并且当前进程所在进程组将要变成孤儿进程了并且当前进程的进程组中含有处于停止状态的作业（进程），
	// 那么就要向这个当前进程的进程组发送两个信号：SIGHUP和SIGCONT。
	if ((current->p_pptr->pgrp != current->pgrp) &&
    96ea:	83 c4 10             	add    $0x10,%esp
    96ed:	8b 90 bc 02 00 00    	mov    0x2bc(%eax),%edx
	current->exit_code = code;
    96f3:	89 b8 14 02 00 00    	mov    %edi,0x214(%eax)
	if ((current->p_pptr->pgrp != current->pgrp) &&
    96f9:	8b b8 30 02 00 00    	mov    0x230(%eax),%edi
	current->library = NULL;
    96ff:	c7 80 40 03 00 00 00 	movl   $0x0,0x340(%eax)
    9706:	00 00 00 
	current->state = TASK_ZOMBIE;
    9709:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	if ((current->p_pptr->pgrp != current->pgrp) &&
    970f:	39 ba 30 02 00 00    	cmp    %edi,0x230(%edx)
    9715:	74 4b                	je     9762 <do_exit+0x178>
    9717:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    971d:	39 82 34 02 00 00    	cmp    %eax,0x234(%edx)
    9723:	75 3d                	jne    9762 <do_exit+0x178>
	    (current->p_pptr->session == current->session) &&
	    is_orphaned_pgrp(current->pgrp) &&
    9725:	83 ec 0c             	sub    $0xc,%esp
    9728:	57                   	push   %edi
    9729:	e8 55 fe ff ff       	call   9583 <is_orphaned_pgrp>
    972e:	83 c4 10             	add    $0x10,%esp
	    (current->p_pptr->session == current->session) &&
    9731:	85 c0                	test   %eax,%eax
    9733:	74 2d                	je     9762 <do_exit+0x178>
	    has_stopped_jobs(current->pgrp)) {
    9735:	89 f8                	mov    %edi,%eax
    9737:	e8 09 f9 ff ff       	call   9045 <has_stopped_jobs>
	    is_orphaned_pgrp(current->pgrp) &&
    973c:	85 c0                	test   %eax,%eax
    973e:	74 22                	je     9762 <do_exit+0x178>
		kill_pg(current->pgrp,SIGHUP,1);
    9740:	55                   	push   %ebp
    9741:	6a 01                	push   $0x1
    9743:	6a 01                	push   $0x1
    9745:	57                   	push   %edi
    9746:	e8 ea fc ff ff       	call   9435 <kill_pg>
		kill_pg(current->pgrp,SIGCONT,1);
    974b:	8b 06                	mov    (%esi),%eax
    974d:	83 c4 0c             	add    $0xc,%esp
    9750:	6a 01                	push   $0x1
    9752:	6a 12                	push   $0x12
    9754:	ff b0 30 02 00 00    	pushl  0x230(%eax)
    975a:	e8 d6 fc ff ff       	call   9435 <kill_pg>
    975f:	83 c4 10             	add    $0x10,%esp
	}
	/* Let father know we died */           /* 通知父进程当前进程将终止 */
	current->p_pptr->signal |= (1 << (SIGCHLD - 1));
    9762:	8b 06                	mov    (%esi),%eax
    9764:	8b 90 bc 02 00 00    	mov    0x2bc(%eax),%edx
     * B. 检查当前进程的退出是否会造成任何进程组变成孤儿进程组。如果有，并且有处于停止状态
     * （TASK_STOPPED）的组员，则向它们发送一个SIGHUP信号和一个SIGCONT信号。（POSIX 3.2.2.2节要求）
     */
	// 如果当前进程有子进程（其p_cptr指针指向最近创建的子进程），则让进程1（init进程）成为其所有子进程的父进程。如果
	// 子进程已经处于僵死状态，则向init进程（父进程）发送子进程已终止信号SIGCHLD。
	if (p = current->p_cptr) {
    976a:	8b b8 c0 02 00 00    	mov    0x2c0(%eax),%edi
	current->p_pptr->signal |= (1 << (SIGCHLD - 1));
    9770:	81 4a 0c 00 00 01 00 	orl    $0x10000,0xc(%edx)
	if (p = current->p_cptr) {
    9777:	85 ff                	test   %edi,%edi
    9779:	0f 84 bb 00 00 00    	je     983a <do_exit+0x250>
		while (1) {
			p->p_pptr = task[1];
    977f:	c7 c0 60 22 02 00    	mov    $0x22260,%eax
    9785:	89 44 24 0c          	mov    %eax,0xc(%esp)
    9789:	8b 44 24 0c          	mov    0xc(%esp),%eax
			if (p->state == TASK_ZOMBIE)
    978d:	83 3f 03             	cmpl   $0x3,(%edi)
			p->p_pptr = task[1];
    9790:	8b 40 04             	mov    0x4(%eax),%eax
    9793:	89 87 bc 02 00 00    	mov    %eax,0x2bc(%edi)
			if (p->state == TASK_ZOMBIE)
    9799:	75 07                	jne    97a2 <do_exit+0x1b8>
				task[1]->signal |= (1 << (SIGCHLD - 1));
    979b:	81 48 0c 00 00 01 00 	orl    $0x10000,0xc(%eax)
             * 因此现在子进程所有进程组将变成孤儿进程组了。
             */
			// 如果子进程与当前进程不在同一个进程组但属于同一个session中，并且当前进程所在进程组将要变成孤儿进程了，并且当前
			// 进程的进程组中含有处于停止状态的作业（进程），那么就要向这个当前进程的进程组发送两个信号：SIGHUP和SIGCONT。如果
			// 该子进程有兄弟进程，则继续循环处理这些兄弟进程。
			if ((p->pgrp != current->pgrp) &&
    97a2:	8b 06                	mov    (%esi),%eax
    97a4:	8b af 30 02 00 00    	mov    0x230(%edi),%ebp
    97aa:	3b a8 30 02 00 00    	cmp    0x230(%eax),%ebp
    97b0:	74 49                	je     97fb <do_exit+0x211>
    97b2:	8b 80 34 02 00 00    	mov    0x234(%eax),%eax
    97b8:	39 87 34 02 00 00    	cmp    %eax,0x234(%edi)
    97be:	75 3b                	jne    97fb <do_exit+0x211>
			    (p->session == current->session) &&
			    is_orphaned_pgrp(p->pgrp) &&
    97c0:	83 ec 0c             	sub    $0xc,%esp
    97c3:	55                   	push   %ebp
    97c4:	e8 ba fd ff ff       	call   9583 <is_orphaned_pgrp>
    97c9:	83 c4 10             	add    $0x10,%esp
			    (p->session == current->session) &&
    97cc:	85 c0                	test   %eax,%eax
    97ce:	74 2b                	je     97fb <do_exit+0x211>
			    has_stopped_jobs(p->pgrp)) {
    97d0:	89 e8                	mov    %ebp,%eax
    97d2:	e8 6e f8 ff ff       	call   9045 <has_stopped_jobs>
			    is_orphaned_pgrp(p->pgrp) &&
    97d7:	85 c0                	test   %eax,%eax
    97d9:	74 20                	je     97fb <do_exit+0x211>
				kill_pg(p->pgrp,SIGHUP,1);
    97db:	51                   	push   %ecx
    97dc:	6a 01                	push   $0x1
    97de:	6a 01                	push   $0x1
    97e0:	55                   	push   %ebp
    97e1:	e8 4f fc ff ff       	call   9435 <kill_pg>
				kill_pg(p->pgrp,SIGCONT,1);
    97e6:	83 c4 0c             	add    $0xc,%esp
    97e9:	6a 01                	push   $0x1
    97eb:	6a 12                	push   $0x12
    97ed:	ff b7 30 02 00 00    	pushl  0x230(%edi)
    97f3:	e8 3d fc ff ff       	call   9435 <kill_pg>
    97f8:	83 c4 10             	add    $0x10,%esp
			}
			if (p->p_osptr) {
    97fb:	8b 87 c8 02 00 00    	mov    0x2c8(%edi),%eax
    9801:	85 c0                	test   %eax,%eax
    9803:	74 04                	je     9809 <do_exit+0x21f>
    9805:	89 c7                	mov    %eax,%edi
    9807:	eb 80                	jmp    9789 <do_exit+0x19f>
             */
			// 通过上面处理，当前进程子进程的所有兄弟子进程都已经处理过。此时p指向最老的兄弟子进程。于是把这些兄弟子进程全部加入
			// init进程的子进程双向链表表头部中。加入后，init进程的p_cptr指向当前进程原子进程中最年轻的（the youngest）子进程
			// 而原子进程中最老的（the oldest）兄弟子进程p_osptr指向原init进程的最年轻进程，而原init进程中最年轻进程的p_ysptr
			// 指向原子进程中最老的兄弟子进程。最后把当前进程的p_cptr指针置空，并退出循环。
			p->p_osptr = task[1]->p_cptr;
    9809:	8b 44 24 0c          	mov    0xc(%esp),%eax
    980d:	8b 50 04             	mov    0x4(%eax),%edx
    9810:	8b 82 c0 02 00 00    	mov    0x2c0(%edx),%eax
    9816:	89 87 c8 02 00 00    	mov    %eax,0x2c8(%edi)
			task[1]->p_cptr->p_ysptr = p;
    981c:	89 b8 c4 02 00 00    	mov    %edi,0x2c4(%eax)
			task[1]->p_cptr = current->p_cptr;
    9822:	8b 06                	mov    (%esi),%eax
    9824:	8b 88 c0 02 00 00    	mov    0x2c0(%eax),%ecx
    982a:	89 8a c0 02 00 00    	mov    %ecx,0x2c0(%edx)
			current->p_cptr = 0;
    9830:	c7 80 c0 02 00 00 00 	movl   $0x0,0x2c0(%eax)
    9837:	00 00 00 
			break;
		}
	}
	// 如果当前进程是会话头领（leader）进程，那么若它有控制终端，则首先向使用该控制终端的进程组发送挂断信号SIGHUP，然后释放
	// 该终端。接着扫描任务数组，把属于当前进程会话中进程的终端置空（取消）。
	if (current->leader) {
    983a:	8b 06                	mov    (%esi),%eax
    983c:	83 b8 38 02 00 00 00 	cmpl   $0x0,0x238(%eax)
    9843:	74 79                	je     98be <do_exit+0x2d4>
		struct task_struct **p;
		struct tty_struct *tty;

		if (current->tty >= 0) {
    9845:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
    984b:	85 c0                	test   %eax,%eax
    984d:	78 40                	js     988f <do_exit+0x2a5>
    984f:	c7 c7 00 57 03 00    	mov    $0x35700,%edi
			tty = TTY_TABLE(current->tty);
    9855:	74 08                	je     985f <do_exit+0x275>
    9857:	83 f8 3f             	cmp    $0x3f,%eax
    985a:	7f 0b                	jg     9867 <do_exit+0x27d>
    985c:	48                   	dec    %eax
    985d:	eb 08                	jmp    9867 <do_exit+0x27d>
    985f:	c7 c0 a0 51 02 00    	mov    $0x251a0,%eax
    9865:	8b 00                	mov    (%eax),%eax
    9867:	c1 e0 06             	shl    $0x6,%eax
    986a:	01 c7                	add    %eax,%edi
			if (tty->pgrp>0)
    986c:	8b 47 24             	mov    0x24(%edi),%eax
    986f:	85 c0                	test   %eax,%eax
    9871:	7e 0e                	jle    9881 <do_exit+0x297>
				kill_pg(tty->pgrp, SIGHUP, 1);
    9873:	52                   	push   %edx
    9874:	6a 01                	push   $0x1
    9876:	6a 01                	push   $0x1
    9878:	50                   	push   %eax
    9879:	e8 b7 fb ff ff       	call   9435 <kill_pg>
    987e:	83 c4 10             	add    $0x10,%esp
			tty->pgrp = 0;
    9881:	c7 47 24 00 00 00 00 	movl   $0x0,0x24(%edi)
			tty->session = 0;
    9888:	c7 47 28 00 00 00 00 	movl   $0x0,0x28(%edi)
		}
	 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if ((*p)->session == current->session)
    988f:	8b 06                	mov    (%esi),%eax
    9891:	c7 c2 60 22 02 00    	mov    $0x22260,%edx
    9897:	8b b8 34 02 00 00    	mov    0x234(%eax),%edi
    989d:	8d 82 fc 00 00 00    	lea    0xfc(%edx),%eax
    98a3:	8b 08                	mov    (%eax),%ecx
    98a5:	39 b9 34 02 00 00    	cmp    %edi,0x234(%ecx)
    98ab:	75 0a                	jne    98b7 <do_exit+0x2cd>
				(*p)->tty = -1;
    98ad:	c7 81 2c 03 00 00 ff 	movl   $0xffffffff,0x32c(%ecx)
    98b4:	ff ff ff 
	 	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p)
    98b7:	83 e8 04             	sub    $0x4,%eax
    98ba:	39 d0                	cmp    %edx,%eax
    98bc:	77 e5                	ja     98a3 <do_exit+0x2b9>
	}
	// 如果当前进程上次使用过协处理器，则把记录此信息的指针置空。若定义了调试进程树符号，则调用进程树检测显示函数。最后调用调度
	// 函数，重新调度进程运行，以让父进程能够处理僵死进程的其他善后事宜。
	if (last_task_used_math == current)
    98be:	c7 c0 60 2a 02 00    	mov    $0x22a60,%eax
    98c4:	8b 0e                	mov    (%esi),%ecx
    98c6:	39 08                	cmp    %ecx,(%eax)
    98c8:	75 06                	jne    98d0 <do_exit+0x2e6>
		last_task_used_math = NULL;
    98ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#ifdef DEBUG_PROC_TREE
	audit_ptree();
    98d0:	e8 86 f8 ff ff       	call   915b <audit_ptree>
#endif
	schedule();
    98d5:	e8 d2 d3 ff ff       	call   6cac <schedule>
}
    98da:	83 c4 1c             	add    $0x1c,%esp
    98dd:	5b                   	pop    %ebx
    98de:	5e                   	pop    %esi
    98df:	5f                   	pop    %edi
    98e0:	5d                   	pop    %ebp
    98e1:	c3                   	ret    

000098e2 <sys_exit>:
// 系统调用exit()。终止进程。
// 参数error_code是用户程序提供的退出状态信息，只有低字节有效。把error_code左移8位是wait()或waitpid()函数的要求。
// 低字节中将用来保存wait()的状态信息。例如，如果进程处于暂停状态（TASK_STOPPED），那么其低字节就等于0x7f。参见
// sys/wait.h文件。wait()或waitpid()利用这些宏就可以取得子进程的退出状态码或子进程终止的原因（信号）。
int sys_exit(int error_code)
{
    98e2:	83 ec 18             	sub    $0x18,%esp
	do_exit((error_code & 0xff) << 8);
    98e5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    98e9:	c1 e0 08             	shl    $0x8,%eax
    98ec:	0f b7 c0             	movzwl %ax,%eax
    98ef:	50                   	push   %eax
    98f0:	e8 f5 fc ff ff       	call   95ea <do_exit>
}
    98f5:	83 c4 1c             	add    $0x1c,%esp
    98f8:	c3                   	ret    

000098f9 <sys_waitpid>:
// 若options = WUNTRACED，表示如果子进程是停止的，也马上返回（无须跟踪）。
// 若options = WNOHANG，表示如果没有子进程退出或终止就马上返回。
// 如果返回状态指针stat_addr不为空，则就将状态信息保存到那里。
// 参数pid是进程号；*stat_addr是保存状态信息位置的指针；options是waitpid选项。
int sys_waitpid(pid_t pid, unsigned long * stat_addr, int options)
{
    98f9:	55                   	push   %ebp
    98fa:	57                   	push   %edi
    98fb:	56                   	push   %esi
    98fc:	53                   	push   %ebx
    98fd:	e8 2a d1 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9902:	81 c3 fe 76 01 00    	add    $0x176fe,%ebx
    9908:	83 ec 24             	sub    $0x24,%esp
    990b:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
	int flag;               				// 该标志用于后面所选出的子进程处于就绪或睡眠态。
	struct task_struct *p;
	unsigned long oldblocked;

	// 首先验证将在存放状态信息的位置处内在空间足够。然后复位标志flag。接着从当前进程的最年轻子进程开始扫描子进程兄弟链表。
	verify_area(stat_addr, 4);
    990f:	6a 04                	push   $0x4
    9911:	57                   	push   %edi
    9912:	e8 d4 e2 ff ff       	call   7beb <verify_area>
repeat:
	flag = 0;
	for (p = current->p_cptr ; p ; p = p->p_osptr) {
    9917:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
	verify_area(stat_addr, 4);
    991d:	83 c4 10             	add    $0x10,%esp
	for (p = current->p_cptr ; p ; p = p->p_osptr) {
    9920:	8b 55 00             	mov    0x0(%ebp),%edx
		// 0，于是继续扫描处理其他子进程。如果WUNTRACED置位且子进程退出码不为0,则把退出码移入高字节，同状态信息0x7f进行或运算后
		// 放入*stat_addr，在复位子进程退出码后立刻返回子进程号pid。这里0x7f表示的返回状态使WIFSTOPPED()宏为值。参见include/
		// sys/wait.h。
		switch (p->state) {
			case TASK_STOPPED:
				if (!(options & WUNTRACED) ||
    9923:	8b 44 24 38          	mov    0x38(%esp),%eax
	flag = 0;
    9927:	31 c9                	xor    %ecx,%ecx
	for (p = current->p_cptr ; p ; p = p->p_osptr) {
    9929:	8b b2 c0 02 00 00    	mov    0x2c0(%edx),%esi
				if (!(options & WUNTRACED) ||
    992f:	83 e0 02             	and    $0x2,%eax
    9932:	89 44 24 0c          	mov    %eax,0xc(%esp)
	for (p = current->p_cptr ; p ; p = p->p_osptr) {
    9936:	85 f6                	test   %esi,%esi
    9938:	0f 84 e5 00 00 00    	je     9a23 <sys_waitpid+0x12a>
		if (pid > 0) {
    993e:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
    9943:	7e 0c                	jle    9951 <sys_waitpid+0x58>
			if (p->pid != pid)
    9945:	8b 44 24 30          	mov    0x30(%esp),%eax
    9949:	39 86 2c 02 00 00    	cmp    %eax,0x22c(%esi)
    994f:	eb 21                	jmp    9972 <sys_waitpid+0x79>
		} else if (!pid) {
    9951:	75 0e                	jne    9961 <sys_waitpid+0x68>
			if (p->pgrp != current->pgrp)
    9953:	8b 82 30 02 00 00    	mov    0x230(%edx),%eax
    9959:	39 86 30 02 00 00    	cmp    %eax,0x230(%esi)
    995f:	eb 11                	jmp    9972 <sys_waitpid+0x79>
		} else if (pid != -1) {
    9961:	83 7c 24 30 ff       	cmpl   $0xffffffff,0x30(%esp)
    9966:	74 10                	je     9978 <sys_waitpid+0x7f>
			if (p->pgrp != -pid)
    9968:	8b 86 30 02 00 00    	mov    0x230(%esi),%eax
    996e:	03 44 24 30          	add    0x30(%esp),%eax
    9972:	0f 85 a0 00 00 00    	jne    9a18 <sys_waitpid+0x11f>
		switch (p->state) {
    9978:	8b 06                	mov    (%esi),%eax
    997a:	83 f8 03             	cmp    $0x3,%eax
    997d:	74 3c                	je     99bb <sys_waitpid+0xc2>
    997f:	83 f8 04             	cmp    $0x4,%eax
    9982:	0f 85 8b 00 00 00    	jne    9a13 <sys_waitpid+0x11a>
				if (!(options & WUNTRACED) ||
    9988:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    998d:	0f 84 85 00 00 00    	je     9a18 <sys_waitpid+0x11f>
				    !p->exit_code)
    9993:	8b 86 14 02 00 00    	mov    0x214(%esi),%eax
				if (!(options & WUNTRACED) ||
    9999:	85 c0                	test   %eax,%eax
    999b:	74 7b                	je     9a18 <sys_waitpid+0x11f>
					continue;
				put_fs_long((p->exit_code << 8) | 0x7f,
    999d:	c1 e0 08             	shl    $0x8,%eax
    99a0:	83 c8 7f             	or     $0x7f,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    99a3:	64 89 07             	mov    %eax,%fs:(%edi)
					stat_addr);
				p->exit_code = 0;
    99a6:	c7 86 14 02 00 00 00 	movl   $0x0,0x214(%esi)
    99ad:	00 00 00 
				return p->pid;
    99b0:	8b ae 2c 02 00 00    	mov    0x22c(%esi),%ebp
    99b6:	e9 bb 00 00 00       	jmp    9a76 <sys_waitpid+0x17d>
			// 把退出码放入返回状态位置stat_addr处并释放该子进程。最后返回子进程的退出码和pid。若定义了调试进程树符号，则调用进程树
			// 检测显示函数。
			case TASK_ZOMBIE:
				current->cutime += p->utime;
				current->cstime += p->stime;
				flag = p->pid;
    99bb:	8b ae 2c 02 00 00    	mov    0x22c(%esi),%ebp
				current->cutime += p->utime;
    99c1:	8b 86 e0 02 00 00    	mov    0x2e0(%esi),%eax
				Log(LOG_INFO_TYPE, "<<<<< sys_waitpid current_pid = %d, child_pid = %d, exit_code = %d >>>>>\n", current->pid, p->pid, p->exit_code);
    99c7:	83 ec 0c             	sub    $0xc,%esp
				current->cutime += p->utime;
    99ca:	01 82 e8 02 00 00    	add    %eax,0x2e8(%edx)
				current->cstime += p->stime;
    99d0:	8b 86 e4 02 00 00    	mov    0x2e4(%esi),%eax
    99d6:	01 82 ec 02 00 00    	add    %eax,0x2ec(%edx)
				Log(LOG_INFO_TYPE, "<<<<< sys_waitpid current_pid = %d, child_pid = %d, exit_code = %d >>>>>\n", current->pid, p->pid, p->exit_code);
    99dc:	8d 83 70 6d ff ff    	lea    -0x9290(%ebx),%eax
    99e2:	ff b6 14 02 00 00    	pushl  0x214(%esi)
    99e8:	55                   	push   %ebp
    99e9:	ff b2 2c 02 00 00    	pushl  0x22c(%edx)
    99ef:	50                   	push   %eax
    99f0:	6a 00                	push   $0x0
    99f2:	e8 98 da 00 00       	call   1748f <Log>
    99f7:	8b 86 14 02 00 00    	mov    0x214(%esi),%eax
    99fd:	64 89 07             	mov    %eax,%fs:(%edi)
				put_fs_long(p->exit_code, stat_addr);
				release(p);
    9a00:	83 c4 14             	add    $0x14,%esp
    9a03:	56                   	push   %esi
    9a04:	e8 75 f6 ff ff       	call   907e <release>
#ifdef DEBUG_PROC_TREE
				audit_ptree();
    9a09:	e8 4d f7 ff ff       	call   915b <audit_ptree>
#endif
				return flag;
    9a0e:	83 c4 10             	add    $0x10,%esp
    9a11:	eb 63                	jmp    9a76 <sys_waitpid+0x17d>
			// 如果这个子进程p的状态即是不停止也不是僵死，那么就置flag = 1。表示找到过一个符合要求的子进程，但是它处于运行态或睡眠态。
			default:
				flag = 1;
    9a13:	b9 01 00 00 00       	mov    $0x1,%ecx
	for (p = current->p_cptr ; p ; p = p->p_osptr) {
    9a18:	8b b6 c8 02 00 00    	mov    0x2c8(%esi),%esi
    9a1e:	e9 13 ff ff ff       	jmp    9936 <sys_waitpid+0x3d>
    }
	// 在上面对任务数组扫描结束后，如果flag被置位，说明了有符合等待要求的子进程并没有处于退出立刻或僵死状态。此时如果已设置
	// WNOHANG选项（表示若没有子进程处于退出或终止态就返回），就立刻返回0,退出。否则把当前进程置为可中断等待状态，保留并修改当前
	// 进程信号阻塞位图，允许其接收SIGCHLD信号。然后执行调度程序。当系统又开始执行本进程时，如果本进程收到除SIGCHLD以外的
	// 其他未屏蔽信号，则以退出码“重新启动系统调用”返回。否则跳转到函数开始处repeat标号处重重复处理。
	if (flag) {
    9a23:	85 c9                	test   %ecx,%ecx
    9a25:	74 46                	je     9a6d <sys_waitpid+0x174>
		if (options & WNOHANG)
    9a27:	f6 44 24 38 01       	testb  $0x1,0x38(%esp)
    9a2c:	75 46                	jne    9a74 <sys_waitpid+0x17b>
			return 0;
		current->state = TASK_INTERRUPTIBLE;
		oldblocked = current->blocked;
    9a2e:	8b b2 10 02 00 00    	mov    0x210(%edx),%esi
		current->state = TASK_INTERRUPTIBLE;
    9a34:	c7 02 01 00 00 00    	movl   $0x1,(%edx)
		current->blocked &= ~(1 << (SIGCHLD - 1));
    9a3a:	89 f0                	mov    %esi,%eax
    9a3c:	25 ff ff fe ff       	and    $0xfffeffff,%eax
    9a41:	89 82 10 02 00 00    	mov    %eax,0x210(%edx)
		schedule();
    9a47:	e8 60 d2 ff ff       	call   6cac <schedule>
		current->blocked = oldblocked;
    9a4c:	8b 45 00             	mov    0x0(%ebp),%eax
    9a4f:	89 b0 10 02 00 00    	mov    %esi,0x210(%eax)
		if (current->signal & ~(current->blocked | (1 << (SIGCHLD - 1))))
    9a55:	81 ce 00 00 01 00    	or     $0x10000,%esi
    9a5b:	f7 d6                	not    %esi
    9a5d:	85 70 0c             	test   %esi,0xc(%eax)
    9a60:	0f 84 ba fe ff ff    	je     9920 <sys_waitpid+0x27>
			return -ERESTARTSYS;
    9a66:	bd 00 fe ff ff       	mov    $0xfffffe00,%ebp
    9a6b:	eb 09                	jmp    9a76 <sys_waitpid+0x17d>
		else
			goto repeat;
	}
	// 若flag = 0，表示没有找到符合要求的子进程，则返回出错码（子进程不存在）。
	return -ECHILD;
    9a6d:	bd f6 ff ff ff       	mov    $0xfffffff6,%ebp
    9a72:	eb 02                	jmp    9a76 <sys_waitpid+0x17d>
			return 0;
    9a74:	31 ed                	xor    %ebp,%ebp
}
    9a76:	83 c4 1c             	add    $0x1c,%esp
    9a79:	89 e8                	mov    %ebp,%eax
    9a7b:	5b                   	pop    %ebx
    9a7c:	5e                   	pop    %esi
    9a7d:	5f                   	pop    %edi
    9a7e:	5d                   	pop    %ebp
    9a7f:	c3                   	ret    

00009a80 <sys_sgetmask>:
#include <signal.h>
#include <errno.h>

// 获取当前任务信号屏蔽位图（屏蔽码或阻塞码）。sgetmask可分解为signal-get-mask。以下类似。
int sys_sgetmask()
{
    9a80:	e8 f5 03 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    9a85:	05 7b 75 01 00       	add    $0x1757b,%eax
	return current->blocked;
    9a8a:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    9a90:	8b 00                	mov    (%eax),%eax
    9a92:	8b 80 10 02 00 00    	mov    0x210(%eax),%eax
}
    9a98:	c3                   	ret    

00009a99 <sys_ssetmask>:

// 设置新的信号屏蔽位图。信号SIGKILL和SIGSTOP不能被屏蔽。返回值是原信号屏蔽位图。
int sys_ssetmask(int newmask)
{
    9a99:	e8 dc 03 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    9a9e:	05 62 75 01 00       	add    $0x17562,%eax
	int old = current->blocked;

	current->blocked = newmask & ~(1 << (SIGKILL - 1)) & ~(1 << (SIGSTOP - 1));
    9aa3:	8b 54 24 04          	mov    0x4(%esp),%edx
	int old = current->blocked;
    9aa7:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	current->blocked = newmask & ~(1 << (SIGKILL - 1)) & ~(1 << (SIGSTOP - 1));
    9aad:	81 e2 ff fe fb ff    	and    $0xfffbfeff,%edx
	int old = current->blocked;
    9ab3:	8b 08                	mov    (%eax),%ecx
    9ab5:	8b 81 10 02 00 00    	mov    0x210(%ecx),%eax
	current->blocked = newmask & ~(1 << (SIGKILL - 1)) & ~(1 << (SIGSTOP - 1));
    9abb:	89 91 10 02 00 00    	mov    %edx,0x210(%ecx)
	return old;
}
    9ac1:	c3                   	ret    

00009ac2 <sys_sigpending>:

// 检测并取得进程收到的但被屏蔽（阻塞）的信号。还未处理信号的位图将被放入set中。
int sys_sigpending(sigset_t *set)
{
    9ac2:	56                   	push   %esi
    9ac3:	53                   	push   %ebx
    9ac4:	e8 63 cf ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9ac9:	81 c3 37 75 01 00    	add    $0x17537,%ebx
    9acf:	83 ec 0c             	sub    $0xc,%esp
    9ad2:	8b 74 24 18          	mov    0x18(%esp),%esi
    /* fill in "set" with signals pending but blocked. */
    /* 用还未处理并且被阻塞信号的位图填入set指针所指位置处 */
	// 首先验证进程提供的用户存储空间就有4个字节。然后把还未处理并且被阻塞信号的位图填入set指针所指位置处。
    verify_area(set, 4);
    9ad6:	6a 04                	push   $0x4
    9ad8:	56                   	push   %esi
    9ad9:	e8 0d e1 ff ff       	call   7beb <verify_area>
    put_fs_long(current->blocked & current->signal, (unsigned long *)set);
    9ade:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    9ae4:	8b 10                	mov    (%eax),%edx
    9ae6:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    9aec:	23 42 0c             	and    0xc(%edx),%eax
    9aef:	64 89 06             	mov    %eax,%fs:(%esi)
    return 0;
}
    9af2:	83 c4 14             	add    $0x14,%esp
    9af5:	31 c0                	xor    %eax,%eax
    9af7:	5b                   	pop    %ebx
    9af8:	5e                   	pop    %esi
    9af9:	c3                   	ret    

00009afa <sys_sigsuspend>:
// 该系统调用临时把进程信号屏蔽码替换成参数中给定的set，然后挂起进程，直到收到一个信号为止。
// restart是一个被中断的系统调用重新启动标志。当第1次调用该系统调用时，这是0.并且在该函数中会把进程原来的阻塞码
// blocked保存起来（old_mask），并设置restart为非0值。因此当进程第2次调用该系统调用时，它就会恢复进程原来保存在
// old_mask中的阻塞码。
int sys_sigsuspend(int restart, unsigned long old_mask, unsigned long set)
{
    9afa:	53                   	push   %ebx
    9afb:	e8 2c cf ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9b00:	81 c3 00 75 01 00    	add    $0x17500,%ebx
    9b06:	83 ec 08             	sub    $0x8,%esp
	// 相应的信号捕获函数。
    extern int sys_pause(void);

	// 如果restart标志不为0,表示重新让程序运行起来。于是恢复前面保存在old_mask中的原进程阻塞码。并返回码-EINTR（系统
	// 调用被信号中断）。
    if (restart) {
    9b09:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    9b0e:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    9b14:	8b 10                	mov    (%eax),%edx
    9b16:	74 11                	je     9b29 <sys_sigsuspend+0x2f>
			/* we're restarting */  /* 我们正在重新启动系统调用 */
			current->blocked = old_mask;
    9b18:	8b 44 24 14          	mov    0x14(%esp),%eax
    9b1c:	89 82 10 02 00 00    	mov    %eax,0x210(%edx)
			return -EINTR;
    9b22:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9b27:	eb 26                	jmp    9b4f <sys_sigsuspend+0x55>
	// 进程会去执行信号处理函数，然后本调用返回-ERESTARTNOINTR码退出。这个返回码说明在处理完信号后要求返回到本系统调用中继续
	// 运行，即本系统调用不会被中断。
    /* we're not restarting.  do the work */
    /* 我们不是重新运行，那么就干活吧 */
    //*(&restart) = 1;
	__asm__("movl $1, %0\n\t" \
    9b29:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
    9b30:	00 
			: \
			:"m"(restart));
    //*(&old_mask) = current->blocked;
	__asm__("movl %%eax, %0\n\t" \
    9b31:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    9b37:	89 44 24 14          	mov    %eax,0x14(%esp)
			: \
			:"m"(old_mask), "a"(current->blocked));
    current->blocked = set;
    9b3b:	8b 44 24 18          	mov    0x18(%esp),%eax
    9b3f:	89 82 10 02 00 00    	mov    %eax,0x210(%edx)
    (void) sys_pause();			/* return after a signal arrives */
    9b45:	e8 7a d2 ff ff       	call   6dc4 <sys_pause>
    return -ERESTARTNOINTR;		/* handle the signal, and come back */
    9b4a:	b8 ff fd ff ff       	mov    $0xfffffdff,%eax
}
    9b4f:	83 c4 08             	add    $0x8,%esp
    9b52:	5b                   	pop    %ebx
    9b53:	c3                   	ret    

00009b54 <sys_signal>:
// 信号句柄可以是用户指定的函数，也可以是SIG_DFL（默认句柄）或SIG_IGN（忽略）。
// 参数signum -- 指定的信号； handler -- 指定的句柄； restorer -- 恢复函数指针，该函数由Libc库提供。用于在信号
// 处理程序结束后恢复系统调用返回时几个寄存器的原有值以及系统调用的返回值，就好像系统调用没有执行过信号处理程序而直接
// 返回到用户程序一样。函数返回原信号句柄。
int sys_signal(int signum, long handler, long restorer)
{
    9b54:	53                   	push   %ebx
    9b55:	8b 54 24 08          	mov    0x8(%esp),%edx
    9b59:	e8 1c 03 00 00       	call   9e7a <__x86.get_pc_thunk.ax>
    9b5e:	05 a2 74 01 00       	add    $0x174a2,%eax
	struct sigaction tmp;

	// 首先验证信号值在有效范围（1--32）内，并且不得是信号SIGKILL和SIGSTOP。因为这两个信号不能被进程捕获。
	if (signum < 1 || signum > 32 || signum == SIGKILL || signum == SIGSTOP)
    9b63:	83 fa 09             	cmp    $0x9,%edx
    9b66:	0f 94 c3             	sete   %bl
    9b69:	83 fa 13             	cmp    $0x13,%edx
    9b6c:	0f 94 c1             	sete   %cl
    9b6f:	08 cb                	or     %cl,%bl
    9b71:	75 32                	jne    9ba5 <sys_signal+0x51>
    9b73:	8d 4a ff             	lea    -0x1(%edx),%ecx
    9b76:	83 f9 1f             	cmp    $0x1f,%ecx
    9b79:	77 2a                	ja     9ba5 <sys_signal+0x51>
	tmp.sa_handler = (void (*)(int)) handler;
	tmp.sa_mask = 0;
	tmp.sa_flags = SA_ONESHOT | SA_NOMASK;
	tmp.sa_restorer = (void (*)(void)) restorer;    				// 保存恢复处理函数指针。
	// 接着取该信号原来的处理句柄，并设置该信号的sigaction结构。最后返回原信号句柄。
	handler = (long) current->sigaction[signum - 1].sa_handler;
    9b7b:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    9b81:	c1 e2 04             	shl    $0x4,%edx
	current->sigaction[signum - 1] = tmp;
    9b84:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
	handler = (long) current->sigaction[signum - 1].sa_handler;
    9b88:	03 10                	add    (%eax),%edx
    9b8a:	8b 02                	mov    (%edx),%eax
	current->sigaction[signum - 1] = tmp;
    9b8c:	89 0a                	mov    %ecx,(%edx)
    9b8e:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    9b92:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
    9b99:	c7 42 08 00 00 00 c0 	movl   $0xc0000000,0x8(%edx)
    9ba0:	89 4a 0c             	mov    %ecx,0xc(%edx)
	return handler;
    9ba3:	eb 05                	jmp    9baa <sys_signal+0x56>
		return -EINVAL;
    9ba5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    9baa:	5b                   	pop    %ebx
    9bab:	c3                   	ret    

00009bac <sys_sigaction>:

// sigaction()系统调用。改变进程在收到一个信号时的操作。signum是除了SIGKILL以外的任何信号。[如果新操作（action）不为空]
// 则新操作被安装。如果oldaction指针不为空，则原操作被保留到oldaction。成功则返回0,否则为-EINVAL。
int sys_sigaction(int signum, const struct sigaction * action,
	struct sigaction * oldaction)
{
    9bac:	55                   	push   %ebp
    9bad:	57                   	push   %edi
    9bae:	56                   	push   %esi
    9baf:	53                   	push   %ebx
    9bb0:	e8 77 ce ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9bb5:	81 c3 4b 74 01 00    	add    $0x1744b,%ebx
    9bbb:	83 ec 2c             	sub    $0x2c,%esp
    9bbe:	8b 6c 24 40          	mov    0x40(%esp),%ebp
	struct sigaction tmp;

	// 首先验证信号值在有效范围（1--32）内，并且不得是信号SIGKILL和SIGSTOP。因为这两个信号不能被进程捕获。
	if (signum < 1 || signum > 32 || signum == SIGKILL || signum == SIGSTOP)
    9bc2:	83 fd 09             	cmp    $0x9,%ebp
    9bc5:	0f 94 c2             	sete   %dl
    9bc8:	83 fd 13             	cmp    $0x13,%ebp
    9bcb:	0f 94 c0             	sete   %al
    9bce:	08 c2                	or     %al,%dl
    9bd0:	0f 85 ab 00 00 00    	jne    9c81 <sys_sigaction+0xd5>
    9bd6:	8d 45 ff             	lea    -0x1(%ebp),%eax
    9bd9:	83 f8 1f             	cmp    $0x1f,%eax
    9bdc:	89 44 24 08          	mov    %eax,0x8(%esp)
    9be0:	0f 87 9b 00 00 00    	ja     9c81 <sys_sigaction+0xd5>
		return -EINVAL;
	// 在信号的sigaction结构中设置新的操作（动作）。如果oldaction指针不为空的话，则将原操作指针保存到oldaction所指的位置。
	tmp = current->sigaction[signum - 1];
    9be6:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    9bec:	89 ee                	mov    %ebp,%esi
    9bee:	8d 7c 24 10          	lea    0x10(%esp),%edi
    9bf2:	c1 e6 04             	shl    $0x4,%esi
    9bf5:	b9 04 00 00 00       	mov    $0x4,%ecx
    9bfa:	8b 02                	mov    (%edx),%eax
    9bfc:	01 c6                	add    %eax,%esi
    9bfe:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	get_new((char *) action,
    9c00:	89 e9                	mov    %ebp,%ecx
    9c02:	8d 74 24 10          	lea    0x10(%esp),%esi
    9c06:	c1 e1 04             	shl    $0x4,%ecx
    9c09:	8d 3c 01             	lea    (%ecx,%eax,1),%edi
	for (i = 0 ; i < sizeof(struct sigaction) ; i++)
    9c0c:	31 c0                	xor    %eax,%eax
    9c0e:	8b 4c 24 44          	mov    0x44(%esp),%ecx
    9c12:	01 c1                	add    %eax,%ecx
    9c14:	83 f8 10             	cmp    $0x10,%eax
    9c17:	74 09                	je     9c22 <sys_sigaction+0x76>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    9c19:	64 8a 09             	mov    %fs:(%ecx),%cl
		*(to++) = get_fs_byte(from++);
    9c1c:	88 0c 07             	mov    %cl,(%edi,%eax,1)
	for (i = 0 ; i < sizeof(struct sigaction) ; i++)
    9c1f:	40                   	inc    %eax
    9c20:	eb ec                	jmp    9c0e <sys_sigaction+0x62>
		(char *) (signum - 1 + current->sigaction));
	if (oldaction)
    9c22:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
    9c27:	75 1a                	jne    9c43 <sys_sigaction+0x97>
    9c29:	c1 e5 04             	shl    $0x4,%ebp
    9c2c:	03 2a                	add    (%edx),%ebp
		save_old((char *) &tmp,(char *) oldaction);
	// 如果允许信号在自己的信号句柄中收到，则令屏蔽码为0,否则设置屏蔽本信号。
	if (current->sigaction[signum - 1].sa_flags & SA_NOMASK)
    9c2e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c31:	25 00 00 00 40       	and    $0x40000000,%eax
    9c36:	74 39                	je     9c71 <sys_sigaction+0xc5>
		current->sigaction[signum - 1].sa_mask = 0;
    9c38:	c7 45 04 00 00 00 00 	movl   $0x0,0x4(%ebp)
	else
		current->sigaction[signum - 1].sa_mask |= (1 << (signum - 1));
	return 0;
    9c3f:	31 c0                	xor    %eax,%eax
    9c41:	eb 43                	jmp    9c86 <sys_sigaction+0xda>
    9c43:	89 54 24 0c          	mov    %edx,0xc(%esp)
	verify_area(to, sizeof(struct sigaction));
    9c47:	50                   	push   %eax
    9c48:	50                   	push   %eax
    9c49:	6a 10                	push   $0x10
    9c4b:	ff 74 24 54          	pushl  0x54(%esp)
    9c4f:	e8 97 df ff ff       	call   7beb <verify_area>
    9c54:	83 c4 10             	add    $0x10,%esp
    9c57:	8b 54 24 0c          	mov    0xc(%esp),%edx
	for (i = 0 ; i < sizeof(struct sigaction) ; i++) {
    9c5b:	31 c9                	xor    %ecx,%ecx
    9c5d:	8b 5c 24 48          	mov    0x48(%esp),%ebx
    9c61:	01 cb                	add    %ecx,%ebx
    9c63:	83 f9 10             	cmp    $0x10,%ecx
    9c66:	74 c1                	je     9c29 <sys_sigaction+0x7d>
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    9c68:	8a 04 0e             	mov    (%esi,%ecx,1),%al
    9c6b:	64 88 03             	mov    %al,%fs:(%ebx)
    9c6e:	41                   	inc    %ecx
    9c6f:	eb ec                	jmp    9c5d <sys_sigaction+0xb1>
		current->sigaction[signum - 1].sa_mask |= (1 << (signum - 1));
    9c71:	8a 4c 24 08          	mov    0x8(%esp),%cl
    9c75:	ba 01 00 00 00       	mov    $0x1,%edx
    9c7a:	d3 e2                	shl    %cl,%edx
    9c7c:	09 55 04             	or     %edx,0x4(%ebp)
    9c7f:	eb 05                	jmp    9c86 <sys_sigaction+0xda>
		return -EINVAL;
    9c81:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}
    9c86:	83 c4 2c             	add    $0x2c,%esp
    9c89:	5b                   	pop    %ebx
    9c8a:	5e                   	pop    %esi
    9c8b:	5f                   	pop    %edi
    9c8c:	5d                   	pop    %ebp
    9c8d:	c3                   	ret    

00009c8e <core_dump>:
 * 在当前目录中产生core dump映像文件的子程序。目前还没有实现。
 */
int core_dump(long signr)
{
	return(0);	/* We didn't do a dump */
}
    9c8e:	31 c0                	xor    %eax,%eax
    9c90:	c3                   	ret    

00009c91 <do_signal>:
// 4、第124行压入栈中的当前处理的信号值（signr）。
int do_signal(long signr, long eax, long ebx, long ecx, long edx, long orig_eax,
	long fs, long es, long ds,
	long eip, long cs, long eflags,
	unsigned long * esp, long ss)
{
    9c91:	55                   	push   %ebp
    9c92:	57                   	push   %edi
    9c93:	56                   	push   %esi
    9c94:	53                   	push   %ebx
    9c95:	e8 92 cd ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9c9a:	81 c3 66 73 01 00    	add    $0x17366,%ebx
    9ca0:	83 ec 1c             	sub    $0x1c,%esp
	unsigned long sa_handler;
	long old_eip = eip;
    9ca3:	8b 44 24 54          	mov    0x54(%esp),%eax
{
    9ca7:	8b 74 24 30          	mov    0x30(%esp),%esi
    9cab:	8b 4c 24 44          	mov    0x44(%esp),%ecx
    9caf:	8b 6c 24 34          	mov    0x34(%esp),%ebp
	long old_eip = eip;
    9cb3:	89 44 24 08          	mov    %eax,0x8(%esp)
	struct sigaction * sa = current->sigaction + signr - 1;			// 得到对应信号的处理数据结构
    9cb7:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    9cbd:	8b 10                	mov    (%eax),%edx
    9cbf:	89 f0                	mov    %esi,%eax
    9cc1:	c1 e0 04             	shl    $0x4,%eax
	// 当前读数据但没有读到任何数据等情况下，进程收到了任何一个非阻塞的信号，则都会-ERESTARTSYS返回值返回。它表示进程可以被
	// 中断，但是在继续执行后会重新启动系统调用。返回码-ERESTARTNOINTR说明在处理完信号后要求返回到原系统调用中继续运行，即系统
	// 调用不会被中断。
	// 因此下面语句说明如果是在系统调用中调用的本函数，并且相应系统调用的返回码eax等于-ERESTARTSYS或-ERESTARTNOINTR时进行下面
	// 的处理（实际上还没有真正回到用户程序中）。
	if ((orig_eax != -1) &&
    9cc4:	83 f9 ff             	cmp    $0xffffffff,%ecx
	struct sigaction * sa = current->sigaction + signr - 1;			// 得到对应信号的处理数据结构
    9cc7:	8d 3c 10             	lea    (%eax,%edx,1),%edi
	if ((orig_eax != -1) &&
    9cca:	74 35                	je     9d01 <do_signal+0x70>
	    ((eax == -ERESTARTSYS) || (eax == -ERESTARTNOINTR))) {
    9ccc:	8d 85 01 02 00 00    	lea    0x201(%ebp),%eax
	if ((orig_eax != -1) &&
    9cd2:	83 f8 01             	cmp    $0x1,%eax
    9cd5:	77 2a                	ja     9d01 <do_signal+0x70>
		// 如果系统调用返回码是-ERESTARTSYS（重新启动系统调用），并且sigaction中含有标志SA_INTERRUPT（系统调用被信号中断后不重新
		// 启动系统调用）或者信号值小于SIGCONT或者信号值大于SIGTTOU（即信号不是SIGCONT、SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU），
		// 则修改系统调用的返回值为eax = -EINTR，即被信号中断的系统调用。
		if ((eax == -ERESTARTSYS) && ((sa->sa_flags & SA_INTERRUPT) ||
    9cd7:	81 fd 00 fe ff ff    	cmp    $0xfffffe00,%ebp
    9cdd:	75 13                	jne    9cf2 <do_signal+0x61>
    9cdf:	f6 47 0b 20          	testb  $0x20,0xb(%edi)
		    signr < SIGCONT || signr > SIGTTOU))
			*(&eax) = -EINTR;
    9ce3:	bd fc ff ff ff       	mov    $0xfffffffc,%ebp
		if ((eax == -ERESTARTSYS) && ((sa->sa_flags & SA_INTERRUPT) ||
    9ce8:	75 17                	jne    9d01 <do_signal+0x70>
		    signr < SIGCONT || signr > SIGTTOU))
    9cea:	8d 46 ee             	lea    -0x12(%esi),%eax
    9ced:	83 f8 04             	cmp    $0x4,%eax
    9cf0:	77 0f                	ja     9d01 <do_signal+0x70>
		// 中断的系统调用。
		else {
			*(&eax) = orig_eax;     				// orig_eax系统调用号
			//*(&eip) = old_eip -= 2;
			// 系统调用返回到用户态的时候再次执行本次系统调用
			old_eip -= 2;
    9cf2:	83 6c 24 08 02       	subl   $0x2,0x8(%esp)
			__asm__ ("movl %%eax, %0\n\t" \
    9cf7:	8b 44 24 08          	mov    0x8(%esp),%eax
    9cfb:	89 44 24 54          	mov    %eax,0x54(%esp)
    9cff:	89 cd                	mov    %ecx,%ebp
					: \
					:"m"(eip), "a"(old_eip));
		}
	}
	// 如果信号句柄为SIG_IGN（1,默认忽略句柄）则不对信号进行处理而直接返回。
	sa_handler = (unsigned long) sa->sa_handler;
    9d01:	8b 0f                	mov    (%edi),%ecx
	if (sa_handler == 1)
    9d03:	83 f9 01             	cmp    $0x1,%ecx
    9d06:	75 0a                	jne    9d12 <do_signal+0x81>
		return(1);   								/* Ignore, see if there are more signals... */
    9d08:	b8 01 00 00 00       	mov    $0x1,%eax
    9d0d:	e9 e7 00 00 00       	jmp    9df9 <do_signal+0x168>
	// 如果句柄为SIG_DFL（0,默认处理），则根据具体的信号进行分别处理。
	if (!sa_handler) {
    9d12:	85 c9                	test   %ecx,%ecx
    9d14:	75 53                	jne    9d69 <do_signal+0xd8>
		switch (signr) {
    9d16:	83 fe 11             	cmp    $0x11,%esi
    9d19:	7c 3a                	jl     9d55 <do_signal+0xc4>
    9d1b:	83 fe 12             	cmp    $0x12,%esi
		// 如果信号是以下两个则也忽略之，并返回
		case SIGCONT:
		case SIGCHLD:
			return(1);  							/* Ignore, ... */
    9d1e:	b8 01 00 00 00       	mov    $0x1,%eax
		switch (signr) {
    9d23:	0f 8e d0 00 00 00    	jle    9df9 <do_signal+0x168>
    9d29:	83 fe 16             	cmp    $0x16,%esi
    9d2c:	7f 27                	jg     9d55 <do_signal+0xc4>
		// 信号。
		case SIGSTOP:
		case SIGTSTP:
		case SIGTTIN:
		case SIGTTOU:
			current->state = TASK_STOPPED;
    9d2e:	c7 02 04 00 00 00    	movl   $0x4,(%edx)
			current->exit_code = signr;
    9d34:	89 b2 14 02 00 00    	mov    %esi,0x214(%edx)
			if (!(current->p_pptr->sigaction[SIGCHLD - 1].sa_flags &
    9d3a:	8b 92 bc 02 00 00    	mov    0x2bc(%edx),%edx
    9d40:	f6 82 18 01 00 00 01 	testb  $0x1,0x118(%edx)
    9d47:	75 bf                	jne    9d08 <do_signal+0x77>
					SA_NOCLDSTOP))
				current->p_pptr->signal |= (1 << (SIGCHLD - 1));
    9d49:	81 4a 0c 00 00 01 00 	orl    $0x10000,0xc(%edx)
    9d50:	e9 a4 00 00 00       	jmp    9df9 <do_signal+0x168>
    9d55:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
		case SIGSEGV:
			if (core_dump(signr))
				do_exit(signr | 0x80);
			/* fall through */
		default:
			do_exit(signr);
    9d59:	83 ec 0c             	sub    $0xc,%esp
    9d5c:	56                   	push   %esi
    9d5d:	e8 88 f8 ff ff       	call   95ea <do_exit>
    9d62:	83 c4 10             	add    $0x10,%esp
    9d65:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
	// 如果该信号句柄只需被调用一次，则将该句柄置空。注意，该信号句柄前面已经保存在sa_handler指针中。
	// 在系统调用进程内核时，用户程序返回地址（eip、cs）被保存在内核态栈中。下面这段代码修改内核态堆栈上用户调用时
	// 的代码指针eip为指向信号处理句柄，同时也将sa_restorer、signr、进程屏蔽码（如果SA_NOMASK没置位）、eax、
	// ecx、edx作为参数以及原调用系统调用的程序返回指针及标志寄存器值压入用户堆栈。因此在本次系统调用中断返回用户
	// 程序时会首先执行用户信号句柄程序，然后继续执行用户程序。
	if (sa->sa_flags & SA_ONESHOT)
    9d69:	8b 47 08             	mov    0x8(%edi),%eax
    9d6c:	85 c0                	test   %eax,%eax
    9d6e:	79 06                	jns    9d76 <do_signal+0xe5>
		sa->sa_handler = NULL;
    9d70:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	// 调用do_signal()时的所有参数都丢弃。eip等仍然在堆栈中。
	// sigaction结构的sa_mask字段给出了在当前信号句柄（信号描述符）程序执行期间应该被屏蔽的信号集。同时，引起本
	// 信号句柄执行的信号也会被屏蔽。不过若sa_flags中使用了SA_NOMASK标志，那么引起本信号句柄执行的信号将不会被屏蔽
	// 掉。如果允许信号自己的处理句柄程序收到信号自己，则也需要将进程的信号阻塞码压入堆栈。
	*(&eip) = sa_handler;
	longs = (sa->sa_flags & SA_NOMASK)?7:8;
    9d76:	01 c0                	add    %eax,%eax
	*(&eip) = sa_handler;
    9d78:	89 4c 24 54          	mov    %ecx,0x54(%esp)
	longs = (sa->sa_flags & SA_NOMASK)?7:8;
    9d7c:	c1 f8 1f             	sar    $0x1f,%eax
	// 将原调用程序的用户堆栈指针向下扩展7（或8）个长字（用来存放调用信号句柄的参数等），并检查内存使用情况（如内存超
	// 界则分配新页等）。
	//*(&esp) -= longs;
	__asm__("subl %1, %0\n\t" \
			: \
			:"m"(esp), "a"(longs * 4));
    9d7f:	8d 04 85 20 00 00 00 	lea    0x20(,%eax,4),%eax
	__asm__("subl %1, %0\n\t" \
    9d86:	29 44 24 60          	sub    %eax,0x60(%esp)
	verify_area(esp, longs * 4);
    9d8a:	52                   	push   %edx
    9d8b:	52                   	push   %edx
    9d8c:	50                   	push   %eax
    9d8d:	ff 74 24 6c          	pushl  0x6c(%esp)
    9d91:	e8 55 de ff ff       	call   7beb <verify_area>
	// 在用户堆栈中从下到上存放sa_restorer、信号signr、屏蔽码blocked（如果SA_NOMASK置位）、eax、ecx、edx、eflags
	// 和用户程序原代码指针。
	tmp_esp = esp;
    9d96:	8b 54 24 70          	mov    0x70(%esp),%edx
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    9d9a:	8b 47 0c             	mov    0xc(%edi),%eax
    9d9d:	64 89 02             	mov    %eax,%fs:(%edx)
	put_fs_long((long) sa->sa_restorer, tmp_esp++);
	put_fs_long(signr, tmp_esp++);
    9da0:	8d 42 08             	lea    0x8(%edx),%eax
    9da3:	89 f1                	mov    %esi,%ecx
    9da5:	64 89 4a 04          	mov    %ecx,%fs:0x4(%edx)
	if (!(sa->sa_flags & SA_NOMASK))
    9da9:	83 c4 10             	add    $0x10,%esp
    9dac:	f6 47 0b 40          	testb  $0x40,0xb(%edi)
    9db0:	c7 c1 60 23 02 00    	mov    $0x22360,%ecx
    9db6:	75 0f                	jne    9dc7 <do_signal+0x136>
		put_fs_long(current->blocked, tmp_esp++);
    9db8:	8b 19                	mov    (%ecx),%ebx
    9dba:	8d 42 0c             	lea    0xc(%edx),%eax
    9dbd:	8b 9b 10 02 00 00    	mov    0x210(%ebx),%ebx
    9dc3:	64 89 5a 08          	mov    %ebx,%fs:0x8(%edx)
    9dc7:	89 eb                	mov    %ebp,%ebx
    9dc9:	64 89 18             	mov    %ebx,%fs:(%eax)
    9dcc:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    9dd0:	64 89 50 04          	mov    %edx,%fs:0x4(%eax)
    9dd4:	8b 54 24 40          	mov    0x40(%esp),%edx
    9dd8:	64 89 50 08          	mov    %edx,%fs:0x8(%eax)
    9ddc:	8b 54 24 5c          	mov    0x5c(%esp),%edx
    9de0:	64 89 50 0c          	mov    %edx,%fs:0xc(%eax)
    9de4:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    9de8:	64 89 58 10          	mov    %ebx,%fs:0x10(%eax)
	put_fs_long(eax, tmp_esp++);
	put_fs_long(ecx, tmp_esp++);
	put_fs_long(edx, tmp_esp++);
	put_fs_long(eflags, tmp_esp++);
	put_fs_long(old_eip, tmp_esp++);
	current->blocked |= sa->sa_mask;                // 进程阻塞码（屏蔽码）添上as_mask中的码。
    9dec:	8b 01                	mov    (%ecx),%eax
    9dee:	8b 57 04             	mov    0x4(%edi),%edx
    9df1:	09 90 10 02 00 00    	or     %edx,0x210(%eax)
	return(0);										/* Continue, execute handler */
    9df7:	31 c0                	xor    %eax,%eax
}
    9df9:	83 c4 1c             	add    $0x1c,%esp
    9dfc:	5b                   	pop    %ebx
    9dfd:	5e                   	pop    %esi
    9dfe:	5f                   	pop    %edi
    9dff:	5d                   	pop    %ebp
    9e00:	c3                   	ret    

00009e01 <kernel_mktime>:
};

// 该函数计算从1970年1月1日0时起到开机当日经过的秒数,作为开机时间.
// 参数tm中各字段已经在init/main.c中被赋值,信息取自CMOS.
long kernel_mktime(struct tm * tm)
{
    9e01:	57                   	push   %edi
    9e02:	56                   	push   %esi
    9e03:	53                   	push   %ebx
    9e04:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    9e08:	e8 75 00 00 00       	call   9e82 <__x86.get_pc_thunk.si>
    9e0d:	81 c6 f3 71 01 00    	add    $0x171f3,%esi
	// if(tm->tm_year<70) tm->tm_year += 100;由于UNIX计年份y是从1970年算起.到1972年就是一个闰年,因此过3年(71,72,73)
	// 就是第1个闰年,这样从1970年开始的闰年数计算方法就应该是1+(y-3)/4,即为(y+1)/4.res=这些年经过的秒数时间+每个闰年时多1天
	// 的秒数时间+当年到当月时的秒数.另外,month[]数组中已经在2月份的天数中包含进了闰年时的天数,即2月份天数多算了1天.因此,若
	// 当年不是闰年并且当前月份大于2月份的话,我们就要减去这天.因为人70开始算起,所以当年是闰年的判断方法是(y+2)能被4除尽.若不能
	// 除尽(有余数)就不是闰年.
	if(tm->tm_year < 70) tm->tm_year += 100;				//处理2000年问题
    9e13:	8b 41 14             	mov    0x14(%ecx),%eax
    9e16:	83 f8 45             	cmp    $0x45,%eax
    9e19:	7f 06                	jg     9e21 <kernel_mktime+0x20>
    9e1b:	83 c0 64             	add    $0x64,%eax
    9e1e:	89 41 14             	mov    %eax,0x14(%ecx)
	year = tm->tm_year - 70;
    9e21:	8b 59 14             	mov    0x14(%ecx),%ebx
	/* magic offsets (y+1) needed to get leapyears right.*/
	/* 为了获得正确的闰年数,这里需要这样一个魔幻值(y+1) */
	res = YEAR * year + DAY * ((year + 1) / 4);
    9e24:	bf 04 00 00 00       	mov    $0x4,%edi
    9e29:	8d 43 bb             	lea    -0x45(%ebx),%eax
    9e2c:	99                   	cltd   
    9e2d:	f7 ff                	idiv   %edi
	year = tm->tm_year - 70;
    9e2f:	8d 53 ba             	lea    -0x46(%ebx),%edx
	res = YEAR * year + DAY * ((year + 1) / 4);
    9e32:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
    9e38:	69 d2 80 33 e1 01    	imul   $0x1e13380,%edx,%edx
    9e3e:	01 d0                	add    %edx,%eax
	res += month[tm->tm_mon];
    9e40:	8b 51 10             	mov    0x10(%ecx),%edx
    9e43:	03 84 96 20 66 ff ff 	add    -0x99e0(%esi,%edx,4),%eax
	/* and (y+2) here. If it wasn't a leap-year, we have to adjust */
	/* 以及(y+2).如果(y+2)不是闰年,那么我们就必须进行调整(减去一天的秒数时间). */
	if (tm->tm_mon > 1 && ((year + 2) % 4))
    9e4a:	4a                   	dec    %edx
    9e4b:	7e 0a                	jle    9e57 <kernel_mktime+0x56>
    9e4d:	80 e3 03             	and    $0x3,%bl
    9e50:	74 05                	je     9e57 <kernel_mktime+0x56>
		res -= DAY;
    9e52:	2d 80 51 01 00       	sub    $0x15180,%eax
	res += DAY * (tm->tm_mday - 1);							// 再加上本月过去的天数的秒数时间.
    9e57:	8b 71 0c             	mov    0xc(%ecx),%esi
	res += HOUR * tm->tm_hour;								// 再加上当天过去的小时数的秒数时间.
	res += MINUTE * tm->tm_min;								// 再加上1小时内过去的分钟数的秒数时间.
	res += tm->tm_sec;										// 再加上1分钟内已过的秒数.
	return res;												// 即等于从1970年以来经过的秒数时间.
}
    9e5a:	5b                   	pop    %ebx
	res += DAY * (tm->tm_mday - 1);							// 再加上本月过去的天数的秒数时间.
    9e5b:	8d 56 ff             	lea    -0x1(%esi),%edx
}
    9e5e:	5e                   	pop    %esi
	res += DAY * (tm->tm_mday - 1);							// 再加上本月过去的天数的秒数时间.
    9e5f:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
}
    9e65:	5f                   	pop    %edi
	res += DAY * (tm->tm_mday - 1);							// 再加上本月过去的天数的秒数时间.
    9e66:	01 d0                	add    %edx,%eax
	res += HOUR * tm->tm_hour;								// 再加上当天过去的小时数的秒数时间.
    9e68:	69 51 08 10 0e 00 00 	imul   $0xe10,0x8(%ecx),%edx
    9e6f:	01 c2                	add    %eax,%edx
	res += MINUTE * tm->tm_min;								// 再加上1小时内过去的分钟数的秒数时间.
    9e71:	6b 41 04 3c          	imul   $0x3c,0x4(%ecx),%eax
    9e75:	01 d0                	add    %edx,%eax
	res += tm->tm_sec;										// 再加上1分钟内已过的秒数.
    9e77:	03 01                	add    (%ecx),%eax
}
    9e79:	c3                   	ret    

00009e7a <__x86.get_pc_thunk.ax>:
    9e7a:	8b 04 24             	mov    (%esp),%eax
    9e7d:	c3                   	ret    

00009e7e <__x86.get_pc_thunk.cx>:
    9e7e:	8b 0c 24             	mov    (%esp),%ecx
    9e81:	c3                   	ret    

00009e82 <__x86.get_pc_thunk.si>:
    9e82:	8b 34 24             	mov    (%esp),%esi
    9e85:	c3                   	ret    

00009e86 <put_page>:
// 或者说是把线性地址空间中指定地址address处的页面映射到主内存区页面page上.主要工作是在相关页目录项和页表项中设置指定页面的信息.若成功则返回物理页面地址.
// 在处理缺页异常的C函数do_no_page()中会调用此函数.对于缺页引起的异常,由于任何缺页缘故而对页表作修改时,并不需要刷新CPU的页变换缓冲(或称Translation Lookaside
// Buffer,TLB),即使页表项中标志P被从0修改成1.因为无效页项不会被缓冲,因此当修改了一个无效的页表项时不需要刷新.在此就表现为不用调用Invalidate()函数.
// 参数page是分配的主内存区中某一页面(页帧,页框)的指针;address是线性地址.
static unsigned long put_page(unsigned long page, unsigned long address)
{
    9e86:	55                   	push   %ebp
    9e87:	57                   	push   %edi
    9e88:	89 c7                	mov    %eax,%edi
    9e8a:	56                   	push   %esi
    9e8b:	53                   	push   %ebx
    9e8c:	89 d6                	mov    %edx,%esi
    9e8e:	e8 99 cb ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9e93:	81 c3 6d 71 01 00    	add    $0x1716d,%ebx
    9e99:	83 ec 0c             	sub    $0xc,%esp
	/* 注意!!!这里使用了页目录表基地址pg_dir=0的条件 */

	// 首先判断参数给定物理内存页面page的有效性.如果该页面位置低于LOW_MEM(1MB)或超出系统实际含有内存高端HIGH_MEMORY,则发出警告.LOW_MEM是主内存区可能有的
	// 最小起始位置.当系统后果内存小于或等于6MB时,主内存区始于LOW_MEM处.再查看一下该page页面是不已经申请的页面,即判断其在内存页面映射字节图mem_map[]中相应
	// 字节是否以置位.若没有则需发出警告.
	if (page < LOW_MEM || page >= HIGH_MEMORY)
    9e9c:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
    9ea1:	76 08                	jbe    9eab <put_page+0x25>
    9ea3:	39 83 e0 30 00 00    	cmp    %eax,0x30e0(%ebx)
    9ea9:	77 12                	ja     9ebd <put_page+0x37>
		printk("Trying to put page %p at %p\n", page, address);
    9eab:	8d 83 ba 6d ff ff    	lea    -0x9246(%ebx),%eax
    9eb1:	52                   	push   %edx
    9eb2:	56                   	push   %esi
    9eb3:	57                   	push   %edi
    9eb4:	50                   	push   %eax
    9eb5:	e8 67 e2 ff ff       	call   8121 <printk>
    9eba:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page - LOW_MEM) >> 12] != 1)
    9ebd:	8d 87 00 00 f0 ff    	lea    -0x100000(%edi),%eax
    9ec3:	c1 e8 0c             	shr    $0xc,%eax
    9ec6:	80 bc 03 e0 21 00 00 	cmpb   $0x1,0x21e0(%ebx,%eax,1)
    9ecd:	01 
    9ece:	74 12                	je     9ee2 <put_page+0x5c>
		printk("mem_map disagrees with %p at %p\n", page, address);
    9ed0:	50                   	push   %eax
    9ed1:	8d 83 d7 6d ff ff    	lea    -0x9229(%ebx),%eax
    9ed7:	56                   	push   %esi
    9ed8:	57                   	push   %edi
    9ed9:	50                   	push   %eax
    9eda:	e8 42 e2 ff ff       	call   8121 <printk>
    9edf:	83 c4 10             	add    $0x10,%esp
	// 然后根据参数指定的线性地址address计算其在页目录表中对应的目录项指针,并从中取得一级页表地址.如果该目录项有效(P=1),即指定的页表在内存中,则从中取得指定页表
	// 地址放到page_table变量中.否则申请一空闲页面给页表使用,并在对应目录项中置相应标志(7 - User,U/S,R/W).然后将该页表地址放到page_table变量中.
	page_table = (unsigned long *) ((address >> 20) & 0xffc);
    9ee2:	89 f5                	mov    %esi,%ebp
    9ee4:	c1 ed 14             	shr    $0x14,%ebp
    9ee7:	81 e5 fc 0f 00 00    	and    $0xffc,%ebp
	if ((*page_table) & 1)
    9eed:	8b 45 00             	mov    0x0(%ebp),%eax
    9ef0:	a8 01                	test   $0x1,%al
    9ef2:	74 07                	je     9efb <put_page+0x75>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    9ef4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    9ef9:	eb 11                	jmp    9f0c <put_page+0x86>
	else {
		if (!(tmp = get_free_page()))
    9efb:	e8 05 0c 00 00       	call   ab05 <get_free_page>
    9f00:	85 c0                	test   %eax,%eax
    9f02:	74 1b                	je     9f1f <put_page+0x99>
			return 0;
		*page_table = tmp | 7;
    9f04:	89 c2                	mov    %eax,%edx
    9f06:	83 ca 07             	or     $0x7,%edx
    9f09:	89 55 00             	mov    %edx,0x0(%ebp)
		page_table = (unsigned long *) tmp;
	}
	// 最后在找到的页表page_table中设置相关页表项内容,即把物理页面page的地址填入表项同时置位3个标志(U/S,W/R,P).该页表项在页表中的索引值等于线性地址位21~位12
	// 组成的10位的值.每个页表共可有1024项(0~0x3ff).
	page_table[(address >> 12) & 0x3ff] = page | 7;
    9f0c:	c1 ee 0c             	shr    $0xc,%esi
    9f0f:	89 fa                	mov    %edi,%edx
    9f11:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
    9f17:	83 ca 07             	or     $0x7,%edx
    9f1a:	89 14 b0             	mov    %edx,(%eax,%esi,4)
	/* no need for invalidate */
	/* 不需要刷新页变换高速缓冲 */
	return page;					// 返回物理页面地址.
    9f1d:	89 f8                	mov    %edi,%eax
}
    9f1f:	83 c4 0c             	add    $0xc,%esp
    9f22:	5b                   	pop    %ebx
    9f23:	5e                   	pop    %esi
    9f24:	5f                   	pop    %edi
    9f25:	5d                   	pop    %ebp
    9f26:	c3                   	ret    

00009f27 <oom>:
void swap_in(unsigned long *table_ptr);                                             // 把页表项是table_ptr的一页物理内存换出到交换空间

// 下面函数名前关键字volatile用于告诉编译器gcc该函数不会返回.这样可让gcc产生更好的代码,更重要的是使用这个关键字可以避免产生某些(未
//　初始化变量的)假警告信息.
static inline void oom(void)
{
    9f27:	53                   	push   %ebx
    9f28:	e8 ff ca ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9f2d:	81 c3 d3 70 01 00    	add    $0x170d3,%ebx
    9f33:	83 ec 14             	sub    $0x14,%esp
	printk("out of memory\n\r");
    9f36:	8d 83 f8 6d ff ff    	lea    -0x9208(%ebx),%eax
    9f3c:	50                   	push   %eax
    9f3d:	e8 df e1 ff ff       	call   8121 <printk>
    //　do_exit()应该使用退出代码,这里用了信息值SIGSEGV(11).相同值的出错码含义是"资源暂不可用",正好同义.
	do_exit(SIGSEGV);
    9f42:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    9f49:	e8 9c f6 ff ff       	call   95ea <do_exit>
}
    9f4e:	83 c4 18             	add    $0x18,%esp
    9f51:	5b                   	pop    %ebx
    9f52:	c3                   	ret    

00009f53 <free_page>:
{
    9f53:	56                   	push   %esi
    9f54:	53                   	push   %ebx
    9f55:	52                   	push   %edx
    9f56:	8b 74 24 10          	mov    0x10(%esp),%esi
    9f5a:	e8 cd ca ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9f5f:	81 c3 a1 70 01 00    	add    $0x170a1,%ebx
	if (addr < LOW_MEM) return;
    9f65:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    9f6b:	76 4a                	jbe    9fb7 <free_page+0x64>
	if (addr >= HIGH_MEMORY)
    9f6d:	3b b3 e0 30 00 00    	cmp    0x30e0(%ebx),%esi
    9f73:	72 12                	jb     9f87 <free_page+0x34>
		panic("trying to free nonexistent page");
    9f75:	8d 83 08 6e ff ff    	lea    -0x91f8(%ebx),%eax
    9f7b:	83 ec 0c             	sub    $0xc,%esp
    9f7e:	50                   	push   %eax
    9f7f:	e8 4e e1 ff ff       	call   80d2 <panic>
    9f84:	83 c4 10             	add    $0x10,%esp
	addr -= LOW_MEM;
    9f87:	81 ee 00 00 10 00    	sub    $0x100000,%esi
	addr >>= 12;
    9f8d:	c1 ee 0c             	shr    $0xc,%esi
	if (mem_map[addr]--) return;
    9f90:	8a 84 33 e0 21 00 00 	mov    0x21e0(%ebx,%esi,1),%al
    9f97:	84 c0                	test   %al,%al
    9f99:	74 0a                	je     9fa5 <free_page+0x52>
    9f9b:	48                   	dec    %eax
    9f9c:	88 84 33 e0 21 00 00 	mov    %al,0x21e0(%ebx,%esi,1)
    9fa3:	eb 12                	jmp    9fb7 <free_page+0x64>
	panic("trying to free free page");
    9fa5:	8d 83 28 6e ff ff    	lea    -0x91d8(%ebx),%eax
    9fab:	83 ec 0c             	sub    $0xc,%esp
    9fae:	50                   	push   %eax
    9faf:	e8 1e e1 ff ff       	call   80d2 <panic>
    9fb4:	83 c4 10             	add    $0x10,%esp
}
    9fb7:	58                   	pop    %eax
    9fb8:	5b                   	pop    %ebx
    9fb9:	5e                   	pop    %esi
    9fba:	c3                   	ret    

00009fbb <free_page_tables>:
{
    9fbb:	55                   	push   %ebp
    9fbc:	57                   	push   %edi
    9fbd:	56                   	push   %esi
    9fbe:	53                   	push   %ebx
    9fbf:	e8 68 ca ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    9fc4:	81 c3 3c 70 01 00    	add    $0x1703c,%ebx
    9fca:	83 ec 1c             	sub    $0x1c,%esp
    9fcd:	8b 74 24 30          	mov    0x30(%esp),%esi
	if (from & 0x3fffff)
    9fd1:	f7 c6 ff ff 3f 00    	test   $0x3fffff,%esi
    9fd7:	74 0b                	je     9fe4 <free_page_tables+0x29>
		panic("free_page_tables called with wrong alignment");
    9fd9:	83 ec 0c             	sub    $0xc,%esp
    9fdc:	8d 83 41 6e ff ff    	lea    -0x91bf(%ebx),%eax
    9fe2:	eb 0d                	jmp    9ff1 <free_page_tables+0x36>
	if (!from)
    9fe4:	85 f6                	test   %esi,%esi
    9fe6:	75 12                	jne    9ffa <free_page_tables+0x3f>
		panic("Trying to free up swapper memory space");
    9fe8:	8d 83 6e 6e ff ff    	lea    -0x9192(%ebx),%eax
    9fee:	83 ec 0c             	sub    $0xc,%esp
    9ff1:	50                   	push   %eax
    9ff2:	e8 db e0 ff ff       	call   80d2 <panic>
    9ff7:	83 c4 10             	add    $0x10,%esp
	size = (size + 0x3fffff) >> 22;
    9ffa:	8b 44 24 34          	mov    0x34(%esp),%eax
	dir = (unsigned long *) ((from >> 20) & 0xffc); 			/* _pg_dir = 0 */
    9ffe:	c1 ee 14             	shr    $0x14,%esi
    a001:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
	size = (size + 0x3fffff) >> 22;
    a007:	05 ff ff 3f 00       	add    $0x3fffff,%eax
    a00c:	c1 e8 16             	shr    $0x16,%eax
    a00f:	8d 04 86             	lea    (%esi,%eax,4),%eax
    a012:	89 44 24 0c          	mov    %eax,0xc(%esp)
	for ( ; size-- > 0 ; dir++) {
    a016:	3b 74 24 0c          	cmp    0xc(%esp),%esi
    a01a:	74 68                	je     a084 <free_page_tables+0xc9>
		if (!(1 & *dir))
    a01c:	8b 06                	mov    (%esi),%eax
    a01e:	a8 01                	test   $0x1,%al
    a020:	74 5d                	je     a07f <free_page_tables+0xc4>
		pg_table = (unsigned long *) (0xfffff000 & *dir);		// 取页表地址.
    a022:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a027:	8d a8 00 10 00 00    	lea    0x1000(%eax),%ebp
    a02d:	89 c7                	mov    %eax,%edi
			if (*pg_table) {									// 若所指页表项内容不为0,则若该项有效,则释放对应面.
    a02f:	8b 17                	mov    (%edi),%edx
    a031:	85 d2                	test   %edx,%edx
    a033:	74 2a                	je     a05f <free_page_tables+0xa4>
				if (1 & *pg_table)
    a035:	f6 c2 01             	test   $0x1,%dl
    a038:	74 11                	je     a04b <free_page_tables+0x90>
					free_page(0xfffff000 & *pg_table);
    a03a:	83 ec 0c             	sub    $0xc,%esp
    a03d:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
    a043:	52                   	push   %edx
    a044:	e8 0a ff ff ff       	call   9f53 <free_page>
    a049:	eb 0b                	jmp    a056 <free_page_tables+0x9b>
					swap_free(*pg_table >> 1);
    a04b:	83 ec 0c             	sub    $0xc,%esp
    a04e:	d1 ea                	shr    %edx
    a050:	52                   	push   %edx
    a051:	e8 a7 08 00 00       	call   a8fd <swap_free>
    a056:	83 c4 10             	add    $0x10,%esp
				*pg_table = 0;									// 该页表项内容清零.
    a059:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
			pg_table++;											//指向页表中下一项.
    a05f:	83 c7 04             	add    $0x4,%edi
		for (nr = 0 ; nr < 1024 ; nr++) {
    a062:	39 ef                	cmp    %ebp,%edi
    a064:	75 c9                	jne    a02f <free_page_tables+0x74>
		free_page(0xfffff000 & *dir);							// 释放该页表所占内存页面.
    a066:	8b 06                	mov    (%esi),%eax
    a068:	83 ec 0c             	sub    $0xc,%esp
    a06b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a070:	50                   	push   %eax
    a071:	e8 dd fe ff ff       	call   9f53 <free_page>
		*dir = 0;												// 对应页表的目录项清零.
    a076:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    a07c:	83 c4 10             	add    $0x10,%esp
	for ( ; size-- > 0 ; dir++) {
    a07f:	83 c6 04             	add    $0x4,%esi
    a082:	eb 92                	jmp    a016 <free_page_tables+0x5b>
	invalidate();												// 刷新CPU页变换高速缓冲.
    a084:	31 c0                	xor    %eax,%eax
    a086:	0f 22 d8             	mov    %eax,%cr3
}
    a089:	83 c4 1c             	add    $0x1c,%esp
    a08c:	5b                   	pop    %ebx
    a08d:	5e                   	pop    %esi
    a08e:	5f                   	pop    %edi
    a08f:	5d                   	pop    %ebp
    a090:	c3                   	ret    

0000a091 <copy_page_tables>:
{
    a091:	55                   	push   %ebp
    a092:	57                   	push   %edi
    a093:	56                   	push   %esi
    a094:	53                   	push   %ebx
    a095:	e8 92 c9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a09a:	81 c3 66 6f 01 00    	add    $0x16f66,%ebx
    a0a0:	83 ec 3c             	sub    $0x3c,%esp
    a0a3:	8b 74 24 50          	mov    0x50(%esp),%esi
    a0a7:	8b 7c 24 54          	mov    0x54(%esp),%edi
	if ((from & 0x3fffff) || (to & 0x3fffff))
    a0ab:	89 f0                	mov    %esi,%eax
    a0ad:	09 f8                	or     %edi,%eax
    a0af:	a9 ff ff 3f 00       	test   $0x3fffff,%eax
    a0b4:	74 12                	je     a0c8 <copy_page_tables+0x37>
		panic("copy_page_tables called with wrong alignment");
    a0b6:	8d 83 95 6e ff ff    	lea    -0x916b(%ebx),%eax
    a0bc:	83 ec 0c             	sub    $0xc,%esp
    a0bf:	50                   	push   %eax
    a0c0:	e8 0d e0 ff ff       	call   80d2 <panic>
    a0c5:	83 c4 10             	add    $0x10,%esp
	from_dir = (unsigned long *) ((from >> 20) & 0xffc); 				/* _pg_dir = 0 */
    a0c8:	89 f0                	mov    %esi,%eax
	to_dir = (unsigned long *) ((to >> 20) & 0xffc);
    a0ca:	c1 ef 14             	shr    $0x14,%edi
	from_dir = (unsigned long *) ((from >> 20) & 0xffc); 				/* _pg_dir = 0 */
    a0cd:	c1 e8 14             	shr    $0x14,%eax
	to_dir = (unsigned long *) ((to >> 20) & 0xffc);
    a0d0:	81 e7 fc 0f 00 00    	and    $0xffc,%edi
	from_dir = (unsigned long *) ((from >> 20) & 0xffc); 				/* _pg_dir = 0 */
    a0d6:	25 fc 0f 00 00       	and    $0xffc,%eax
	to_dir = (unsigned long *) ((to >> 20) & 0xffc);
    a0db:	89 7c 24 14          	mov    %edi,0x14(%esp)
	from_dir = (unsigned long *) ((from >> 20) & 0xffc); 				/* _pg_dir = 0 */
    a0df:	89 44 24 10          	mov    %eax,0x10(%esp)
    a0e3:	89 44 24 08          	mov    %eax,0x8(%esp)
	size = ((unsigned) (size + 0x3fffff)) >> 22;
    a0e7:	8b 44 24 58          	mov    0x58(%esp),%eax
    a0eb:	05 ff ff 3f 00       	add    $0x3fffff,%eax
    a0f0:	c1 e8 16             	shr    $0x16,%eax
    a0f3:	83 fe 01             	cmp    $0x1,%esi
    a0f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
    a0fa:	19 c0                	sbb    %eax,%eax
    a0fc:	25 a0 fc ff ff       	and    $0xfffffca0,%eax
    a101:	8d 04 85 00 10 00 00 	lea    0x1000(,%eax,4),%eax
    a108:	89 44 24 1c          	mov    %eax,0x1c(%esp)
				read_swap_page(this_page >> 1, (char *) new_page);
    a10c:	c7 c0 e4 40 02 00    	mov    $0x240e4,%eax
    a112:	89 44 24 24          	mov    %eax,0x24(%esp)
    a116:	8b 74 24 14          	mov    0x14(%esp),%esi
    a11a:	2b 74 24 10          	sub    0x10(%esp),%esi
    a11e:	03 74 24 08          	add    0x8(%esp),%esi
	for( ; size-- > 0 ; from_dir++, to_dir++) {
    a122:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    a127:	0f 84 d4 00 00 00    	je     a201 <copy_page_tables+0x170>
		if (1 & *to_dir)
    a12d:	f6 06 01             	testb  $0x1,(%esi)
    a130:	74 12                	je     a144 <copy_page_tables+0xb3>
			panic("copy_page_tables: already exist");
    a132:	8d 83 c2 6e ff ff    	lea    -0x913e(%ebx),%eax
    a138:	83 ec 0c             	sub    $0xc,%esp
    a13b:	50                   	push   %eax
    a13c:	e8 91 df ff ff       	call   80d2 <panic>
    a141:	83 c4 10             	add    $0x10,%esp
		if (!(1 & *from_dir))
    a144:	8b 44 24 08          	mov    0x8(%esp),%eax
    a148:	8b 00                	mov    (%eax),%eax
    a14a:	a8 01                	test   $0x1,%al
    a14c:	75 0b                	jne    a159 <copy_page_tables+0xc8>
	for( ; size-- > 0 ; from_dir++, to_dir++) {
    a14e:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
    a153:	ff 4c 24 0c          	decl   0xc(%esp)
    a157:	eb bd                	jmp    a116 <copy_page_tables+0x85>
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);
    a159:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a15e:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (!(to_page_table = (unsigned long *) get_free_page()))
    a162:	e8 9e 09 00 00       	call   ab05 <get_free_page>
    a167:	85 c0                	test   %eax,%eax
    a169:	89 c2                	mov    %eax,%edx
    a16b:	89 c7                	mov    %eax,%edi
    a16d:	75 08                	jne    a177 <copy_page_tables+0xe6>
			return -1;													/* Out of memory, see freeing */
    a16f:	83 c8 ff             	or     $0xffffffff,%eax
    a172:	e9 93 00 00 00       	jmp    a20a <copy_page_tables+0x179>
		*to_dir = ((unsigned long) to_page_table) | 7;
    a177:	83 c8 07             	or     $0x7,%eax
    a17a:	89 06                	mov    %eax,(%esi)
    a17c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    a180:	01 d0                	add    %edx,%eax
    a182:	89 44 24 20          	mov    %eax,0x20(%esp)
    a186:	8b 6c 24 18          	mov    0x18(%esp),%ebp
    a18a:	29 d5                	sub    %edx,%ebp
    a18c:	01 fd                	add    %edi,%ebp
		for ( ; nr-- > 0 ; from_page_table++, to_page_table++) {
    a18e:	3b 7c 24 20          	cmp    0x20(%esp),%edi
    a192:	74 ba                	je     a14e <copy_page_tables+0xbd>
			this_page = *from_page_table;
    a194:	8b 75 00             	mov    0x0(%ebp),%esi
			if (!this_page)
    a197:	85 f6                	test   %esi,%esi
    a199:	74 61                	je     a1fc <copy_page_tables+0x16b>
			if (!(1 & this_page)) {
    a19b:	f7 c6 01 00 00 00    	test   $0x1,%esi
    a1a1:	75 39                	jne    a1dc <copy_page_tables+0x14b>
    a1a3:	89 54 24 2c          	mov    %edx,0x2c(%esp)
				if (!(new_page = get_free_page()))
    a1a7:	e8 59 09 00 00       	call   ab05 <get_free_page>
    a1ac:	85 c0                	test   %eax,%eax
    a1ae:	74 bf                	je     a16f <copy_page_tables+0xde>
				read_swap_page(this_page >> 1, (char *) new_page);
    a1b0:	50                   	push   %eax
    a1b1:	89 f1                	mov    %esi,%ecx
    a1b3:	d1 e9                	shr    %ecx
    a1b5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    a1b9:	51                   	push   %ecx
    a1ba:	8b 44 24 2c          	mov    0x2c(%esp),%eax
    a1be:	ff 30                	pushl  (%eax)
    a1c0:	6a 00                	push   $0x0
    a1c2:	e8 62 66 00 00       	call   10829 <ll_rw_page>
				*from_page_table = new_page | (PAGE_DIRTY | 7);
    a1c7:	8b 44 24 38          	mov    0x38(%esp),%eax
				continue;
    a1cb:	83 c4 10             	add    $0x10,%esp
				*to_page_table = this_page;
    a1ce:	89 37                	mov    %esi,(%edi)
				continue;
    a1d0:	8b 54 24 2c          	mov    0x2c(%esp),%edx
				*from_page_table = new_page | (PAGE_DIRTY | 7);
    a1d4:	83 c8 47             	or     $0x47,%eax
    a1d7:	89 45 00             	mov    %eax,0x0(%ebp)
				continue;
    a1da:	eb 20                	jmp    a1fc <copy_page_tables+0x16b>
			this_page &= ~2;
    a1dc:	83 e6 fd             	and    $0xfffffffd,%esi
			if (this_page > LOW_MEM) {
    a1df:	81 fe 00 00 10 00    	cmp    $0x100000,%esi
			*to_page_table = this_page;
    a1e5:	89 37                	mov    %esi,(%edi)
			if (this_page > LOW_MEM) {
    a1e7:	76 13                	jbe    a1fc <copy_page_tables+0x16b>
				*from_page_table = this_page;		// 令源页表项也只读.
    a1e9:	89 75 00             	mov    %esi,0x0(%ebp)
				this_page -= LOW_MEM;
    a1ec:	81 ee 00 00 10 00    	sub    $0x100000,%esi
				this_page >>= 12;
    a1f2:	c1 ee 0c             	shr    $0xc,%esi
				mem_map[this_page]++;
    a1f5:	fe 84 33 e0 21 00 00 	incb   0x21e0(%ebx,%esi,1)
		for ( ; nr-- > 0 ; from_page_table++, to_page_table++) {
    a1fc:	83 c7 04             	add    $0x4,%edi
    a1ff:	eb 85                	jmp    a186 <copy_page_tables+0xf5>
	invalidate();									// 刷新页变换高速缓冲.
    a201:	8b 44 24 0c          	mov    0xc(%esp),%eax
    a205:	0f 22 d8             	mov    %eax,%cr3
	return 0;
    a208:	31 c0                	xor    %eax,%eax
}
    a20a:	83 c4 3c             	add    $0x3c,%esp
    a20d:	5b                   	pop    %ebx
    a20e:	5e                   	pop    %esi
    a20f:	5f                   	pop    %edi
    a210:	5d                   	pop    %ebp
    a211:	c3                   	ret    

0000a212 <put_dirty_page>:
 * 已修改状态标志.因而下面就有了与上面相同的函数,但是该函数在放置页面时会把页面标志为已修改状态.
 */
// 把一内容已修改过的物理内存页面映射到线性地址空间指定处.
// 该函数与一个函数put_page()几乎完全一样,除了本函数在第223行设置页表项内容时,同时还设置了页面已修改标志(位6,PAGE_DIRTY).
unsigned long put_dirty_page(unsigned long page, unsigned long address)
{
    a212:	55                   	push   %ebp
    a213:	57                   	push   %edi
    a214:	56                   	push   %esi
    a215:	53                   	push   %ebx
    a216:	e8 11 c8 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a21b:	81 c3 e5 6d 01 00    	add    $0x16de5,%ebx
    a221:	83 ec 0c             	sub    $0xc,%esp
    a224:	8b 7c 24 20          	mov    0x20(%esp),%edi
    a228:	8b 74 24 24          	mov    0x24(%esp),%esi
	/* NOTE !!! This uses the fact that _pg_dir=0 */

	// 首先判断参数给定物理内存页面page的有效性.如果该页面位置低于LOW_MEM(1MB)或超出系统实际含有内存高端HIGH_MEMORY,则发出警告.LOW_MEM是主内存区可能有的
	// 最小起始位置.当系统后果内存小于或等于6MB时,主内存区始于LOW_MEM处.再查看一下该page页面是不已经申请的页面,即判断其在内存页面映射字节图mem_map[]中相应
	// 字节是否以置位.若没有则需发出警告.
	if (page < LOW_MEM || page >= HIGH_MEMORY)
    a22c:	81 ff ff ff 0f 00    	cmp    $0xfffff,%edi
    a232:	76 08                	jbe    a23c <put_dirty_page+0x2a>
    a234:	39 bb e0 30 00 00    	cmp    %edi,0x30e0(%ebx)
    a23a:	77 12                	ja     a24e <put_dirty_page+0x3c>
		printk("Trying to put page %p at %p\n", page, address);
    a23c:	8d 83 ba 6d ff ff    	lea    -0x9246(%ebx),%eax
    a242:	52                   	push   %edx
    a243:	56                   	push   %esi
    a244:	57                   	push   %edi
    a245:	50                   	push   %eax
    a246:	e8 d6 de ff ff       	call   8121 <printk>
    a24b:	83 c4 10             	add    $0x10,%esp
	if (mem_map[(page-LOW_MEM)>>12] != 1)
    a24e:	8d 87 00 00 f0 ff    	lea    -0x100000(%edi),%eax
    a254:	c1 e8 0c             	shr    $0xc,%eax
    a257:	80 bc 03 e0 21 00 00 	cmpb   $0x1,0x21e0(%ebx,%eax,1)
    a25e:	01 
    a25f:	74 12                	je     a273 <put_dirty_page+0x61>
		printk("mem_map disagrees with %p at %p\n", page, address);
    a261:	50                   	push   %eax
    a262:	8d 83 d7 6d ff ff    	lea    -0x9229(%ebx),%eax
    a268:	56                   	push   %esi
    a269:	57                   	push   %edi
    a26a:	50                   	push   %eax
    a26b:	e8 b1 de ff ff       	call   8121 <printk>
    a270:	83 c4 10             	add    $0x10,%esp
	// 然后根据参数指定的线性地址address计算其在页目录表中对应的目录项指针,并从中取得一级页表地址.如果该目录项有效(P=1),即指定的页表在内存中,则从中取得指定页表
	// 地址放到page_table变量中.否则申请一空闲页面给页表使用,并在对应目录项中置相应标志(7 - User,U/S,R/W).然后将该页表地址放到page_table变量中.
	page_table = (unsigned long *) ((address >> 20) & 0xffc);
    a273:	89 f5                	mov    %esi,%ebp
    a275:	c1 ed 14             	shr    $0x14,%ebp
    a278:	81 e5 fc 0f 00 00    	and    $0xffc,%ebp
	if ((*page_table) & 1)
    a27e:	8b 45 00             	mov    0x0(%ebp),%eax
    a281:	a8 01                	test   $0x1,%al
    a283:	74 07                	je     a28c <put_dirty_page+0x7a>
		page_table = (unsigned long *) (0xfffff000 & *page_table);
    a285:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a28a:	eb 11                	jmp    a29d <put_dirty_page+0x8b>
	else {
		if (!(tmp = get_free_page()))
    a28c:	e8 74 08 00 00       	call   ab05 <get_free_page>
    a291:	85 c0                	test   %eax,%eax
    a293:	74 1b                	je     a2b0 <put_dirty_page+0x9e>
			return 0;
		*page_table = tmp | 7;
    a295:	89 c2                	mov    %eax,%edx
    a297:	83 ca 07             	or     $0x7,%edx
    a29a:	89 55 00             	mov    %edx,0x0(%ebp)
		page_table = (unsigned long *) tmp;
	}
	// 最后在找到的页表page_table中设置相关页表项内容,即把物理页面page的地址填入表项同时置位3个标志(U/S,W/R,P).该页表项在页表中的索引值等于线性地址位21~位12
	// 组成的10位的值.每个页表共可有1024项(0~0x3ff).
	page_table[(address >> 12) & 0x3ff] = page | (PAGE_DIRTY | 7);
    a29d:	c1 ee 0c             	shr    $0xc,%esi
    a2a0:	89 fa                	mov    %edi,%edx
    a2a2:	81 e6 ff 03 00 00    	and    $0x3ff,%esi
    a2a8:	83 ca 47             	or     $0x47,%edx
    a2ab:	89 14 b0             	mov    %edx,(%eax,%esi,4)
	/* no need for invalidate */
	/* 不需要刷新页变换高速缓冲 */
	return page;
    a2ae:	89 f8                	mov    %edi,%eax
}
    a2b0:	83 c4 0c             	add    $0xc,%esp
    a2b3:	5b                   	pop    %ebx
    a2b4:	5e                   	pop    %esi
    a2b5:	5f                   	pop    %edi
    a2b6:	5d                   	pop    %ebp
    a2b7:	c3                   	ret    

0000a2b8 <un_wp_page>:
// 用于页异常中断过程中写保护异常的处理(写时复制).在内核创建进程时,新进程与父进程被设置成共享代码和数据内存页面,并且所有这些页面均被设置成只读页面.而当新进程或原
// 进程需要向内存页面写数据时,CPU就会检测到这个情况并产生页面写保护异常.于是在这个函数中内核就会首先判断要写的页面是否被共享.若没有则把页面设置成可写然后退出.若页面
// 处于共享状态,则要重新申请一新页面并复制被写页面内容,以供写进程单独使用.共享被取消.
// 输入参数为页面表项指针,是物理地址.[un_wp_page -- Un-Write Protect Page]
void un_wp_page(unsigned long * table_entry)
{
    a2b8:	55                   	push   %ebp
    a2b9:	57                   	push   %edi
    a2ba:	56                   	push   %esi
    a2bb:	53                   	push   %ebx
    a2bc:	e8 6b c7 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a2c1:	81 c3 3f 6d 01 00    	add    $0x16d3f,%ebx
    a2c7:	83 ec 0c             	sub    $0xc,%esp
    a2ca:	8b 6c 24 20          	mov    0x20(%esp),%ebp
	unsigned long old_page, new_page;

	// 首先取参数指定的页表项中物理页面位置(地址)并判断该页面是不是共享页面.如果原页面地址大于内存低端LOW_MEM(表示在主内存区中),并且其在页面映射字节图数组中值为1(表示
	// 页面仅被引用1次,页面没有被共享),则在该页面的页表项中 R/W标志(可写),并刷新页变换高速缓冲,然后返回.即如果该内存页面此时只被一个进程使用,并且不是内核中的进程,就直接
	// 把属性改为可写即可,不必重新申请一个新页面.
	old_page = 0xfffff000 & *table_entry;				// 取指定页表项中物理页面地址.
    a2ce:	8b 45 00             	mov    0x0(%ebp),%eax
    a2d1:	89 c6                	mov    %eax,%esi
    a2d3:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)] == 1) {
    a2d9:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    a2df:	76 1b                	jbe    a2fc <un_wp_page+0x44>
    a2e1:	8d 96 00 00 f0 ff    	lea    -0x100000(%esi),%edx
    a2e7:	c1 ea 0c             	shr    $0xc,%edx
    a2ea:	80 bc 13 e0 21 00 00 	cmpb   $0x1,0x21e0(%ebx,%edx,1)
    a2f1:	01 
    a2f2:	75 08                	jne    a2fc <un_wp_page+0x44>
		*table_entry |= 2;
    a2f4:	83 c8 02             	or     $0x2,%eax
    a2f7:	89 45 00             	mov    %eax,0x0(%ebp)
    a2fa:	eb 3a                	jmp    a336 <un_wp_page+0x7e>
		invalidate();
		return;
	}
	// 否则就需要在主内存区内申请一页空闲页面给执行写操作的进程单独使用,取消页面共享.如果原页面大于内存低端(则意味着mem_map[]>1,页面是共享的),则将原页面的页面映射字节数组
	// 值递减1.然后将指定页表项内容更新为新页面地址,并置可读写标志(U/S,R/W,P).在刷新页变换高速缓冲之后,最后将原页面内容复制到新页面.
	if (!(new_page = get_free_page()))
    a2fc:	e8 04 08 00 00       	call   ab05 <get_free_page>
    a301:	85 c0                	test   %eax,%eax
    a303:	89 c7                	mov    %eax,%edi
    a305:	75 05                	jne    a30c <un_wp_page+0x54>
		oom();											// 内存不够处理.
    a307:	e8 1b fc ff ff       	call   9f27 <oom>
	if (old_page >= LOW_MEM)
    a30c:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    a312:	76 10                	jbe    a324 <un_wp_page+0x6c>
		mem_map[MAP_NR(old_page)]--;
    a314:	8d 86 00 00 f0 ff    	lea    -0x100000(%esi),%eax
    a31a:	c1 e8 0c             	shr    $0xc,%eax
    a31d:	fe 8c 03 e0 21 00 00 	decb   0x21e0(%ebx,%eax,1)
	copy_page(old_page, new_page);
    a324:	b9 00 04 00 00       	mov    $0x400,%ecx
    a329:	57                   	push   %edi
    a32a:	56                   	push   %esi
    a32b:	fc                   	cld    
    a32c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    a32e:	5e                   	pop    %esi
    a32f:	5f                   	pop    %edi
	// 将新的页面设置为可读可写且存在
	*table_entry = new_page | 7;
    a330:	83 cf 07             	or     $0x7,%edi
    a333:	89 7d 00             	mov    %edi,0x0(%ebp)
	// 刷新高速缓冲
	invalidate();
    a336:	31 c0                	xor    %eax,%eax
    a338:	0f 22 d8             	mov    %eax,%cr3
}
    a33b:	83 c4 0c             	add    $0xc,%esp
    a33e:	5b                   	pop    %ebx
    a33f:	5e                   	pop    %esi
    a340:	5f                   	pop    %edi
    a341:	5d                   	pop    %ebp
    a342:	c3                   	ret    

0000a343 <do_wp_page>:
// 执行写保护页面处理.
// 是写共享页面处理函数.是页异常中断处理过程中调用的C函数.在page.s程序中被调用.
// 函数参数error_code和address是进程在写写保护页面时由CPU产生异常而自动生成的.error_code指出出错类型;address是产生异常的页面
// 线性地址.写共享页面时需复制页面(写时复制).
void do_wp_page(unsigned long error_code, unsigned long address)
{
    a343:	56                   	push   %esi
    a344:	53                   	push   %ebx
    a345:	52                   	push   %edx
    a346:	8b 74 24 14          	mov    0x14(%esp),%esi
    a34a:	e8 dd c6 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a34f:	81 c3 b1 6c 01 00    	add    $0x16cb1,%ebx
	// 首先判断CPU控制寄存器CR2给出的引起页面异常的线性地址在什么范围中.如果address小于TASK_SIZE(0x4000000,即64MB),表示异常页面位置
	// 在内核或任务0和任务1所处的线性地址范围内,于是发出警告信息"内核范围内存被写保护";如果(address - 当前进程代码起始地址)大于一个进程的
	// 长度(64MB),表示address所指的线性地址不在引起异常的进程线性地址空间范围内,则在发出出错信息后退出.
	if (address < TASK_SIZE)
    a355:	81 fe ff ff ff 03    	cmp    $0x3ffffff,%esi
    a35b:	77 12                	ja     a36f <do_wp_page+0x2c>
		printk("\n\rBAD! KERNEL MEMORY WP-ERR!\n\r");
    a35d:	8d 83 e2 6e ff ff    	lea    -0x911e(%ebx),%eax
    a363:	83 ec 0c             	sub    $0xc,%esp
    a366:	50                   	push   %eax
    a367:	e8 b5 dd ff ff       	call   8121 <printk>
    a36c:	83 c4 10             	add    $0x10,%esp
	if (address - current->start_code > TASK_SIZE) {
    a36f:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    a375:	89 f2                	mov    %esi,%edx
    a377:	8b 00                	mov    (%eax),%eax
    a379:	2b 90 18 02 00 00    	sub    0x218(%eax),%edx
    a37f:	81 fa 00 00 00 04    	cmp    $0x4000000,%edx
    a385:	76 1e                	jbe    a3a5 <do_wp_page+0x62>
		printk("Bad things happen: page error in do_wp_page\n\r");
    a387:	8d 83 01 6f ff ff    	lea    -0x90ff(%ebx),%eax
    a38d:	83 ec 0c             	sub    $0xc,%esp
    a390:	50                   	push   %eax
    a391:	e8 8b dd ff ff       	call   8121 <printk>
		do_exit(SIGSEGV);
    a396:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    a39d:	e8 48 f2 ff ff       	call   95ea <do_exit>
    a3a2:	83 c4 10             	add    $0x10,%esp
	// 的物理地址.最后与上0xffffff000用于屏蔽掉页目录项内容中的一些标志位(目录项低12位).直观表示为(0xffffff000 & *((unsigned long *) (((
	// address>>22) & 0x3ff)<<2))).3:由1中页表项在页表中偏移地址加上2中目录表项内容中对应页表的物理地址即可得到页表项的指针(物理地址).这里对
	// 共享的页面进行复制.
	un_wp_page((unsigned long *)
		(((address >> 10) & 0xffc) + (0xfffff000 &
		*((unsigned long *) ((address >> 20) & 0xffc)))));
    a3a5:	89 f0                	mov    %esi,%eax
		(((address >> 10) & 0xffc) + (0xfffff000 &
    a3a7:	c1 ee 0a             	shr    $0xa,%esi
		*((unsigned long *) ((address >> 20) & 0xffc)))));
    a3aa:	c1 e8 14             	shr    $0x14,%eax
		(((address >> 10) & 0xffc) + (0xfffff000 &
    a3ad:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
		*((unsigned long *) ((address >> 20) & 0xffc)))));
    a3b3:	25 fc 0f 00 00       	and    $0xffc,%eax
		(((address >> 10) & 0xffc) + (0xfffff000 &
    a3b8:	8b 00                	mov    (%eax),%eax
    a3ba:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a3bf:	09 c6                	or     %eax,%esi
	un_wp_page((unsigned long *)
    a3c1:	89 74 24 10          	mov    %esi,0x10(%esp)

}
    a3c5:	58                   	pop    %eax
    a3c6:	5b                   	pop    %ebx
    a3c7:	5e                   	pop    %esi
	un_wp_page((unsigned long *)
    a3c8:	e9 eb fe ff ff       	jmp    a2b8 <un_wp_page>

0000a3cd <write_verify>:

// 写页面验证.
// 若页面不可写,则复制页面.在fork.c中被内存验证通用函数verify_area()调用.
// 参数address是指定页面在4GB空间中的线性地址.
void write_verify(unsigned long address)
{
    a3cd:	8b 54 24 04          	mov    0x4(%esp),%edx

	// 首先取指定线性地址对应的页目录项,根据目录项中的存在位(P)判断目录项对应的页表是否存在(存在位P=1?),若不存在(P=0)则返回.这样处理
	// 是因为对于不存在的页面没有共享和写时复制可言,并且若程序对此不存在的页面执行写操作时,系统就会因为缺页异常而去执行do_no_page(),
	// 并为这个地方使用put_page()函数映射一个物理页面.接着程序从目录项中取页表地址,加上指定页面在页表中的页表项偏移值,得对应地址的页表
	// 项指针.在该表项中包含着给定线性地址对应的物理页面.
	if (!( (page = *((unsigned long *) ((address >> 20) & 0xffc)) ) & 1))
    a3d1:	89 d0                	mov    %edx,%eax
    a3d3:	c1 e8 14             	shr    $0x14,%eax
    a3d6:	25 fc 0f 00 00       	and    $0xffc,%eax
    a3db:	8b 00                	mov    (%eax),%eax
    a3dd:	a8 01                	test   $0x1,%al
    a3df:	74 24                	je     a405 <write_verify+0x38>
		return;
	page &= 0xfffff000;
    a3e1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a3e6:	89 c1                	mov    %eax,%ecx
	// 得到页表项的物理地址
	page += ((address >> 10) & 0xffc);
    a3e8:	89 d0                	mov    %edx,%eax
    a3ea:	c1 e8 0a             	shr    $0xa,%eax
    a3ed:	25 fc 0f 00 00       	and    $0xffc,%eax
    a3f2:	09 c8                	or     %ecx,%eax
	// 然后判断该页表项中位1(P/W),位0(P)标志.如果该页面不可写(R/W=0)且存在,那么就执行共享检验和复制页面操作(写时复制).否则什么也不做,
	// 直接退出.
	if ((3 & *(unsigned long *) page) == 1)  /* non-writeable, present */
    a3f4:	8b 10                	mov    (%eax),%edx
    a3f6:	83 e2 03             	and    $0x3,%edx
    a3f9:	4a                   	dec    %edx
    a3fa:	75 09                	jne    a405 <write_verify+0x38>
		un_wp_page((unsigned long *) page);
    a3fc:	89 44 24 04          	mov    %eax,0x4(%esp)
    a400:	e9 b3 fe ff ff       	jmp    a2b8 <un_wp_page>
	return;
}
    a405:	c3                   	ret    

0000a406 <get_empty_page>:

// 取得一页空闲内存并映射到指定线性地址处.
// get_free_page()仅是申请取得了主内存区的一页物理内存.而本函数则不仅是获取到一页物理内存页面,还进一步调用put_page(),将物理页面映射到指定的线性地址处.
// 参数address是指定页面的线性地址.
void get_empty_page(unsigned long address)
{
    a406:	56                   	push   %esi
    a407:	53                   	push   %ebx
    a408:	e8 1f c6 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a40d:	81 c3 f3 6b 01 00    	add    $0x16bf3,%ebx
    a413:	52                   	push   %edx
    a414:	8b 74 24 10          	mov    0x10(%esp),%esi
	unsigned long tmp;

	// 若不能取得一空闲页面,或者不能将所取页面放置到指定地址处,则显示内存不够的信息.292行上英文注释的含义是:free_page()函数的参数tmp是0也没有关系,该函数会忽略它
	// 并能正常返回.
	if (!(tmp = get_free_page()) || !put_page(tmp, address)) {
    a418:	e8 e8 06 00 00       	call   ab05 <get_free_page>
    a41d:	85 c0                	test   %eax,%eax
    a41f:	89 c3                	mov    %eax,%ebx
    a421:	75 13                	jne    a436 <get_empty_page+0x30>
		free_page(tmp);		/* 0 is ok - ignored */
    a423:	83 ec 0c             	sub    $0xc,%esp
    a426:	53                   	push   %ebx
    a427:	e8 27 fb ff ff       	call   9f53 <free_page>
		oom();
	}
}
    a42c:	83 c4 14             	add    $0x14,%esp
    a42f:	5b                   	pop    %ebx
    a430:	5e                   	pop    %esi
		oom();
    a431:	e9 f1 fa ff ff       	jmp    9f27 <oom>
	if (!(tmp = get_free_page()) || !put_page(tmp, address)) {
    a436:	89 f2                	mov    %esi,%edx
    a438:	e8 49 fa ff ff       	call   9e86 <put_page>
    a43d:	85 c0                	test   %eax,%eax
    a43f:	74 e2                	je     a423 <get_empty_page+0x1d>
}
    a441:	58                   	pop    %eax
    a442:	5b                   	pop    %ebx
    a443:	5e                   	pop    %esi
    a444:	c3                   	ret    

0000a445 <do_no_page>:
// 是访问不存在页面处理函数.页异常中断处理过程中调用的函数.在page.s程序中被调用.函数参数error_code和address是进程在访问页面时由CPU因
// 缺页产生异常而自动生成.error_code指出出错类型;address产生异常的页面线性地址.
// 该函数首先查看所缺页是否在交换设备中,若是则交换进来.否则尝试与已加载的相同文件进行页面共享,或者只是由于进程动态申请内存页面而只需映射一页
// 物理内存页即可.若共享操作不成功,那么只能从相应文件中读入所缺的数据页面到指定线性地址处.
void do_no_page(unsigned long error_code, unsigned long address)
{
    a445:	55                   	push   %ebp
    a446:	57                   	push   %edi
    a447:	56                   	push   %esi
    a448:	53                   	push   %ebx
    a449:	e8 de c5 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a44e:	81 c3 b2 6b 01 00    	add    $0x16bb2,%ebx
    a454:	83 ec 3c             	sub    $0x3c,%esp
    a457:	8b 74 24 54          	mov    0x54(%esp),%esi
	struct m_inode * inode;

	// 首先判断CPU控制寄存器CR2给出的引起页面异常的线性地址在什么范围中.如果address小于TASK_SIZE(0x4000000,即64MB),表示异常页面位置在内核
	// 或任务0和任务1所处的线性地址范围内,于是发出警告信息"内核范围内存被写保护";如果(address-当前进程代码起始地址)大于一个进程的长度(64MB),表示
	// address所指的线性地址不在引起异常的进程线性地址空间范围内,则在发出出错信息后退出
	if (address < TASK_SIZE)
    a45b:	81 fe ff ff ff 03    	cmp    $0x3ffffff,%esi
    a461:	77 12                	ja     a475 <do_no_page+0x30>
		printk("\n\rBAD!! KERNEL PAGE MISSING\n\r");
    a463:	8d 83 2f 6f ff ff    	lea    -0x90d1(%ebx),%eax
    a469:	83 ec 0c             	sub    $0xc,%esp
    a46c:	50                   	push   %eax
    a46d:	e8 af dc ff ff       	call   8121 <printk>
    a472:	83 c4 10             	add    $0x10,%esp
	if (address - current->start_code > TASK_SIZE) {
    a475:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
    a47b:	89 f1                	mov    %esi,%ecx
    a47d:	8b 07                	mov    (%edi),%eax
    a47f:	2b 88 18 02 00 00    	sub    0x218(%eax),%ecx
    a485:	81 f9 00 00 00 04    	cmp    $0x4000000,%ecx
    a48b:	76 1e                	jbe    a4ab <do_no_page+0x66>
		printk("Bad things happen: nonexistent page error in do_no_page\n\r");
    a48d:	8d 83 4d 6f ff ff    	lea    -0x90b3(%ebx),%eax
    a493:	83 ec 0c             	sub    $0xc,%esp
    a496:	50                   	push   %eax
    a497:	e8 85 dc ff ff       	call   8121 <printk>
		do_exit(SIGSEGV);
    a49c:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    a4a3:	e8 42 f1 ff ff       	call   95ea <do_exit>
    a4a8:	83 c4 10             	add    $0x10,%esp
	}
	// 然后根据指定的线性地址address求出其对应的二级页表项指针,并根据该页表项内容判断address处的页面是否在交换设备中.若是则调入页面并退出.方法是首先
	// 取指定线性地址address对应的目录项内容.如果对应的二级页表存在,则取出该目录项中二级页表的地址,加上页表项偏移值即得到线性地址address处页面对应的
	// 页表项指针,从而获得页表项内容.若页表内容不为0并且页表项存在位P=0,则说明该页表项指定的物理页面应该在交换设备中.于是从交换设备中调入指定页面后退出函数.
	page = *(unsigned long *) ((address >> 20) & 0xffc);				// 取目录项内容.
    a4ab:	89 f0                	mov    %esi,%eax
    a4ad:	c1 e8 14             	shr    $0x14,%eax
    a4b0:	25 fc 0f 00 00       	and    $0xffc,%eax
    a4b5:	8b 00                	mov    (%eax),%eax
	if (page & 1) {
    a4b7:	a8 01                	test   $0x1,%al
    a4b9:	74 2c                	je     a4e7 <do_no_page+0xa2>
		page &= 0xfffff000;												// 二级页表地址.
    a4bb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
    a4c0:	89 c2                	mov    %eax,%edx
		page += (address >> 10) & 0xffc;								// 页表项指针.
    a4c2:	89 f0                	mov    %esi,%eax
    a4c4:	c1 e8 0a             	shr    $0xa,%eax
    a4c7:	25 fc 0f 00 00       	and    $0xffc,%eax
    a4cc:	09 d0                	or     %edx,%eax
		tmp = *(unsigned long *) page;									// 页表项内容.
    a4ce:	8b 10                	mov    (%eax),%edx
		if (tmp && !(1 & tmp)) {
    a4d0:	85 d2                	test   %edx,%edx
    a4d2:	74 13                	je     a4e7 <do_no_page+0xa2>
    a4d4:	80 e2 01             	and    $0x1,%dl
    a4d7:	75 0e                	jne    a4e7 <do_no_page+0xa2>
			swap_in((unsigned long *) page);							// 从交换设备读页面.
    a4d9:	83 ec 0c             	sub    $0xc,%esp
    a4dc:	50                   	push   %eax
    a4dd:	e8 8a 06 00 00       	call   ab6c <swap_in>
    a4e2:	e9 4c 02 00 00       	jmp    a733 <do_no_page+0x2ee>
		}
	}
	// 否则取线性空间中指定地址address处页面地址,并算出指定线性地址在进程空间中相对于进程基址的偏移长度值tmp,即对应的逻辑地址.从而可以算出缺页页面在执行文件映像
	// 中或在库文件中的具体起始数据块号.
	address &= 0xfffff000;												// address处缺页页面地址.
	tmp = address - current->start_code;								// 缺页页面对应逻辑地址.
    a4e7:	8b 0f                	mov    (%edi),%ecx
	address &= 0xfffff000;												// address处缺页页面地址.
    a4e9:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	tmp = address - current->start_code;								// 缺页页面对应逻辑地址.
    a4ef:	89 f7                	mov    %esi,%edi
	address &= 0xfffff000;												// address处缺页页面地址.
    a4f1:	89 74 24 04          	mov    %esi,0x4(%esp)
	tmp = address - current->start_code;								// 缺页页面对应逻辑地址.
    a4f5:	8b 81 18 02 00 00    	mov    0x218(%ecx),%eax
    a4fb:	29 c7                	sub    %eax,%edi
    a4fd:	89 44 24 08          	mov    %eax,0x8(%esp)
	// 如果缺页对应的逻辑地址tmp大于库映像文件在进程逻辑空间中的起始位置,说明缺少的页面在库映像文件中.于是从当前进程任务数据结构中可以取得库映像文件的i节点library,
	// 并计算出该缺页在库文件中的起始数据块号block.
	// 因为设置上存放的执行文件映像第1块数据是程序头结构,因此在读取该文件时需要跳过第1块数据.所以需要首先计算缺页所在数据块号.因为每块数据长度为BLOCK_SIZE = 1KB,因此
	// 一页内存可存放4个数据块.进程逻辑地址tmp除以数据块大小再加1即可得出缺少的页面在执行映像文件中的起始块号block.
	if (tmp >= LIBRARY_OFFSET ) {
    a501:	81 ff ff ff bf 03    	cmp    $0x3bfffff,%edi
    a507:	76 11                	jbe    a51a <do_no_page+0xd5>
		inode = current->library;										// 库文件i节点和缺页起始块号.
    a509:	8b 81 40 03 00 00    	mov    0x340(%ecx),%eax
    a50f:	89 04 24             	mov    %eax,(%esp)
		block = 1 + (tmp - LIBRARY_OFFSET) / BLOCK_SIZE;
    a512:	8d 87 00 00 40 fc    	lea    -0x3c00000(%edi),%eax
    a518:	eb 13                	jmp    a52d <do_no_page+0xe8>
	// 如果缺页对应的逻辑地址tmp小于进程的执行映像文件在逻辑地址空间的末端位置,则说明缺少的页面在进程执行文件映像中,于是可
	// 以从当前进程任务数据机构中取得执行文件的i节点号executable,并计算出该缺页在执行文件映像中的起始数据块号block.若逻辑地址tmp既不在执行文件映像的地址范围内,
	} else if (tmp < current->end_data) {
    a51a:	39 b9 20 02 00 00    	cmp    %edi,0x220(%ecx)
    a520:	76 19                	jbe    a53b <do_no_page+0xf6>
		inode = current->executable;									// 执行文件i节点和缺页起始块号.
    a522:	8b 81 3c 03 00 00    	mov    0x33c(%ecx),%eax
    a528:	89 04 24             	mov    %eax,(%esp)
		block = 1 + tmp / BLOCK_SIZE;
    a52b:	89 f8                	mov    %edi,%eax
    a52d:	c1 e8 0a             	shr    $0xa,%eax
    a530:	40                   	inc    %eax
	} else {
		inode = NULL;													// 是动态申请的数据或栈内存页面.
		block = 0;
	}
	// 若是进程访问其动态申请的页面或为了存放栈信息而引起的缺页异常,则直接申请一页物理内存页面并映射到线性地址address处即可.
	if (!inode) {														// 是动态申请的数据内存页面.
    a531:	83 3c 24 00          	cmpl   $0x0,(%esp)
		block = 1 + tmp / BLOCK_SIZE;
    a535:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if (!inode) {														// 是动态申请的数据内存页面.
    a539:	75 11                	jne    a54c <do_no_page+0x107>
		get_empty_page(address);
    a53b:	83 ec 0c             	sub    $0xc,%esp
    a53e:	ff 74 24 10          	pushl  0x10(%esp)
    a542:	e8 bf fe ff ff       	call   a406 <get_empty_page>
    a547:	e9 e7 01 00 00       	jmp    a733 <do_no_page+0x2ee>
	if (inode->i_count < 2 || !inode)
    a54c:	8b 04 24             	mov    (%esp),%eax
    a54f:	66 83 78 34 01       	cmpw   $0x1,0x34(%eax)
    a554:	0f 86 44 01 00 00    	jbe    a69e <do_no_page+0x259>
	from_page = to_page = ((address >> 20) & 0xffc);
    a55a:	89 f8                	mov    %edi,%eax
    a55c:	c1 e8 14             	shr    $0x14,%eax
    a55f:	25 fc 0f 00 00       	and    $0xffc,%eax
    a564:	89 44 24 10          	mov    %eax,0x10(%esp)
	from_page = from + ((address >> 10) & 0xffc);             		// 页表项指针。
    a568:	89 f8                	mov    %edi,%eax
    a56a:	c1 e8 0a             	shr    $0xa,%eax
    a56d:	25 fc 0f 00 00       	and    $0xffc,%eax
    a572:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
    a576:	8b 83 e0 30 00 00    	mov    0x30e0(%ebx),%eax
    a57c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    a580:	c7 c0 60 22 02 00    	mov    $0x22260,%eax
    a586:	8d 90 fc 00 00 00    	lea    0xfc(%eax),%edx
    a58c:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (!*p)								// 如果该任务项空闲,则继续寻找.
    a590:	8b 02                	mov    (%edx),%eax
    a592:	85 c0                	test   %eax,%eax
    a594:	0f 84 f7 00 00 00    	je     a691 <do_no_page+0x24c>
		if (current == *p)						// 如果是当前任务,也继续寻找.
    a59a:	39 c1                	cmp    %eax,%ecx
    a59c:	0f 84 ef 00 00 00    	je     a691 <do_no_page+0x24c>
		if (address < LIBRARY_OFFSET) {
    a5a2:	81 ff ff ff bf 03    	cmp    $0x3bfffff,%edi
			if (inode != (*p)->executable)		// 进程执行文件i节点.
    a5a8:	8b 34 24             	mov    (%esp),%esi
		if (address < LIBRARY_OFFSET) {
    a5ab:	77 08                	ja     a5b5 <do_no_page+0x170>
			if (inode != (*p)->executable)		// 进程执行文件i节点.
    a5ad:	3b b0 3c 03 00 00    	cmp    0x33c(%eax),%esi
    a5b3:	eb 06                	jmp    a5bb <do_no_page+0x176>
			if (inode != (*p)->library)			// 进程使用库文件i节点.
    a5b5:	3b b0 40 03 00 00    	cmp    0x340(%eax),%esi
    a5bb:	0f 85 d0 00 00 00    	jne    a691 <do_no_page+0x24c>
	from_page += ((p->start_code >> 20) & 0xffc);             		// p进程目录项。
    a5c1:	8b 80 18 02 00 00    	mov    0x218(%eax),%eax
	from = *(unsigned long *) from_page;                    		// p进程目录项内容。
    a5c7:	8b 74 24 10          	mov    0x10(%esp),%esi
	from_page += ((p->start_code >> 20) & 0xffc);             		// p进程目录项。
    a5cb:	c1 e8 14             	shr    $0x14,%eax
    a5ce:	25 fc 0f 00 00       	and    $0xffc,%eax
	from = *(unsigned long *) from_page;                    		// p进程目录项内容。
    a5d3:	8b 2c 30             	mov    (%eax,%esi,1),%ebp
	if (!(from & 1))
    a5d6:	f7 c5 01 00 00 00    	test   $0x1,%ebp
    a5dc:	0f 84 af 00 00 00    	je     a691 <do_no_page+0x24c>
	from &= 0xfffff000;                                     		// 页表地址。
    a5e2:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
	from_page = from + ((address >> 10) & 0xffc);             		// 页表项指针。
    a5e8:	0b 6c 24 14          	or     0x14(%esp),%ebp
	phys_addr = *(unsigned long *) from_page;               		// 页表项内容。
    a5ec:	8b 75 00             	mov    0x0(%ebp),%esi
	if ((phys_addr & 0x41) != 0x01)
    a5ef:	89 f0                	mov    %esi,%eax
    a5f1:	83 e0 41             	and    $0x41,%eax
    a5f4:	48                   	dec    %eax
    a5f5:	0f 85 96 00 00 00    	jne    a691 <do_no_page+0x24c>
	phys_addr &= 0xfffff000;                                		// 物理页面地址。
    a5fb:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
	if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
    a601:	3b 74 24 1c          	cmp    0x1c(%esp),%esi
    a605:	0f 83 86 00 00 00    	jae    a691 <do_no_page+0x24c>
    a60b:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
    a611:	76 7e                	jbe    a691 <do_no_page+0x24c>
	to_page += ((current->start_code >> 20) & 0xffc);         		// 当前进程目录项。
    a613:	8b 54 24 08          	mov    0x8(%esp),%edx
    a617:	c1 ea 14             	shr    $0x14,%edx
    a61a:	81 e2 fc 0f 00 00    	and    $0xffc,%edx
    a620:	03 54 24 10          	add    0x10(%esp),%edx
	to = *(unsigned long *) to_page;                        		// 当前进程目录项内容。
    a624:	8b 3a                	mov    (%edx),%edi
	if (!(to & 1))
    a626:	f7 c7 01 00 00 00    	test   $0x1,%edi
    a62c:	75 1d                	jne    a64b <do_no_page+0x206>
    a62e:	89 14 24             	mov    %edx,(%esp)
		if (to = get_free_page())
    a631:	e8 cf 04 00 00       	call   ab05 <get_free_page>
    a636:	85 c0                	test   %eax,%eax
    a638:	89 c7                	mov    %eax,%edi
    a63a:	74 0a                	je     a646 <do_no_page+0x201>
			*(unsigned long *) to_page = to | 7;
    a63c:	8b 14 24             	mov    (%esp),%edx
    a63f:	83 c8 07             	or     $0x7,%eax
    a642:	89 02                	mov    %eax,(%edx)
    a644:	eb 05                	jmp    a64b <do_no_page+0x206>
			oom();
    a646:	e8 dc f8 ff ff       	call   9f27 <oom>
	to &= 0xfffff000;                                       		// 当前进程的页表地址。
    a64b:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
	to_page = to + ((address >> 10) & 0xffc);                 		// 当前进程的页表项地址。
    a651:	0b 7c 24 14          	or     0x14(%esp),%edi
	if (1 & *(unsigned long *) to_page)
    a655:	f6 07 01             	testb  $0x1,(%edi)
    a658:	74 12                	je     a66c <do_no_page+0x227>
		panic("try_to_share: to_page already exists");
    a65a:	8d 83 87 6f ff ff    	lea    -0x9079(%ebx),%eax
    a660:	83 ec 0c             	sub    $0xc,%esp
    a663:	50                   	push   %eax
    a664:	e8 69 da ff ff       	call   80d2 <panic>
    a669:	83 c4 10             	add    $0x10,%esp
	*(unsigned long *) from_page &= ~2;
    a66c:	8b 45 00             	mov    0x0(%ebp),%eax
    a66f:	83 e0 fd             	and    $0xfffffffd,%eax
    a672:	89 45 00             	mov    %eax,0x0(%ebp)
	*(unsigned long *) to_page = *(unsigned long *) from_page;
    a675:	89 07                	mov    %eax,(%edi)
	invalidate();
    a677:	31 c0                	xor    %eax,%eax
    a679:	0f 22 d8             	mov    %eax,%cr3
	phys_addr -= LOW_MEM;
    a67c:	81 ee 00 00 10 00    	sub    $0x100000,%esi
	phys_addr >>= 12;                       						// 得页面号。
    a682:	c1 ee 0c             	shr    $0xc,%esi
	mem_map[phys_addr]++;
    a685:	fe 84 33 e0 21 00 00 	incb   0x21e0(%ebx,%esi,1)
    a68c:	e9 a5 00 00 00       	jmp    a736 <do_no_page+0x2f1>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    a691:	83 ea 04             	sub    $0x4,%edx
    a694:	3b 54 24 18          	cmp    0x18(%esp),%edx
    a698:	0f 87 f2 fe ff ff    	ja     a590 <do_no_page+0x14b>
	}
	// 否则说明所缺页面进程执行文件或库文件范围内,于是就尝试共享页面操作,若成功则退出.
	if (share_page(inode, tmp))											// 尝试逻辑地址tmp处页面的共享.
		return;
	// 如果共享不成功就只能申请一页物理内存页面page,然后从设备上读取执行文件中的相应页面并放置(映射)到进程页面逻辑地址tmp处.
	if (!(page = get_free_page()))										// 申请一页物理内存.
    a69e:	e8 62 04 00 00       	call   ab05 <get_free_page>
    a6a3:	85 c0                	test   %eax,%eax
    a6a5:	89 c6                	mov    %eax,%esi
    a6a7:	75 05                	jne    a6ae <do_no_page+0x269>
		oom();
    a6a9:	e8 79 f8 ff ff       	call   9f27 <oom>
	for (p = &LAST_TASK ; p > &FIRST_TASK ; --p) {
    a6ae:	31 ed                	xor    %ebp,%ebp
	/* remember that 1 block is used for header */
	/* 记住,(程序)头要使用1个数据块 */
	// 根据这个块号和执行文件的i节点,我们就可以从映射位图中找到对应块设备中对应的设备逻辑块号(保存在nr[]数组中).利用break_page()
	// 即可把这4个逻辑块读入到物理页面page中.
	for (i = 0 ; i < 4 ; block++, i++)
		nr[i] = bmap(inode, block);
    a6b0:	52                   	push   %edx
    a6b1:	52                   	push   %edx
    a6b2:	8b 44 24 14          	mov    0x14(%esp),%eax
    a6b6:	01 e8                	add    %ebp,%eax
    a6b8:	50                   	push   %eax
    a6b9:	ff 74 24 0c          	pushl  0xc(%esp)
    a6bd:	e8 4a 13 00 00       	call   ba0c <bmap>
    a6c2:	8d 4c 24 30          	lea    0x30(%esp),%ecx
	for (i = 0 ; i < 4 ; block++, i++)
    a6c6:	83 c4 10             	add    $0x10,%esp
		nr[i] = bmap(inode, block);
    a6c9:	89 04 a9             	mov    %eax,(%ecx,%ebp,4)
	for (i = 0 ; i < 4 ; block++, i++)
    a6cc:	45                   	inc    %ebp
    a6cd:	83 fd 04             	cmp    $0x4,%ebp
    a6d0:	75 de                	jne    a6b0 <do_no_page+0x26b>
	bread_page(page, inode->i_dev, nr);
    a6d2:	50                   	push   %eax
    a6d3:	51                   	push   %ecx
    a6d4:	8b 44 24 08          	mov    0x8(%esp),%eax
    a6d8:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    a6dc:	50                   	push   %eax
    a6dd:	56                   	push   %esi
    a6de:	e8 39 1d 00 00       	call   c41c <bread_page>
	// 在读设备逻辑块操作时,可能会出现这样一种情况,即在执行文件中的读取页面位置可能离文件尾不到1个页面的长度.因此就可能读入一些无用
	// 的信息.下面的操作就是把这部分超出执行文件end_data以后的部分进行清零处理.当然,若该页面离末端超过1页,说明不是从执行文件映像中
	// 读取的页面,而是从库文件中读取的,因此不用执行清零操作.
	i = tmp + 4096 - current->end_data;									// 超出的字节长度值.
    a6e3:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	if (i > 4095)														// 离末端超过1页则不用清零.
    a6e9:	83 c4 10             	add    $0x10,%esp
	i = tmp + 4096 - current->end_data;									// 超出的字节长度值.
    a6ec:	8b 00                	mov    (%eax),%eax
    a6ee:	2b b8 20 02 00 00    	sub    0x220(%eax),%edi
    a6f4:	8d 87 00 10 00 00    	lea    0x1000(%edi),%eax
	if (i > 4095)														// 离末端超过1页则不用清零.
    a6fa:	3d ff 0f 00 00       	cmp    $0xfff,%eax
    a6ff:	7e 02                	jle    a703 <do_no_page+0x2be>
		i = 0;
    a701:	31 c0                	xor    %eax,%eax
	tmp = page + 4096;
	while (i-- > 0) {
		tmp--;															// tmp指向页面末端.
		*(char *)tmp = 0;       										// 页面末端i字节清零.
    a703:	8d 96 ff 0f 00 00    	lea    0xfff(%esi),%edx
    a709:	29 c2                	sub    %eax,%edx
	while (i-- > 0) {
    a70b:	85 c0                	test   %eax,%eax
    a70d:	7e 07                	jle    a716 <do_no_page+0x2d1>
		*(char *)tmp = 0;       										// 页面末端i字节清零.
    a70f:	c6 04 02 00          	movb   $0x0,(%edx,%eax,1)
    a713:	48                   	dec    %eax
    a714:	eb f5                	jmp    a70b <do_no_page+0x2c6>
	}
	// 最后把引起缺页异常的一页物理页面映射到指定线性地址address处.若操作成功就返回.否则就释放内存页,显示内存不够.
	if (put_page(page, address))
    a716:	8b 54 24 04          	mov    0x4(%esp),%edx
    a71a:	89 f0                	mov    %esi,%eax
    a71c:	e8 65 f7 ff ff       	call   9e86 <put_page>
    a721:	85 c0                	test   %eax,%eax
    a723:	75 11                	jne    a736 <do_no_page+0x2f1>
		return;
	free_page(page);
    a725:	83 ec 0c             	sub    $0xc,%esp
    a728:	56                   	push   %esi
    a729:	e8 25 f8 ff ff       	call   9f53 <free_page>
	oom();
    a72e:	e8 f4 f7 ff ff       	call   9f27 <oom>
    a733:	83 c4 10             	add    $0x10,%esp
}
    a736:	83 c4 3c             	add    $0x3c,%esp
    a739:	5b                   	pop    %ebx
    a73a:	5e                   	pop    %esi
    a73b:	5f                   	pop    %edi
    a73c:	5d                   	pop    %ebp
    a73d:	c3                   	ret    

0000a73e <mem_init>:
// 不用.对于具有16MB内存的PC系统,在没有设置虚拟盘RAMDISK的情况下,共有3072个物理页面可供分配.而范围0~1MB内存空间用于内核系统(其实内核
// 只使用0~640KB,剩下的部分被部分高速缓冲和设备内存占用).
// 参数start_mem是可用作页面分配的主内存区起始地址(已去除RAMDISK所占内存空间).end_mem是实际物理内存最大地址.而地址范围start_mem到
// end_mem是主内存区.
void mem_init(long start_mem, long end_mem)
{
    a73e:	56                   	push   %esi
    a73f:	53                   	push   %ebx
	int i;

	// 首先将1MB到16MB范围内所有内存页面对应的内存映射字节数组项置为已占用状态,即各项字节值全部设置成USED(100).PAGING_PAGES被定义为(
	// PAGING_MEMORY>>12),即1MB以上所有物理内存分页后的内存页面数(15MB/4KB = 3840).
	HIGH_MEMORY = end_mem;									// 设置内存最高端(16MB).
	for (i = 0; i < PAGING_PAGES; i++)
    a740:	31 d2                	xor    %edx,%edx
{
    a742:	8b 44 24 10          	mov    0x10(%esp),%eax
    a746:	8b 74 24 0c          	mov    0xc(%esp),%esi
    a74a:	e8 dd c2 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a74f:	81 c3 b1 68 01 00    	add    $0x168b1,%ebx
	HIGH_MEMORY = end_mem;									// 设置内存最高端(16MB).
    a755:	89 83 e0 30 00 00    	mov    %eax,0x30e0(%ebx)
		mem_map[i] = USED;
    a75b:	c6 84 1a e0 21 00 00 	movb   $0x64,0x21e0(%edx,%ebx,1)
    a762:	64 
	for (i = 0; i < PAGING_PAGES; i++)
    a763:	42                   	inc    %edx
    a764:	81 fa 00 0f 00 00    	cmp    $0xf00,%edx
    a76a:	75 ef                	jne    a75b <mem_init+0x1d>
	// 然后计算主内存区起始内存start_mem处页面对应内存映射字节数组中项号i和主内存区页面数.此时mem_map[]数组的第i项正对应主内存区中第1个页面.
	// 最后将主内存区中页面对应的数组项清零(表示空闲).对于具有16MB物理内存的系统,mem_map[]中对应4MB~16MB主内存区的项被清零.
	i = MAP_NR(start_mem);									// 主内存区起始位置处页面号.
    a76c:	8d 8e 00 00 f0 ff    	lea    -0x100000(%esi),%ecx
	end_mem -= start_mem;
    a772:	29 f0                	sub    %esi,%eax
	// 得到主内存区的页面的数量
	end_mem >>= 12;											// 主内存区中的总页面数.
	// 将主内存区对应的页面数的应用数置零
	while (end_mem-- > 0)
    a774:	31 d2                	xor    %edx,%edx
	end_mem >>= 12;											// 主内存区中的总页面数.
    a776:	c1 f8 0c             	sar    $0xc,%eax
	i = MAP_NR(start_mem);									// 主内存区起始位置处页面号.
    a779:	c1 f9 0c             	sar    $0xc,%ecx
		mem_map[i++] = 0;									// 主内存区页面对应字节值清零.
    a77c:	8d 9c 0b e0 21 00 00 	lea    0x21e0(%ebx,%ecx,1),%ebx
    a783:	89 c1                	mov    %eax,%ecx
    a785:	29 d1                	sub    %edx,%ecx
	while (end_mem-- > 0)
    a787:	85 c9                	test   %ecx,%ecx
    a789:	7e 07                	jle    a792 <mem_init+0x54>
		mem_map[i++] = 0;									// 主内存区页面对应字节值清零.
    a78b:	c6 04 13 00          	movb   $0x0,(%ebx,%edx,1)
    a78f:	42                   	inc    %edx
    a790:	eb f1                	jmp    a783 <mem_init+0x45>
}
    a792:	5b                   	pop    %ebx
    a793:	5e                   	pop    %esi
    a794:	c3                   	ret    

0000a795 <show_mem>:
// 显示系统内存信息.
// 根据内存映射字节数组mem_map[]中的信息以及页目录和页表内容统计系统中使用的内存页面数和主内存区中总物理内存页面数.该函数在chr_drv/keyboard.S程序
// 被调用.
// 即当按下"Shift + Scroll Lock"组合键时会显示系统内存统计信息.
void show_mem(void)
{
    a795:	55                   	push   %ebp
    a796:	57                   	push   %edi
    a797:	56                   	push   %esi
    a798:	53                   	push   %ebx
	int i, j, k, free = 0, total = 0;
    a799:	31 f6                	xor    %esi,%esi
    a79b:	e8 8c c2 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a7a0:	81 c3 60 68 01 00    	add    $0x16860,%ebx
{
    a7a6:	83 ec 38             	sub    $0x38,%esp
	int shared = 0;
	unsigned long * pg_tbl;

	// 根据内存映射字节数组mem_map[],统计系统主内存区页面总数total,以及其中空闲页面数free和被共享的页面数shared.并显示这些信息.
	printk("Mem-info:\n\r");
    a7a9:	8d 83 ac 6f ff ff    	lea    -0x9054(%ebx),%eax
    a7af:	50                   	push   %eax
    a7b0:	e8 6c d9 ff ff       	call   8121 <printk>
    a7b5:	83 c4 10             	add    $0x10,%esp
	int shared = 0;
    a7b8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    a7bf:	00 
	int i, j, k, free = 0, total = 0;
    a7c0:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    a7c7:	00 
	for(i = 0 ; i < PAGING_PAGES ; i++) {
    a7c8:	31 d2                	xor    %edx,%edx
		if (mem_map[i] == USED)								// 1MB以上内存系统占用的页面.
    a7ca:	0f b6 84 1a e0 21 00 	movzbl 0x21e0(%edx,%ebx,1),%eax
    a7d1:	00 
    a7d2:	3c 64                	cmp    $0x64,%al
    a7d4:	74 17                	je     a7ed <show_mem+0x58>
			continue;
		// 统计主内存中的页面数
		total++;
    a7d6:	ff 44 24 10          	incl   0x10(%esp)
		if (!mem_map[i])
    a7da:	84 c0                	test   %al,%al
    a7dc:	75 03                	jne    a7e1 <show_mem+0x4c>
			// 统计未使用的主内存页面数
			free++;											// 主内存区空闲页面统计.
    a7de:	46                   	inc    %esi
    a7df:	eb 0c                	jmp    a7ed <show_mem+0x58>
		else
			// 统计共享页面数
			shared += mem_map[i] - 1;						// 共享的页面数(字节值>1)
    a7e1:	8b 7c 24 0c          	mov    0xc(%esp),%edi
    a7e5:	8d 44 07 ff          	lea    -0x1(%edi,%eax,1),%eax
    a7e9:	89 44 24 0c          	mov    %eax,0xc(%esp)
	for(i = 0 ; i < PAGING_PAGES ; i++) {
    a7ed:	42                   	inc    %edx
    a7ee:	81 fa 00 0f 00 00    	cmp    $0xf00,%edx
    a7f4:	75 d4                	jne    a7ca <show_mem+0x35>
	}
	printk("%d free pages of %d\n\r", free, total);
    a7f6:	8d 83 b8 6f ff ff    	lea    -0x9048(%ebx),%eax
    a7fc:	57                   	push   %edi
    a7fd:	ff 74 24 14          	pushl  0x14(%esp)
    a801:	56                   	push   %esi
	printk("%d pages shared\n\r", shared);
	// 统计处理器分页管理逻辑页面数.页目录表前4项供内核代码使用,不列为统计范围,因此扫描处理的页目录项从第5项开始.方法是循环处理所有页目录项
	// (除前4个项),若对应的二级页表存在,那么先统计二级页表本身占用的内存页面,然后对该页表中所有页表项对应页面情况进行统计.
	k = 0;													// 一个进程占用页面统计值.
    a802:	31 ff                	xor    %edi,%edi
	printk("%d free pages of %d\n\r", free, total);
    a804:	50                   	push   %eax
    a805:	e8 17 d9 ff ff       	call   8121 <printk>
	printk("%d pages shared\n\r", shared);
    a80a:	5d                   	pop    %ebp
    a80b:	58                   	pop    %eax
    a80c:	8d 83 ce 6f ff ff    	lea    -0x9032(%ebx),%eax
    a812:	ff 74 24 14          	pushl  0x14(%esp)
	for(i = 4 ; i < 1024 ;) {
    a816:	bd 04 00 00 00       	mov    $0x4,%ebp
	printk("%d pages shared\n\r", shared);
    a81b:	50                   	push   %eax
    a81c:	e8 00 d9 ff ff       	call   8121 <printk>
		if (1 & pg_dir[i]) {
    a821:	c7 c0 d0 02 00 00    	mov    $0x2d0,%eax
	printk("%d pages shared\n\r", shared);
    a827:	83 c4 10             	add    $0x10,%esp
		if (1 & pg_dir[i]) {
    a82a:	89 44 24 18          	mov    %eax,0x18(%esp)
    a82e:	8b 44 24 18          	mov    0x18(%esp),%eax
    a832:	8b 04 a8             	mov    (%eax,%ebp,4),%eax
    a835:	a8 01                	test   $0x1,%al
    a837:	74 71                	je     a8aa <show_mem+0x115>
			// (如果页目录项对应二级页表地址大于机器最高物理内存地址HIGH_MEMORY,说明该目录项有问题.于是显示该目录项信息并继续处理下一个目录项.
			if (pg_dir[i] > HIGH_MEMORY) {					// 目录项内容不正常.
    a839:	3b 83 e0 30 00 00    	cmp    0x30e0(%ebx),%eax
    a83f:	76 14                	jbe    a855 <show_mem+0xc0>
				printk("page directory[%d]: %08X\n\r",
    a841:	51                   	push   %ecx
    a842:	50                   	push   %eax
    a843:	8d 83 e0 6f ff ff    	lea    -0x9020(%ebx),%eax
    a849:	55                   	push   %ebp
    a84a:	50                   	push   %eax
    a84b:	e8 d1 d8 ff ff       	call   8121 <printk>
					i, pg_dir[i]);
				continue;
    a850:	83 c4 10             	add    $0x10,%esp
    a853:	eb 7e                	jmp    a8d3 <show_mem+0x13e>
			}
			// 如果页目录项对应二级页表的"地址"大于LOW_MEM(即1MB),则把一个进程占用的物理内存页统计值k增1,把系统占用的所有物理内存页统计值free增1.
			// 然后邓对应页表地址pg_tb1,并对该页表中所有页表项进行统计.如果当前页表项所指物理页面存在并且该物理页面"地址"大于LOW_MEME,那么就将页表项对应页面
			// 纳入统计值.
			if (pg_dir[i] > LOW_MEM)
    a855:	3d 00 00 10 00       	cmp    $0x100000,%eax
    a85a:	76 02                	jbe    a85e <show_mem+0xc9>
				free++, k++;								// 统计页表占用页面.
    a85c:	46                   	inc    %esi
    a85d:	47                   	inc    %edi
			pg_tbl = (unsigned long *) (0xfffff000 & pg_dir[i]);
    a85e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
			for(j = 0 ; j < 1024 ; j++)
    a863:	31 c9                	xor    %ecx,%ecx
			pg_tbl = (unsigned long *) (0xfffff000 & pg_dir[i]);
    a865:	89 44 24 14          	mov    %eax,0x14(%esp)
				if ((pg_tbl[j]&1) && pg_tbl[j] > LOW_MEM)
    a869:	8b 44 24 14          	mov    0x14(%esp),%eax
    a86d:	8b 04 88             	mov    (%eax,%ecx,4),%eax
    a870:	3d 00 00 10 00       	cmp    $0x100000,%eax
    a875:	76 2a                	jbe    a8a1 <show_mem+0x10c>
    a877:	a8 01                	test   $0x1,%al
    a879:	74 26                	je     a8a1 <show_mem+0x10c>
					// (若该物理页面地址大于机器最高物理内存地址HIGH_MEMORY,则说明该页表项内容有问题,于是显示该页表项内容.否则将页表项对应页面纳入统计值.)
					if (pg_tbl[j] > HIGH_MEMORY)
    a87b:	3b 83 e0 30 00 00    	cmp    0x30e0(%ebx),%eax
    a881:	76 1c                	jbe    a89f <show_mem+0x10a>
						printk("page_dir[%d][%d]: %08X\n\r",
    a883:	50                   	push   %eax
    a884:	8d 83 fb 6f ff ff    	lea    -0x9005(%ebx),%eax
    a88a:	51                   	push   %ecx
    a88b:	89 4c 24 24          	mov    %ecx,0x24(%esp)
    a88f:	55                   	push   %ebp
    a890:	50                   	push   %eax
    a891:	e8 8b d8 ff ff       	call   8121 <printk>
    a896:	83 c4 10             	add    $0x10,%esp
    a899:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    a89d:	eb 02                	jmp    a8a1 <show_mem+0x10c>
							i, j, pg_tbl[j]);
					else
						k++, free++;						// 统计责表项对应页面.
    a89f:	47                   	inc    %edi
    a8a0:	46                   	inc    %esi
			for(j = 0 ; j < 1024 ; j++)
    a8a1:	41                   	inc    %ecx
    a8a2:	81 f9 00 04 00 00    	cmp    $0x400,%ecx
    a8a8:	75 bf                	jne    a869 <show_mem+0xd4>
		}
		// 因每个任务线性空间长度是64MB,所以一个任务占用16个目录项.因此这每统计了16个目录项就把进程的任务结构占用的页表统计进来.若此时k=0则表示当前的16个页
		// 目录所对应的进程在系统中不存在(没有创建或者已经终止).在显示了对应进程号和其占用的物理内存页统计值k后,将k清零,以用于统计下一个进程占用的内存页面数.
		i++;
    a8aa:	45                   	inc    %ebp
		if (!(i & 15) && k) {
    a8ab:	f7 c5 0f 00 00 00    	test   $0xf,%ebp
    a8b1:	75 20                	jne    a8d3 <show_mem+0x13e>
    a8b3:	85 ff                	test   %edi,%edi
    a8b5:	74 1c                	je     a8d3 <show_mem+0x13e>
			k++, free++;									/* one page/process for task_struct */
			printk("Process %d: %d pages\n\r", (i >> 4) - 1, k);
    a8b7:	89 e8                	mov    %ebp,%eax
			k++, free++;									/* one page/process for task_struct */
    a8b9:	47                   	inc    %edi
			printk("Process %d: %d pages\n\r", (i >> 4) - 1, k);
    a8ba:	52                   	push   %edx
    a8bb:	c1 f8 04             	sar    $0x4,%eax
    a8be:	57                   	push   %edi
			k++, free++;									/* one page/process for task_struct */
    a8bf:	46                   	inc    %esi
			printk("Process %d: %d pages\n\r", (i >> 4) - 1, k);
    a8c0:	48                   	dec    %eax
			k = 0;
    a8c1:	31 ff                	xor    %edi,%edi
			printk("Process %d: %d pages\n\r", (i >> 4) - 1, k);
    a8c3:	50                   	push   %eax
    a8c4:	8d 83 14 70 ff ff    	lea    -0x8fec(%ebx),%eax
    a8ca:	50                   	push   %eax
    a8cb:	e8 51 d8 ff ff       	call   8121 <printk>
    a8d0:	83 c4 10             	add    $0x10,%esp
	for(i = 4 ; i < 1024 ;) {
    a8d3:	81 fd 00 04 00 00    	cmp    $0x400,%ebp
    a8d9:	0f 85 4f ff ff ff    	jne    a82e <show_mem+0x99>
		}
	}
	// 最后显示系统中正在使用的内存页面和主内存区中总的内存页面数.
	printk("Memory found: %d (%d)\n\r\n\r", free - shared, total);
    a8df:	50                   	push   %eax
    a8e0:	ff 74 24 14          	pushl  0x14(%esp)
    a8e4:	8d 83 2b 70 ff ff    	lea    -0x8fd5(%ebx),%eax
    a8ea:	2b 74 24 14          	sub    0x14(%esp),%esi
    a8ee:	56                   	push   %esi
    a8ef:	50                   	push   %eax
    a8f0:	e8 2c d8 ff ff       	call   8121 <printk>
}
    a8f5:	83 c4 3c             	add    $0x3c,%esp
    a8f8:	5b                   	pop    %ebx
    a8f9:	5e                   	pop    %esi
    a8fa:	5f                   	pop    %edi
    a8fb:	5d                   	pop    %ebp
    a8fc:	c3                   	ret    

0000a8fd <swap_free>:

// 释放交换设备中指定的交换页面.
// 在交换位图中设置指定页面号对应的位(置1).若原来该位就等于1,则表示交换设备中原来该页面就没有被占用,或者位图出错.于是显示出错信息并返回.
// 参数指定交换页面号.
void swap_free(int swap_nr)
{
    a8fd:	53                   	push   %ebx
    a8fe:	e8 29 c1 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a903:	81 c3 fd 66 01 00    	add    $0x166fd,%ebx
    a909:	83 ec 08             	sub    $0x8,%esp
    a90c:	8b 44 24 10          	mov    0x10(%esp),%eax
	if (!swap_nr)
    a910:	85 c0                	test   %eax,%eax
    a912:	74 2f                	je     a943 <swap_free+0x46>
		return;
	if (swap_bitmap && swap_nr < SWAP_BITS)
    a914:	8b 8b e8 30 00 00    	mov    0x30e8(%ebx),%ecx
    a91a:	85 c9                	test   %ecx,%ecx
    a91c:	74 13                	je     a931 <swap_free+0x34>
    a91e:	3d ff 7f 00 00       	cmp    $0x7fff,%eax
    a923:	7f 0c                	jg     a931 <swap_free+0x34>
bitop(setbit, "s")							// 定义内嵌函数setbit(char * addr, unsigned int nr).
    a925:	31 d2                	xor    %edx,%edx
    a927:	0f ab 01             	bts    %eax,(%ecx)
    a92a:	83 d2 00             	adc    $0x0,%edx
		if (!setbit(swap_bitmap, swap_nr))
    a92d:	85 d2                	test   %edx,%edx
    a92f:	74 12                	je     a943 <swap_free+0x46>
			return;
	printk("Swap-space bad (swap_free())\n\r");
    a931:	8d 83 45 70 ff ff    	lea    -0x8fbb(%ebx),%eax
    a937:	83 ec 0c             	sub    $0xc,%esp
    a93a:	50                   	push   %eax
    a93b:	e8 e1 d7 ff ff       	call   8121 <printk>
	return;
    a940:	83 c4 10             	add    $0x10,%esp
}
    a943:	83 c4 08             	add    $0x8,%esp
    a946:	5b                   	pop    %ebx
    a947:	c3                   	ret    

0000a948 <try_to_swap_out>:

// 尝试把页面交换出去.
// 若页面没有被修改过则不必保存在交换设备中,因为对应页面还可以再直接从相应映像文件中读入.于是可以直接释放掉相应物理页面了事.否则就申请一个交换页面号,然后
// 把页面交换出去.此时交换页面号要保存在对应页表项中,并且仍需要保持页表项存在位P=0.参数是页表项指针.页面换或释放成功返回1,否则返回0.
int try_to_swap_out(unsigned long * table_ptr)
{
    a948:	57                   	push   %edi
    a949:	56                   	push   %esi

	// 首先判断参数的有效性.若需要交换出去的内存页面并不存在(或称无效),则即可退出.若页表项指定的物理页面地址大于分页管理的内存高端PAGING_MEMORY(15MB),
	// 也退出.
	page = *table_ptr;
	if (!(PAGE_PRESENT & page))
		return 0;
    a94a:	31 c0                	xor    %eax,%eax
{
    a94c:	53                   	push   %ebx
    a94d:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    a951:	e8 d6 c0 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    a956:	81 c3 aa 66 01 00    	add    $0x166aa,%ebx
	page = *table_ptr;
    a95c:	8b 11                	mov    (%ecx),%edx
	if (!(PAGE_PRESENT & page))
    a95e:	f6 c2 01             	test   $0x1,%dl
    a961:	0f 84 92 00 00 00    	je     a9f9 <try_to_swap_out+0xb1>
	if (page - LOW_MEM > PAGING_MEMORY)
    a967:	8d b2 00 00 f0 ff    	lea    -0x100000(%edx),%esi
    a96d:	81 fe 00 00 f0 00    	cmp    $0xf00000,%esi
    a973:	0f 87 80 00 00 00    	ja     a9f9 <try_to_swap_out+0xb1>
		return 0;
	// 若内存页面已被修改过,但是该页面是被共享的,那么为了提高运行效率,此类页面不宜被交换出去,于是直接退出,函数返回0.否则就申请一交换页面号,并把它保存在页表
	// 项中,然后把页面交换出去并释放对应物理内存页面.
	if (PAGE_DIRTY & page) {
    a979:	f6 c2 40             	test   $0x40,%dl
    a97c:	74 43                	je     a9c1 <try_to_swap_out+0x79>
		page &= 0xfffff000;									// 取物理页面地址.
    a97e:	89 d6                	mov    %edx,%esi
		if (mem_map[MAP_NR(page)] != 1)
    a980:	c7 c7 e0 31 02 00    	mov    $0x231e0,%edi
		page &= 0xfffff000;									// 取物理页面地址.
    a986:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
		if (mem_map[MAP_NR(page)] != 1)
    a98c:	8d 96 00 00 f0 ff    	lea    -0x100000(%esi),%edx
    a992:	c1 ea 0c             	shr    $0xc,%edx
    a995:	80 3c 17 01          	cmpb   $0x1,(%edi,%edx,1)
    a999:	75 5e                	jne    a9f9 <try_to_swap_out+0xb1>
	if (!swap_bitmap)
    a99b:	8b bb e8 30 00 00    	mov    0x30e8(%ebx),%edi
    a9a1:	85 ff                	test   %edi,%edi
    a9a3:	74 54                	je     a9f9 <try_to_swap_out+0xb1>
	for (nr = 1; nr < 32768 ; nr++)
    a9a5:	ba 01 00 00 00       	mov    $0x1,%edx
bitop(clrbit, "r")							// 定义内嵌函数clrbit(char * addr, unsigned int nr).
    a9aa:	31 c0                	xor    %eax,%eax
    a9ac:	0f b3 17             	btr    %edx,(%edi)
    a9af:	83 d0 00             	adc    $0x0,%eax
		if (clrbit(swap_bitmap, nr))
    a9b2:	85 c0                	test   %eax,%eax
    a9b4:	75 1a                	jne    a9d0 <try_to_swap_out+0x88>
	for (nr = 1; nr < 32768 ; nr++)
    a9b6:	42                   	inc    %edx
    a9b7:	81 fa 00 80 00 00    	cmp    $0x8000,%edx
    a9bd:	75 eb                	jne    a9aa <try_to_swap_out+0x62>
    a9bf:	eb 38                	jmp    a9f9 <try_to_swap_out+0xb1>
		write_swap_page(swap_nr, (char *) page);
		free_page(page);
		return 1;
	}
	// 否则表明页面没有修改过.那么就不用交换出去,而直接释放即可.
	*table_ptr = 0;
    a9c1:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	invalidate();
    a9c7:	0f 22 d8             	mov    %eax,%cr3
	free_page(page);
    a9ca:	83 ec 0c             	sub    $0xc,%esp
    a9cd:	52                   	push   %edx
    a9ce:	eb 1c                	jmp    a9ec <try_to_swap_out+0xa4>
		*table_ptr = swap_nr << 1;
    a9d0:	8d 04 12             	lea    (%edx,%edx,1),%eax
    a9d3:	89 01                	mov    %eax,(%ecx)
		invalidate();										// 刷新CPU页变换高速缓冲.
    a9d5:	31 c0                	xor    %eax,%eax
    a9d7:	0f 22 d8             	mov    %eax,%cr3
		write_swap_page(swap_nr, (char *) page);
    a9da:	56                   	push   %esi
    a9db:	52                   	push   %edx
    a9dc:	ff b3 e4 30 00 00    	pushl  0x30e4(%ebx)
    a9e2:	6a 01                	push   $0x1
    a9e4:	e8 40 5e 00 00       	call   10829 <ll_rw_page>
		free_page(page);
    a9e9:	89 34 24             	mov    %esi,(%esp)
    a9ec:	e8 62 f5 ff ff       	call   9f53 <free_page>
		return 1;
    a9f1:	83 c4 10             	add    $0x10,%esp
    a9f4:	b8 01 00 00 00       	mov    $0x1,%eax
	return 1;
}
    a9f9:	5b                   	pop    %ebx
    a9fa:	5e                   	pop    %esi
    a9fb:	5f                   	pop    %edi
    a9fc:	c3                   	ret    

0000a9fd <swap_out>:
 */
// 把内存页面放到交换设备中.
// 从线性地址64MB对应的目录项(FIRST_VM_PAGE>>10)开始,搜索整个4GB线性空间,对有效页目录二级页表指定的物理内存页面执行交换
// 到交换设备中去的尝试.一旦成功地交换出一个页面,就返回-1.否则返回0.该函数会在get_free_page()中被调用.
int swap_out(void)
{
    a9fd:	55                   	push   %ebp
    a9fe:	57                   	push   %edi
    a9ff:	31 d2                	xor    %edx,%edx
    aa01:	56                   	push   %esi
    aa02:	53                   	push   %ebx
	static int dir_entry = FIRST_VM_PAGE >> 10;	// 即任务1的第1个目录项索引.
	static int page_entry = -1;
	int counter = VM_PAGES;						// 表示除去任务0以外的其他任务的所有页数目
    aa03:	be 00 c0 0f 00       	mov    $0xfc000,%esi
    aa08:	e8 1f c0 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    aa0d:	81 c3 f3 65 01 00    	add    $0x165f3,%ebx
{
    aa13:	83 ec 0c             	sub    $0xc,%esp
    aa16:	8b 83 68 13 00 00    	mov    0x1368(%ebx),%eax
	int pg_table;

	// 首先搜索页目录表,查找二级页表存在的页目录项pg_table.找到则退出循环,否则高速页目录项数对应剩余二级页表项数counter,然后继续
	// 检测下一项目录项.若全部搜索完还没有找到适合的(存在的)页目录项,就重新搜索.
	while (counter > 0) {
		pg_table = pg_dir[dir_entry];			// 页目录项内容.
    aa1c:	c7 c5 d0 02 00 00    	mov    $0x2d0,%ebp
    aa22:	8b 7c 85 00          	mov    0x0(%ebp,%eax,4),%edi
		if (pg_table & 1)
    aa26:	f7 c7 01 00 00 00    	test   $0x1,%edi
    aa2c:	74 06                	je     aa34 <swap_out+0x37>
    aa2e:	84 d2                	test   %dl,%dl
    aa30:	74 21                	je     aa53 <swap_out+0x56>
    aa32:	eb 19                	jmp    aa4d <swap_out+0x50>
			break;
		counter -= 1024;						// 1个页表对应1024个页帧
		dir_entry++;							// 下一目录项.
    aa34:	40                   	inc    %eax
		counter -= 1024;						// 1个页表对应1024个页帧
    aa35:	81 ee 00 04 00 00    	sub    $0x400,%esi
		// 如果整个4GB的1024个页目录项检查完了则又回到第1个任务重新开始检查
		if (dir_entry >= 1024)
    aa3b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    aa40:	7e 05                	jle    aa47 <swap_out+0x4a>
			dir_entry = FIRST_VM_PAGE >> 10;
    aa42:	b8 10 00 00 00       	mov    $0x10,%eax
	while (counter > 0) {
    aa47:	85 f6                	test   %esi,%esi
    aa49:	b2 01                	mov    $0x1,%dl
    aa4b:	75 d5                	jne    aa22 <swap_out+0x25>
    aa4d:	89 83 68 13 00 00    	mov    %eax,0x1368(%ebx)
	}
	// 在取得当前目录项的页表指针后,针对该页表中的所有1024个页面,逐一调用交换函数try_to_swap_out()尝试交换出去.一旦某个页面成功交换到交换设备
	// 中就返回1.若对所有目录项的所有页表都已尝试失败,则显示"交换内存用完"的警告,并返回0.
	pg_table &= 0xfffff000;						// 页表指针(地址)(页对齐)
    aa53:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
	while (counter-- > 0) {
    aa59:	85 f6                	test   %esi,%esi
    aa5b:	8d 56 ff             	lea    -0x1(%esi),%edx
    aa5e:	0f 8e 85 00 00 00    	jle    aae9 <swap_out+0xec>
		page_entry++;
    aa64:	8b 83 64 13 00 00    	mov    0x1364(%ebx),%eax
    aa6a:	40                   	inc    %eax
		// 如果已经尝试处理完当前页表所有项还没有能够成功地交换出一个页面,即此时页表项索引大于等于1024,则如同前面第135-143行执行相同的处理来选出一个
		// 二级页表存在的页目录项,并取得相应二级页表指针.
		if (page_entry >= 1024) {
    aa6b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    aa70:	7f 0a                	jg     aa7c <swap_out+0x7f>
		page_entry++;
    aa72:	89 83 64 13 00 00    	mov    %eax,0x1364(%ebx)
	while (counter-- > 0) {
    aa78:	89 d6                	mov    %edx,%esi
    aa7a:	eb 49                	jmp    aac5 <swap_out+0xc8>
    aa7c:	8b 83 68 13 00 00    	mov    0x1368(%ebx),%eax
			page_entry = 0;
    aa82:	c7 83 64 13 00 00 00 	movl   $0x0,0x1364(%ebx)
    aa89:	00 00 00 
	while (counter-- > 0) {
    aa8c:	89 d6                	mov    %edx,%esi
		repeat:
			dir_entry++;
    aa8e:	40                   	inc    %eax
			if (dir_entry >= 1024)
    aa8f:	3d ff 03 00 00       	cmp    $0x3ff,%eax
    aa94:	7e 05                	jle    aa9b <swap_out+0x9e>
				dir_entry = FIRST_VM_PAGE >> 10;
    aa96:	b8 10 00 00 00       	mov    $0x10,%eax
			pg_table = pg_dir[dir_entry];		// 页目录项内容.
    aa9b:	8b 7c 85 00          	mov    0x0(%ebp,%eax,4),%edi
			if (!(pg_table & 1))
    aa9f:	f7 c7 01 00 00 00    	test   $0x1,%edi
    aaa5:	75 12                	jne    aab9 <swap_out+0xbc>
				if ((counter -= 1024) > 0)
    aaa7:	81 ee 00 04 00 00    	sub    $0x400,%esi
    aaad:	85 f6                	test   %esi,%esi
    aaaf:	7f dd                	jg     aa8e <swap_out+0x91>
    aab1:	89 83 68 13 00 00    	mov    %eax,0x1368(%ebx)
    aab7:	eb 30                	jmp    aae9 <swap_out+0xec>
    aab9:	89 83 68 13 00 00    	mov    %eax,0x1368(%ebx)
					goto repeat;
				else
					break;
			pg_table &= 0xfffff000;				// 页表指针.
    aabf:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
		}
		if (try_to_swap_out(page_entry + (unsigned long *) pg_table))
    aac5:	8b 83 64 13 00 00    	mov    0x1364(%ebx),%eax
    aacb:	83 ec 0c             	sub    $0xc,%esp
    aace:	8d 04 87             	lea    (%edi,%eax,4),%eax
    aad1:	50                   	push   %eax
    aad2:	e8 71 fe ff ff       	call   a948 <try_to_swap_out>
    aad7:	83 c4 10             	add    $0x10,%esp
    aada:	85 c0                	test   %eax,%eax
    aadc:	0f 84 77 ff ff ff    	je     aa59 <swap_out+0x5c>
			return 1;
    aae2:	b8 01 00 00 00       	mov    $0x1,%eax
    aae7:	eb 14                	jmp    aafd <swap_out+0x100>
        }
	printk("Out of swap-memory\n\r");
    aae9:	8d 83 64 70 ff ff    	lea    -0x8f9c(%ebx),%eax
    aaef:	83 ec 0c             	sub    $0xc,%esp
    aaf2:	50                   	push   %eax
    aaf3:	e8 29 d6 ff ff       	call   8121 <printk>
	return 0;
    aaf8:	83 c4 10             	add    $0x10,%esp
    aafb:	31 c0                	xor    %eax,%eax
}
    aafd:	83 c4 0c             	add    $0xc,%esp
    ab00:	5b                   	pop    %ebx
    ab01:	5e                   	pop    %esi
    ab02:	5f                   	pop    %edi
    ab03:	5d                   	pop    %ebp
    ab04:	c3                   	ret    

0000ab05 <get_free_page>:
// 上面%4寄存器实际指向mem_map[]内存字节位图的最后一个字节.本函数从位图末端开始向前扫描所有页面标志(页面总数为PAGING_AGES),若有页面空闲
// (内存位图字节为0)则返回页面地址.注意!本函数只是指出在主内存区的一页空闲物理页面,但并没有映射到某个进程的地址空间中去.后面的put_page()函数
// 即用于把指定页面映射到某个进程的地址空间中.当然对于内核使用本函数并不需要再使用put_page()进行映射,因为内核代码和数据空间(16MB)已经对等
// 地映射到物理地址空间.
unsigned long get_free_page(void)
{
    ab05:	e8 70 f3 ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
    ab0a:	05 f6 64 01 00       	add    $0x164f6,%eax
    ab0f:	57                   	push   %edi
    ab10:	56                   	push   %esi
register unsigned long __res;

// 首先在内存映射字节位图中查找址为0的字节项,然后把对应物理内存页面清零.如果得到的页面地址大于实际物理内存容量则重新寻找.如果没有找到空闲页面则
// 去调用执行交换处理,并重新查找.最后返回空闲物理页面地址.
repeat:
	__asm__(
    ab11:	b9 00 0f 00 00       	mov    $0xf00,%ecx
		"cld"
		:"=a" (__res)
		:"0" (0), "i" (LOW_MEM), "c" (PAGING_PAGES),
		"D" (mem_map + PAGING_PAGES - 1)
		:"dx");
	if (__res >= HIGH_MEMORY)						// 页面地址大于实际内存容量则重新寻找
    ab16:	c7 c6 e0 40 02 00    	mov    $0x240e0,%esi
	__asm__(
    ab1c:	c7 c0 e0 31 02 00    	mov    $0x231e0,%eax
{
    ab22:	53                   	push   %ebx
	__asm__(
    ab23:	31 db                	xor    %ebx,%ebx
    ab25:	8d b8 ff 0e 00 00    	lea    0xeff(%eax),%edi
    ab2b:	89 d8                	mov    %ebx,%eax
    ab2d:	fd                   	std    
    ab2e:	f2 ae                	repnz scas %es:(%edi),%al
    ab30:	75 1e                	jne    ab50 <get_free_page+0x4b>
    ab32:	c6 47 01 01          	movb   $0x1,0x1(%edi)
    ab36:	c1 e1 0c             	shl    $0xc,%ecx
    ab39:	81 c1 00 00 10 00    	add    $0x100000,%ecx
    ab3f:	89 ca                	mov    %ecx,%edx
    ab41:	b9 00 04 00 00       	mov    $0x400,%ecx
    ab46:	8d ba fc 0f 00 00    	lea    0xffc(%edx),%edi
    ab4c:	f3 ab                	rep stos %eax,%es:(%edi)
    ab4e:	89 d0                	mov    %edx,%eax
    ab50:	fc                   	cld    
    ab51:	89 c3                	mov    %eax,%ebx
	if (__res >= HIGH_MEMORY)						// 页面地址大于实际内存容量则重新寻找
    ab53:	8b 06                	mov    (%esi),%eax
    ab55:	39 d8                	cmp    %ebx,%eax
    ab57:	76 fc                	jbe    ab55 <get_free_page+0x50>
		goto repeat;
	if (!__res && swap_out())						// 若没有得到空闲页面则执行交换处理,并重新查找.
    ab59:	85 db                	test   %ebx,%ebx
    ab5b:	75 09                	jne    ab66 <get_free_page+0x61>
    ab5d:	e8 9b fe ff ff       	call   a9fd <swap_out>
    ab62:	85 c0                	test   %eax,%eax
    ab64:	75 ed                	jne    ab53 <get_free_page+0x4e>
		goto repeat;
	return __res;									// 返回空闲物理页面地址.
}
    ab66:	89 d8                	mov    %ebx,%eax
    ab68:	5b                   	pop    %ebx
    ab69:	5e                   	pop    %esi
    ab6a:	5f                   	pop    %edi
    ab6b:	c3                   	ret    

0000ab6c <swap_in>:
{
    ab6c:	55                   	push   %ebp
    ab6d:	57                   	push   %edi
    ab6e:	56                   	push   %esi
    ab6f:	53                   	push   %ebx
    ab70:	e8 b7 be ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ab75:	81 c3 8b 64 01 00    	add    $0x1648b,%ebx
    ab7b:	83 ec 0c             	sub    $0xc,%esp
	if (!swap_bitmap) {
    ab7e:	83 bb e8 30 00 00 00 	cmpl   $0x0,0x30e8(%ebx)
{
    ab85:	8b 6c 24 20          	mov    0x20(%esp),%ebp
	if (!swap_bitmap) {
    ab89:	75 0b                	jne    ab96 <swap_in+0x2a>
		printk("Trying to swap in without swap bit-map");
    ab8b:	83 ec 0c             	sub    $0xc,%esp
    ab8e:	8d 83 79 70 ff ff    	lea    -0x8f87(%ebx),%eax
    ab94:	eb 23                	jmp    abb9 <swap_in+0x4d>
	if (1 & *table_ptr) {
    ab96:	8b 75 00             	mov    0x0(%ebp),%esi
    ab99:	f7 c6 01 00 00 00    	test   $0x1,%esi
    ab9f:	74 0b                	je     abac <swap_in+0x40>
		printk("trying to swap in present page\n\r");
    aba1:	83 ec 0c             	sub    $0xc,%esp
    aba4:	8d 83 a0 70 ff ff    	lea    -0x8f60(%ebx),%eax
    abaa:	eb 0d                	jmp    abb9 <swap_in+0x4d>
	if (!swap_nr) {
    abac:	d1 ee                	shr    %esi
    abae:	75 14                	jne    abc4 <swap_in+0x58>
		printk("No swap page in swap_in\n\r");
    abb0:	8d 83 c1 70 ff ff    	lea    -0x8f3f(%ebx),%eax
    abb6:	83 ec 0c             	sub    $0xc,%esp
    abb9:	50                   	push   %eax
    abba:	e8 62 d5 ff ff       	call   8121 <printk>
		return;
    abbf:	83 c4 10             	add    $0x10,%esp
    abc2:	eb 65                	jmp    ac29 <swap_in+0xbd>
	if (!(page = get_free_page()))
    abc4:	e8 3c ff ff ff       	call   ab05 <get_free_page>
    abc9:	85 c0                	test   %eax,%eax
    abcb:	89 c7                	mov    %eax,%edi
    abcd:	75 1e                	jne    abed <swap_in+0x81>
	printk("out of memory\n\r");
    abcf:	8d 83 f8 6d ff ff    	lea    -0x9208(%ebx),%eax
    abd5:	83 ec 0c             	sub    $0xc,%esp
    abd8:	50                   	push   %eax
    abd9:	e8 43 d5 ff ff       	call   8121 <printk>
	do_exit(SIGSEGV);
    abde:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
    abe5:	e8 00 ea ff ff       	call   95ea <do_exit>
    abea:	83 c4 10             	add    $0x10,%esp
	read_swap_page(swap_nr, (char *) page);
    abed:	57                   	push   %edi
    abee:	56                   	push   %esi
    abef:	ff b3 e4 30 00 00    	pushl  0x30e4(%ebx)
    abf5:	6a 00                	push   $0x0
    abf7:	e8 2d 5c 00 00       	call   10829 <ll_rw_page>
bitop(setbit, "s")							// 定义内嵌函数setbit(char * addr, unsigned int nr).
    abfc:	8b 83 e8 30 00 00    	mov    0x30e8(%ebx),%eax
    ac02:	31 d2                	xor    %edx,%edx
    ac04:	0f ab 30             	bts    %esi,(%eax)
    ac07:	83 d2 00             	adc    $0x0,%edx
	if (setbit(swap_bitmap, swap_nr))
    ac0a:	83 c4 10             	add    $0x10,%esp
    ac0d:	85 d2                	test   %edx,%edx
    ac0f:	74 12                	je     ac23 <swap_in+0xb7>
		printk("swapping in multiply from same page\n\r");
    ac11:	8d 83 db 70 ff ff    	lea    -0x8f25(%ebx),%eax
    ac17:	83 ec 0c             	sub    $0xc,%esp
    ac1a:	50                   	push   %eax
    ac1b:	e8 01 d5 ff ff       	call   8121 <printk>
    ac20:	83 c4 10             	add    $0x10,%esp
	*table_ptr = page | (PAGE_DIRTY | 7);
    ac23:	83 cf 47             	or     $0x47,%edi
    ac26:	89 7d 00             	mov    %edi,0x0(%ebp)
}
    ac29:	83 c4 0c             	add    $0xc,%esp
    ac2c:	5b                   	pop    %ebx
    ac2d:	5e                   	pop    %esi
    ac2e:	5f                   	pop    %edi
    ac2f:	5d                   	pop    %ebp
    ac30:	c3                   	ret    

0000ac31 <init_swapping>:

// 内存交换初始化.
void init_swapping(void)
{
    ac31:	55                   	push   %ebp
    ac32:	57                   	push   %edi
    ac33:	56                   	push   %esi
    ac34:	53                   	push   %ebx
    ac35:	e8 f2 bd ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ac3a:	81 c3 c6 63 01 00    	add    $0x163c6,%ebx
    ac40:	83 ec 1c             	sub    $0x1c,%esp
	// blk_size[]指向指定主设备号的块设备块数数组.该块数数组每一项对应一个设备上所拥有的数据块总数(1块大小=1KB).
	extern int *blk_size[];							// blk_drv/ll_rw_blk.c
	int swap_size, i, j;

	// 如果没有定义交换设备则返回.如果交换设备没有设置块数数组,则显示并返回.
	if (!SWAP_DEV)
    ac43:	8b 83 e4 30 00 00    	mov    0x30e4(%ebx),%eax
    ac49:	85 c0                	test   %eax,%eax
    ac4b:	0f 84 53 01 00 00    	je     ada4 <init_swapping+0x173>
		return;
	if (!blk_size[MAJOR(SWAP_DEV)]) {
    ac51:	c7 c2 20 50 02 00    	mov    $0x25020,%edx
    ac57:	89 c1                	mov    %eax,%ecx
    ac59:	c1 e9 08             	shr    $0x8,%ecx
    ac5c:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
    ac5f:	85 d2                	test   %edx,%edx
    ac61:	75 0b                	jne    ac6e <init_swapping+0x3d>
		printk("Unable to get size of swap device\n\r");
    ac63:	83 ec 0c             	sub    $0xc,%esp
    ac66:	8d 83 01 71 ff ff    	lea    -0x8eff(%ebx),%eax
    ac6c:	eb 36                	jmp    aca4 <init_swapping+0x73>
		return;
	}
	// 取指定交换设备号的交换区数据块总数swap_size.若为0则返回,若总块数小于100块则显示信息"交换设备区太小",然后退出.
	swap_size = blk_size[MAJOR(SWAP_DEV)][MINOR(SWAP_DEV)];
    ac6e:	0f b6 c0             	movzbl %al,%eax
    ac71:	8b 2c 82             	mov    (%edx,%eax,4),%ebp
	if (!swap_size)
    ac74:	85 ed                	test   %ebp,%ebp
    ac76:	0f 84 28 01 00 00    	je     ada4 <init_swapping+0x173>
		return;
	if (swap_size < 100) {
    ac7c:	83 fd 63             	cmp    $0x63,%ebp
    ac7f:	7f 0b                	jg     ac8c <init_swapping+0x5b>
		printk("Swap device too small (%d blocks)\n\r", swap_size);
    ac81:	8d 83 25 71 ff ff    	lea    -0x8edb(%ebx),%eax
    ac87:	52                   	push   %edx
    ac88:	52                   	push   %edx
    ac89:	55                   	push   %ebp
    ac8a:	eb 18                	jmp    aca4 <init_swapping+0x73>
	// 交换数据块总数转换成对应可交换页面总数.该值不能大于SWAP_BITS所能表示的页面数.即交换页面总数不得大于32768.
	swap_size >>= 2;
	if (swap_size > SWAP_BITS)
		swap_size = SWAP_BITS;
	// 然后申请一页物理内存来存放交换页面映射数组swap_bitmap,其中每1比特代表1页交换页面
	swap_bitmap = (char *) get_free_page();
    ac8c:	e8 74 fe ff ff       	call   ab05 <get_free_page>
	if (!swap_bitmap) {
    ac91:	85 c0                	test   %eax,%eax
	swap_bitmap = (char *) get_free_page();
    ac93:	89 83 e8 30 00 00    	mov    %eax,0x30e8(%ebx)
	if (!swap_bitmap) {
    ac99:	75 14                	jne    acaf <init_swapping+0x7e>
		printk("Unable to start swapping: out of memory :-)\n\r");
    ac9b:	8d 83 49 71 ff ff    	lea    -0x8eb7(%ebx),%eax
    aca1:	83 ec 0c             	sub    $0xc,%esp
    aca4:	50                   	push   %eax
    aca5:	e8 77 d4 ff ff       	call   8121 <printk>
    acaa:	e9 f2 00 00 00       	jmp    ada1 <init_swapping+0x170>
		return;
	}
	// read_swap_page(nr,buffer)被定义为ll_rw_page(READ,SWAP_DEV,(nr),(buffer)).这里把交换设备上的页面０读到swap_bitmap页面中.该页面
	//　是交换区管理页面.其中第4086字节开始处含有１０个字符的交换设备特征字符串"SWAP-SPACE".若没有找到该特征字符串,则说明不是一个有效的交换设备.
	// 于是显示信息,释放刚申请的物理页面并退出函数.否则将特征字符串字节清零.
	read_swap_page(0, swap_bitmap);
    acaf:	50                   	push   %eax
    acb0:	6a 00                	push   $0x0
// %0 - eax(__res)返回值,%1 - edi(cs)字符串1指针,%2 - esi(ct)字符串2指针,%3 - ecx(count).
// 返回:如果串1>串2,则返回1;串1=串2,则返回0;串1<串2,则返回-1.
static inline int strncmp(const char * cs, const char * ct, int count)
{
register int __res __asm__("ax");							// __res是寄存器变量(eax).
__asm__(
    acb2:	8d bb 77 71 ff ff    	lea    -0x8e89(%ebx),%edi
    acb8:	ff b3 e4 30 00 00    	pushl  0x30e4(%ebx)
    acbe:	6a 00                	push   $0x0
    acc0:	e8 64 5b 00 00       	call   10829 <ll_rw_page>
	if (strncmp("SWAP-SPACE", swap_bitmap + 4086, 10)) {
    acc5:	8b 93 e8 30 00 00    	mov    0x30e8(%ebx),%edx
    accb:	b9 0a 00 00 00       	mov    $0xa,%ecx
    acd0:	8d 82 f6 0f 00 00    	lea    0xff6(%edx),%eax
    acd6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    acda:	89 c6                	mov    %eax,%esi
    acdc:	83 c4 10             	add    $0x10,%esp
    acdf:	fc                   	cld    
    ace0:	49                   	dec    %ecx
    ace1:	78 08                	js     aceb <init_swapping+0xba>
    ace3:	ac                   	lods   %ds:(%esi),%al
    ace4:	ae                   	scas   %es:(%edi),%al
    ace5:	75 08                	jne    acef <init_swapping+0xbe>
    ace7:	84 c0                	test   %al,%al
    ace9:	75 f5                	jne    ace0 <init_swapping+0xaf>
    aceb:	31 c0                	xor    %eax,%eax
    aced:	eb 09                	jmp    acf8 <init_swapping+0xc7>
    acef:	b8 01 00 00 00       	mov    $0x1,%eax
    acf4:	7c 02                	jl     acf8 <init_swapping+0xc7>
    acf6:	f7 d8                	neg    %eax
    acf8:	85 c0                	test   %eax,%eax
	"3:\tmovl $1, %%eax\n\t"								// eax中置1.
	"jl 4f\n\t"												// 如果前面比较中串2字符<串1字符,则返回1结束.
	"negl %%eax\n"											// 否则eax=-eax,返回负值,结束.
	"4:"
	:"=a" (__res):"D" (cs), "S" (ct), "c" (count):);
return __res;												// 返回比较结果.
    acfa:	89 c6                	mov    %eax,%esi
    acfc:	74 0b                	je     ad09 <init_swapping+0xd8>
		printk("Unable to find swap-space signature\n\r");
    acfe:	83 ec 0c             	sub    $0xc,%esp
    ad01:	8d 83 82 71 ff ff    	lea    -0x8e7e(%ebx),%eax
    ad07:	eb 33                	jmp    ad3c <init_swapping+0x10b>
	swap_size >>= 2;
    ad09:	c1 fd 02             	sar    $0x2,%ebp
    ad0c:	b8 00 80 00 00       	mov    $0x8000,%eax
// 用字符填写指定长度内存块.
// 用字符c填写s指向的内存区域,共填count字节.
// %0 - eax(字符c),%1 - edi(内存地址),%2 - ecx(字节数count).
static inline void * memset(void * s, char c, int count)
{
__asm__(
    ad11:	8d ba f6 0f 00 00    	lea    0xff6(%edx),%edi
    ad17:	81 fd 00 80 00 00    	cmp    $0x8000,%ebp
    ad1d:	0f 4f e8             	cmovg  %eax,%ebp
    ad20:	31 c0                	xor    %eax,%eax
    ad22:	fc                   	cld    
    ad23:	57                   	push   %edi
    ad24:	f3 aa                	rep stos %al,%es:(%edi)
    ad26:	5f                   	pop    %edi
bitop(bit, "")								// 定义内嵌函数bit(char * addr, unsigned int nr).
    ad27:	31 c0                	xor    %eax,%eax
    ad29:	0f a3 32             	bt     %esi,(%edx)
    ad2c:	83 d0 00             	adc    $0x0,%eax
	// 然后检查读入的交换位映射图.应该32768个位全为0,若位图中有置位的位0,则表示位图有问题,于是显示出错信息,释放位图占用的页面并退出函数.为了加快检查速度,
	// 这里首先仅挑选查看位图0和最后一个交换页面对应的位,即swap_size交换页面对应的位,以及随后到SWAP_BITS(32768)位.
	for (i = 0 ; i < SWAP_BITS ; i++) {
		if (i == 1)
			i = swap_size;
		if (bit(swap_bitmap, i)) {
    ad2f:	85 c0                	test   %eax,%eax
    ad31:	74 18                	je     ad4b <init_swapping+0x11a>
			printk("Bad swap-space bit-map\n\r");
    ad33:	8d 83 a8 71 ff ff    	lea    -0x8e58(%ebx),%eax
    ad39:	83 ec 0c             	sub    $0xc,%esp
    ad3c:	50                   	push   %eax
    ad3d:	e8 df d3 ff ff       	call   8121 <printk>
			free_page((long) swap_bitmap);
    ad42:	58                   	pop    %eax
    ad43:	ff b3 e8 30 00 00    	pushl  0x30e8(%ebx)
    ad49:	eb 30                	jmp    ad7b <init_swapping+0x14a>
	for (i = 0 ; i < SWAP_BITS ; i++) {
    ad4b:	46                   	inc    %esi
    ad4c:	81 fe ff 7f 00 00    	cmp    $0x7fff,%esi
    ad52:	7f 08                	jg     ad5c <init_swapping+0x12b>
			i = swap_size;
    ad54:	83 fe 01             	cmp    $0x1,%esi
    ad57:	0f 44 f5             	cmove  %ebp,%esi
    ad5a:	eb cb                	jmp    ad27 <init_swapping+0xf6>
		}
	}
	// 然后再仔细地检测位1到位swap_size所有位是否为0.若存在不是0的位,则表示位图有问题,于是释放位图占用的页面并退出函数.否则显示交换设备工作正常以及交换页面
	// 和交换空间总字节数.
	j = 0;
	for (i = 1 ; i < swap_size ; i++)
    ad5c:	b9 01 00 00 00       	mov    $0x1,%ecx
bitop(bit, "")								// 定义内嵌函数bit(char * addr, unsigned int nr).
    ad61:	31 f6                	xor    %esi,%esi
    ad63:	0f a3 0a             	bt     %ecx,(%edx)
    ad66:	83 d6 00             	adc    $0x0,%esi
		if (bit(swap_bitmap, i))
    ad69:	85 f6                	test   %esi,%esi
    ad6b:	74 01                	je     ad6e <init_swapping+0x13d>
			j++;
    ad6d:	40                   	inc    %eax
	for (i = 1 ; i < swap_size ; i++)
    ad6e:	41                   	inc    %ecx
    ad6f:	39 e9                	cmp    %ebp,%ecx
    ad71:	7c ee                	jl     ad61 <init_swapping+0x130>
	if (!j) {
    ad73:	85 c0                	test   %eax,%eax
    ad75:	75 15                	jne    ad8c <init_swapping+0x15b>
		free_page((long) swap_bitmap);
    ad77:	83 ec 0c             	sub    $0xc,%esp
    ad7a:	52                   	push   %edx
    ad7b:	e8 d3 f1 ff ff       	call   9f53 <free_page>
		swap_bitmap = NULL;
    ad80:	c7 83 e8 30 00 00 00 	movl   $0x0,0x30e8(%ebx)
    ad87:	00 00 00 
    ad8a:	eb 15                	jmp    ada1 <init_swapping+0x170>
		return;
	}
	Log(LOG_INFO_TYPE, "<<<<< Swap device ok: %d pages (%d bytes) swap-space >>>>>\n\r", j, j * 4096);
    ad8c:	89 c2                	mov    %eax,%edx
    ad8e:	c1 e2 0c             	shl    $0xc,%edx
    ad91:	52                   	push   %edx
    ad92:	50                   	push   %eax
    ad93:	8d 83 c1 71 ff ff    	lea    -0x8e3f(%ebx),%eax
    ad99:	50                   	push   %eax
    ad9a:	6a 00                	push   $0x0
    ad9c:	e8 ee c6 00 00       	call   1748f <Log>
    ada1:	83 c4 10             	add    $0x10,%esp
}
    ada4:	83 c4 1c             	add    $0x1c,%esp
    ada7:	5b                   	pop    %ebx
    ada8:	5e                   	pop    %esi
    ada9:	5f                   	pop    %edi
    adaa:	5d                   	pop    %ebp
    adab:	c3                   	ret    

0000adac <page_fault>:
    adac:	87 04 24             	xchg   %eax,(%esp)
    adaf:	51                   	push   %ecx
    adb0:	52                   	push   %edx
    adb1:	1e                   	push   %ds
    adb2:	06                   	push   %es
    adb3:	0f a0                	push   %fs
    adb5:	ba 10 00 00 00       	mov    $0x10,%edx
    adba:	8e da                	mov    %edx,%ds
    adbc:	8e c2                	mov    %edx,%es
    adbe:	8e e2                	mov    %edx,%fs
    adc0:	0f 20 d2             	mov    %cr2,%edx
    adc3:	52                   	push   %edx
    adc4:	50                   	push   %eax
    adc5:	a9 01 00 00 00       	test   $0x1,%eax
    adca:	75 07                	jne    add3 <page_fault+0x27>
    adcc:	e8 74 f6 ff ff       	call   a445 <do_no_page>
    add1:	eb 05                	jmp    add8 <page_fault+0x2c>
    add3:	e8 6b f5 ff ff       	call   a343 <do_wp_page>
    add8:	83 c4 08             	add    $0x8,%esp
    addb:	0f a1                	pop    %fs
    addd:	07                   	pop    %es
    adde:	1f                   	pop    %ds
    addf:	5a                   	pop    %edx
    ade0:	59                   	pop    %ecx
    ade1:	58                   	pop    %eax
    ade2:	cf                   	iret   

0000ade3 <sys_ustat>:
// 调用用于返回已安装（mounted）文件系统的统计信息。成功时返回0，并且ubuf指向的ustate结构被添入文件系统总空闲块
// 和空闲i节点数。ustat结构定义在include/sys/types.h中。
int sys_ustat(int dev, struct ustat * ubuf)
{
	return -ENOSYS;         						// 出错码：功能还未实现。
}
    ade3:	b8 da ff ff ff       	mov    $0xffffffda,%eax
    ade8:	c3                   	ret    

0000ade9 <sys_utime>:
// 设置文件访问和修改时间。
// 参数filename是文件名，times是访问和修改时间结构指针。
// 如果times指针不为NULL，则取utimbuf结构中的时间信息来设置文件的访问和修改时间。
// 如果times指针是NULL，则取系统当前时间来设置指定文件的访问和修改时间域。
int sys_utime(char * filename, struct utimbuf * times)
{
    ade9:	56                   	push   %esi
    adea:	53                   	push   %ebx
    adeb:	e8 3c bc ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    adf0:	81 c3 10 62 01 00    	add    $0x16210,%ebx
    adf6:	83 ec 10             	sub    $0x10,%esp
    adf9:	8b 74 24 20          	mov    0x20(%esp),%esi
	long actime, modtime;

	// 文件的时间信息保存在其i节点中。因此我们首先根据文件名取得对应i节点。如果没有找到，则返回出错码。如果提供的访问
	// 和修改时间结构指针times不为NULL，则从结构中读取用户设置的时间值。否则就用系统当前时间来设置文件的访问和修改时
	// 间。
	if (!(inode = namei(filename)))
    adfd:	ff 74 24 1c          	pushl  0x1c(%esp)
    ae01:	e8 32 3b 00 00       	call   e938 <namei>
    ae06:	89 c1                	mov    %eax,%ecx
    ae08:	83 c4 10             	add    $0x10,%esp
    ae0b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    ae10:	85 c9                	test   %ecx,%ecx
    ae12:	74 48                	je     ae5c <sys_utime+0x73>
		return -ENOENT;
	if (times) {
    ae14:	85 f6                	test   %esi,%esi
    ae16:	74 09                	je     ae21 <sys_utime+0x38>
// 返回:返回内存fs:[addr]处的长字.
static inline unsigned long get_fs_long(const unsigned long *addr)
{
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    ae18:	64 8b 06             	mov    %fs:(%esi),%eax
    ae1b:	64 8b 56 04          	mov    %fs:0x4(%esi),%edx
    ae1f:	eb 23                	jmp    ae44 <sys_utime+0x5b>
		actime = get_fs_long((unsigned long *) &times->actime);
		modtime = get_fs_long((unsigned long *) &times->modtime);
	} else
		actime = modtime = CURRENT_TIME;
    ae21:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    ae27:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    ae2d:	be 64 00 00 00       	mov    $0x64,%esi
    ae32:	8b 00                	mov    (%eax),%eax
    ae34:	03 02                	add    (%edx),%eax
    ae36:	31 d2                	xor    %edx,%edx
    ae38:	f7 f6                	div    %esi
    ae3a:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    ae40:	03 02                	add    (%edx),%eax
    ae42:	89 c2                	mov    %eax,%edx
	// 然后修改i节点中的访问时间字段和修改时间字段。再设置i节点已修改标志，放回该i节点，并返回0。
	inode->i_atime = actime;
	inode->i_mtime = modtime;
	inode->i_dirt = 1;
	iput(inode);
    ae44:	83 ec 0c             	sub    $0xc,%esp
	inode->i_atime = actime;
    ae47:	89 41 28             	mov    %eax,0x28(%ecx)
	inode->i_mtime = modtime;
    ae4a:	89 51 08             	mov    %edx,0x8(%ecx)
	inode->i_dirt = 1;
    ae4d:	c6 41 37 01          	movb   $0x1,0x37(%ecx)
	iput(inode);
    ae51:	51                   	push   %ecx
    ae52:	e8 d1 0c 00 00       	call   bb28 <iput>
    ae57:	83 c4 10             	add    $0x10,%esp
	return 0;
    ae5a:	31 c0                	xor    %eax,%eax
}
    ae5c:	5a                   	pop    %edx
    ae5d:	5b                   	pop    %ebx
    ae5e:	5e                   	pop    %esi
    ae5f:	c3                   	ret    

0000ae60 <sys_access>:
 */
// 检查文件的访问权限。
// 参数filename是文件名，mode是检查的访问属性，它有3个有效位组成：R_OK（值4）、W_OK（2）、X_OK（1）和F_OK（0）
// 组成，分别表示检测文件是否可读、可写、可执行和文件是否存在。如果访问允许的话，则返回0,否则返回出错码。
int sys_access(const char * filename, int mode)
{
    ae60:	55                   	push   %ebp
    ae61:	57                   	push   %edi
    ae62:	56                   	push   %esi
    ae63:	53                   	push   %ebx
    ae64:	e8 c3 bb ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ae69:	81 c3 97 61 01 00    	add    $0x16197,%ebx
    ae6f:	83 ec 28             	sub    $0x28,%esp
	int res, i_mode;

	// 文件的访问权限信息同样保存在文件的i节点结构中，因此我们要先取得对应文件名的i节点。检测的访问属性mode由低3位组成，
	// 因此需要与上八进制0007来清除所有高位。如果文件名对应的i节点不存在，则返回没有许可权限出错码。若i节点存在，则取i
	// 节点中文件属性码，并放回该i节点。另外，57行上语句“iput(inode);”最好放在61行之后。
	mode &= 0007;
    ae72:	8b 44 24 40          	mov    0x40(%esp),%eax
    ae76:	83 e0 07             	and    $0x7,%eax
    ae79:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (!(inode = namei(filename)))
    ae7d:	ff 74 24 3c          	pushl  0x3c(%esp)
    ae81:	e8 b2 3a 00 00       	call   e938 <namei>
    ae86:	83 c4 10             	add    $0x10,%esp
    ae89:	85 c0                	test   %eax,%eax
    ae8b:	74 64                	je     aef1 <sys_access+0x91>
		return -EACCES;                 				// 出错码：无访问权限。
	i_mode = res = inode->i_mode & 0777;
	iput(inode);
    ae8d:	83 ec 0c             	sub    $0xc,%esp
	i_mode = res = inode->i_mode & 0777;
    ae90:	8b 38                	mov    (%eax),%edi
    ae92:	89 c5                	mov    %eax,%ebp
	iput(inode);
    ae94:	50                   	push   %eax
    ae95:	e8 8e 0c 00 00       	call   bb28 <iput>
	// 如果当前进程用户是该文件的宿主，则取文件宿主属性。否则如果当前进程用户与该文件宿主同属一个级，则取文件组属性。否则
	// 此时res低3位是其他人访问该文件的许可属性。
	// [??这里应res >> 3 ??]
	if (current->uid == inode->i_uid)
    ae9a:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	i_mode = res = inode->i_mode & 0777;
    aea0:	89 fe                	mov    %edi,%esi
	iput(inode);
    aea2:	83 c4 10             	add    $0x10,%esp
	i_mode = res = inode->i_mode & 0777;
    aea5:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
	if (current->uid == inode->i_uid)
    aeab:	8b 00                	mov    (%eax),%eax
    aead:	8b 88 cc 02 00 00    	mov    0x2cc(%eax),%ecx
    aeb3:	66 3b 4d 02          	cmp    0x2(%ebp),%cx
    aeb7:	75 05                	jne    aebe <sys_access+0x5e>
		res >>= 6;
    aeb9:	c1 fe 06             	sar    $0x6,%esi
    aebc:	eb 10                	jmp    aece <sys_access+0x6e>
	else if (current->gid == inode->i_gid)
    aebe:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
    aec2:	66 39 98 d2 02 00 00 	cmp    %bx,0x2d2(%eax)
    aec9:	75 03                	jne    aece <sys_access+0x6e>
		res >>= 3;
    aecb:	c1 fe 03             	sar    $0x3,%esi
	// 此时res的最低3位是根据当前进程用户与文件的关系选择出来的访问属性位。现在我们来判断这3位。如果文件属性具有参数所查询
	// 的属性位mode，则访问许可，返回0。
	if ((res & 0007 & mode) == mode)
    aece:	23 74 24 0c          	and    0xc(%esp),%esi
		return 0;
    aed2:	31 c0                	xor    %eax,%eax
	if ((res & 0007 & mode) == mode)
    aed4:	3b 74 24 0c          	cmp    0xc(%esp),%esi
    aed8:	74 1c                	je     aef6 <sys_access+0x96>
    /*
     * XXX我们最后才做下面的测试，因为我们实际上需要交换有效用户ID和真实用户ID（临时地），然后才调用suser()函数，
     * 如果我们确实要调用suser()函数，则需要最后才被调用。
     */
	// 如果当前用户ID为0（超级用户）并且屏蔽码执行位是0或者文件可以被任何人执行、搜索，则返回0。否则返回出错码。
	if ((!current->uid) &&
    aeda:	66 85 c9             	test   %cx,%cx
    aedd:	75 12                	jne    aef1 <sys_access+0x91>
    aedf:	8b 44 24 34          	mov    0x34(%esp),%eax
    aee3:	83 e0 01             	and    $0x1,%eax
    aee6:	74 0e                	je     aef6 <sys_access+0x96>
		return 0;
    aee8:	31 c0                	xor    %eax,%eax
	    (!(mode & 1) || (i_mode & 0111)))
    aeea:	66 f7 c7 49 00       	test   $0x49,%di
    aeef:	75 05                	jne    aef6 <sys_access+0x96>
		return 0;
	return -EACCES;         							// 出错码：无访问权限。
    aef1:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
}
    aef6:	83 c4 1c             	add    $0x1c,%esp
    aef9:	5b                   	pop    %ebx
    aefa:	5e                   	pop    %esi
    aefb:	5f                   	pop    %edi
    aefc:	5d                   	pop    %ebp
    aefd:	c3                   	ret    

0000aefe <sys_chdir>:

// 改变当前工作目录系统调用。
// 参数filename是目录名。
// 操作成功则返回0,否则返回出错码。
int sys_chdir(const char * filename)
{
    aefe:	57                   	push   %edi
    aeff:	56                   	push   %esi
    af00:	53                   	push   %ebx
    af01:	e8 26 bb ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    af06:	81 c3 fa 60 01 00    	add    $0x160fa,%ebx
	struct m_inode * inode;

	// 改变当前工作目录就是要求把进程任务结构的当前工作目录字段指向给定目录名的i节点。因此我们首先取目录名的i节点。如果目录名对应
	// 的i节点不存在，则返回出错码。如果该i节点不是一个目录i节点，则放回该i节点，并返回出错码。
	if (!(inode = namei(filename)))
    af0c:	83 ec 0c             	sub    $0xc,%esp
    af0f:	ff 74 24 1c          	pushl  0x1c(%esp)
    af13:	e8 20 3a 00 00       	call   e938 <namei>
    af18:	89 c6                	mov    %eax,%esi
    af1a:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;                 				// 出错码：文件或目录不存在。
    af1d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!(inode = namei(filename)))
    af22:	85 f6                	test   %esi,%esi
    af24:	74 42                	je     af68 <sys_chdir+0x6a>
	if (!S_ISDIR(inode->i_mode)) {
    af26:	8b 06                	mov    (%esi),%eax
    af28:	66 25 00 f0          	and    $0xf000,%ax
    af2c:	66 3d 00 40          	cmp    $0x4000,%ax
    af30:	74 13                	je     af45 <sys_chdir+0x47>
		iput(inode);
    af32:	83 ec 0c             	sub    $0xc,%esp
    af35:	56                   	push   %esi
    af36:	e8 ed 0b 00 00       	call   bb28 <iput>
    af3b:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;                				// 出错码：不是目录名。
    af3e:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
    af43:	eb 23                	jmp    af68 <sys_chdir+0x6a>
	}
	// 然后释放进程原工作目录i节点，并使其指向新设置的工作目录i节点。返回0.
	iput(current->pwd);
    af45:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
    af4b:	83 ec 0c             	sub    $0xc,%esp
    af4e:	8b 07                	mov    (%edi),%eax
    af50:	ff b0 34 03 00 00    	pushl  0x334(%eax)
    af56:	e8 cd 0b 00 00       	call   bb28 <iput>
	current->pwd = inode;
    af5b:	8b 07                	mov    (%edi),%eax
	iput(current->pwd);
    af5d:	83 c4 10             	add    $0x10,%esp
	current->pwd = inode;
    af60:	89 b0 34 03 00 00    	mov    %esi,0x334(%eax)
	return (0);
    af66:	31 c0                	xor    %eax,%eax
}
    af68:	5b                   	pop    %ebx
    af69:	5e                   	pop    %esi
    af6a:	5f                   	pop    %edi
    af6b:	c3                   	ret    

0000af6c <sys_chroot>:

// 改变根目录系统调用。
// 把指定的目录名设置成为当前进程的根目录“/”。
// 如果操作成功则返回0，否则返回出错码。
int sys_chroot(const char * filename)
{
    af6c:	57                   	push   %edi
    af6d:	56                   	push   %esi
    af6e:	53                   	push   %ebx
    af6f:	e8 b8 ba ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    af74:	81 c3 8c 60 01 00    	add    $0x1608c,%ebx
	struct m_inode * inode;

	// 该调用用于改变当前进程任务结构中的根目录字段root，让其指向参数给定目录名的i节点。如果目录名对应i节点不存在，则返回出错码。
	// 如果该i节点不是目录i节点，则放回该i节点，也返回出错码。
	if (!(inode = namei(filename)))
    af7a:	83 ec 0c             	sub    $0xc,%esp
    af7d:	ff 74 24 1c          	pushl  0x1c(%esp)
    af81:	e8 b2 39 00 00       	call   e938 <namei>
    af86:	89 c6                	mov    %eax,%esi
    af88:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
    af8b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!(inode = namei(filename)))
    af90:	85 f6                	test   %esi,%esi
    af92:	74 42                	je     afd6 <sys_chroot+0x6a>
	if (!S_ISDIR(inode->i_mode)) {
    af94:	8b 06                	mov    (%esi),%eax
    af96:	66 25 00 f0          	and    $0xf000,%ax
    af9a:	66 3d 00 40          	cmp    $0x4000,%ax
    af9e:	74 13                	je     afb3 <sys_chroot+0x47>
		iput(inode);
    afa0:	83 ec 0c             	sub    $0xc,%esp
    afa3:	56                   	push   %esi
    afa4:	e8 7f 0b 00 00       	call   bb28 <iput>
    afa9:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
    afac:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
    afb1:	eb 23                	jmp    afd6 <sys_chroot+0x6a>
	}
	// 然后释放当前进程的根目录，并重新设置为指定目录名的i节点，返回0。
	iput(current->root);
    afb3:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
    afb9:	83 ec 0c             	sub    $0xc,%esp
    afbc:	8b 07                	mov    (%edi),%eax
    afbe:	ff b0 38 03 00 00    	pushl  0x338(%eax)
    afc4:	e8 5f 0b 00 00       	call   bb28 <iput>
	current->root = inode;
    afc9:	8b 07                	mov    (%edi),%eax
	iput(current->root);
    afcb:	83 c4 10             	add    $0x10,%esp
	current->root = inode;
    afce:	89 b0 38 03 00 00    	mov    %esi,0x338(%eax)
	return (0);
    afd4:	31 c0                	xor    %eax,%eax
}
    afd6:	5b                   	pop    %ebx
    afd7:	5e                   	pop    %esi
    afd8:	5f                   	pop    %edi
    afd9:	c3                   	ret    

0000afda <sys_chmod>:

// 修改文件属性系统调用。
// 参数filename是文件名，mode是新的文件属性。
int sys_chmod(const char * filename, int mode)
{
    afda:	53                   	push   %ebx
    afdb:	e8 4c ba ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    afe0:	81 c3 20 60 01 00    	add    $0x16020,%ebx
    afe6:	83 ec 14             	sub    $0x14,%esp
	struct m_inode * inode;

	// 该调用为指定文件设置新的访问属性mode。文件的访问属性在文件名对应的i节点中，因此我们首先取文件名对应的i节点。如果i节点不存
	// 在，则返回出错码（文件或目录不存在）。如果当前进程的有效用户名id与文件i节点的用户id不同，并且也不是超级用户，则放回该文件
	// i节点，返回出错码（没有访问权限）。
	if (!(inode = namei(filename)))
    afe9:	ff 74 24 1c          	pushl  0x1c(%esp)
    afed:	e8 46 39 00 00       	call   e938 <namei>
    aff2:	89 c2                	mov    %eax,%edx
    aff4:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
    aff7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!(inode = namei(filename)))
    affc:	85 d2                	test   %edx,%edx
    affe:	74 53                	je     b053 <sys_chmod+0x79>
	if ((current->euid != inode->i_uid) && !suser()) {
    b000:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    b006:	8b 00                	mov    (%eax),%eax
    b008:	66 8b 80 ce 02 00 00 	mov    0x2ce(%eax),%ax
    b00f:	66 39 42 02          	cmp    %ax,0x2(%edx)
    b013:	74 18                	je     b02d <sys_chmod+0x53>
    b015:	66 85 c0             	test   %ax,%ax
    b018:	74 13                	je     b02d <sys_chmod+0x53>
		iput(inode);
    b01a:	83 ec 0c             	sub    $0xc,%esp
    b01d:	52                   	push   %edx
    b01e:	e8 05 0b 00 00       	call   bb28 <iput>
    b023:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    b026:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    b02b:	eb 26                	jmp    b053 <sys_chmod+0x79>
	}
	// 否则就重新设置该i节点的文件属性，并置该i节点已修改标志。放回该i节点，返回0。
	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
    b02d:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    b031:	8b 02                	mov    (%edx),%eax
	inode->i_dirt = 1;
	iput(inode);
    b033:	83 ec 0c             	sub    $0xc,%esp
	inode->i_dirt = 1;
    b036:	c6 42 37 01          	movb   $0x1,0x37(%edx)
	inode->i_mode = (mode & 07777) | (inode->i_mode & ~07777);
    b03a:	66 81 e1 ff 0f       	and    $0xfff,%cx
    b03f:	66 25 00 f0          	and    $0xf000,%ax
    b043:	09 c8                	or     %ecx,%eax
    b045:	66 89 02             	mov    %ax,(%edx)
	iput(inode);
    b048:	52                   	push   %edx
    b049:	e8 da 0a 00 00       	call   bb28 <iput>
    b04e:	83 c4 10             	add    $0x10,%esp
	return 0;
    b051:	31 c0                	xor    %eax,%eax
}
    b053:	83 c4 08             	add    $0x8,%esp
    b056:	5b                   	pop    %ebx
    b057:	c3                   	ret    

0000b058 <sys_chown>:

// 修改文件宿主系统调用。
// 参数filename是文件名，uid是用户标识符（用户ID），gid是组ID。
// 若操作成功则返回0，否则返回出错码。
int sys_chown(const char * filename, int uid, int gid)
{
    b058:	53                   	push   %ebx
    b059:	e8 ce b9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b05e:	81 c3 a2 5f 01 00    	add    $0x15fa2,%ebx
    b064:	83 ec 14             	sub    $0x14,%esp
	struct m_inode * inode;

	// 该调用用于设置文件i节点中的用户和组ID，因此首先要取得给定文件名的i节点。如果文件名的i节点不存在，则返回出错码（文件
	// 或目录不存在）。如果当前进程不是超级用户，则放回该i节点，并返回出错码（没有访问权限）。
	if (!(inode = namei(filename)))
    b067:	ff 74 24 1c          	pushl  0x1c(%esp)
    b06b:	e8 c8 38 00 00       	call   e938 <namei>
    b070:	89 c2                	mov    %eax,%edx
    b072:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
    b075:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!(inode = namei(filename)))
    b07a:	85 d2                	test   %edx,%edx
    b07c:	74 46                	je     b0c4 <sys_chown+0x6c>
	if (!suser()) {
    b07e:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    b084:	8b 00                	mov    (%eax),%eax
    b086:	66 83 b8 ce 02 00 00 	cmpw   $0x0,0x2ce(%eax)
    b08d:	00 
    b08e:	74 13                	je     b0a3 <sys_chown+0x4b>
		iput(inode);
    b090:	83 ec 0c             	sub    $0xc,%esp
    b093:	52                   	push   %edx
    b094:	e8 8f 0a 00 00       	call   bb28 <iput>
    b099:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    b09c:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    b0a1:	eb 21                	jmp    b0c4 <sys_chown+0x6c>
	}
	// 否则我们就用参数提供的值来设置文件i节点的用户ID和组ID，并置i节点已经修改标志，放回该i节点，返回0。
	inode->i_uid = uid;
    b0a3:	8b 44 24 14          	mov    0x14(%esp),%eax
	inode->i_gid = gid;
	inode->i_dirt = 1;
	iput(inode);
    b0a7:	83 ec 0c             	sub    $0xc,%esp
	inode->i_dirt = 1;
    b0aa:	c6 42 37 01          	movb   $0x1,0x37(%edx)
	inode->i_uid = uid;
    b0ae:	66 89 42 02          	mov    %ax,0x2(%edx)
	inode->i_gid = gid;
    b0b2:	8b 44 24 24          	mov    0x24(%esp),%eax
    b0b6:	88 42 0c             	mov    %al,0xc(%edx)
	iput(inode);
    b0b9:	52                   	push   %edx
    b0ba:	e8 69 0a 00 00       	call   bb28 <iput>
    b0bf:	83 c4 10             	add    $0x10,%esp
	return 0;
    b0c2:	31 c0                	xor    %eax,%eax
}
    b0c4:	83 c4 08             	add    $0x8,%esp
    b0c7:	5b                   	pop    %ebx
    b0c8:	c3                   	ret    

0000b0c9 <sys_open>:
// O_EXCL(被创建文件必须不存在),O_APPEND(在文件尾添加数据)等其他一些标志的组合,如果本调用创建了一个新文件,则mode就用于指定
// 文件的许可属性.这些属性有S_IRWXU(文件宿主具有读,写和执行权限),S_IRUSR(用户具有读文件权限),S_IRWXG(组成员有读,写
// 执行)等等.对于新创建的文件,这些属性只应用于将来对文件的访问,创建了只读文件的打开调用也将返回一个读写的文件句柄.如果调用
// 操作成功,则返回文件句柄(文件描述符),否则返回出错码.参见sys/tat.h,fcntl.h.
int sys_open(const char * filename, int flag, int mode)
{
    b0c9:	55                   	push   %ebp
    b0ca:	57                   	push   %edi
	int i, fd;

	// 首先对参数进行处理.将用户设置的文件模式和进程模式屏蔽码相与,产适配器的文件模式.为了为打开文件建立一个文件句柄,需要搜索进程
	// 结构中文件结构指针数组,以查找一个空闲项.空闲项的索引号fd即是句柄值.若已经没有空闲项,则返回出错码(参数无效).
	mode &= 0777 & ~current->umask;
	for(fd = 0 ; fd < NR_OPEN ; fd++)
    b0cb:	31 ff                	xor    %edi,%edi
{
    b0cd:	56                   	push   %esi
    b0ce:	53                   	push   %ebx
    b0cf:	e8 58 b9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b0d4:	81 c3 2c 5f 01 00    	add    $0x15f2c,%ebx
    b0da:	83 ec 2c             	sub    $0x2c,%esp
	mode &= 0777 & ~current->umask;
    b0dd:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    b0e3:	8b 10                	mov    (%eax),%edx
    b0e5:	0f b7 82 30 03 00 00 	movzwl 0x330(%edx),%eax
    b0ec:	f7 d0                	not    %eax
    b0ee:	25 ff 01 00 00       	and    $0x1ff,%eax
    b0f3:	23 44 24 48          	and    0x48(%esp),%eax
		if (!current->filp[fd])
    b0f7:	83 bc ba 48 03 00 00 	cmpl   $0x0,0x348(%edx,%edi,4)
    b0fe:	00 
    b0ff:	74 10                	je     b111 <sys_open+0x48>
	for(fd = 0 ; fd < NR_OPEN ; fd++)
    b101:	47                   	inc    %edi
    b102:	83 ff 14             	cmp    $0x14,%edi
    b105:	75 f0                	jne    b0f7 <sys_open+0x2e>
			break;          						// 找到空闲项.
	if (fd >= NR_OPEN)
		return -EINVAL;
    b107:	bf ea ff ff ff       	mov    $0xffffffea,%edi
    b10c:	e9 bb 01 00 00       	jmp    b2cc <sys_open+0x203>
	// 该子进程中调用execve()函数加载执行另一个新程序.此时子进程中开始执行新程序.若一个文件句柄close_on_exec中的对应位被置位,那么在
	// 执行execve()时该对应文件句柄将被关闭,否则该文件句柄将始终处于打开状态.当打开一个文件时,默认情况下文件句柄在子进程中也处于打开
	// 状态.因此这里要复位对应位.然后为打开文件在文件表中寻找一个空闲结构项.我们令f指向文件表数组开始处.搜索空闲文件结构项(引用计数
	// 为0的项),若已经没有空闲文件表结构项,则返回出错码.另外,第184行上的指针赋值"0+file_table"等同于"file_table"和"&file_table[0]"
	// 不过这样写可能更能明了一些.
	current->close_on_exec &= ~(1 << fd);           // 复位对应文件打开位
    b111:	89 f9                	mov    %edi,%ecx
    b113:	be fe ff ff ff       	mov    $0xfffffffe,%esi
    b118:	d3 c6                	rol    %cl,%esi
    b11a:	21 b2 44 03 00 00    	and    %esi,0x344(%edx)
	f = 0 + file_table;
    b120:	c7 c6 60 4e 03 00    	mov    $0x34e60,%esi
	for (i = 0 ; i < NR_FILE ; i++, f++)
    b126:	8d 8e 00 04 00 00    	lea    0x400(%esi),%ecx
		if (!f->f_count) break;         			// 在文件表中找到空闲结构项。
    b12c:	66 83 7e 04 00       	cmpw   $0x0,0x4(%esi)
    b131:	74 09                	je     b13c <sys_open+0x73>
	for (i = 0 ; i < NR_FILE ; i++, f++)
    b133:	83 c6 10             	add    $0x10,%esi
    b136:	39 ce                	cmp    %ecx,%esi
    b138:	75 f2                	jne    b12c <sys_open+0x63>
    b13a:	eb cb                	jmp    b107 <sys_open+0x3e>
	if (i >= NR_FILE)
		return -EINVAL;
	// 此时我们让进程对应文件句柄fd的文件结构指针指向搜索到的文件结构,并令文件引用计数递增1.然后调用函数open_namei()执行打开操作,若返回
	// 值小于0,则说明出错,于是释放刚申请到的文件结构,返回出错码i.若文件打开操作成功,则inode是已打开文件的i节点指针.
	(current->filp[fd] = f)->f_count++;
    b13c:	8d af d0 00 00 00    	lea    0xd0(%edi),%ebp
    b142:	89 74 aa 08          	mov    %esi,0x8(%edx,%ebp,4)
	// Log(LOG_INFO_TYPE, "<<<<< sys_open : fd = %d\n", fd);
	if ((i = open_namei(filename, flag, mode, &inode)) < 0) {
    b146:	8d 54 24 1c          	lea    0x1c(%esp),%edx
	(current->filp[fd] = f)->f_count++;
    b14a:	66 c7 46 04 01 00    	movw   $0x1,0x4(%esi)
	if ((i = open_namei(filename, flag, mode, &inode)) < 0) {
    b150:	52                   	push   %edx
    b151:	50                   	push   %eax
    b152:	ff 74 24 4c          	pushl  0x4c(%esp)
    b156:	ff 74 24 4c          	pushl  0x4c(%esp)
    b15a:	e8 e9 37 00 00       	call   e948 <open_namei>
    b15f:	83 c4 10             	add    $0x10,%esp
    b162:	85 c0                	test   %eax,%eax
    b164:	79 1d                	jns    b183 <sys_open+0xba>
		current->filp[fd] = NULL;
    b166:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
		f->f_count = 0;
		return i;
    b16c:	89 c7                	mov    %eax,%edi
		current->filp[fd] = NULL;
    b16e:	8b 12                	mov    (%edx),%edx
    b170:	c7 44 aa 08 00 00 00 	movl   $0x0,0x8(%edx,%ebp,4)
    b177:	00 
		f->f_count = 0;
    b178:	66 c7 46 04 00 00    	movw   $0x0,0x4(%esi)
		return i;
    b17e:	e9 49 01 00 00       	jmp    b2cc <sys_open+0x203>
	}
	// 根据已打开文件i节点的属性字段,我们可以知道文件的类型.对于不同类型的文件,我们需要作一些特别处理.如果打开的是字符设备文件,那么我们就要调用
	// check_char_dev()函数来检查当前进程是否能打开这个字符设备文件.如果允许(函数返回0),那么在check_char_dev()中会根据具体文件打开标志为进程
	// 设置控制终端.如果不允许打开使用该字符设备文件,那么我们只能释放上面申请的文件项和句柄资源.返回出错码.
	/* ttys are somewhat special (ttyxx major==4, tty major==5) */
	if (S_ISCHR(inode->i_mode))
    b183:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    b187:	8b 02                	mov    (%edx),%eax
    b189:	66 25 00 f0          	and    $0xf000,%ax
    b18d:	66 3d 00 20          	cmp    $0x2000,%ax
    b191:	0f 85 fe 00 00 00    	jne    b295 <sys_open+0x1cc>
		if (check_char_dev(inode, inode->i_zone[0], flag)) {
    b197:	66 8b 42 0e          	mov    0xe(%edx),%ax
	if (MAJOR(dev) == 4 || MAJOR(dev) == 5) {
    b19b:	0f b6 cc             	movzbl %ah,%ecx
		if (check_char_dev(inode, inode->i_zone[0], flag)) {
    b19e:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	if (MAJOR(dev) == 4 || MAJOR(dev) == 5) {
    b1a3:	8d 41 fc             	lea    -0x4(%ecx),%eax
    b1a6:	83 f8 01             	cmp    $0x1,%eax
    b1a9:	0f 87 fc 00 00 00    	ja     b2ab <sys_open+0x1e2>
		if (MAJOR(dev) == 5)
    b1af:	83 f9 05             	cmp    $0x5,%ecx
			min = MINOR(dev);
    b1b2:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
		if (MAJOR(dev) == 5)
    b1b7:	75 16                	jne    b1cf <sys_open+0x106>
			min = current->tty;
    b1b9:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    b1bf:	8b 00                	mov    (%eax),%eax
    b1c1:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
		if (min < 0)
    b1c7:	85 c0                	test   %eax,%eax
    b1c9:	0f 88 9d 00 00 00    	js     b26c <sys_open+0x1a3>
		if ((IS_A_PTY_MASTER(min)) && (inode->i_count > 1))
    b1cf:	89 c1                	mov    %eax,%ecx
    b1d1:	81 e1 c0 00 00 00    	and    $0xc0,%ecx
    b1d7:	83 c1 80             	add    $0xffffff80,%ecx
    b1da:	75 0c                	jne    b1e8 <sys_open+0x11f>
    b1dc:	66 83 7a 34 01       	cmpw   $0x1,0x34(%edx)
    b1e1:	76 17                	jbe    b1fa <sys_open+0x131>
    b1e3:	e9 84 00 00 00       	jmp    b26c <sys_open+0x1a3>
		tty = TTY_TABLE(min);
    b1e8:	85 c0                	test   %eax,%eax
    b1ea:	c7 c1 00 57 03 00    	mov    $0x35700,%ecx
    b1f0:	74 15                	je     b207 <sys_open+0x13e>
    b1f2:	83 f8 3f             	cmp    $0x3f,%eax
    b1f5:	8d 50 ff             	lea    -0x1(%eax),%edx
    b1f8:	7e 15                	jle    b20f <sys_open+0x146>
    b1fa:	89 c2                	mov    %eax,%edx
    b1fc:	c1 e2 06             	shl    $0x6,%edx
    b1ff:	81 c2 00 57 03 00    	add    $0x35700,%edx
    b205:	eb 0d                	jmp    b214 <sys_open+0x14b>
    b207:	c7 c2 a0 51 02 00    	mov    $0x251a0,%edx
    b20d:	8b 12                	mov    (%edx),%edx
    b20f:	c1 e2 06             	shl    $0x6,%edx
    b212:	01 ca                	add    %ecx,%edx
		if (!(flag & O_NOCTTY) &&
    b214:	8b 4c 24 44          	mov    0x44(%esp),%ecx
    b218:	0f ba e1 08          	bt     $0x8,%ecx
    b21c:	72 38                	jb     b256 <sys_open+0x18d>
		    current->leader &&
    b21e:	c7 c1 60 23 02 00    	mov    $0x22360,%ecx
    b224:	8b 09                	mov    (%ecx),%ecx
		if (!(flag & O_NOCTTY) &&
    b226:	83 b9 38 02 00 00 00 	cmpl   $0x0,0x238(%ecx)
    b22d:	74 27                	je     b256 <sys_open+0x18d>
		    current->leader &&
    b22f:	83 b9 2c 03 00 00 00 	cmpl   $0x0,0x32c(%ecx)
    b236:	79 1e                	jns    b256 <sys_open+0x18d>
		    current->tty < 0 &&
    b238:	83 7a 28 00          	cmpl   $0x0,0x28(%edx)
    b23c:	75 18                	jne    b256 <sys_open+0x18d>
			current->tty = min;
    b23e:	89 81 2c 03 00 00    	mov    %eax,0x32c(%ecx)
			tty->session = current->session;
    b244:	8b 81 34 02 00 00    	mov    0x234(%ecx),%eax
    b24a:	89 42 28             	mov    %eax,0x28(%edx)
			tty->pgrp = current->pgrp;
    b24d:	8b 81 30 02 00 00    	mov    0x230(%ecx),%eax
    b253:	89 42 24             	mov    %eax,0x24(%edx)
		if (flag & O_NONBLOCK) {
    b256:	8b 44 24 44          	mov    0x44(%esp),%eax
    b25a:	0f ba e0 0b          	bt     $0xb,%eax
    b25e:	73 4b                	jae    b2ab <sys_open+0x1e2>
			TTY_TABLE(min)->termios.c_cc[VTIME] = 0;
    b260:	66 c7 42 16 00 00    	movw   $0x0,0x16(%edx)
			TTY_TABLE(min)->termios.c_lflag &= ~ICANON;
    b266:	83 62 0c fd          	andl   $0xfffffffd,0xc(%edx)
    b26a:	eb 3f                	jmp    b2ab <sys_open+0x1e2>
			iput(inode);
    b26c:	83 ec 0c             	sub    $0xc,%esp
			current->filp[fd] = NULL;
			f->f_count = 0;
			return -EAGAIN;         				// 出错号:资源暂不可用.
    b26f:	bf f5 ff ff ff       	mov    $0xfffffff5,%edi
			iput(inode);
    b274:	52                   	push   %edx
    b275:	e8 ae 08 00 00       	call   bb28 <iput>
			current->filp[fd] = NULL;
    b27a:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
			iput(inode);
    b280:	83 c4 10             	add    $0x10,%esp
			current->filp[fd] = NULL;
    b283:	8b 00                	mov    (%eax),%eax
    b285:	c7 44 a8 08 00 00 00 	movl   $0x0,0x8(%eax,%ebp,4)
    b28c:	00 
			f->f_count = 0;
    b28d:	66 c7 46 04 00 00    	movw   $0x0,0x4(%esi)
			return -EAGAIN;         				// 出错号:资源暂不可用.
    b293:	eb 37                	jmp    b2cc <sys_open+0x203>
		}
	// 如果打开的是块设备文件,则检查盘片是否更换过.若更换过则需要让高速缓冲区中该设备的所有缓冲块失效.
	/* Likewise with block-devices: check for floppy_change */
	/* 同样对于块设备文件:需要检查盘片是否被更换 */
	if (S_ISBLK(inode->i_mode))
    b295:	66 3d 00 60          	cmp    $0x6000,%ax
    b299:	75 10                	jne    b2ab <sys_open+0x1e2>
		check_disk_change(inode->i_zone[0]);
    b29b:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
    b29f:	83 ec 0c             	sub    $0xc,%esp
    b2a2:	50                   	push   %eax
    b2a3:	e8 57 0e 00 00       	call   c0ff <check_disk_change>
    b2a8:	83 c4 10             	add    $0x10,%esp
	// 现在我们初始化打开文件的文件结构.设置文件结构属性和标志,置句柄引用计数为1,并设置i节点字段为打开文件的i节点,初始化文件读写指针为0.最后返回文件句柄号.
	f->f_mode = inode->i_mode;
    b2ab:	8b 44 24 1c          	mov    0x1c(%esp),%eax
	f->f_flags = flag;
    b2af:	8b 5c 24 44          	mov    0x44(%esp),%ebx
	f->f_mode = inode->i_mode;
    b2b3:	8b 10                	mov    (%eax),%edx
	f->f_flags = flag;
    b2b5:	66 89 5e 02          	mov    %bx,0x2(%esi)
	f->f_count = 1;
    b2b9:	66 c7 46 04 01 00    	movw   $0x1,0x4(%esi)
	f->f_inode = inode;
    b2bf:	89 46 08             	mov    %eax,0x8(%esi)
	f->f_pos = 0;
    b2c2:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
	f->f_mode = inode->i_mode;
    b2c9:	66 89 16             	mov    %dx,(%esi)
	return (fd);
}
    b2cc:	83 c4 2c             	add    $0x2c,%esp
    b2cf:	89 f8                	mov    %edi,%eax
    b2d1:	5b                   	pop    %ebx
    b2d2:	5e                   	pop    %esi
    b2d3:	5f                   	pop    %edi
    b2d4:	5d                   	pop    %ebp
    b2d5:	c3                   	ret    

0000b2d6 <sys_creat>:

// 创建文件系统调用。
// 参数pathname是路径名，mode与上面的sys_open()函数相同。
// 成功则返回文件句柄，否则返回出错码。
int sys_creat(const char * pathname, int mode)
{
    b2d6:	83 ec 10             	sub    $0x10,%esp
	return sys_open(pathname, O_CREAT | O_TRUNC, mode);
    b2d9:	ff 74 24 18          	pushl  0x18(%esp)
    b2dd:	68 40 02 00 00       	push   $0x240
    b2e2:	ff 74 24 1c          	pushl  0x1c(%esp)
    b2e6:	e8 de fd ff ff       	call   b0c9 <sys_open>
}
    b2eb:	83 c4 1c             	add    $0x1c,%esp
    b2ee:	c3                   	ret    

0000b2ef <sys_close>:

// 关闭文件系统调用.
// 参数fd是文件句柄.
// 成功则返回0,否则返回出错码.
int sys_close(unsigned int fd)
{
    b2ef:	57                   	push   %edi
    b2f0:	56                   	push   %esi
    b2f1:	53                   	push   %ebx
    b2f2:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    b2f6:	e8 31 b7 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b2fb:	81 c3 05 5d 01 00    	add    $0x15d05,%ebx
	struct file * filp;

	// 首先检查参数有效性.若给出的文件句柄值大于程序同时打开的文件数NR_OPEN,则返回出错码(参数无效).然后复位进程的执行时关闭文件句柄位图对应位.若该文件句柄对应的
	// 文件结构指针是NULL,则返回出错码.
	if (fd >= NR_OPEN)
    b301:	83 f9 13             	cmp    $0x13,%ecx
    b304:	76 07                	jbe    b30d <sys_close+0x1e>
		return -EINVAL;
    b306:	bf ea ff ff ff       	mov    $0xffffffea,%edi
    b30b:	eb 64                	jmp    b371 <sys_close+0x82>
	current->close_on_exec &= ~(1 << fd);
    b30d:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    b313:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    b318:	d3 c2                	rol    %cl,%edx
    b31a:	8b 00                	mov    (%eax),%eax
    b31c:	21 90 44 03 00 00    	and    %edx,0x344(%eax)
    b322:	8d 04 88             	lea    (%eax,%ecx,4),%eax
	if (!(filp = current->filp[fd]))
    b325:	8b b0 48 03 00 00    	mov    0x348(%eax),%esi
    b32b:	85 f6                	test   %esi,%esi
    b32d:	74 d7                	je     b306 <sys_close+0x17>
		return -EINVAL;
	// 现在置该文件句柄的文件结构指针为NULL.若在关闭文件之前,对应文件结构中的句柄引用计数已经为0,则说明内核出错,停机.否则将对应文件结构的引用计数减1.此时如果它还不
	// 为0,则说明有其他进程正在使用该文件,于是返回0(成功).如果引用计数已等于0,说明该文件已经没有进程引用,该文件结构已变为空闲.则释放该文件i节点,返回0.
	current->filp[fd] = NULL;
	if (filp->f_count == 0)
    b32f:	66 83 7e 04 00       	cmpw   $0x0,0x4(%esi)
	current->filp[fd] = NULL;
    b334:	c7 80 48 03 00 00 00 	movl   $0x0,0x348(%eax)
    b33b:	00 00 00 
	if (filp->f_count == 0)
    b33e:	75 12                	jne    b352 <sys_close+0x63>
		panic("Close: file count is 0");
    b340:	8d 83 14 72 ff ff    	lea    -0x8dec(%ebx),%eax
    b346:	83 ec 0c             	sub    $0xc,%esp
    b349:	50                   	push   %eax
    b34a:	e8 83 cd ff ff       	call   80d2 <panic>
    b34f:	83 c4 10             	add    $0x10,%esp
	if (--filp->f_count)
    b352:	8b 46 04             	mov    0x4(%esi),%eax
		return (0);
    b355:	31 ff                	xor    %edi,%edi
	if (--filp->f_count)
    b357:	8d 50 ff             	lea    -0x1(%eax),%edx
    b35a:	66 85 d2             	test   %dx,%dx
    b35d:	66 89 56 04          	mov    %dx,0x4(%esi)
    b361:	75 0e                	jne    b371 <sys_close+0x82>
	iput(filp->f_inode);
    b363:	83 ec 0c             	sub    $0xc,%esp
    b366:	ff 76 08             	pushl  0x8(%esi)
    b369:	e8 ba 07 00 00       	call   bb28 <iput>
    b36e:	83 c4 10             	add    $0x10,%esp
	return (0);
}
    b371:	89 f8                	mov    %edi,%eax
    b373:	5b                   	pop    %ebx
    b374:	5e                   	pop    %esi
    b375:	5f                   	pop    %edi
    b376:	c3                   	ret    

0000b377 <sys_lseek>:

// 重定位文件读写指针系统调用。
// 参数fd是文件句柄，offset是新的文件读写指针偏移值，origin是偏移的起始位置，可有三种选择：SEEK_SET（0,
// 从文件开始处）、SEEK_CUR（1,从当前读写位置）、SEEK_END（2,从文件尾处）。
int sys_lseek(unsigned int fd, off_t offset, int origin)
{
    b377:	57                   	push   %edi
    b378:	56                   	push   %esi
	// 首先判断函数提供的参数有效性。如果文件句柄大于程序最多打开文件数NR_OPEN（20），或者该句柄的文件结构指针为空，
	// 或者对应文件结构的i节点字段为空，或者指定设备文件指针是不可定位的，则返回出错码并退出。如果文件对应i节点是管道
	// 节点，则返回出错码退出。因为管道头尾指针不可随意移动！
	if (fd >= NR_OPEN || !(file = current->filp[fd]) || !(file->f_inode)
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
		return -EBADF;
    b379:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
{
    b37e:	53                   	push   %ebx
    b37f:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    b383:	e8 a4 b6 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b388:	81 c3 78 5c 01 00    	add    $0x15c78,%ebx
    b38e:	8b 54 24 14          	mov    0x14(%esp),%edx
    b392:	8b 74 24 18          	mov    0x18(%esp),%esi
	if (fd >= NR_OPEN || !(file = current->filp[fd]) || !(file->f_inode)
    b396:	83 f9 13             	cmp    $0x13,%ecx
    b399:	77 5c                	ja     b3f7 <sys_lseek+0x80>
    b39b:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    b3a1:	8b 00                	mov    (%eax),%eax
    b3a3:	8b 8c 88 48 03 00 00 	mov    0x348(%eax,%ecx,4),%ecx
		return -EBADF;
    b3aa:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
	if (fd >= NR_OPEN || !(file = current->filp[fd]) || !(file->f_inode)
    b3af:	85 c9                	test   %ecx,%ecx
    b3b1:	74 44                	je     b3f7 <sys_lseek+0x80>
    b3b3:	8b 59 08             	mov    0x8(%ecx),%ebx
    b3b6:	85 db                	test   %ebx,%ebx
    b3b8:	74 3d                	je     b3f7 <sys_lseek+0x80>
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
    b3ba:	0f b6 7b 31          	movzbl 0x31(%ebx),%edi
    b3be:	4f                   	dec    %edi
    b3bf:	66 83 ff 02          	cmp    $0x2,%di
    b3c3:	77 32                	ja     b3f7 <sys_lseek+0x80>
	if (file->f_inode->i_pipe)
    b3c5:	80 7b 38 00          	cmpb   $0x0,0x38(%ebx)
		return -ESPIPE;
    b3c9:	b8 e3 ff ff ff       	mov    $0xffffffe3,%eax
	if (file->f_inode->i_pipe)
    b3ce:	75 27                	jne    b3f7 <sys_lseek+0x80>
	// 然后根据设置的定位标志，分别重新定位文件读写指针。
	switch (origin) {
    b3d0:	83 fe 01             	cmp    $0x1,%esi
		// origin = SEEK_SET，要求以文件起始处作为原点设置文件读写指针。若偏移值小于零，则出错返回错误码。否则设置文件
		// 读写指针等于offset。
		case 0:
			if (offset < 0) return -EINVAL;
    b3d3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	switch (origin) {
    b3d8:	74 0d                	je     b3e7 <sys_lseek+0x70>
    b3da:	83 fe 02             	cmp    $0x2,%esi
    b3dd:	74 0d                	je     b3ec <sys_lseek+0x75>
    b3df:	85 f6                	test   %esi,%esi
    b3e1:	75 14                	jne    b3f7 <sys_lseek+0x80>
			if (offset < 0) return -EINVAL;
    b3e3:	85 d2                	test   %edx,%edx
    b3e5:	eb 08                	jmp    b3ef <sys_lseek+0x78>
			file->f_pos = offset;
			break;
		// origin = SEEK_CUR，要求以文件当前读写指针处作为原点重定位读写指针。如果文件当前指针加上偏移值小于0,则返回
		// 出错码退出。否则在当前读写指针上加上偏移值。
		case 1:
			if (file->f_pos + offset < 0) return -EINVAL;
    b3e7:	03 51 0c             	add    0xc(%ecx),%edx
    b3ea:	eb 03                	jmp    b3ef <sys_lseek+0x78>
			file->f_pos += offset;
			break;
		// origin = SEEK_END，要求以文件末尾作为原点重定位读写指针。此时若文件大小加上偏移值小于零则返回出错码退出。否则
		// 重定位读写指针为文件长度加上偏移值。
		case 2:
			if ((tmp = file->f_inode->i_size + offset) < 0)
    b3ec:	03 53 04             	add    0x4(%ebx),%edx
    b3ef:	78 06                	js     b3f7 <sys_lseek+0x80>
				return -EINVAL;
			file->f_pos = tmp;
    b3f1:	89 51 0c             	mov    %edx,0xc(%ecx)
			break;
		// origin设置无效，返回出错码退出。
		default:
			return -EINVAL;
	}
	return file->f_pos;             					// 最后返回重定位后的文件读写指针值。
    b3f4:	8b 41 0c             	mov    0xc(%ecx),%eax
}
    b3f7:	5b                   	pop    %ebx
    b3f8:	5e                   	pop    %esi
    b3f9:	5f                   	pop    %edi
    b3fa:	c3                   	ret    

0000b3fb <sys_read>:

// 读文件系统调用。
// 参数fd是文件句柄，buf是缓冲区，count是欲读字节数。
int sys_read(unsigned int fd, char * buf, int count)
{
    b3fb:	55                   	push   %ebp
    b3fc:	57                   	push   %edi
    b3fd:	56                   	push   %esi
    b3fe:	53                   	push   %ebx
    b3ff:	e8 28 b6 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b404:	81 c3 fc 5b 01 00    	add    $0x15bfc,%ebx
    b40a:	83 ec 1c             	sub    $0x1c,%esp
    b40d:	8b 44 24 30          	mov    0x30(%esp),%eax
    b411:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    b415:	8b 7c 24 38          	mov    0x38(%esp),%edi
	struct file * file;
	struct m_inode * inode;

	// 同样地,我们首先判断函数参数的有效性.如果进程文件句柄值大于程序最多打开文件数NR_OPEN,或者需要写入的字节计数小于0,或者该句柄的文件结构指针为空,
	// 则返回出错码并退出.如果需读取的字节数count等于0,则返回0退出.
	if (fd >= NR_OPEN || count < 0 || !(file = current->filp[fd]))
    b419:	83 f8 13             	cmp    $0x13,%eax
    b41c:	0f 87 eb 00 00 00    	ja     b50d <sys_read+0x112>
    b422:	85 ff                	test   %edi,%edi
    b424:	0f 88 e3 00 00 00    	js     b50d <sys_read+0x112>
    b42a:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    b430:	8b 12                	mov    (%edx),%edx
    b432:	8b b4 82 48 03 00 00 	mov    0x348(%edx,%eax,4),%esi
		return -EINVAL;
    b439:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (fd >= NR_OPEN || count < 0 || !(file = current->filp[fd]))
    b43e:	85 f6                	test   %esi,%esi
    b440:	0f 84 cc 00 00 00    	je     b512 <sys_read+0x117>
	if (!count)
    b446:	85 ff                	test   %edi,%edi
    b448:	75 07                	jne    b451 <sys_read+0x56>
		return 0;
    b44a:	31 c0                	xor    %eax,%eax
    b44c:	e9 c1 00 00 00       	jmp    b512 <sys_read+0x117>
	// 然后验证存放数据的缓冲区内存限制。并取文件的i节点。用于根据该i节点的属性，分别调用相应的读操作函数。若是管道操作，并且是读管道文件模式，则进行读
	// 管道操作，若成功则返回读取的字节数，否则返回出错码，退出。如果是字符型文件，则进行读字符设备操作，并返回读取的字符数。如果是块设备文件，则执行
	// 块设备读操作，并返回读取的字节数。
	verify_area(buf, count);
    b451:	50                   	push   %eax
    b452:	50                   	push   %eax
    b453:	57                   	push   %edi
    b454:	55                   	push   %ebp
    b455:	e8 91 c7 ff ff       	call   7beb <verify_area>
	inode = file->f_inode;
    b45a:	8b 56 08             	mov    0x8(%esi),%edx
	verify_area(buf, count);
    b45d:	83 c4 10             	add    $0x10,%esp
	// 管道文件的读操作
	if (inode->i_pipe)
    b460:	80 7a 38 00          	cmpb   $0x0,0x38(%edx)
    b464:	74 19                	je     b47f <sys_read+0x84>
		return (file->f_mode & 1) ? read_pipe(inode, buf, count) : -EIO;
    b466:	f6 06 01             	testb  $0x1,(%esi)
    b469:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    b46e:	0f 84 9e 00 00 00    	je     b512 <sys_read+0x117>
    b474:	51                   	push   %ecx
    b475:	57                   	push   %edi
    b476:	55                   	push   %ebp
    b477:	52                   	push   %edx
    b478:	e8 2e 2a 00 00       	call   deab <read_pipe>
    b47d:	eb 3f                	jmp    b4be <sys_read+0xc3>
	// 字符设备的读操作
	if (S_ISCHR(inode->i_mode))
    b47f:	0f b7 0a             	movzwl (%edx),%ecx
    b482:	89 c8                	mov    %ecx,%eax
    b484:	66 25 00 f0          	and    $0xf000,%ax
    b488:	66 3d 00 20          	cmp    $0x2000,%ax
    b48c:	75 1a                	jne    b4a8 <sys_read+0xad>
		return rw_char(READ, inode->i_zone[0], buf, count, &file->f_pos);
    b48e:	83 ec 0c             	sub    $0xc,%esp
    b491:	83 c6 0c             	add    $0xc,%esi
    b494:	56                   	push   %esi
    b495:	57                   	push   %edi
    b496:	55                   	push   %ebp
    b497:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
    b49b:	50                   	push   %eax
    b49c:	6a 00                	push   $0x0
    b49e:	e8 46 1b 00 00       	call   cfe9 <rw_char>
    b4a3:	83 c4 20             	add    $0x20,%esp
    b4a6:	eb 6a                	jmp    b512 <sys_read+0x117>
	// 块设备的读操作
	if (S_ISBLK(inode->i_mode))
    b4a8:	66 3d 00 60          	cmp    $0x6000,%ax
    b4ac:	75 15                	jne    b4c3 <sys_read+0xc8>
		return block_read(inode->i_zone[0], &file->f_pos, buf, count);
    b4ae:	83 c6 0c             	add    $0xc,%esi
    b4b1:	57                   	push   %edi
    b4b2:	55                   	push   %ebp
    b4b3:	56                   	push   %esi
    b4b4:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
    b4b8:	50                   	push   %eax
    b4b9:	e8 4d 19 00 00       	call   ce0b <block_read>
    b4be:	83 c4 10             	add    $0x10,%esp
    b4c1:	eb 4f                	jmp    b512 <sys_read+0x117>
	// 如果是目录文件或者是常规文件，则首先验证读取字节数count的有效性并进行调整（若读取字节数加上文件当前读写指针值大于文件长度，则重新设置读取字节
	// 数为文件长度-当前读写指针值，若读取数等于0,则返回0退出），然后执行文件读操作，返回读取的字节数并退出。
	if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {
    b4c3:	66 2d 00 40          	sub    $0x4000,%ax
    b4c7:	66 a9 00 b0          	test   $0xb000,%ax
    b4cb:	75 2e                	jne    b4fb <sys_read+0x100>
		if (count + file->f_pos > inode->i_size)
    b4cd:	8b 4a 04             	mov    0x4(%edx),%ecx
    b4d0:	8b 46 0c             	mov    0xc(%esi),%eax
    b4d3:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    b4d7:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
    b4da:	3b 4c 24 0c          	cmp    0xc(%esp),%ecx
    b4de:	76 10                	jbe    b4f0 <sys_read+0xf5>
			count = inode->i_size - file->f_pos;
    b4e0:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    b4e4:	29 c1                	sub    %eax,%ecx
		if (count <= 0)
    b4e6:	85 c9                	test   %ecx,%ecx
			count = inode->i_size - file->f_pos;
    b4e8:	89 cf                	mov    %ecx,%edi
		if (count <= 0)
    b4ea:	0f 8e 5a ff ff ff    	jle    b44a <sys_read+0x4f>
			return 0;
		return file_read(inode, file, buf, count);
    b4f0:	57                   	push   %edi
    b4f1:	55                   	push   %ebp
    b4f2:	56                   	push   %esi
    b4f3:	52                   	push   %edx
    b4f4:	e8 23 1b 00 00       	call   d01c <file_read>
    b4f9:	eb c3                	jmp    b4be <sys_read+0xc3>
	}
	// 执行到这里，说明我们无法判断文件的属性。则打印节点文件的属性，并返回出错码退出。
	printk("(Read)inode->i_mode=%06o\n\r", inode->i_mode);
    b4fb:	50                   	push   %eax
    b4fc:	50                   	push   %eax
    b4fd:	8d 83 2b 72 ff ff    	lea    -0x8dd5(%ebx),%eax
    b503:	51                   	push   %ecx
    b504:	50                   	push   %eax
    b505:	e8 17 cc ff ff       	call   8121 <printk>
    b50a:	83 c4 10             	add    $0x10,%esp
		return -EINVAL;
    b50d:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	return -EINVAL;
}
    b512:	83 c4 1c             	add    $0x1c,%esp
    b515:	5b                   	pop    %ebx
    b516:	5e                   	pop    %esi
    b517:	5f                   	pop    %edi
    b518:	5d                   	pop    %ebp
    b519:	c3                   	ret    

0000b51a <sys_write>:

// 写文件系统调用.
// 参数fd是文件句柄,buf是用户缓冲区,count是欲写字节数.
int sys_write(unsigned int fd, char * buf, int count)
{
    b51a:	55                   	push   %ebp
    b51b:	57                   	push   %edi
    b51c:	56                   	push   %esi
    b51d:	53                   	push   %ebx
    b51e:	e8 09 b5 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b523:	81 c3 dd 5a 01 00    	add    $0x15add,%ebx
    b529:	83 ec 0c             	sub    $0xc,%esp
    b52c:	8b 54 24 20          	mov    0x20(%esp),%edx
    b530:	8b 7c 24 24          	mov    0x24(%esp),%edi
    b534:	8b 44 24 28          	mov    0x28(%esp),%eax
	struct file * file;
	struct m_inode * inode;

	// 同样地,我们首先判断函数参数的有效性.如果进程文件句柄值大于程序最多打开文件数NR_OPEN,或者需要写入的字节计数小于0,或者该句柄的文件结构指针为空,
	// 则返回出错码并退出.如果需读取的字节数count等于0,则返回0退出.
	if (fd >= NR_OPEN || count < 0 || !(file = current->filp[fd]))
    b538:	83 fa 13             	cmp    $0x13,%edx
    b53b:	0f 87 ab 00 00 00    	ja     b5ec <sys_write+0xd2>
    b541:	85 c0                	test   %eax,%eax
    b543:	0f 88 a3 00 00 00    	js     b5ec <sys_write+0xd2>
    b549:	c7 c1 60 23 02 00    	mov    $0x22360,%ecx
    b54f:	8b 09                	mov    (%ecx),%ecx
    b551:	8b 94 91 48 03 00 00 	mov    0x348(%ecx,%edx,4),%edx
    b558:	85 d2                	test   %edx,%edx
    b55a:	0f 84 8c 00 00 00    	je     b5ec <sys_write+0xd2>
		return -EINVAL;
	// Log(LOG_INFO_TYPE, "<<<<< sys_write : fd = %d>>>>>\n", fd);
	if (!count)
    b560:	85 c0                	test   %eax,%eax
    b562:	0f 84 90 00 00 00    	je     b5f8 <sys_write+0xde>
		return 0;
	// 然后验证存放数据的缓冲区内存限制.并取文件的i节点.根据该i节点的属性,分别调用相应的写操作函数.若是管道文件,并且是写管道文件模式,则进行写管道操作,若成功则
	// 返回写入的字节数,否则返回出错码退出.如果是字符设备文件,则进行写字符设备操作,返回写入的字符数退出.如果是块设备文件,则进行块设备写操作,并返回写入的字节数
	// 退出.若是常规文件,则执行文件写操作,并返回写入的字节数.退出.
	inode = file->f_inode;
    b568:	8b 4a 08             	mov    0x8(%edx),%ecx
	// 管道的写操作
	if (inode->i_pipe)
    b56b:	80 79 38 00          	cmpb   $0x0,0x38(%ecx)
    b56f:	74 10                	je     b581 <sys_write+0x67>
		return (file->f_mode & 2) ? write_pipe(inode, buf, count) : -EIO;
    b571:	f6 02 02             	testb  $0x2,(%edx)
    b574:	74 7d                	je     b5f3 <sys_write+0xd9>
    b576:	52                   	push   %edx
    b577:	50                   	push   %eax
    b578:	57                   	push   %edi
    b579:	51                   	push   %ecx
    b57a:	e8 3e 2a 00 00       	call   dfbd <write_pipe>
    b57f:	eb 42                	jmp    b5c3 <sys_write+0xa9>
	// 字符设备的写操作
	if (S_ISCHR(inode->i_mode))
    b581:	0f b7 31             	movzwl (%ecx),%esi
    b584:	89 f5                	mov    %esi,%ebp
    b586:	66 81 e5 00 f0       	and    $0xf000,%bp
    b58b:	66 81 fd 00 20       	cmp    $0x2000,%bp
    b590:	75 1a                	jne    b5ac <sys_write+0x92>
		return rw_char(WRITE, inode->i_zone[0], buf, count, &file->f_pos);
    b592:	83 ec 0c             	sub    $0xc,%esp
    b595:	83 c2 0c             	add    $0xc,%edx
    b598:	52                   	push   %edx
    b599:	50                   	push   %eax
    b59a:	57                   	push   %edi
    b59b:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
    b59f:	50                   	push   %eax
    b5a0:	6a 01                	push   $0x1
    b5a2:	e8 42 1a 00 00       	call   cfe9 <rw_char>
    b5a7:	83 c4 20             	add    $0x20,%esp
    b5aa:	eb 4c                	jmp    b5f8 <sys_write+0xde>
	// 块设备的写操作
	if (S_ISBLK(inode->i_mode))
    b5ac:	66 81 fd 00 60       	cmp    $0x6000,%bp
    b5b1:	75 15                	jne    b5c8 <sys_write+0xae>
		return block_write(inode->i_zone[0], &file->f_pos, buf, count);
    b5b3:	83 c2 0c             	add    $0xc,%edx
    b5b6:	50                   	push   %eax
    b5b7:	57                   	push   %edi
    b5b8:	52                   	push   %edx
    b5b9:	0f b7 41 0e          	movzwl 0xe(%ecx),%eax
    b5bd:	50                   	push   %eax
    b5be:	e8 36 17 00 00       	call   ccf9 <block_write>
    b5c3:	83 c4 10             	add    $0x10,%esp
    b5c6:	eb 30                	jmp    b5f8 <sys_write+0xde>
	// 文件的写操作
	if (S_ISREG(inode->i_mode))
    b5c8:	66 81 fd 00 80       	cmp    $0x8000,%bp
    b5cd:	75 0b                	jne    b5da <sys_write+0xc0>
		return file_write(inode, file, buf, count);
    b5cf:	50                   	push   %eax
    b5d0:	57                   	push   %edi
    b5d1:	52                   	push   %edx
    b5d2:	51                   	push   %ecx
    b5d3:	e8 9d 1b 00 00       	call   d175 <file_write>
    b5d8:	eb e9                	jmp    b5c3 <sys_write+0xa9>
	// 执行到这里,说明我们无法判断文件的属性.则打印节点文件属性,并返回出错码退出.
	printk("(Write)inode->i_mode=%06o\n\r", inode->i_mode);
    b5da:	50                   	push   %eax
    b5db:	50                   	push   %eax
    b5dc:	8d 83 46 72 ff ff    	lea    -0x8dba(%ebx),%eax
    b5e2:	56                   	push   %esi
    b5e3:	50                   	push   %eax
    b5e4:	e8 38 cb ff ff       	call   8121 <printk>
    b5e9:	83 c4 10             	add    $0x10,%esp
		return -EINVAL;
    b5ec:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    b5f1:	eb 05                	jmp    b5f8 <sys_write+0xde>
		return (file->f_mode & 2) ? write_pipe(inode, buf, count) : -EIO;
    b5f3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	return -EINVAL;
}
    b5f8:	83 c4 0c             	add    $0xc,%esp
    b5fb:	5b                   	pop    %ebx
    b5fc:	5e                   	pop    %esi
    b5fd:	5f                   	pop    %edi
    b5fe:	5d                   	pop    %ebp
    b5ff:	c3                   	ret    

0000b600 <wait_on_inode>:
static void write_inode(struct m_inode * inode);					// 写i节点信息到高速缓冲中.

// 等待指定的i节点可用.
// 如果i节点已被锁定,则将当前任务置为不可中断的等待状态,并添加到该i节点的等待队列i_wait中.直到该i节点解锁并明确地唤醒本任务.
static inline void wait_on_inode(struct m_inode * inode)
{
    b600:	56                   	push   %esi
    b601:	53                   	push   %ebx
    b602:	89 c6                	mov    %eax,%esi
    b604:	52                   	push   %edx
    b605:	e8 22 b4 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b60a:	81 c3 f6 59 01 00    	add    $0x159f6,%ebx
	cli();
    b610:	fa                   	cli    
	while (inode->i_lock)
    b611:	80 7e 36 00          	cmpb   $0x0,0x36(%esi)
    b615:	74 11                	je     b628 <wait_on_inode+0x28>
		sleep_on(&inode->i_wait);									// kernel/sched.c
    b617:	8d 46 20             	lea    0x20(%esi),%eax
    b61a:	83 ec 0c             	sub    $0xc,%esp
    b61d:	50                   	push   %eax
    b61e:	e8 62 b8 ff ff       	call   6e85 <sleep_on>
    b623:	83 c4 10             	add    $0x10,%esp
    b626:	eb e9                	jmp    b611 <wait_on_inode+0x11>
	sti();
    b628:	fb                   	sti    
}
    b629:	58                   	pop    %eax
    b62a:	5b                   	pop    %ebx
    b62b:	5e                   	pop    %esi
    b62c:	c3                   	ret    

0000b62d <_bmap.part.0>:
}

// 文件数据块映射到盘块的处理操作.(block位图处理函数,bmap - block map)
// 参数:inode - 文件的i节点指针;block - 文件中的数据块号;create - 创建块标志.该函数把指定的文件数据块block对应到设备上逻辑块上,并返回逻辑块号.
// 如果创建标志置位,则在设备上对应逻辑块不存在时就申请新磁盘块,返回文件数据块block对应在设备上的逻辑块号(盘块号).
static int _bmap(struct m_inode * inode, int block, int create)
    b62d:	55                   	push   %ebp
		return inode->i_zone[block];
	}
	// 如果该块号>=7,且小于7+512,则说明使用的是一次间接块.下面对一次间接块进行处理.如果是创建,并且该i节点中对应间接块字段i_zone[7]是0,表明文件是首次使用间接块,
	// 则需申请一磁盘块用于存放间接块信息,并将此实际磁盘块号填入间接块字段中.然后设置i节点已修改标志和修改时间.如果创建时申请磁盘块失败,则此时i节点间接块字段i_zone[7]
	// 为0,则返回0.或者不是创建,但i_zone[7]原来就为0,表明i节点中没有间接块,于是映射磁盘块失败,返回0退出.
	block -= 7;
    b62e:	8d 6a f9             	lea    -0x7(%edx),%ebp
static int _bmap(struct m_inode * inode, int block, int create)
    b631:	57                   	push   %edi
    b632:	56                   	push   %esi
    b633:	53                   	push   %ebx
    b634:	89 c6                	mov    %eax,%esi
    b636:	e8 f1 b3 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b63b:	81 c3 c5 59 01 00    	add    $0x159c5,%ebx
    b641:	83 ec 1c             	sub    $0x1c,%esp
	if (block < 512) {
    b644:	81 fd ff 01 00 00    	cmp    $0x1ff,%ebp
static int _bmap(struct m_inode * inode, int block, int create)
    b64a:	89 cf                	mov    %ecx,%edi
    b64c:	89 54 24 04          	mov    %edx,0x4(%esp)
	if (block < 512) {
    b650:	0f 8f ba 00 00 00    	jg     b710 <_bmap.part.0+0xe3>
		// 如果创建标志置位，同时索引7这个位置没有绑定到对应的逻辑块,则申请一个逻辑块
		if (create && !inode->i_zone[7])
    b656:	85 c9                	test   %ecx,%ecx
    b658:	74 48                	je     b6a2 <_bmap.part.0+0x75>
    b65a:	66 83 78 1c 00       	cmpw   $0x0,0x1c(%eax)
    b65f:	75 51                	jne    b6b2 <_bmap.part.0+0x85>
			if (inode->i_zone[7] = new_block(inode->i_dev)) {
    b661:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    b665:	83 ec 0c             	sub    $0xc,%esp
    b668:	50                   	push   %eax
    b669:	e8 8e 43 00 00       	call   f9fc <new_block>
    b66e:	83 c4 10             	add    $0x10,%esp
    b671:	66 85 c0             	test   %ax,%ax
    b674:	66 89 46 1c          	mov    %ax,0x1c(%esi)
    b678:	74 31                	je     b6ab <_bmap.part.0+0x7e>
				inode->i_dirt = 1;
				inode->i_ctime = CURRENT_TIME;
    b67a:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    b680:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    b686:	b9 64 00 00 00       	mov    $0x64,%ecx
				inode->i_dirt = 1;
    b68b:	c6 46 37 01          	movb   $0x1,0x37(%esi)
				inode->i_ctime = CURRENT_TIME;
    b68f:	8b 00                	mov    (%eax),%eax
    b691:	03 02                	add    (%edx),%eax
    b693:	31 d2                	xor    %edx,%edx
    b695:	f7 f1                	div    %ecx
    b697:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    b69d:	03 02                	add    (%edx),%eax
    b69f:	89 46 2c             	mov    %eax,0x2c(%esi)
			}
		if (!inode->i_zone[7])
    b6a2:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
    b6a6:	66 85 c0             	test   %ax,%ax
    b6a9:	75 0b                	jne    b6b6 <_bmap.part.0+0x89>
			return 0;
    b6ab:	31 c0                	xor    %eax,%eax
    b6ad:	e9 bb 01 00 00       	jmp    b86d <_bmap.part.0+0x240>
		if (!inode->i_zone[7])
    b6b2:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
		// 现在读取设备上该i节点的一次间接块.并取该间接块上第block项中的逻辑块号(盘块号)i.每一项占2个字节.如果是创建并且间接块的第block项中的逻辑块号为0的话,则申请一磁盘块,
		// 并让间接块中的第block项等于该新逻辑块块号.然后置位间接块的已修改标志.如果不是创建,则i就是需要映射(寻找)的逻辑块号.
		if (!(bh = bread(inode->i_dev, inode->i_zone[7])))
    b6b6:	52                   	push   %edx
    b6b7:	52                   	push   %edx
    b6b8:	50                   	push   %eax
    b6b9:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    b6bd:	50                   	push   %eax
    b6be:	e8 ed 0c 00 00       	call   c3b0 <bread>
    b6c3:	83 c4 10             	add    $0x10,%esp
    b6c6:	85 c0                	test   %eax,%eax
    b6c8:	89 c2                	mov    %eax,%edx
    b6ca:	74 df                	je     b6ab <_bmap.part.0+0x7e>
			return 0;
		i = ((unsigned short *) (bh->b_data))[block];
    b6cc:	8b 00                	mov    (%eax),%eax
    b6ce:	01 ed                	add    %ebp,%ebp
    b6d0:	0f b7 04 28          	movzwl (%eax,%ebp,1),%eax
		if (create && !i)
    b6d4:	85 c0                	test   %eax,%eax
    b6d6:	75 2b                	jne    b703 <_bmap.part.0+0xd6>
    b6d8:	83 e7 01             	and    $0x1,%edi
    b6db:	74 26                	je     b703 <_bmap.part.0+0xd6>
			if (i = new_block(inode->i_dev)) {
    b6dd:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    b6e1:	89 54 24 04          	mov    %edx,0x4(%esp)
    b6e5:	83 ec 0c             	sub    $0xc,%esp
    b6e8:	50                   	push   %eax
    b6e9:	e8 0e 43 00 00       	call   f9fc <new_block>
    b6ee:	83 c4 10             	add    $0x10,%esp
    b6f1:	85 c0                	test   %eax,%eax
    b6f3:	8b 54 24 04          	mov    0x4(%esp),%edx
    b6f7:	74 0a                	je     b703 <_bmap.part.0+0xd6>
				((unsigned short *) (bh->b_data))[block] = i;
    b6f9:	8b 0a                	mov    (%edx),%ecx
    b6fb:	66 89 04 29          	mov    %ax,(%ecx,%ebp,1)
				bh->b_dirt = 1;
    b6ff:	c6 42 0b 01          	movb   $0x1,0xb(%edx)
    b703:	89 44 24 04          	mov    %eax,0x4(%esp)
			}
		// 最后释放该间接块占用的缓冲块,并返回磁盘上新申请或原有的对应block的逻辑块块号.
		brelse(bh);
    b707:	83 ec 0c             	sub    $0xc,%esp
    b70a:	52                   	push   %edx
    b70b:	e9 46 01 00 00       	jmp    b856 <_bmap.part.0+0x229>
	// 若程序运行到此,则表明数据块属于二次间接块.其处理过程与一次间接块类似.下面是对二次间接块的处理.首先将block再减去间接块所容纳的块数(512).然后根据
	// 是否设置了创建标志进行创建或寻找处理.如果是新创建并且i节点的二次间接块字段为0,则需申请一磁盘块用于存放二次间接块的一级块信息,并将此实际磁盘块号填入
	// 二次间接块字段中.之后,置i节点已修改编制和修改时间.同样地,如果创建时申请磁盘块失败,则此时i节点二次间接块字段i_zone[8]为0,则返回0.或者不是创建,但
	// i_zone[8]原来变为0,表明i节点中没有间接块,于是映射磁盘块失败,返回0退出.
	block -= 512;
	if (create && !inode->i_zone[8])
    b710:	85 c9                	test   %ecx,%ecx
    b712:	74 50                	je     b764 <_bmap.part.0+0x137>
    b714:	66 83 78 1e 00       	cmpw   $0x0,0x1e(%eax)
    b719:	0f 85 45 01 00 00    	jne    b864 <_bmap.part.0+0x237>
		if (inode->i_zone[8] = new_block(inode->i_dev)) {
    b71f:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    b723:	83 ec 0c             	sub    $0xc,%esp
    b726:	50                   	push   %eax
    b727:	e8 d0 42 00 00       	call   f9fc <new_block>
    b72c:	83 c4 10             	add    $0x10,%esp
    b72f:	66 85 c0             	test   %ax,%ax
    b732:	66 89 46 1e          	mov    %ax,0x1e(%esi)
    b736:	0f 84 6f ff ff ff    	je     b6ab <_bmap.part.0+0x7e>
			inode->i_dirt = 1;
			inode->i_ctime = CURRENT_TIME;
    b73c:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    b742:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    b748:	b9 64 00 00 00       	mov    $0x64,%ecx
			inode->i_dirt = 1;
    b74d:	c6 46 37 01          	movb   $0x1,0x37(%esi)
			inode->i_ctime = CURRENT_TIME;
    b751:	8b 00                	mov    (%eax),%eax
    b753:	03 02                	add    (%edx),%eax
    b755:	31 d2                	xor    %edx,%edx
    b757:	f7 f1                	div    %ecx
    b759:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    b75f:	03 02                	add    (%edx),%eax
    b761:	89 46 2c             	mov    %eax,0x2c(%esi)
		}
	if (!inode->i_zone[8])
    b764:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
    b768:	66 85 c0             	test   %ax,%ax
    b76b:	0f 84 3a ff ff ff    	je     b6ab <_bmap.part.0+0x7e>
		return 0;
	// 现在读取设备上该i节点的二次间接块.并取该二次间接块的一级块上第(block/512)项中的逻辑块号i.如果是创建并且二次间接块的一级块上第(block/512)项中的逻辑
	// 块号为0的话,则需申请一磁盘块(逻辑块)作为二次间接块的二级块i,并让二次间接块的一级块中第(block/512)项等于该二级块的块号i.然后置位二次间接块的一级块已
	// 修改标志.并释放二次间接块的一级块.如果不是创建,则i就是需要映射(寻找)的逻辑块号.
	if (!(bh = bread(inode->i_dev, inode->i_zone[8])))
    b771:	51                   	push   %ecx
    b772:	51                   	push   %ecx
    b773:	50                   	push   %eax
    b774:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    b778:	50                   	push   %eax
    b779:	e8 32 0c 00 00       	call   c3b0 <bread>
    b77e:	83 c4 10             	add    $0x10,%esp
    b781:	85 c0                	test   %eax,%eax
    b783:	89 c2                	mov    %eax,%edx
    b785:	0f 84 20 ff ff ff    	je     b6ab <_bmap.part.0+0x7e>
	block -= 512;
    b78b:	8b 6c 24 04          	mov    0x4(%esp),%ebp
		return 0;
	i = ((unsigned short *)bh->b_data)[block >> 9];
    b78f:	8b 00                	mov    (%eax),%eax
	block -= 512;
    b791:	81 ed 07 02 00 00    	sub    $0x207,%ebp
	i = ((unsigned short *)bh->b_data)[block >> 9];
    b797:	89 e9                	mov    %ebp,%ecx
    b799:	c1 f9 09             	sar    $0x9,%ecx
    b79c:	01 c9                	add    %ecx,%ecx
    b79e:	0f b7 04 08          	movzwl (%eax,%ecx,1),%eax
    b7a2:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	if (create && !i)
    b7a6:	89 f9                	mov    %edi,%ecx
    b7a8:	83 e1 01             	and    $0x1,%ecx
    b7ab:	88 4c 24 04          	mov    %cl,0x4(%esp)
    b7af:	85 c0                	test   %eax,%eax
    b7b1:	75 2e                	jne    b7e1 <_bmap.part.0+0x1b4>
    b7b3:	84 c9                	test   %cl,%cl
    b7b5:	74 2a                	je     b7e1 <_bmap.part.0+0x1b4>
		if (i = new_block(inode->i_dev)) {
    b7b7:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    b7bb:	89 54 24 08          	mov    %edx,0x8(%esp)
    b7bf:	83 ec 0c             	sub    $0xc,%esp
    b7c2:	50                   	push   %eax
    b7c3:	e8 34 42 00 00       	call   f9fc <new_block>
    b7c8:	83 c4 10             	add    $0x10,%esp
    b7cb:	85 c0                	test   %eax,%eax
    b7cd:	8b 54 24 08          	mov    0x8(%esp),%edx
    b7d1:	74 0e                	je     b7e1 <_bmap.part.0+0x1b4>
			((unsigned short *) (bh->b_data))[block >> 9] = i;
    b7d3:	8b 3a                	mov    (%edx),%edi
    b7d5:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    b7d9:	66 89 04 0f          	mov    %ax,(%edi,%ecx,1)
			bh->b_dirt=1;
    b7dd:	c6 42 0b 01          	movb   $0x1,0xb(%edx)
    b7e1:	89 44 24 08          	mov    %eax,0x8(%esp)
		}
	brelse(bh);
    b7e5:	83 ec 0c             	sub    $0xc,%esp
    b7e8:	52                   	push   %edx
    b7e9:	e8 70 0b 00 00       	call   c35e <brelse>
    b7ee:	83 c4 10             	add    $0x10,%esp
	// 如果二次间接块的二级块块号为0,表示申请磁盘失败或者原来对应块号就为0,则返回0退出.否则就从设备上读取二次间接块的二级块,并取该二级块上第block项中的逻辑块
	// 号(与上511是为了限定block值不超过511).
	if (!i)
    b7f1:	8b 44 24 08          	mov    0x8(%esp),%eax
    b7f5:	85 c0                	test   %eax,%eax
    b7f7:	0f 84 ae fe ff ff    	je     b6ab <_bmap.part.0+0x7e>
		return 0;
	if (!(bh = bread(inode->i_dev, i)))
    b7fd:	52                   	push   %edx
    b7fe:	52                   	push   %edx
    b7ff:	50                   	push   %eax
    b800:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    b804:	50                   	push   %eax
    b805:	e8 a6 0b 00 00       	call   c3b0 <bread>
    b80a:	83 c4 10             	add    $0x10,%esp
    b80d:	85 c0                	test   %eax,%eax
    b80f:	89 c7                	mov    %eax,%edi
    b811:	0f 84 94 fe ff ff    	je     b6ab <_bmap.part.0+0x7e>
		return 0;
	i = ((unsigned short *)bh->b_data)[block & 511];
    b817:	8b 00                	mov    (%eax),%eax
    b819:	81 e5 ff 01 00 00    	and    $0x1ff,%ebp
    b81f:	01 ed                	add    %ebp,%ebp
    b821:	0f b7 04 28          	movzwl (%eax,%ebp,1),%eax
	// 如果是创建并且二级块的第block项中逻辑块号为0的话,则申请一磁盘块(逻辑块),作为最终存放数据信息的块.并让二级块中的第block项等于该新逻辑块块号(i).然后置位
	// 二级块的已修改标志.
	if (create && !i)
    b825:	85 c0                	test   %eax,%eax
    b827:	75 25                	jne    b84e <_bmap.part.0+0x221>
    b829:	80 7c 24 04 00       	cmpb   $0x0,0x4(%esp)
    b82e:	74 1e                	je     b84e <_bmap.part.0+0x221>
		if (i = new_block(inode->i_dev)) {
    b830:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    b834:	83 ec 0c             	sub    $0xc,%esp
    b837:	50                   	push   %eax
    b838:	e8 bf 41 00 00       	call   f9fc <new_block>
    b83d:	83 c4 10             	add    $0x10,%esp
    b840:	85 c0                	test   %eax,%eax
    b842:	74 0a                	je     b84e <_bmap.part.0+0x221>
			((unsigned short *) (bh->b_data))[block & 511] = i;
    b844:	8b 17                	mov    (%edi),%edx
    b846:	66 89 04 2a          	mov    %ax,(%edx,%ebp,1)
			bh->b_dirt = 1;
    b84a:	c6 47 0b 01          	movb   $0x1,0xb(%edi)
    b84e:	89 44 24 04          	mov    %eax,0x4(%esp)
		}
	// 最后释放该二次间接块的二级块,返回磁盘上新申请的或原有的对应block的逻辑块块号.
	brelse(bh);
    b852:	83 ec 0c             	sub    $0xc,%esp
    b855:	57                   	push   %edi
    b856:	e8 03 0b 00 00       	call   c35e <brelse>
    b85b:	83 c4 10             	add    $0x10,%esp
    b85e:	8b 44 24 04          	mov    0x4(%esp),%eax
    b862:	eb 09                	jmp    b86d <_bmap.part.0+0x240>
	if (!inode->i_zone[8])
    b864:	0f b7 40 1e          	movzwl 0x1e(%eax),%eax
    b868:	e9 04 ff ff ff       	jmp    b771 <_bmap.part.0+0x144>
	return i;
}
    b86d:	83 c4 1c             	add    $0x1c,%esp
    b870:	5b                   	pop    %ebx
    b871:	5e                   	pop    %esi
    b872:	5f                   	pop    %edi
    b873:	5d                   	pop    %ebp
    b874:	c3                   	ret    

0000b875 <write_inode>:
// 将i节点信息写入缓冲区中.
// 该函数把参数指定的i节点写入缓冲区相应的缓冲块中,待缓冲区刷新时会写入盘中.为了确定i节点所在的设备逻辑块号(或缓冲块),必须首先读取相应设备上的超级块,
// 以获取用于计算逻辑块号的每块i节点数信息INODES_PER_BLOCK.在计算出i节点所在的逻辑块号后,就把该逻辑块读入一缓冲块中.然后把i节点内容复制到缓冲块的
// 相应位置处.
static void write_inode(struct m_inode * inode)
{
    b875:	55                   	push   %ebp
    b876:	57                   	push   %edi
    b877:	89 c5                	mov    %eax,%ebp
    b879:	56                   	push   %esi
    b87a:	53                   	push   %ebx
    b87b:	e8 ac b1 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b880:	81 c3 80 57 01 00    	add    $0x15780,%ebx
    b886:	83 ec 1c             	sub    $0x1c,%esp
	cli();
    b889:	fa                   	cli    
	while (inode->i_lock)
    b88a:	80 7d 36 00          	cmpb   $0x0,0x36(%ebp)
    b88e:	8d 45 20             	lea    0x20(%ebp),%eax
    b891:	89 44 24 08          	mov    %eax,0x8(%esp)
    b895:	74 11                	je     b8a8 <write_inode+0x33>
		sleep_on(&inode->i_wait);
    b897:	83 ec 0c             	sub    $0xc,%esp
    b89a:	ff 74 24 14          	pushl  0x14(%esp)
    b89e:	e8 e2 b5 ff ff       	call   6e85 <sleep_on>
    b8a3:	83 c4 10             	add    $0x10,%esp
    b8a6:	eb e2                	jmp    b88a <write_inode+0x15>
	inode->i_lock = 1;												// 置锁定标志.
    b8a8:	c6 45 36 01          	movb   $0x1,0x36(%ebp)
	sti();
    b8ac:	fb                   	sti    
	int block;

	// 首先锁定该i节点,如果该i节点没有被修改过或者该i节点的设备号等于零,则解锁该i节点,并退出.对于没有被修改过的i节点,其内容与缓冲区中或设备中的相同.然后获取
	// 该i节点的超级块.
	lock_inode(inode);
	if (!inode->i_dirt || !inode->i_dev) {
    b8ad:	80 7d 37 00          	cmpb   $0x0,0x37(%ebp)
    b8b1:	74 09                	je     b8bc <write_inode+0x47>
    b8b3:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    b8b7:	66 85 c0             	test   %ax,%ax
    b8ba:	75 0c                	jne    b8c8 <write_inode+0x53>
	inode->i_lock = 0;
    b8bc:	c6 45 36 00          	movb   $0x0,0x36(%ebp)
	wake_up(&inode->i_wait);										// kernel/sched.c
    b8c0:	83 ec 0c             	sub    $0xc,%esp
    b8c3:	e9 98 00 00 00       	jmp    b960 <write_inode+0xeb>
		unlock_inode(inode);
		return;
	}
	if (!(sb = get_super(inode->i_dev)))
    b8c8:	83 ec 0c             	sub    $0xc,%esp
    b8cb:	50                   	push   %eax
    b8cc:	e8 96 0d 00 00       	call   c667 <get_super>
    b8d1:	83 c4 10             	add    $0x10,%esp
    b8d4:	85 c0                	test   %eax,%eax
    b8d6:	89 c6                	mov    %eax,%esi
    b8d8:	75 12                	jne    b8ec <write_inode+0x77>
		panic("trying to write inode without device");
    b8da:	8d 83 62 72 ff ff    	lea    -0x8d9e(%ebx),%eax
    b8e0:	83 ec 0c             	sub    $0xc,%esp
    b8e3:	50                   	push   %eax
    b8e4:	e8 e9 c7 ff ff       	call   80d2 <panic>
    b8e9:	83 c4 10             	add    $0x10,%esp
	// 该i节点所在的设备逻辑号 = (启动块 + 超级块) + i节点位图占用的块数 + 逻辑块位图占用的块数 + (i节点号-1)/每块含有的i节点数.我们从设备上读取该i节点所
	// 在的逻辑块,并将该i节点信息复制到逻辑块对应该i节点的项位置处.
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
		(inode->i_num - 1) / INODES_PER_BLOCK;
	if (!(bh = bread(inode->i_dev, block)))
    b8ec:	52                   	push   %edx
    b8ed:	52                   	push   %edx
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    b8ee:	0f b7 46 06          	movzwl 0x6(%esi),%eax
    b8f2:	0f b7 56 04          	movzwl 0x4(%esi),%edx
    b8f6:	8d 54 02 02          	lea    0x2(%edx,%eax,1),%edx
		(inode->i_num - 1) / INODES_PER_BLOCK;
    b8fa:	0f b7 45 32          	movzwl 0x32(%ebp),%eax
    b8fe:	48                   	dec    %eax
    b8ff:	c1 e8 05             	shr    $0x5,%eax
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    b902:	01 d0                	add    %edx,%eax
	if (!(bh = bread(inode->i_dev, block)))
    b904:	50                   	push   %eax
    b905:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    b909:	50                   	push   %eax
    b90a:	e8 a1 0a 00 00       	call   c3b0 <bread>
    b90f:	83 c4 10             	add    $0x10,%esp
    b912:	85 c0                	test   %eax,%eax
    b914:	89 c2                	mov    %eax,%edx
    b916:	75 1a                	jne    b932 <write_inode+0xbd>
    b918:	89 44 24 0c          	mov    %eax,0xc(%esp)
		panic("unable to read i-node block");
    b91c:	8d 83 87 72 ff ff    	lea    -0x8d79(%ebx),%eax
    b922:	83 ec 0c             	sub    $0xc,%esp
    b925:	50                   	push   %eax
    b926:	e8 a7 c7 ff ff       	call   80d2 <panic>
    b92b:	83 c4 10             	add    $0x10,%esp
    b92e:	8b 54 24 0c          	mov    0xc(%esp),%edx
	((struct d_inode *)bh->b_data)
		[(inode->i_num - 1) % INODES_PER_BLOCK] =
    b932:	0f b7 45 32          	movzwl 0x32(%ebp),%eax
    b936:	b9 08 00 00 00       	mov    $0x8,%ecx
    b93b:	89 ee                	mov    %ebp,%esi
			*(struct d_inode *)inode;
	// 然后置缓冲区已修改标志,而i节点内容已经与缓冲区中的一致,因此修改标志置零.然后释放该含有i节点的缓冲区,并解锁该i节点.
	bh->b_dirt = 1;
	inode->i_dirt = 0;
	brelse(bh);
    b93d:	83 ec 0c             	sub    $0xc,%esp
		[(inode->i_num - 1) % INODES_PER_BLOCK] =
    b940:	48                   	dec    %eax
    b941:	83 e0 1f             	and    $0x1f,%eax
    b944:	c1 e0 05             	shl    $0x5,%eax
    b947:	03 02                	add    (%edx),%eax
    b949:	89 c7                	mov    %eax,%edi
    b94b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	bh->b_dirt = 1;
    b94d:	c6 42 0b 01          	movb   $0x1,0xb(%edx)
	inode->i_dirt = 0;
    b951:	c6 45 37 00          	movb   $0x0,0x37(%ebp)
	brelse(bh);
    b955:	52                   	push   %edx
    b956:	e8 03 0a 00 00       	call   c35e <brelse>
    b95b:	58                   	pop    %eax
	inode->i_lock = 0;
    b95c:	c6 45 36 00          	movb   $0x0,0x36(%ebp)
	wake_up(&inode->i_wait);										// kernel/sched.c
    b960:	ff 74 24 14          	pushl  0x14(%esp)
    b964:	e8 2a b5 ff ff       	call   6e93 <wake_up>
    b969:	83 c4 10             	add    $0x10,%esp
	unlock_inode(inode);
}
    b96c:	83 c4 1c             	add    $0x1c,%esp
    b96f:	5b                   	pop    %ebx
    b970:	5e                   	pop    %esi
    b971:	5f                   	pop    %edi
    b972:	5d                   	pop    %ebp
    b973:	c3                   	ret    

0000b974 <invalidate_inodes>:
{
    b974:	56                   	push   %esi
    b975:	53                   	push   %ebx
    b976:	e8 b1 b0 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    b97b:	81 c3 85 56 01 00    	add    $0x15685,%ebx
    b981:	52                   	push   %edx
	inode = 0 + inode_table;                  						// 指向i节点表指针数组首项。
    b982:	8d b3 00 31 00 00    	lea    0x3100(%ebx),%esi
		wait_on_inode(inode);           							// 等待该i节点可用（解锁）。
    b988:	89 f0                	mov    %esi,%eax
    b98a:	e8 71 fc ff ff       	call   b600 <wait_on_inode>
		if (inode->i_dev == dev) {
    b98f:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    b993:	3b 44 24 10          	cmp    0x10(%esp),%eax
    b997:	75 23                	jne    b9bc <invalidate_inodes+0x48>
			if (inode->i_count)     								// 若其引用数不为0,则显示出错警告。
    b999:	66 83 7e 34 00       	cmpw   $0x0,0x34(%esi)
    b99e:	74 12                	je     b9b2 <invalidate_inodes+0x3e>
				printk("inode in use on removed disk\n\r");
    b9a0:	8d 83 a3 72 ff ff    	lea    -0x8d5d(%ebx),%eax
    b9a6:	83 ec 0c             	sub    $0xc,%esp
    b9a9:	50                   	push   %eax
    b9aa:	e8 72 c7 ff ff       	call   8121 <printk>
    b9af:	83 c4 10             	add    $0x10,%esp
			inode->i_dev = inode->i_dirt = 0;       				// 释放i节点（置设备号为0）。
    b9b2:	c6 46 37 00          	movb   $0x0,0x37(%esi)
    b9b6:	66 c7 46 30 00 00    	movw   $0x0,0x30(%esi)
	for(i = 0 ; i < NR_INODE ; i++, inode++) {
    b9bc:	8d 83 00 40 00 00    	lea    0x4000(%ebx),%eax
    b9c2:	83 c6 3c             	add    $0x3c,%esi
    b9c5:	39 c6                	cmp    %eax,%esi
    b9c7:	75 bf                	jne    b988 <invalidate_inodes+0x14>
}
    b9c9:	58                   	pop    %eax
    b9ca:	5b                   	pop    %ebx
    b9cb:	5e                   	pop    %esi
    b9cc:	c3                   	ret    

0000b9cd <sync_inodes>:
{
    b9cd:	56                   	push   %esi
    b9ce:	53                   	push   %ebx
    b9cf:	e8 ae e4 ff ff       	call   9e82 <__x86.get_pc_thunk.si>
    b9d4:	81 c6 2c 56 01 00    	add    $0x1562c,%esi
    b9da:	52                   	push   %edx
	inode = 0 + inode_table;                          				// 让指针首先指向i节点表指针数组首项。
    b9db:	8d 9e 00 31 00 00    	lea    0x3100(%esi),%ebx
		wait_on_inode(inode);                   					// 等待该i节点可用（解锁）。
    b9e1:	89 d8                	mov    %ebx,%eax
    b9e3:	e8 18 fc ff ff       	call   b600 <wait_on_inode>
		if (inode->i_dirt && !inode->i_pipe)    					// 若i节点已修改且不是管道节点，
    b9e8:	80 7b 37 00          	cmpb   $0x0,0x37(%ebx)
    b9ec:	74 0d                	je     b9fb <sync_inodes+0x2e>
    b9ee:	80 7b 38 00          	cmpb   $0x0,0x38(%ebx)
    b9f2:	75 07                	jne    b9fb <sync_inodes+0x2e>
			write_inode(inode);             						// 则写盘（实际是写入缓冲区中）。
    b9f4:	89 d8                	mov    %ebx,%eax
    b9f6:	e8 7a fe ff ff       	call   b875 <write_inode>
	for(i = 0 ; i < NR_INODE ; i++, inode++) {           			// 扫描i节点表指针数组。
    b9fb:	8d 86 00 40 00 00    	lea    0x4000(%esi),%eax
    ba01:	83 c3 3c             	add    $0x3c,%ebx
    ba04:	39 c3                	cmp    %eax,%ebx
    ba06:	75 d9                	jne    b9e1 <sync_inodes+0x14>
}
    ba08:	58                   	pop    %eax
    ba09:	5b                   	pop    %ebx
    ba0a:	5e                   	pop    %esi
    ba0b:	c3                   	ret    

0000ba0c <bmap>:
{
    ba0c:	57                   	push   %edi
    ba0d:	56                   	push   %esi
    ba0e:	53                   	push   %ebx
    ba0f:	8b 74 24 14          	mov    0x14(%esp),%esi
    ba13:	e8 14 b0 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ba18:	81 c3 e8 55 01 00    	add    $0x155e8,%ebx
    ba1e:	8b 7c 24 10          	mov    0x10(%esp),%edi
	if (block < 0)
    ba22:	85 f6                	test   %esi,%esi
    ba24:	79 14                	jns    ba3a <bmap+0x2e>
		panic("_bmap: block<0");
    ba26:	8d 83 c2 72 ff ff    	lea    -0x8d3e(%ebx),%eax
    ba2c:	83 ec 0c             	sub    $0xc,%esp
    ba2f:	50                   	push   %eax
    ba30:	e8 9d c6 ff ff       	call   80d2 <panic>
    ba35:	83 c4 10             	add    $0x10,%esp
    ba38:	eb 2f                	jmp    ba69 <bmap+0x5d>
	if (block >= 7 + 512 + 512 * 512)
    ba3a:	81 fe 06 02 04 00    	cmp    $0x40206,%esi
    ba40:	7e 14                	jle    ba56 <bmap+0x4a>
		panic("_bmap: block>big");
    ba42:	8d 83 d1 72 ff ff    	lea    -0x8d2f(%ebx),%eax
    ba48:	83 ec 0c             	sub    $0xc,%esp
    ba4b:	50                   	push   %eax
    ba4c:	e8 81 c6 ff ff       	call   80d2 <panic>
    ba51:	83 c4 10             	add    $0x10,%esp
    ba54:	eb 05                	jmp    ba5b <bmap+0x4f>
	if (block < 7) {
    ba56:	83 fe 06             	cmp    $0x6,%esi
    ba59:	7e 0e                	jle    ba69 <bmap+0x5d>
}
    ba5b:	5b                   	pop    %ebx
    ba5c:	89 f2                	mov    %esi,%edx
    ba5e:	89 f8                	mov    %edi,%eax
    ba60:	31 c9                	xor    %ecx,%ecx
    ba62:	5e                   	pop    %esi
    ba63:	5f                   	pop    %edi
    ba64:	e9 c4 fb ff ff       	jmp    b62d <_bmap.part.0>
		return inode->i_zone[block];
    ba69:	0f b7 44 77 0e       	movzwl 0xe(%edi,%esi,2),%eax
}
    ba6e:	5b                   	pop    %ebx
    ba6f:	5e                   	pop    %esi
    ba70:	5f                   	pop    %edi
    ba71:	c3                   	ret    

0000ba72 <create_block>:
{
    ba72:	57                   	push   %edi
    ba73:	56                   	push   %esi
    ba74:	53                   	push   %ebx
    ba75:	8b 74 24 14          	mov    0x14(%esp),%esi
    ba79:	e8 ae af ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ba7e:	81 c3 82 55 01 00    	add    $0x15582,%ebx
    ba84:	8b 7c 24 10          	mov    0x10(%esp),%edi
	if (block < 0)
    ba88:	85 f6                	test   %esi,%esi
    ba8a:	79 14                	jns    baa0 <create_block+0x2e>
		panic("_bmap: block<0");
    ba8c:	8d 83 c2 72 ff ff    	lea    -0x8d3e(%ebx),%eax
    ba92:	83 ec 0c             	sub    $0xc,%esp
    ba95:	50                   	push   %eax
    ba96:	e8 37 c6 ff ff       	call   80d2 <panic>
    ba9b:	83 c4 10             	add    $0x10,%esp
    ba9e:	eb 21                	jmp    bac1 <create_block+0x4f>
	if (block >= 7 + 512 + 512 * 512)
    baa0:	81 fe 06 02 04 00    	cmp    $0x40206,%esi
    baa6:	7e 14                	jle    babc <create_block+0x4a>
		panic("_bmap: block>big");
    baa8:	8d 83 d1 72 ff ff    	lea    -0x8d2f(%ebx),%eax
    baae:	83 ec 0c             	sub    $0xc,%esp
    bab1:	50                   	push   %eax
    bab2:	e8 1b c6 ff ff       	call   80d2 <panic>
    bab7:	83 c4 10             	add    $0x10,%esp
    baba:	eb 53                	jmp    bb0f <create_block+0x9d>
	if (block < 7) {
    babc:	83 fe 06             	cmp    $0x6,%esi
    babf:	7f 4e                	jg     bb0f <create_block+0x9d>
    bac1:	01 f6                	add    %esi,%esi
    bac3:	01 fe                	add    %edi,%esi
		if (create && !inode->i_zone[block])
    bac5:	66 83 7e 0e 00       	cmpw   $0x0,0xe(%esi)
    baca:	75 54                	jne    bb20 <create_block+0xae>
			if (inode->i_zone[block] = new_block(inode->i_dev)) {
    bacc:	0f b7 47 30          	movzwl 0x30(%edi),%eax
    bad0:	83 ec 0c             	sub    $0xc,%esp
    bad3:	50                   	push   %eax
    bad4:	e8 23 3f 00 00       	call   f9fc <new_block>
    bad9:	83 c4 10             	add    $0x10,%esp
    badc:	66 85 c0             	test   %ax,%ax
    badf:	66 89 46 0e          	mov    %ax,0xe(%esi)
    bae3:	74 3b                	je     bb20 <create_block+0xae>
				inode->i_ctime = CURRENT_TIME;
    bae5:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    baeb:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    baf1:	b9 64 00 00 00       	mov    $0x64,%ecx
				inode->i_dirt = 1;
    baf6:	c6 47 37 01          	movb   $0x1,0x37(%edi)
				inode->i_ctime = CURRENT_TIME;
    bafa:	8b 00                	mov    (%eax),%eax
    bafc:	03 02                	add    (%edx),%eax
    bafe:	31 d2                	xor    %edx,%edx
    bb00:	f7 f1                	div    %ecx
    bb02:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    bb08:	03 02                	add    (%edx),%eax
    bb0a:	89 47 2c             	mov    %eax,0x2c(%edi)
    bb0d:	eb 11                	jmp    bb20 <create_block+0xae>
}
    bb0f:	5b                   	pop    %ebx
    bb10:	89 f2                	mov    %esi,%edx
    bb12:	89 f8                	mov    %edi,%eax
    bb14:	b9 01 00 00 00       	mov    $0x1,%ecx
    bb19:	5e                   	pop    %esi
    bb1a:	5f                   	pop    %edi
    bb1b:	e9 0d fb ff ff       	jmp    b62d <_bmap.part.0>
		return inode->i_zone[block];
    bb20:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
}
    bb24:	5b                   	pop    %ebx
    bb25:	5e                   	pop    %esi
    bb26:	5f                   	pop    %edi
    bb27:	c3                   	ret    

0000bb28 <iput>:
{
    bb28:	56                   	push   %esi
    bb29:	53                   	push   %ebx
    bb2a:	52                   	push   %edx
    bb2b:	8b 74 24 10          	mov    0x10(%esp),%esi
    bb2f:	e8 f8 ae ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    bb34:	81 c3 cc 54 01 00    	add    $0x154cc,%ebx
	if (!inode)
    bb3a:	85 f6                	test   %esi,%esi
    bb3c:	0f 84 cf 00 00 00    	je     bc11 <iput+0xe9>
	wait_on_inode(inode);
    bb42:	89 f0                	mov    %esi,%eax
    bb44:	e8 b7 fa ff ff       	call   b600 <wait_on_inode>
	if (!inode->i_count)
    bb49:	66 83 7e 34 00       	cmpw   $0x0,0x34(%esi)
    bb4e:	75 12                	jne    bb62 <iput+0x3a>
		panic("iput: trying to free free inode");
    bb50:	8d 83 e2 72 ff ff    	lea    -0x8d1e(%ebx),%eax
    bb56:	83 ec 0c             	sub    $0xc,%esp
    bb59:	50                   	push   %eax
    bb5a:	e8 73 c5 ff ff       	call   80d2 <panic>
    bb5f:	83 c4 10             	add    $0x10,%esp
	if (inode->i_pipe) {
    bb62:	80 7e 38 00          	cmpb   $0x0,0x38(%esi)
    bb66:	74 40                	je     bba8 <iput+0x80>
		wake_up(&inode->i_wait);
    bb68:	8d 46 20             	lea    0x20(%esi),%eax
    bb6b:	83 ec 0c             	sub    $0xc,%esp
    bb6e:	50                   	push   %eax
    bb6f:	e8 1f b3 ff ff       	call   6e93 <wake_up>
		wake_up(&inode->i_wait2);
    bb74:	8d 46 24             	lea    0x24(%esi),%eax
    bb77:	89 04 24             	mov    %eax,(%esp)
    bb7a:	e8 14 b3 ff ff       	call   6e93 <wake_up>
    bb7f:	83 c4 10             	add    $0x10,%esp
		if (--inode->i_count)
    bb82:	66 ff 4e 34          	decw   0x34(%esi)
    bb86:	0f 85 85 00 00 00    	jne    bc11 <iput+0xe9>
		free_page(inode->i_size);
    bb8c:	83 ec 0c             	sub    $0xc,%esp
    bb8f:	ff 76 04             	pushl  0x4(%esi)
    bb92:	e8 bc e3 ff ff       	call   9f53 <free_page>
    bb97:	83 c4 10             	add    $0x10,%esp
		inode->i_count = 0;
    bb9a:	66 c7 46 34 00 00    	movw   $0x0,0x34(%esi)
		inode->i_dirt = 0;
    bba0:	66 c7 46 37 00 00    	movw   $0x0,0x37(%esi)
		return;
    bba6:	eb 69                	jmp    bc11 <iput+0xe9>
	if (!inode->i_dev) {
    bba8:	66 83 7e 30 00       	cmpw   $0x0,0x30(%esi)
    bbad:	75 06                	jne    bbb5 <iput+0x8d>
		inode->i_count--;
    bbaf:	66 ff 4e 34          	decw   0x34(%esi)
		return;
    bbb3:	eb 5c                	jmp    bc11 <iput+0xe9>
	if (S_ISBLK(inode->i_mode)) {
    bbb5:	8b 06                	mov    (%esi),%eax
    bbb7:	66 25 00 f0          	and    $0xf000,%ax
    bbbb:	66 3d 00 60          	cmp    $0x6000,%ax
    bbbf:	75 17                	jne    bbd8 <iput+0xb0>
		sync_dev(inode->i_zone[0]);
    bbc1:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
    bbc5:	83 ec 0c             	sub    $0xc,%esp
    bbc8:	50                   	push   %eax
    bbc9:	e8 41 04 00 00       	call   c00f <sync_dev>
    bbce:	83 c4 10             	add    $0x10,%esp
		wait_on_inode(inode);
    bbd1:	89 f0                	mov    %esi,%eax
    bbd3:	e8 28 fa ff ff       	call   b600 <wait_on_inode>
	if (inode->i_count > 1) {
    bbd8:	8b 46 34             	mov    0x34(%esi),%eax
    bbdb:	66 83 f8 01          	cmp    $0x1,%ax
    bbdf:	77 2b                	ja     bc0c <iput+0xe4>
	if (!inode->i_nlinks) {
    bbe1:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
    bbe5:	75 16                	jne    bbfd <iput+0xd5>
		truncate(inode);
    bbe7:	83 ec 0c             	sub    $0xc,%esp
    bbea:	56                   	push   %esi
    bbeb:	e8 5b 44 00 00       	call   1004b <truncate>
		free_inode(inode);      								// bitmap.c
    bbf0:	89 34 24             	mov    %esi,(%esp)
    bbf3:	e8 4b 3f 00 00       	call   fb43 <free_inode>
    bbf8:	83 c4 10             	add    $0x10,%esp
    bbfb:	eb 14                	jmp    bc11 <iput+0xe9>
	if (inode->i_dirt) {
    bbfd:	80 7e 37 00          	cmpb   $0x0,0x37(%esi)
    bc01:	74 09                	je     bc0c <iput+0xe4>
		write_inode(inode);										/* we can sleep - so do again */
    bc03:	89 f0                	mov    %esi,%eax
    bc05:	e8 6b fc ff ff       	call   b875 <write_inode>
    bc0a:	eb c5                	jmp    bbd1 <iput+0xa9>
	inode->i_count--;
    bc0c:	48                   	dec    %eax
    bc0d:	66 89 46 34          	mov    %ax,0x34(%esi)
}
    bc11:	58                   	pop    %eax
    bc12:	5b                   	pop    %ebx
    bc13:	5e                   	pop    %esi
    bc14:	c3                   	ret    

0000bc15 <get_empty_inode>:
{
    bc15:	57                   	push   %edi
    bc16:	56                   	push   %esi
    bc17:	53                   	push   %ebx
    bc18:	e8 0f ae ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    bc1d:	81 c3 e3 53 01 00    	add    $0x153e3,%ebx
    bc23:	8b 83 6c 13 00 00    	mov    0x136c(%ebx),%eax
			if (++last_inode >= inode_table + NR_INODE)
    bc29:	8d 8b 00 40 00 00    	lea    0x4000(%ebx),%ecx
{
    bc2f:	ba 40 00 00 00       	mov    $0x40,%edx
		inode = NULL;
    bc34:	31 ff                	xor    %edi,%edi
			if (++last_inode >= inode_table + NR_INODE)
    bc36:	83 c0 3c             	add    $0x3c,%eax
    bc39:	39 c8                	cmp    %ecx,%eax
    bc3b:	72 06                	jb     bc43 <get_empty_inode+0x2e>
				last_inode = inode_table;
    bc3d:	8d 83 00 31 00 00    	lea    0x3100(%ebx),%eax
			if (!last_inode->i_count) {
    bc43:	66 83 78 34 00       	cmpw   $0x0,0x34(%eax)
    bc48:	75 13                	jne    bc5d <get_empty_inode+0x48>
				if (!inode->i_dirt && !inode->i_lock)
    bc4a:	66 83 78 36 00       	cmpw   $0x0,0x36(%eax)
    bc4f:	75 0a                	jne    bc5b <get_empty_inode+0x46>
    bc51:	89 83 6c 13 00 00    	mov    %eax,0x136c(%ebx)
    bc57:	89 c7                	mov    %eax,%edi
    bc59:	eb 50                	jmp    bcab <get_empty_inode+0x96>
    bc5b:	89 c7                	mov    %eax,%edi
		for (i = NR_INODE; i ; i--) {							// NR_INODE = 64.
    bc5d:	4a                   	dec    %edx
    bc5e:	75 d6                	jne    bc36 <get_empty_inode+0x21>
		if (!inode) {
    bc60:	85 ff                	test   %edi,%edi
    bc62:	89 83 6c 13 00 00    	mov    %eax,0x136c(%ebx)
    bc68:	75 41                	jne    bcab <get_empty_inode+0x96>
    bc6a:	31 f6                	xor    %esi,%esi
				printk("%04x: %6d\t", inode_table[i].i_dev,
    bc6c:	50                   	push   %eax
    bc6d:	0f b7 84 1e 32 31 00 	movzwl 0x3132(%esi,%ebx,1),%eax
    bc74:	00 
    bc75:	50                   	push   %eax
    bc76:	0f b7 84 1e 30 31 00 	movzwl 0x3130(%esi,%ebx,1),%eax
    bc7d:	00 
    bc7e:	83 c6 3c             	add    $0x3c,%esi
    bc81:	50                   	push   %eax
    bc82:	8d 83 02 73 ff ff    	lea    -0x8cfe(%ebx),%eax
    bc88:	50                   	push   %eax
    bc89:	e8 93 c4 ff ff       	call   8121 <printk>
    bc8e:	83 c4 10             	add    $0x10,%esp
			for (i = 0 ; i < NR_INODE ; i++)
    bc91:	81 fe 00 0f 00 00    	cmp    $0xf00,%esi
    bc97:	75 d3                	jne    bc6c <get_empty_inode+0x57>
			panic("No free inodes in mem");
    bc99:	8d 83 0d 73 ff ff    	lea    -0x8cf3(%ebx),%eax
    bc9f:	83 ec 0c             	sub    $0xc,%esp
    bca2:	50                   	push   %eax
    bca3:	e8 2a c4 ff ff       	call   80d2 <panic>
    bca8:	83 c4 10             	add    $0x10,%esp
			wait_on_inode(inode);
    bcab:	89 f8                	mov    %edi,%eax
    bcad:	e8 4e f9 ff ff       	call   b600 <wait_on_inode>
		while (inode->i_dirt) {
    bcb2:	80 7f 37 00          	cmpb   $0x0,0x37(%edi)
    bcb6:	74 09                	je     bcc1 <get_empty_inode+0xac>
			write_inode(inode);
    bcb8:	89 f8                	mov    %edi,%eax
    bcba:	e8 b6 fb ff ff       	call   b875 <write_inode>
    bcbf:	eb ea                	jmp    bcab <get_empty_inode+0x96>
	} while (inode->i_count);
    bcc1:	66 83 7f 34 00       	cmpw   $0x0,0x34(%edi)
    bcc6:	0f 85 57 ff ff ff    	jne    bc23 <get_empty_inode+0xe>
// 用字符填写指定长度内存块.
// 用字符c填写s指向的内存区域,共填count字节.
// %0 - eax(字符c),%1 - edi(内存地址),%2 - ecx(字节数count).
static inline void * memset(void * s, char c, int count)
{
__asm__(
    bccc:	31 c0                	xor    %eax,%eax
    bcce:	b9 3c 00 00 00       	mov    $0x3c,%ecx
    bcd3:	fc                   	cld    
    bcd4:	57                   	push   %edi
    bcd5:	f3 aa                	rep stos %al,%es:(%edi)
    bcd7:	5f                   	pop    %edi
	inode->i_count = 1;
    bcd8:	66 c7 47 34 01 00    	movw   $0x1,0x34(%edi)
}
    bcde:	89 f8                	mov    %edi,%eax
    bce0:	5b                   	pop    %ebx
    bce1:	5e                   	pop    %esi
    bce2:	5f                   	pop    %edi
    bce3:	c3                   	ret    

0000bce4 <get_pipe_inode>:
{
    bce4:	56                   	push   %esi
    bce5:	53                   	push   %ebx
    bce6:	51                   	push   %ecx
    bce7:	e8 40 ad ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    bcec:	81 c3 14 53 01 00    	add    $0x15314,%ebx
	if (!(inode = get_empty_inode()))
    bcf2:	e8 1e ff ff ff       	call   bc15 <get_empty_inode>
    bcf7:	85 c0                	test   %eax,%eax
    bcf9:	89 c6                	mov    %eax,%esi
    bcfb:	74 27                	je     bd24 <get_pipe_inode+0x40>
	if (!(inode->i_size = get_free_page())) {         			// 节点的i_size字段指向缓冲区。
    bcfd:	e8 03 ee ff ff       	call   ab05 <get_free_page>
    bd02:	85 c0                	test   %eax,%eax
    bd04:	89 46 04             	mov    %eax,0x4(%esi)
    bd07:	75 0a                	jne    bd13 <get_pipe_inode+0x2f>
		inode->i_count = 0;
    bd09:	66 c7 46 34 00 00    	movw   $0x0,0x34(%esi)
		return NULL;
    bd0f:	31 f6                	xor    %esi,%esi
    bd11:	eb 11                	jmp    bd24 <get_pipe_inode+0x40>
	inode->i_count = 2;											/* sum of readers/writers */    /* 读/写两者总计 */
    bd13:	66 c7 46 34 02 00    	movw   $0x2,0x34(%esi)
	PIPE_HEAD(*inode) = PIPE_TAIL(*inode) = 0;      			// 复位管道头尾指针。
    bd19:	c7 46 0e 00 00 00 00 	movl   $0x0,0xe(%esi)
	inode->i_pipe = 1;                              			// 置节点为管道使用标志。
    bd20:	c6 46 38 01          	movb   $0x1,0x38(%esi)
}
    bd24:	89 f0                	mov    %esi,%eax
    bd26:	5a                   	pop    %edx
    bd27:	5b                   	pop    %ebx
    bd28:	5e                   	pop    %esi
    bd29:	c3                   	ret    

0000bd2a <iget>:
{
    bd2a:	55                   	push   %ebp
    bd2b:	57                   	push   %edi
    bd2c:	56                   	push   %esi
    bd2d:	53                   	push   %ebx
    bd2e:	e8 f9 ac ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    bd33:	81 c3 cd 52 01 00    	add    $0x152cd,%ebx
    bd39:	83 ec 1c             	sub    $0x1c,%esp
    bd3c:	8b 74 24 30          	mov    0x30(%esp),%esi
	if (!dev)
    bd40:	85 f6                	test   %esi,%esi
    bd42:	75 12                	jne    bd56 <iget+0x2c>
		panic("iget with dev==0");
    bd44:	8d 83 23 73 ff ff    	lea    -0x8cdd(%ebx),%eax
    bd4a:	83 ec 0c             	sub    $0xc,%esp
    bd4d:	50                   	push   %eax
    bd4e:	e8 7f c3 ff ff       	call   80d2 <panic>
    bd53:	83 c4 10             	add    $0x10,%esp
	empty = get_empty_inode();
    bd56:	e8 ba fe ff ff       	call   bc15 <get_empty_inode>
	inode = inode_table;
    bd5b:	8d 93 00 31 00 00    	lea    0x3100(%ebx),%edx
				if (super_block[i].s_imount == inode)
    bd61:	c7 c7 00 4b 03 00    	mov    $0x34b00,%edi
	empty = get_empty_inode();
    bd67:	89 c5                	mov    %eax,%ebp
    bd69:	89 54 24 08          	mov    %edx,0x8(%esp)
		if (inode->i_dev != dev || inode->i_num != nr) {
    bd6d:	0f b7 42 30          	movzwl 0x30(%edx),%eax
    bd71:	39 f0                	cmp    %esi,%eax
    bd73:	75 0a                	jne    bd7f <iget+0x55>
    bd75:	0f b7 42 32          	movzwl 0x32(%edx),%eax
    bd79:	3b 44 24 34          	cmp    0x34(%esp),%eax
    bd7d:	74 12                	je     bd91 <iget+0x67>
	while (inode < NR_INODE + inode_table) {
    bd7f:	8d 83 00 40 00 00    	lea    0x4000(%ebx),%eax
			inode++;
    bd85:	83 c2 3c             	add    $0x3c,%edx
	while (inode < NR_INODE + inode_table) {
    bd88:	39 c2                	cmp    %eax,%edx
    bd8a:	72 e1                	jb     bd6d <iget+0x43>
    bd8c:	e9 87 00 00 00       	jmp    be18 <iget+0xee>
		wait_on_inode(inode);
    bd91:	89 d0                	mov    %edx,%eax
    bd93:	89 54 24 0c          	mov    %edx,0xc(%esp)
    bd97:	e8 64 f8 ff ff       	call   b600 <wait_on_inode>
		if (inode->i_dev != dev || inode->i_num != nr) {
    bd9c:	8b 54 24 0c          	mov    0xc(%esp),%edx
    bda0:	0f b7 42 30          	movzwl 0x30(%edx),%eax
    bda4:	39 f0                	cmp    %esi,%eax
    bda6:	0f 85 9a 01 00 00    	jne    bf46 <iget+0x21c>
    bdac:	0f b7 42 32          	movzwl 0x32(%edx),%eax
    bdb0:	3b 44 24 34          	cmp    0x34(%esp),%eax
    bdb4:	0f 85 8c 01 00 00    	jne    bf46 <iget+0x21c>
		inode->i_count++;
    bdba:	66 ff 42 34          	incw   0x34(%edx)
		if (inode->i_mount) {
    bdbe:	80 7a 39 00          	cmpb   $0x0,0x39(%edx)
    bdc2:	74 33                	je     bdf7 <iget+0xcd>
			for (i = 0 ; i < NR_SUPER ; i++)
    bdc4:	31 c0                	xor    %eax,%eax
				if (super_block[i].s_imount == inode)
    bdc6:	6b f0 6c             	imul   $0x6c,%eax,%esi
    bdc9:	39 54 3e 5c          	cmp    %edx,0x5c(%esi,%edi,1)
    bdcd:	0f 84 5a 01 00 00    	je     bf2d <iget+0x203>
			for (i = 0 ; i < NR_SUPER ; i++)
    bdd3:	40                   	inc    %eax
    bdd4:	83 f8 08             	cmp    $0x8,%eax
    bdd7:	75 ed                	jne    bdc6 <iget+0x9c>
				printk("Mounted inode hasn't got sb\n");
    bdd9:	8d 83 55 73 ff ff    	lea    -0x8cab(%ebx),%eax
    bddf:	89 54 24 08          	mov    %edx,0x8(%esp)
    bde3:	83 ec 0c             	sub    $0xc,%esp
    bde6:	50                   	push   %eax
    bde7:	e8 35 c3 ff ff       	call   8121 <printk>
    bdec:	83 c4 10             	add    $0x10,%esp
				if (empty)
    bdef:	8b 54 24 08          	mov    0x8(%esp),%edx
    bdf3:	85 ed                	test   %ebp,%ebp
    bdf5:	eb 02                	jmp    bdf9 <iget+0xcf>
		if (empty)
    bdf7:	85 ed                	test   %ebp,%ebp
    bdf9:	0f 84 50 01 00 00    	je     bf4f <iget+0x225>
    bdff:	89 54 24 08          	mov    %edx,0x8(%esp)
			iput(empty);
    be03:	83 ec 0c             	sub    $0xc,%esp
    be06:	55                   	push   %ebp
    be07:	e8 1c fd ff ff       	call   bb28 <iput>
    be0c:	83 c4 10             	add    $0x10,%esp
    be0f:	8b 54 24 08          	mov    0x8(%esp),%edx
    be13:	e9 37 01 00 00       	jmp    bf4f <iget+0x225>
		return (NULL);
    be18:	31 d2                	xor    %edx,%edx
	if (!empty)
    be1a:	85 ed                	test   %ebp,%ebp
    be1c:	0f 84 2d 01 00 00    	je     bf4f <iget+0x225>
	inode->i_num = nr;									// 设置i节点号.
    be22:	8b 44 24 34          	mov    0x34(%esp),%eax
	inode->i_dev = dev;									// 设置i节点的设备.
    be26:	66 89 75 30          	mov    %si,0x30(%ebp)
	inode->i_num = nr;									// 设置i节点号.
    be2a:	66 89 45 32          	mov    %ax,0x32(%ebp)
	cli();
    be2e:	fa                   	cli    
	while (inode->i_lock)
    be2f:	80 7d 36 00          	cmpb   $0x0,0x36(%ebp)
    be33:	8d 45 20             	lea    0x20(%ebp),%eax
    be36:	89 44 24 08          	mov    %eax,0x8(%esp)
    be3a:	74 11                	je     be4d <iget+0x123>
		sleep_on(&inode->i_wait);
    be3c:	83 ec 0c             	sub    $0xc,%esp
    be3f:	ff 74 24 14          	pushl  0x14(%esp)
    be43:	e8 3d b0 ff ff       	call   6e85 <sleep_on>
    be48:	83 c4 10             	add    $0x10,%esp
    be4b:	eb e2                	jmp    be2f <iget+0x105>
	inode->i_lock = 1;												// 置锁定标志.
    be4d:	c6 45 36 01          	movb   $0x1,0x36(%ebp)
	sti();
    be51:	fb                   	sti    
	if (!(sb = get_super(inode->i_dev)))
    be52:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    be56:	83 ec 0c             	sub    $0xc,%esp
    be59:	50                   	push   %eax
    be5a:	e8 08 08 00 00       	call   c667 <get_super>
    be5f:	83 c4 10             	add    $0x10,%esp
    be62:	85 c0                	test   %eax,%eax
    be64:	89 c6                	mov    %eax,%esi
    be66:	75 12                	jne    be7a <iget+0x150>
		panic("trying to read inode without dev");
    be68:	8d 83 34 73 ff ff    	lea    -0x8ccc(%ebx),%eax
    be6e:	83 ec 0c             	sub    $0xc,%esp
    be71:	50                   	push   %eax
    be72:	e8 5b c2 ff ff       	call   80d2 <panic>
    be77:	83 c4 10             	add    $0x10,%esp
	if (!(bh = bread(inode->i_dev, block)))
    be7a:	50                   	push   %eax
    be7b:	50                   	push   %eax
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    be7c:	0f b7 46 06          	movzwl 0x6(%esi),%eax
    be80:	0f b7 4e 04          	movzwl 0x4(%esi),%ecx
    be84:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
		(inode->i_num - 1) / INODES_PER_BLOCK;
    be88:	0f b7 45 32          	movzwl 0x32(%ebp),%eax
    be8c:	48                   	dec    %eax
    be8d:	c1 e8 05             	shr    $0x5,%eax
	block = 2 + sb->s_imap_blocks + sb->s_zmap_blocks +
    be90:	01 c8                	add    %ecx,%eax
	if (!(bh = bread(inode->i_dev, block)))
    be92:	50                   	push   %eax
    be93:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    be97:	50                   	push   %eax
    be98:	e8 13 05 00 00       	call   c3b0 <bread>
    be9d:	83 c4 10             	add    $0x10,%esp
    bea0:	85 c0                	test   %eax,%eax
    bea2:	75 1a                	jne    bebe <iget+0x194>
		panic("unable to read i-node block");
    bea4:	8d 8b 87 72 ff ff    	lea    -0x8d79(%ebx),%ecx
    beaa:	89 44 24 0c          	mov    %eax,0xc(%esp)
    beae:	83 ec 0c             	sub    $0xc,%esp
    beb1:	51                   	push   %ecx
    beb2:	e8 1b c2 ff ff       	call   80d2 <panic>
    beb7:	83 c4 10             	add    $0x10,%esp
    beba:	8b 44 24 0c          	mov    0xc(%esp),%eax
			[(inode->i_num - 1) % INODES_PER_BLOCK];
    bebe:	0f b7 75 32          	movzwl 0x32(%ebp),%esi
	*(struct d_inode *)inode =
    bec2:	b9 08 00 00 00       	mov    $0x8,%ecx
    bec7:	89 ef                	mov    %ebp,%edi
	brelse(bh);
    bec9:	83 ec 0c             	sub    $0xc,%esp
			[(inode->i_num - 1) % INODES_PER_BLOCK];
    becc:	4e                   	dec    %esi
    becd:	83 e6 1f             	and    $0x1f,%esi
	*(struct d_inode *)inode =
    bed0:	c1 e6 05             	shl    $0x5,%esi
    bed3:	03 30                	add    (%eax),%esi
    bed5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	brelse(bh);
    bed7:	50                   	push   %eax
    bed8:	e8 81 04 00 00       	call   c35e <brelse>
	if (S_ISBLK(inode->i_mode)) {
    bedd:	8b 45 00             	mov    0x0(%ebp),%eax
	brelse(bh);
    bee0:	83 c4 10             	add    $0x10,%esp
	if (S_ISBLK(inode->i_mode)) {
    bee3:	66 25 00 f0          	and    $0xf000,%ax
    bee7:	66 3d 00 60          	cmp    $0x6000,%ax
    beeb:	75 29                	jne    bf16 <iget+0x1ec>
		int i = inode->i_zone[0];							// 对于块设备文件,i_zone[0]中是设备号.
    beed:	66 8b 45 0e          	mov    0xe(%ebp),%ax
		if (blk_size[MAJOR(i)])
    bef1:	c7 c1 20 50 02 00    	mov    $0x25020,%ecx
    bef7:	0f b6 f4             	movzbl %ah,%esi
    befa:	8b 0c b1             	mov    (%ecx,%esi,4),%ecx
    befd:	85 c9                	test   %ecx,%ecx
    beff:	74 0e                	je     bf0f <iget+0x1e5>
			inode->i_size = 1024 * blk_size[MAJOR(i)][MINOR(i)];
    bf01:	0f b6 c0             	movzbl %al,%eax
    bf04:	8b 04 81             	mov    (%ecx,%eax,4),%eax
    bf07:	c1 e0 0a             	shl    $0xa,%eax
    bf0a:	89 45 04             	mov    %eax,0x4(%ebp)
    bf0d:	eb 07                	jmp    bf16 <iget+0x1ec>
			inode->i_size = 0x7fffffff;
    bf0f:	c7 45 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%ebp)
	wake_up(&inode->i_wait);										// kernel/sched.c
    bf16:	83 ec 0c             	sub    $0xc,%esp
	inode->i_lock = 0;
    bf19:	c6 45 36 00          	movb   $0x0,0x36(%ebp)
	wake_up(&inode->i_wait);										// kernel/sched.c
    bf1d:	ff 74 24 14          	pushl  0x14(%esp)
    bf21:	e8 6d af ff ff       	call   6e93 <wake_up>
    bf26:	83 c4 10             	add    $0x10,%esp
    bf29:	89 ea                	mov    %ebp,%edx
    bf2b:	eb 22                	jmp    bf4f <iget+0x225>
			iput(inode);
    bf2d:	83 ec 0c             	sub    $0xc,%esp
    bf30:	52                   	push   %edx
    bf31:	e8 f2 fb ff ff       	call   bb28 <iput>
			dev = super_block[i].s_dev;
    bf36:	0f b7 74 3e 54       	movzwl 0x54(%esi,%edi,1),%esi
			iput(inode);
    bf3b:	83 c4 10             	add    $0x10,%esp
			nr = ROOT_INO;
    bf3e:	c7 44 24 34 01 00 00 	movl   $0x1,0x34(%esp)
    bf45:	00 
{
    bf46:	8b 54 24 08          	mov    0x8(%esp),%edx
    bf4a:	e9 1e fe ff ff       	jmp    bd6d <iget+0x43>
}
    bf4f:	83 c4 1c             	add    $0x1c,%esp
    bf52:	89 d0                	mov    %edx,%eax
    bf54:	5b                   	pop    %ebx
    bf55:	5e                   	pop    %esi
    bf56:	5f                   	pop    %edi
    bf57:	5d                   	pop    %ebp
    bf58:	c3                   	ret    

0000bf59 <find_buffer>:
}

// 利用hash表在高速缓冲中寻找给定设备和指定块号的缓冲区块.
// 如果找到则返回缓冲区块的指针,否则返回NULL.
static struct buffer_head * find_buffer(int dev, int block)
{
    bf59:	57                   	push   %edi
    bf5a:	89 c1                	mov    %eax,%ecx
    bf5c:	56                   	push   %esi
	struct buffer_head * tmp;

	// 搜索hash表,寻找指定设备与和块号的缓冲块.
	for (tmp = hash(dev, block) ; tmp != NULL ; tmp = tmp->b_next)
    bf5d:	31 d0                	xor    %edx,%eax
{
    bf5f:	53                   	push   %ebx
	for (tmp = hash(dev, block) ; tmp != NULL ; tmp = tmp->b_next)
    bf60:	bf 33 01 00 00       	mov    $0x133,%edi
{
    bf65:	89 d3                	mov    %edx,%ebx
	for (tmp = hash(dev, block) ; tmp != NULL ; tmp = tmp->b_next)
    bf67:	31 d2                	xor    %edx,%edx
    bf69:	f7 f7                	div    %edi
    bf6b:	e8 12 df ff ff       	call   9e82 <__x86.get_pc_thunk.si>
    bf70:	81 c6 90 50 01 00    	add    $0x15090,%esi
    bf76:	c7 c6 20 46 03 00    	mov    $0x34620,%esi
    bf7c:	8b 04 96             	mov    (%esi,%edx,4),%eax
    bf7f:	85 c0                	test   %eax,%eax
    bf81:	74 12                	je     bf95 <find_buffer+0x3c>
		if (tmp->b_dev == dev && tmp->b_blocknr == block)
    bf83:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    bf87:	39 ca                	cmp    %ecx,%edx
    bf89:	75 05                	jne    bf90 <find_buffer+0x37>
    bf8b:	39 58 04             	cmp    %ebx,0x4(%eax)
    bf8e:	74 05                	je     bf95 <find_buffer+0x3c>
	for (tmp = hash(dev, block) ; tmp != NULL ; tmp = tmp->b_next)
    bf90:	8b 40 18             	mov    0x18(%eax),%eax
    bf93:	eb ea                	jmp    bf7f <find_buffer+0x26>
			return tmp;
	return NULL;
}
    bf95:	5b                   	pop    %ebx
    bf96:	5e                   	pop    %esi
    bf97:	5f                   	pop    %edi
    bf98:	c3                   	ret    

0000bf99 <wait_on_buffer>:
{
    bf99:	56                   	push   %esi
    bf9a:	53                   	push   %ebx
    bf9b:	89 c6                	mov    %eax,%esi
    bf9d:	52                   	push   %edx
    bf9e:	e8 89 aa ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    bfa3:	81 c3 5d 50 01 00    	add    $0x1505d,%ebx
	cli();							// 关中断
    bfa9:	fa                   	cli    
	while (bh->b_lock)				// 如果已被上锁则进程进入睡眠,等待其解锁.
    bfaa:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
    bfae:	74 11                	je     bfc1 <wait_on_buffer+0x28>
		sleep_on(&bh->b_wait);
    bfb0:	8d 46 10             	lea    0x10(%esi),%eax
    bfb3:	83 ec 0c             	sub    $0xc,%esp
    bfb6:	50                   	push   %eax
    bfb7:	e8 c9 ae ff ff       	call   6e85 <sleep_on>
    bfbc:	83 c4 10             	add    $0x10,%esp
    bfbf:	eb e9                	jmp    bfaa <wait_on_buffer+0x11>
	sti();							// 开中断.
    bfc1:	fb                   	sti    
}
    bfc2:	58                   	pop    %eax
    bfc3:	5b                   	pop    %ebx
    bfc4:	5e                   	pop    %esi
    bfc5:	c3                   	ret    

0000bfc6 <sys_sync>:
{
    bfc6:	57                   	push   %edi
    bfc7:	56                   	push   %esi
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    bfc8:	31 ff                	xor    %edi,%edi
{
    bfca:	53                   	push   %ebx
    bfcb:	e8 5c aa ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    bfd0:	81 c3 30 50 01 00    	add    $0x15030,%ebx
	sync_inodes();							/* write out inodes into buffers */
    bfd6:	e8 f2 f9 ff ff       	call   b9cd <sync_inodes>
	bh = start_buffer;      				// bh指向缓冲开始处。
    bfdb:	8b b3 70 13 00 00    	mov    0x1370(%ebx),%esi
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    bfe1:	39 bb 00 40 00 00    	cmp    %edi,0x4000(%ebx)
    bfe7:	7e 20                	jle    c009 <sys_sync+0x43>
		wait_on_buffer(bh);             	// 等待缓冲区解锁（如果已上锁的话）。
    bfe9:	89 f0                	mov    %esi,%eax
    bfeb:	e8 a9 ff ff ff       	call   bf99 <wait_on_buffer>
		if (bh->b_dirt)
    bff0:	80 7e 0b 00          	cmpb   $0x0,0xb(%esi)
    bff4:	74 0d                	je     c003 <sys_sync+0x3d>
			ll_rw_block(WRITE, bh);  		// 产生写设备块请求。
    bff6:	50                   	push   %eax
    bff7:	50                   	push   %eax
    bff8:	56                   	push   %esi
    bff9:	6a 01                	push   $0x1
    bffb:	e8 11 49 00 00       	call   10911 <ll_rw_block>
    c000:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c003:	47                   	inc    %edi
    c004:	83 c6 24             	add    $0x24,%esi
    c007:	eb d8                	jmp    bfe1 <sys_sync+0x1b>
}
    c009:	5b                   	pop    %ebx
    c00a:	31 c0                	xor    %eax,%eax
    c00c:	5e                   	pop    %esi
    c00d:	5f                   	pop    %edi
    c00e:	c3                   	ret    

0000c00f <sync_dev>:
{
    c00f:	55                   	push   %ebp
    c010:	57                   	push   %edi
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c011:	31 ff                	xor    %edi,%edi
{
    c013:	56                   	push   %esi
    c014:	53                   	push   %ebx
    c015:	e8 12 aa ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c01a:	81 c3 e6 4f 01 00    	add    $0x14fe6,%ebx
    c020:	83 ec 0c             	sub    $0xc,%esp
    c023:	8b 74 24 20          	mov    0x20(%esp),%esi
	bh = start_buffer;                      		// bf指向缓冲区开始处。
    c027:	8b ab 70 13 00 00    	mov    0x1370(%ebx),%ebp
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c02d:	39 bb 00 40 00 00    	cmp    %edi,0x4000(%ebx)
    c033:	7e 30                	jle    c065 <sync_dev+0x56>
		if (bh->b_dev != dev)           			// 不是设备dev的缓冲块则继续。
    c035:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    c039:	39 f0                	cmp    %esi,%eax
    c03b:	75 22                	jne    c05f <sync_dev+0x50>
		wait_on_buffer(bh);             			// 等待缓冲区解锁（如果已上锁的话）。
    c03d:	89 e8                	mov    %ebp,%eax
    c03f:	e8 55 ff ff ff       	call   bf99 <wait_on_buffer>
		if (bh->b_dev == dev && bh->b_dirt)
    c044:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    c048:	39 f0                	cmp    %esi,%eax
    c04a:	75 13                	jne    c05f <sync_dev+0x50>
    c04c:	80 7d 0b 00          	cmpb   $0x0,0xb(%ebp)
    c050:	74 0d                	je     c05f <sync_dev+0x50>
			ll_rw_block(WRITE, bh);
    c052:	52                   	push   %edx
    c053:	52                   	push   %edx
    c054:	55                   	push   %ebp
    c055:	6a 01                	push   $0x1
    c057:	e8 b5 48 00 00       	call   10911 <ll_rw_block>
    c05c:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c05f:	47                   	inc    %edi
    c060:	83 c5 24             	add    $0x24,%ebp
    c063:	eb c8                	jmp    c02d <sync_dev+0x1e>
	sync_inodes();
    c065:	e8 63 f9 ff ff       	call   b9cd <sync_inodes>
	bh = start_buffer;
    c06a:	8b ab 70 13 00 00    	mov    0x1370(%ebx),%ebp
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c070:	31 ff                	xor    %edi,%edi
    c072:	39 bb 00 40 00 00    	cmp    %edi,0x4000(%ebx)
    c078:	7e 30                	jle    c0aa <sync_dev+0x9b>
		if (bh->b_dev != dev)
    c07a:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    c07e:	39 f0                	cmp    %esi,%eax
    c080:	75 22                	jne    c0a4 <sync_dev+0x95>
		wait_on_buffer(bh);
    c082:	89 e8                	mov    %ebp,%eax
    c084:	e8 10 ff ff ff       	call   bf99 <wait_on_buffer>
		if (bh->b_dev == dev && bh->b_dirt)
    c089:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
    c08d:	39 f0                	cmp    %esi,%eax
    c08f:	75 13                	jne    c0a4 <sync_dev+0x95>
    c091:	80 7d 0b 00          	cmpb   $0x0,0xb(%ebp)
    c095:	74 0d                	je     c0a4 <sync_dev+0x95>
			ll_rw_block(WRITE, bh);
    c097:	50                   	push   %eax
    c098:	50                   	push   %eax
    c099:	55                   	push   %ebp
    c09a:	6a 01                	push   $0x1
    c09c:	e8 70 48 00 00       	call   10911 <ll_rw_block>
    c0a1:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c0a4:	47                   	inc    %edi
    c0a5:	83 c5 24             	add    $0x24,%ebp
    c0a8:	eb c8                	jmp    c072 <sync_dev+0x63>
}
    c0aa:	83 c4 0c             	add    $0xc,%esp
    c0ad:	31 c0                	xor    %eax,%eax
    c0af:	5b                   	pop    %ebx
    c0b0:	5e                   	pop    %esi
    c0b1:	5f                   	pop    %edi
    c0b2:	5d                   	pop    %ebp
    c0b3:	c3                   	ret    

0000c0b4 <invalidate_buffers>:
{
    c0b4:	57                   	push   %edi
    c0b5:	56                   	push   %esi
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c0b6:	31 f6                	xor    %esi,%esi
    c0b8:	e8 d3 46 00 00       	call   10790 <__x86.get_pc_thunk.di>
    c0bd:	81 c7 43 4f 01 00    	add    $0x14f43,%edi
{
    c0c3:	53                   	push   %ebx
	bh = start_buffer;
    c0c4:	8b 9f 70 13 00 00    	mov    0x1370(%edi),%ebx
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c0ca:	39 b7 00 40 00 00    	cmp    %esi,0x4000(%edi)
    c0d0:	7e 29                	jle    c0fb <invalidate_buffers+0x47>
		if (bh->b_dev != dev)           // 如果不是指定设备的缓冲块，则继续扫描下一块。
    c0d2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    c0d6:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c0da:	75 19                	jne    c0f5 <invalidate_buffers+0x41>
		wait_on_buffer(bh);             // 等待该缓冲区解锁（如果已被上锁）。
    c0dc:	89 d8                	mov    %ebx,%eax
    c0de:	e8 b6 fe ff ff       	call   bf99 <wait_on_buffer>
		if (bh->b_dev == dev)
    c0e3:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    c0e7:	39 44 24 10          	cmp    %eax,0x10(%esp)
    c0eb:	75 08                	jne    c0f5 <invalidate_buffers+0x41>
			bh->b_uptodate = bh->b_dirt = 0;
    c0ed:	c6 43 0b 00          	movb   $0x0,0xb(%ebx)
    c0f1:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
	for (i = 0 ; i < NR_BUFFERS ; i++, bh++) {
    c0f5:	46                   	inc    %esi
    c0f6:	83 c3 24             	add    $0x24,%ebx
    c0f9:	eb cf                	jmp    c0ca <invalidate_buffers+0x16>
}
    c0fb:	5b                   	pop    %ebx
    c0fc:	5e                   	pop    %esi
    c0fd:	5f                   	pop    %edi
    c0fe:	c3                   	ret    

0000c0ff <check_disk_change>:
{
    c0ff:	55                   	push   %ebp
    c100:	57                   	push   %edi
    c101:	56                   	push   %esi
    c102:	53                   	push   %ebx
    c103:	e8 24 a9 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c108:	81 c3 f8 4e 01 00    	add    $0x14ef8,%ebx
    c10e:	83 ec 0c             	sub    $0xc,%esp
    c111:	8b 74 24 20          	mov    0x20(%esp),%esi
	if (MAJOR(dev) != 2)
    c115:	89 f0                	mov    %esi,%eax
    c117:	c1 e8 08             	shr    $0x8,%eax
    c11a:	83 f8 02             	cmp    $0x2,%eax
    c11d:	75 56                	jne    c175 <check_disk_change+0x76>
	if (!floppy_change(dev & 0x03))
    c11f:	89 f0                	mov    %esi,%eax
    c121:	83 ec 0c             	sub    $0xc,%esp
    c124:	83 e0 03             	and    $0x3,%eax
    c127:	50                   	push   %eax
    c128:	e8 73 4f 00 00       	call   110a0 <floppy_change>
    c12d:	83 c4 10             	add    $0x10,%esp
    c130:	85 c0                	test   %eax,%eax
    c132:	74 41                	je     c175 <check_disk_change+0x76>
		if (super_block[i].s_dev == dev)
    c134:	c7 c5 00 4b 03 00    	mov    $0x34b00,%ebp
    c13a:	31 ff                	xor    %edi,%edi
    c13c:	0f b7 44 2f 54       	movzwl 0x54(%edi,%ebp,1),%eax
    c141:	39 f0                	cmp    %esi,%eax
    c143:	75 0c                	jne    c151 <check_disk_change+0x52>
			put_super(super_block[i].s_dev);
    c145:	83 ec 0c             	sub    $0xc,%esp
    c148:	56                   	push   %esi
    c149:	e8 a5 07 00 00       	call   c8f3 <put_super>
    c14e:	83 c4 10             	add    $0x10,%esp
    c151:	83 c7 6c             	add    $0x6c,%edi
	for (i = 0 ; i < NR_SUPER ; i++)
    c154:	81 ff 60 03 00 00    	cmp    $0x360,%edi
    c15a:	75 e0                	jne    c13c <check_disk_change+0x3d>
	invalidate_inodes(dev);         // 释放设备dev在内存i节点表中的所有i节点
    c15c:	83 ec 0c             	sub    $0xc,%esp
    c15f:	56                   	push   %esi
    c160:	e8 0f f8 ff ff       	call   b974 <invalidate_inodes>
	invalidate_buffers(dev);        //
    c165:	89 74 24 30          	mov    %esi,0x30(%esp)
}
    c169:	83 c4 1c             	add    $0x1c,%esp
    c16c:	5b                   	pop    %ebx
    c16d:	5e                   	pop    %esi
    c16e:	5f                   	pop    %edi
    c16f:	5d                   	pop    %ebp
	invalidate_buffers(dev);        //
    c170:	e9 3f ff ff ff       	jmp    c0b4 <invalidate_buffers>
}
    c175:	83 c4 0c             	add    $0xc,%esp
    c178:	5b                   	pop    %ebx
    c179:	5e                   	pop    %esi
    c17a:	5f                   	pop    %edi
    c17b:	5d                   	pop    %ebp
    c17c:	c3                   	ret    

0000c17d <get_hash_table>:
 * 代码为什么会是这样子的?我听见你问......原因是竞争条件.由于我们没有对缓冲块上锁(除非我们正在读取它们的数据),那么当我们(进程)睡眠时缓冲块可能
 * 发生一些问题(例如一个读错误将导致该缓冲块出错).目前这种情况实际上是不会发生的,但处理的代码已经准备好了.
 */
// 利用hash表在高速缓冲区中寻找指定的缓冲块.若找到则对该缓冲块上锁并返回块头指针.
struct buffer_head * get_hash_table(int dev, int block)
{
    c17d:	56                   	push   %esi
    c17e:	53                   	push   %ebx
    c17f:	51                   	push   %ecx
    c180:	8b 74 24 14          	mov    0x14(%esp),%esi
	struct buffer_head * bh;

	for (;;) {
		// 在高速缓冲中寻找给定设备和指定块的缓冲区块,如果没有找到则返回NULL,退出.
		if (!(bh = find_buffer(dev, block)))
    c184:	8b 44 24 10          	mov    0x10(%esp),%eax
    c188:	89 f2                	mov    %esi,%edx
    c18a:	e8 ca fd ff ff       	call   bf59 <find_buffer>
    c18f:	85 c0                	test   %eax,%eax
    c191:	89 c3                	mov    %eax,%ebx
    c193:	74 1c                	je     c1b1 <get_hash_table+0x34>
			return NULL;
		// 对该缓冲块增加引用计数,并等待该缓冲块解锁(如果已被上锁).由于经过了睡眠状态,因此有必要再验证该缓冲块的正确性,并返回缓冲块头指针.
		bh->b_count++;
    c195:	fe 40 0c             	incb   0xc(%eax)
		wait_on_buffer(bh);
    c198:	e8 fc fd ff ff       	call   bf99 <wait_on_buffer>
		if (bh->b_dev == dev && bh->b_blocknr == block)
    c19d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
    c1a1:	3b 44 24 10          	cmp    0x10(%esp),%eax
    c1a5:	75 05                	jne    c1ac <get_hash_table+0x2f>
    c1a7:	39 73 04             	cmp    %esi,0x4(%ebx)
    c1aa:	74 05                	je     c1b1 <get_hash_table+0x34>
			return bh;
		// 如果在睡眠时该缓冲块所属的设备号或块号发生的改变,则撤消对它的用计数.重新寻找.
		bh->b_count--;
    c1ac:	fe 4b 0c             	decb   0xc(%ebx)
		if (!(bh = find_buffer(dev, block)))
    c1af:	eb d3                	jmp    c184 <get_hash_table+0x7>
	}
}
    c1b1:	89 d8                	mov    %ebx,%eax
    c1b3:	5a                   	pop    %edx
    c1b4:	5b                   	pop    %ebx
    c1b5:	5e                   	pop    %esi
    c1b6:	c3                   	ret    

0000c1b7 <getblk>:
#define BADNESS(bh) (((bh)->b_dirt << 1) + (bh)->b_lock)
// 取高速缓冲中指定的缓冲块.
// 检查指定(设备号和块号)的缓冲区是否已经在高速缓冲中.如果指定块已经在高速缓冲中,则返回对应缓冲区头指针退出;如果不在,就需要在高速中
// 中设置一个对应设备号和块号的新项.返回相应缓冲区头指针.
struct buffer_head * getblk(int dev, int block)
{
    c1b7:	55                   	push   %ebp
    c1b8:	57                   	push   %edi
    c1b9:	56                   	push   %esi
    c1ba:	53                   	push   %ebx
    c1bb:	e8 6c a8 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c1c0:	81 c3 40 4e 01 00    	add    $0x14e40,%ebx
    c1c6:	83 ec 1c             	sub    $0x1c,%esp
    c1c9:	8b 7c 24 30          	mov    0x30(%esp),%edi
	struct buffer_head * tmp, * bh;

repeat:
	if (bh = get_hash_table(dev, block))
    c1cd:	50                   	push   %eax
    c1ce:	50                   	push   %eax
    c1cf:	ff 74 24 3c          	pushl  0x3c(%esp)
    c1d3:	57                   	push   %edi
    c1d4:	e8 a4 ff ff ff       	call   c17d <get_hash_table>
    c1d9:	83 c4 10             	add    $0x10,%esp
    c1dc:	85 c0                	test   %eax,%eax
    c1de:	89 c6                	mov    %eax,%esi
    c1e0:	0f 85 6e 01 00 00    	jne    c354 <getblk+0x19d>
		return bh;
	// 扫描空闲数据块链表,寻找空闲缓冲区.
	// 首先让tmp指向空闲链表的第一个空闲缓冲区头.
	tmp = free_list;
    c1e6:	8b ab 08 40 00 00    	mov    0x4008(%ebx),%ebp
    c1ec:	89 e8                	mov    %ebp,%eax
	do {
		// 如果该缓冲区正在被使用(引用计数不等于0),则继续扫描下一项.对于b_count=0的块,即高速缓冲中当前没有引用的块不一定就是干净的(b_dirt=0)
		// 或没有锁定的(b_lock=0).因此,我们还是需要继续下面的判断和选择.例如当一个任务改写过一块内容后就释放了,于是该块b_count=0,但b_lock不等于0;
		// 当一个任务执行breada()预读几个块时,只要ll_rw_block()命令发出后,它就会递减b_count;但此时实际上硬盘访问操作可能还在进行,因此此时
		// b_lock=1,但b_count=0.
		if (tmp->b_count)
    c1ee:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
    c1f2:	75 2c                	jne    c220 <getblk+0x69>
    c1f4:	0f b6 50 0b          	movzbl 0xb(%eax),%edx
    c1f8:	0f b6 48 0d          	movzbl 0xd(%eax),%ecx
    c1fc:	01 d2                	add    %edx,%edx
    c1fe:	01 ca                	add    %ecx,%edx
			continue;
		// 如果缓冲头指针bh为空,或者tmp所指缓冲头的标志(修改,锁定)权重小于bh头标志的权重,则让bh指向tmp缓冲块头.如果该tmp缓冲块头表明缓冲
		// 块既没有修改也没有锁定标志置位,则说明已为指定设备上的块取得对应的高速缓冲块,则退出循环.否则我们就继续执行本循环,看看能否找到一个BADNESS()
		// 最小的缓冲块.
		if (!bh || BADNESS(tmp) < BADNESS(bh)) {
    c200:	85 f6                	test   %esi,%esi
    c202:	74 16                	je     c21a <getblk+0x63>
    c204:	0f b6 4e 0b          	movzbl 0xb(%esi),%ecx
    c208:	01 c9                	add    %ecx,%ecx
    c20a:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    c20e:	0f b6 4e 0d          	movzbl 0xd(%esi),%ecx
    c212:	03 4c 24 0c          	add    0xc(%esp),%ecx
    c216:	39 d1                	cmp    %edx,%ecx
    c218:	7e 06                	jle    c220 <getblk+0x69>
			bh = tmp;
			if (!BADNESS(tmp))
    c21a:	85 d2                	test   %edx,%edx
    c21c:	89 c6                	mov    %eax,%esi
    c21e:	74 35                	je     c255 <getblk+0x9e>
				break;
		}
	/* and repeat until we find something good */	/* 重复操作直到找到适合的缓冲块 */
	} while ((tmp = tmp->b_next_free) != free_list);
    c220:	8b 40 20             	mov    0x20(%eax),%eax
    c223:	39 c5                	cmp    %eax,%ebp
    c225:	75 c7                	jne    c1ee <getblk+0x37>
	// 如果循环检查发现所有缓冲块都正在被使用(所有缓冲块的状况引用计数者>0)中,则睡眠等待有空闲缓冲区可用.当有空闲缓冲块可用时本各会被明确地唤醒.然后
	// 我们就跳转到函数开始处重新查找空闲缓冲块.
	if (!bh) {
    c227:	85 f6                	test   %esi,%esi
    c229:	75 2a                	jne    c255 <getblk+0x9e>
		sleep_on(&buffer_wait);
    c22b:	8d 83 04 40 00 00    	lea    0x4004(%ebx),%eax
    c231:	83 ec 0c             	sub    $0xc,%esp
    c234:	50                   	push   %eax
    c235:	e8 4b ac ff ff       	call   6e85 <sleep_on>
    c23a:	83 c4 10             	add    $0x10,%esp
		goto repeat;
    c23d:	eb 8e                	jmp    c1cd <getblk+0x16>
	// 只好重复上述寻找过程.
	wait_on_buffer(bh);
	if (bh->b_count)	// 又被占用??
		goto repeat;
	// 如果该缓冲区已被修改,则将数据写盘,并再次等待缓冲区解锁.同样地,若该缓冲区又被其他任务使用的话,只好再重复上述寻找过程.
	while (bh->b_dirt) {
    c23f:	80 7e 0b 00          	cmpb   $0x0,0xb(%esi)
    c243:	74 22                	je     c267 <getblk+0xb0>
		sync_dev(bh->b_dev);
    c245:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    c249:	83 ec 0c             	sub    $0xc,%esp
    c24c:	50                   	push   %eax
    c24d:	e8 bd fd ff ff       	call   c00f <sync_dev>
    c252:	83 c4 10             	add    $0x10,%esp
		wait_on_buffer(bh);
    c255:	89 f0                	mov    %esi,%eax
    c257:	e8 3d fd ff ff       	call   bf99 <wait_on_buffer>
		if (bh->b_count)	// 又被占用??
    c25c:	80 7e 0c 00          	cmpb   $0x0,0xc(%esi)
    c260:	74 dd                	je     c23f <getblk+0x88>
repeat:
    c262:	e9 66 ff ff ff       	jmp    c1cd <getblk+0x16>
	}
	/* NOTE!! While we slept waiting for this block, somebody else might */
	/* already have added "this" block to the cache. check it */
	/* 注意!!当进程为了等待该缓冲块而睡眠时,其他进程可能已经将该缓冲块加入进高速缓冲中,所以我们也要对此进行检查. */
	// 在高速缓冲hash表中检查指定设备和块的缓冲块是否乘我们睡眠之即已经被加入进去.如果是的话就再次重复上述寻找过程.
	if (find_buffer(dev, block))
    c267:	8b 54 24 34          	mov    0x34(%esp),%edx
    c26b:	89 f8                	mov    %edi,%eax
    c26d:	e8 e7 fc ff ff       	call   bf59 <find_buffer>
    c272:	85 c0                	test   %eax,%eax
    c274:	0f 85 53 ff ff ff    	jne    c1cd <getblk+0x16>
	if (bh->b_next)
    c27a:	8b 46 18             	mov    0x18(%esi),%eax
	/* OK,最终我们知道该缓冲块是指定参数的唯一一块,而且目前还没有被占用 */
	/* (b_count=0),也未被上锁(b_lock=0),并且是干净的(未被修改的) */
	// 于是让我们占用此缓冲块.置引用计数为1,复位修改标志和有效(更新)标志.
	bh->b_count = 1;
	bh->b_dirt = 0;
	bh->b_uptodate = 0;
    c27d:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
	bh->b_dirt = 0;
    c283:	c6 46 0c 01          	movb   $0x1,0xc(%esi)
	if (bh->b_next)
    c287:	85 c0                	test   %eax,%eax
    c289:	74 06                	je     c291 <getblk+0xda>
    c28b:	8b 56 14             	mov    0x14(%esi),%edx
		bh->b_next->b_prev = bh->b_prev;
    c28e:	89 50 14             	mov    %edx,0x14(%eax)
	if (bh->b_prev)
    c291:	8b 56 14             	mov    0x14(%esi),%edx
    c294:	85 d2                	test   %edx,%edx
    c296:	74 03                	je     c29b <getblk+0xe4>
		bh->b_prev->b_next = bh->b_next;
    c298:	89 42 18             	mov    %eax,0x18(%edx)
	if (hash(bh->b_dev, bh->b_blocknr) == bh)
    c29b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    c29f:	31 d2                	xor    %edx,%edx
    c2a1:	b9 33 01 00 00       	mov    $0x133,%ecx
    c2a6:	33 46 04             	xor    0x4(%esi),%eax
    c2a9:	c7 c5 20 46 03 00    	mov    $0x34620,%ebp
    c2af:	f7 f1                	div    %ecx
    c2b1:	39 74 95 00          	cmp    %esi,0x0(%ebp,%edx,4)
    c2b5:	75 07                	jne    c2be <getblk+0x107>
		hash(bh->b_dev, bh->b_blocknr) = bh->b_next;
    c2b7:	8b 46 18             	mov    0x18(%esi),%eax
    c2ba:	89 44 95 00          	mov    %eax,0x0(%ebp,%edx,4)
	if (!(bh->b_prev_free) || !(bh->b_next_free))
    c2be:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
    c2c2:	74 06                	je     c2ca <getblk+0x113>
    c2c4:	83 7e 20 00          	cmpl   $0x0,0x20(%esi)
    c2c8:	75 12                	jne    c2dc <getblk+0x125>
		panic("Free block list corrupted");
    c2ca:	8d 83 72 73 ff ff    	lea    -0x8c8e(%ebx),%eax
    c2d0:	83 ec 0c             	sub    $0xc,%esp
    c2d3:	50                   	push   %eax
    c2d4:	e8 f9 bd ff ff       	call   80d2 <panic>
    c2d9:	83 c4 10             	add    $0x10,%esp
	bh->b_prev_free->b_next_free = bh->b_next_free;
    c2dc:	8b 46 20             	mov    0x20(%esi),%eax
    c2df:	8b 56 1c             	mov    0x1c(%esi),%edx
	if (free_list == bh)
    c2e2:	39 b3 08 40 00 00    	cmp    %esi,0x4008(%ebx)
	bh->b_prev_free->b_next_free = bh->b_next_free;
    c2e8:	89 42 20             	mov    %eax,0x20(%edx)
	bh->b_next_free->b_prev_free = bh->b_prev_free;
    c2eb:	8b 46 20             	mov    0x20(%esi),%eax
    c2ee:	89 50 1c             	mov    %edx,0x1c(%eax)
	if (free_list == bh)
    c2f1:	75 06                	jne    c2f9 <getblk+0x142>
		free_list = bh->b_next_free;
    c2f3:	89 83 08 40 00 00    	mov    %eax,0x4008(%ebx)
	// 从hash队列和空闲块链表中移出该缓冲头,让该缓冲区用于指定设备和其上的指定块.然后根据此新设备号和块号重新插入空闲链表和hash队列新位置处.并最终返回缓冲
	// 头指针.
	remove_from_queues(bh);
	bh->b_dev = dev;
	bh->b_blocknr = block;
    c2f9:	8b 44 24 34          	mov    0x34(%esp),%eax
	if (!bh->b_dev)
    c2fd:	66 85 ff             	test   %di,%di
	bh->b_dev = dev;
    c300:	66 89 7e 08          	mov    %di,0x8(%esi)
	bh->b_blocknr = block;
    c304:	89 46 04             	mov    %eax,0x4(%esi)
	bh->b_next_free = free_list;
    c307:	8b 83 08 40 00 00    	mov    0x4008(%ebx),%eax
	bh->b_prev_free = free_list->b_prev_free;
    c30d:	8b 50 1c             	mov    0x1c(%eax),%edx
	bh->b_next_free = free_list;
    c310:	89 46 20             	mov    %eax,0x20(%esi)
	bh->b_prev_free = free_list->b_prev_free;
    c313:	89 56 1c             	mov    %edx,0x1c(%esi)
	free_list->b_prev_free->b_next_free = bh;
    c316:	8b 50 1c             	mov    0x1c(%eax),%edx
    c319:	89 72 20             	mov    %esi,0x20(%edx)
	free_list->b_prev_free = bh;
    c31c:	89 70 1c             	mov    %esi,0x1c(%eax)
	bh->b_prev = NULL;
    c31f:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
	bh->b_next = NULL;
    c326:	c7 46 18 00 00 00 00 	movl   $0x0,0x18(%esi)
	if (!bh->b_dev)
    c32d:	74 25                	je     c354 <getblk+0x19d>
	bh->b_next = hash(bh->b_dev, bh->b_blocknr);
    c32f:	0f b7 c7             	movzwl %di,%eax
    c332:	33 44 24 34          	xor    0x34(%esp),%eax
    c336:	31 d2                	xor    %edx,%edx
    c338:	b9 33 01 00 00       	mov    $0x133,%ecx
    c33d:	f7 f1                	div    %ecx
    c33f:	8b 44 95 00          	mov    0x0(%ebp,%edx,4),%eax
    c343:	89 46 18             	mov    %eax,0x18(%esi)
	hash(bh->b_dev, bh->b_blocknr) = bh;
    c346:	89 74 95 00          	mov    %esi,0x0(%ebp,%edx,4)
	if(bh->b_next)
    c34a:	8b 46 18             	mov    0x18(%esi),%eax
    c34d:	85 c0                	test   %eax,%eax
    c34f:	74 03                	je     c354 <getblk+0x19d>
		bh->b_next->b_prev = bh;			// 此句前应添加"if(bh->b_next)"判断.
    c351:	89 70 14             	mov    %esi,0x14(%eax)
	insert_into_queues(bh);
	return bh;
}
    c354:	83 c4 1c             	add    $0x1c,%esp
    c357:	89 f0                	mov    %esi,%eax
    c359:	5b                   	pop    %ebx
    c35a:	5e                   	pop    %esi
    c35b:	5f                   	pop    %edi
    c35c:	5d                   	pop    %ebp
    c35d:	c3                   	ret    

0000c35e <brelse>:

// 释放指定缓冲块.
// 等待该缓冲块解锁.然后引用计数递减1,并明确地唤醒等待空闲缓冲块的进程.
void brelse(struct buffer_head * buf)
{
    c35e:	56                   	push   %esi
    c35f:	53                   	push   %ebx
    c360:	52                   	push   %edx
    c361:	8b 74 24 10          	mov    0x10(%esp),%esi
    c365:	e8 c2 a6 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c36a:	81 c3 96 4c 01 00    	add    $0x14c96,%ebx
	if (!buf)						// 如果缓冲头指针无效则返回.
    c370:	85 f6                	test   %esi,%esi
    c372:	74 38                	je     c3ac <brelse+0x4e>
		return;
	wait_on_buffer(buf);
    c374:	89 f0                	mov    %esi,%eax
    c376:	e8 1e fc ff ff       	call   bf99 <wait_on_buffer>
	if (!(buf->b_count--))
    c37b:	8a 46 0c             	mov    0xc(%esi),%al
    c37e:	8d 50 ff             	lea    -0x1(%eax),%edx
    c381:	84 c0                	test   %al,%al
    c383:	88 56 0c             	mov    %dl,0xc(%esi)
    c386:	75 12                	jne    c39a <brelse+0x3c>
		panic("Trying to free free buffer");
    c388:	8d 83 8c 73 ff ff    	lea    -0x8c74(%ebx),%eax
    c38e:	83 ec 0c             	sub    $0xc,%esp
    c391:	50                   	push   %eax
    c392:	e8 3b bd ff ff       	call   80d2 <panic>
    c397:	83 c4 10             	add    $0x10,%esp
	wake_up(&buffer_wait);
    c39a:	8d 83 04 40 00 00    	lea    0x4004(%ebx),%eax
    c3a0:	83 ec 0c             	sub    $0xc,%esp
    c3a3:	50                   	push   %eax
    c3a4:	e8 ea aa ff ff       	call   6e93 <wake_up>
    c3a9:	83 c4 10             	add    $0x10,%esp
}
    c3ac:	58                   	pop    %eax
    c3ad:	5b                   	pop    %ebx
    c3ae:	5e                   	pop    %esi
    c3af:	c3                   	ret    

0000c3b0 <bread>:
 */
// 从设备上读取数据块.
// 该函数根据指定的设备号dev和数据块号block,首先在高速缓冲区中申请一块缓冲块.如果该缓冲块中经包含有有效的数据就直接返回该缓冲块指针,否则就从设备中
// 读取指定的数据块到该缓冲块中并返回缓冲块指针.
struct buffer_head * bread(int dev, int block)
{
    c3b0:	56                   	push   %esi
    c3b1:	53                   	push   %ebx
    c3b2:	e8 75 a6 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c3b7:	81 c3 49 4c 01 00    	add    $0x14c49,%ebx
    c3bd:	83 ec 0c             	sub    $0xc,%esp
	struct buffer_head * bh;

	// 从高速缓冲区中申请一块缓冲块.如果返回值是NULL,则表示内核出错,停机.否则我们判断其中是否已有可用数据.
	if (!(bh = getblk(dev, block)))
    c3c0:	ff 74 24 1c          	pushl  0x1c(%esp)
    c3c4:	ff 74 24 1c          	pushl  0x1c(%esp)
    c3c8:	e8 ea fd ff ff       	call   c1b7 <getblk>
    c3cd:	83 c4 10             	add    $0x10,%esp
    c3d0:	85 c0                	test   %eax,%eax
    c3d2:	89 c6                	mov    %eax,%esi
    c3d4:	75 12                	jne    c3e8 <bread+0x38>
		panic("bread: getblk returned NULL\n");
    c3d6:	8d 83 a7 73 ff ff    	lea    -0x8c59(%ebx),%eax
    c3dc:	83 ec 0c             	sub    $0xc,%esp
    c3df:	50                   	push   %eax
    c3e0:	e8 ed bc ff ff       	call   80d2 <panic>
    c3e5:	83 c4 10             	add    $0x10,%esp
	// 如果该缓冲块中数据是有效的(已更新的)可以直接使用,则返回.
	if (bh->b_uptodate)
    c3e8:	80 7e 0a 00          	cmpb   $0x0,0xa(%esi)
    c3ec:	75 28                	jne    c416 <bread+0x66>
		return bh;
	// 否则我们就调用底层块设备读写ll_rw_block()函数,产生读设备块请求.然后等待指定数据块被读入,并等待缓冲区解锁.在睡眠醒来之后,如果该缓冲区已更新,则返回
	// 缓冲区头指针,退出.否则表明读设备操作失败,于是释放该缓冲区,返回NULL,退出.
	ll_rw_block(READ, bh);
    c3ee:	51                   	push   %ecx
    c3ef:	51                   	push   %ecx
    c3f0:	56                   	push   %esi
    c3f1:	6a 00                	push   $0x0
    c3f3:	e8 19 45 00 00       	call   10911 <ll_rw_block>
    c3f8:	83 c4 10             	add    $0x10,%esp
	wait_on_buffer(bh);
    c3fb:	89 f0                	mov    %esi,%eax
    c3fd:	e8 97 fb ff ff       	call   bf99 <wait_on_buffer>
	if (bh->b_uptodate)
    c402:	80 7e 0a 00          	cmpb   $0x0,0xa(%esi)
    c406:	75 0e                	jne    c416 <bread+0x66>
		return bh;
	brelse(bh);
    c408:	83 ec 0c             	sub    $0xc,%esp
    c40b:	56                   	push   %esi
	return NULL;
    c40c:	31 f6                	xor    %esi,%esi
	brelse(bh);
    c40e:	e8 4b ff ff ff       	call   c35e <brelse>
    c413:	83 c4 10             	add    $0x10,%esp
}
    c416:	89 f0                	mov    %esi,%eax
    c418:	5a                   	pop    %edx
    c419:	5b                   	pop    %ebx
    c41a:	5e                   	pop    %esi
    c41b:	c3                   	ret    

0000c41c <bread_page>:
 */
// 读设备上一个页面(4个缓冲块)的内容到指定内存地址处.
// 参数address是保存页面数据的地址;dev是指定的设备号;b[4]是含有4个设备数据块号的数组.
// 该函数仅用于mm/memory.c文件的do_no_page()函数中.
void bread_page(unsigned long address, int dev, int b[4])
{
    c41c:	55                   	push   %ebp
    c41d:	57                   	push   %edi
    c41e:	56                   	push   %esi
    c41f:	53                   	push   %ebx
	int i;

	// 该函数循环执行4次,根据放在数组b[]中的4个块号从设备dev中读取一页内容放到指定内存位置address处.对于参数b[i]给出的
	// 有效块号,函数首先从高速缓冲中取指定设备和块号的的缓冲块.如果缓冲块中数据无效(未更新)则产生读设备请求从设备上读取相
	// 应数据块.对于b[i]无效的块号则不用处理它了.因此本函数其实可以根据指定的b[]中的块号随意读取1-4个数据块.
	for (i = 0 ; i < 4 ; i++)
    c420:	31 f6                	xor    %esi,%esi
    c422:	e8 05 a6 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c427:	81 c3 d9 4b 01 00    	add    $0x14bd9,%ebx
{
    c42d:	83 ec 2c             	sub    $0x2c,%esp
    c430:	8b 7c 24 40          	mov    0x40(%esp),%edi
		if (b[i]) {
    c434:	8b 44 24 48          	mov    0x48(%esp),%eax
    c438:	8d 6c 24 10          	lea    0x10(%esp),%ebp
    c43c:	8b 04 b0             	mov    (%eax,%esi,4),%eax
    c43f:	85 c0                	test   %eax,%eax
    c441:	74 2c                	je     c46f <bread_page+0x53>
			// 先给该逻辑块号申请一个缓存块
			if (bh[i] = getblk(dev, b[i]))
    c443:	51                   	push   %ecx
    c444:	51                   	push   %ecx
    c445:	50                   	push   %eax
    c446:	ff 74 24 50          	pushl  0x50(%esp)
    c44a:	e8 68 fd ff ff       	call   c1b7 <getblk>
    c44f:	83 c4 10             	add    $0x10,%esp
    c452:	85 c0                	test   %eax,%eax
    c454:	89 44 b5 00          	mov    %eax,0x0(%ebp,%esi,4)
    c458:	74 1d                	je     c477 <bread_page+0x5b>
				// 如果该缓冲块没有更新,则从块设备中读取出来
				if (!bh[i]->b_uptodate)
    c45a:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c45e:	75 17                	jne    c477 <bread_page+0x5b>
					ll_rw_block(READ, bh[i]);
    c460:	52                   	push   %edx
    c461:	52                   	push   %edx
    c462:	50                   	push   %eax
    c463:	6a 00                	push   $0x0
    c465:	e8 a7 44 00 00       	call   10911 <ll_rw_block>
    c46a:	83 c4 10             	add    $0x10,%esp
    c46d:	eb 08                	jmp    c477 <bread_page+0x5b>
		} else
			bh[i] = NULL;
    c46f:	c7 44 b5 00 00 00 00 	movl   $0x0,0x0(%ebp,%esi,4)
    c476:	00 
	for (i = 0 ; i < 4 ; i++)
    c477:	46                   	inc    %esi
    c478:	83 fe 04             	cmp    $0x4,%esi
    c47b:	75 b7                	jne    c434 <bread_page+0x18>
	// 随后将4个缓冲块上的内容顺序复制到指定地址处.在进行复制(使用)缓冲块之前我们先要睡眠等待缓冲块解锁(若被上锁的话).另外,
	// 因为可能睡眠过了,所以我们还需要在复制之前再检查一下缓冲块中的数据是否是有效的.复制完后我们还需要释放缓冲块.
	for (i = 0 ; i < 4 ; i++, address += BLOCK_SIZE)
    c47d:	31 db                	xor    %ebx,%ebx
		if (bh[i]) {
    c47f:	8b 54 9d 00          	mov    0x0(%ebp,%ebx,4),%edx
    c483:	85 d2                	test   %edx,%edx
    c485:	74 2f                	je     c4b6 <bread_page+0x9a>
			wait_on_buffer(bh[i]);						// 等待缓冲块解锁(若被上锁的话).
    c487:	89 d0                	mov    %edx,%eax
    c489:	89 54 24 0c          	mov    %edx,0xc(%esp)
    c48d:	e8 07 fb ff ff       	call   bf99 <wait_on_buffer>
			if (bh[i]->b_uptodate)						// 若缓冲块中数据有效的话则复制.
    c492:	8b 54 24 0c          	mov    0xc(%esp),%edx
    c496:	80 7a 0a 00          	cmpb   $0x0,0xa(%edx)
    c49a:	74 0e                	je     c4aa <bread_page+0x8e>
				COPYBLK((unsigned long) bh[i]->b_data, address);
    c49c:	8b 32                	mov    (%edx),%esi
    c49e:	b9 00 01 00 00       	mov    $0x100,%ecx
    c4a3:	fc                   	cld    
    c4a4:	57                   	push   %edi
    c4a5:	56                   	push   %esi
    c4a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
    c4a8:	5e                   	pop    %esi
    c4a9:	5f                   	pop    %edi
			brelse(bh[i]);								// 释放该缓冲区.
    c4aa:	83 ec 0c             	sub    $0xc,%esp
    c4ad:	52                   	push   %edx
    c4ae:	e8 ab fe ff ff       	call   c35e <brelse>
    c4b3:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < 4 ; i++, address += BLOCK_SIZE)
    c4b6:	43                   	inc    %ebx
    c4b7:	81 c7 00 04 00 00    	add    $0x400,%edi
    c4bd:	83 fb 04             	cmp    $0x4,%ebx
    c4c0:	75 bd                	jne    c47f <bread_page+0x63>
		}
}
    c4c2:	83 c4 2c             	add    $0x2c,%esp
    c4c5:	5b                   	pop    %ebx
    c4c6:	5e                   	pop    %esi
    c4c7:	5f                   	pop    %edi
    c4c8:	5d                   	pop    %ebp
    c4c9:	c3                   	ret    

0000c4ca <breada>:
 * OK,breada可以象bread一样使用,但会另外预读一些块.该函数参数列表需要使用一个负数来表明参数列表的结束.
 */
// 从指定设备读取指定的一些块.
// 函数参数个数可变,是一系列指定的块号.成功时返回第1块的缓冲块头指针,否则返回NULL.
struct buffer_head * breada(int dev, int first, ...)
{
    c4ca:	55                   	push   %ebp
    c4cb:	57                   	push   %edi
    c4cc:	56                   	push   %esi
    c4cd:	53                   	push   %ebx
    c4ce:	e8 59 a5 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c4d3:	81 c3 2d 4b 01 00    	add    $0x14b2d,%ebx
    c4d9:	83 ec 24             	sub    $0x24,%esp
    c4dc:	8b 6c 24 38          	mov    0x38(%esp),%ebp
	struct buffer_head * bh, *tmp;

	// 首先取可变参数表中第1个参数(块号).接着从调整缓冲区中取指定设备和块号的缓冲块.如果该缓冲块数据无效(更新标志未置位),则
	// 发出读设备数据块请求.
	va_start(args, first);
	if (!(bh = getblk(dev, first)))
    c4e0:	ff 74 24 3c          	pushl  0x3c(%esp)
    c4e4:	55                   	push   %ebp
    c4e5:	e8 cd fc ff ff       	call   c1b7 <getblk>
    c4ea:	83 c4 10             	add    $0x10,%esp
    c4ed:	85 c0                	test   %eax,%eax
    c4ef:	89 c6                	mov    %eax,%esi
    c4f1:	75 12                	jne    c505 <breada+0x3b>
		panic("bread: getblk returned NULL\n");
    c4f3:	8d 83 a7 73 ff ff    	lea    -0x8c59(%ebx),%eax
    c4f9:	83 ec 0c             	sub    $0xc,%esp
    c4fc:	50                   	push   %eax
    c4fd:	e8 d0 bb ff ff       	call   80d2 <panic>
    c502:	83 c4 10             	add    $0x10,%esp
	if (!bh->b_uptodate)
    c505:	80 7e 0a 00          	cmpb   $0x0,0xa(%esi)
    c509:	75 0d                	jne    c518 <breada+0x4e>
		ll_rw_block(READ, bh);
    c50b:	57                   	push   %edi
    c50c:	57                   	push   %edi
    c50d:	56                   	push   %esi
    c50e:	6a 00                	push   $0x0
    c510:	e8 fc 43 00 00       	call   10911 <ll_rw_block>
    c515:	83 c4 10             	add    $0x10,%esp
    c518:	8d 7c 24 34          	lea    0x34(%esp),%edi
	// 然后顺序取可变参数表中其他预读块号,并作与上面同样处理,但不引用.注意,336行上有一个bug.其中的bh应该是tmp.这个bug直到在0.96
	// 版的内核代码中才被纠正过来.另外,因为这里是预读随后的数据块,只需读进调整缓冲区但并不马上就使用,所以第337行语句需要将其引用计数
	// 递减释放掉该块(因为getblk()函数会增加缓冲块引用计数值).
	while ((first = va_arg(args, int)) >= 0) {
    c51c:	8b 47 04             	mov    0x4(%edi),%eax
    c51f:	85 c0                	test   %eax,%eax
    c521:	89 44 24 34          	mov    %eax,0x34(%esp)
    c525:	78 33                	js     c55a <breada+0x90>
		tmp = getblk(dev, first);
    c527:	51                   	push   %ecx
    c528:	51                   	push   %ecx
    c529:	50                   	push   %eax
    c52a:	55                   	push   %ebp
    c52b:	e8 87 fc ff ff       	call   c1b7 <getblk>
    c530:	83 c4 10             	add    $0x10,%esp
		if (tmp) {
    c533:	85 c0                	test   %eax,%eax
    c535:	74 1e                	je     c555 <breada+0x8b>
			if (!tmp->b_uptodate)
    c537:	80 78 0a 00          	cmpb   $0x0,0xa(%eax)
    c53b:	75 15                	jne    c552 <breada+0x88>
				ll_rw_block(READA, tmp);
    c53d:	52                   	push   %edx
    c53e:	52                   	push   %edx
    c53f:	50                   	push   %eax
    c540:	89 44 24 18          	mov    %eax,0x18(%esp)
    c544:	6a 02                	push   $0x2
    c546:	e8 c6 43 00 00       	call   10911 <ll_rw_block>
    c54b:	83 c4 10             	add    $0x10,%esp
    c54e:	8b 44 24 0c          	mov    0xc(%esp),%eax
			tmp->b_count--;					// 暂时释放掉该预读块.
    c552:	fe 48 0c             	decb   0xc(%eax)
    c555:	83 c7 04             	add    $0x4,%edi
    c558:	eb c2                	jmp    c51c <breada+0x52>
		}
	}
	// 此时可变参数表中所有参数处理完毕.于是等待第1个缓冲区解锁(如果已被上锁).在等待退出之后如果缓冲区中数据仍然有效,则返回缓冲区头指针
	// 退出.否则释放该缓冲区返回NULL,退出.
	va_end(args);
	wait_on_buffer(bh);
    c55a:	89 f0                	mov    %esi,%eax
    c55c:	e8 38 fa ff ff       	call   bf99 <wait_on_buffer>
	if (bh->b_uptodate)
    c561:	80 7e 0a 00          	cmpb   $0x0,0xa(%esi)
    c565:	75 0e                	jne    c575 <breada+0xab>
		return bh;
	brelse(bh);
    c567:	83 ec 0c             	sub    $0xc,%esp
    c56a:	56                   	push   %esi
	return (NULL);
    c56b:	31 f6                	xor    %esi,%esi
	brelse(bh);
    c56d:	e8 ec fd ff ff       	call   c35e <brelse>
    c572:	83 c4 10             	add    $0x10,%esp
}
    c575:	83 c4 1c             	add    $0x1c,%esp
    c578:	89 f0                	mov    %esi,%eax
    c57a:	5b                   	pop    %ebx
    c57b:	5e                   	pop    %esi
    c57c:	5f                   	pop    %edi
    c57d:	5d                   	pop    %ebp
    c57e:	c3                   	ret    

0000c57f <buffer_init>:

// 缓冲区初始化函数
// 参数buffer_end是缓冲区内存末端.对于具有16M内存的系统,缓冲区末端被设置为4MB.对于有8MB内存的系统,缓冲区末端被设置2MB.该函数从缓冲区开始位置
// start_buffer处和缓冲区末端buffer_end处分别同时设置(初始化)缓冲块头结构和对应的数据块.直到缓冲区中所有内存被分配完毕.
void buffer_init(long buffer_end)
{
    c57f:	55                   	push   %ebp
    c580:	57                   	push   %edi
    c581:	56                   	push   %esi
    c582:	53                   	push   %ebx
    c583:	52                   	push   %edx
    c584:	8b 54 24 18          	mov    0x18(%esp),%edx
    c588:	e8 f1 d8 ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
    c58d:	81 c1 73 4a 01 00    	add    $0x14a73,%ecx
	void * b;
	int i;

	// 首先根据参数提供的缓冲区高端位置确定实际缓冲区高端位置b.如果缓冲区高端等于1MB,则因为从640KB-1MB被显示内存和BIOS占用,所以实际可用缓冲区内存
	// 高端位置应该是640KB.否则缓冲区内存高端一定大于1MB.
	if (buffer_end == 1 << 20)
    c593:	81 fa 00 00 10 00    	cmp    $0x100000,%edx
	struct buffer_head * h = start_buffer;
    c599:	8b b1 70 13 00 00    	mov    0x1370(%ecx),%esi
	if (buffer_end == 1 << 20)
    c59f:	75 05                	jne    c5a6 <buffer_init+0x27>
    c5a1:	ba 00 00 0a 00       	mov    $0xa0000,%edx
    c5a6:	8b b9 00 40 00 00    	mov    0x4000(%ecx),%edi
	struct buffer_head * h = start_buffer;
    c5ac:	89 f3                	mov    %esi,%ebx
    c5ae:	c6 44 24 03 00       	movb   $0x0,0x3(%esp)
		b = (void *) buffer_end;
	// 这段代码用于初始化缓冲区,建立空闲缓冲块循环链表,并获取系统中缓冲块数目.操作的过程是从缓冲区高端开始划分1KB大小的缓冲块,与此同时在缓冲区低端建立
	// 描述该缓冲块的结构buffer_head,并将这些buffer_head组成双向链表.
	// h是指向缓冲头结构的指针,而h+1是指向内存地址连续的下一个缓冲头地址,也可以说是指向h缓冲有头的末端外.为了保证有足够长度的内存来存储一个缓冲头结构,
	// 需要b所指向的内存块地址>=h缓冲头的末端,即要求>=h+1.
	while ( (b -= BLOCK_SIZE) >= ((void *) (h + 1)) ) {
    c5b3:	8d 43 24             	lea    0x24(%ebx),%eax
    c5b6:	81 ea 00 04 00 00    	sub    $0x400,%edx
    c5bc:	8d 6b dc             	lea    -0x24(%ebx),%ebp
    c5bf:	39 d0                	cmp    %edx,%eax
    c5c1:	77 4b                	ja     c60e <buffer_init+0x8f>
		h->b_data = (char *) b;						// 指向对应缓冲块数据块(1024字节).
		h->b_prev_free = h - 1;						// 指向链表中前一项.
		h->b_next_free = h + 1;						// 指向链表中下一项.
		h++;										// h指向下一新缓冲头位置.
		NR_BUFFERS++;								// 缓冲区块数累加.
		if (b == (void *) 0x100000)					// 若b递减到等于1MB,则跳过384KB
    c5c3:	81 fa 00 00 10 00    	cmp    $0x100000,%edx
		h->b_dev = 0;								// 使用该缓冲块的设备号.
    c5c9:	66 c7 40 e4 00 00    	movw   $0x0,-0x1c(%eax)
		h->b_dirt = 0;								// 脏标志,即缓冲块修改标志.
    c5cf:	c6 40 e7 00          	movb   $0x0,-0x19(%eax)
		h->b_count = 0;								// 缓冲块引用计数.
    c5d3:	c6 40 e8 00          	movb   $0x0,-0x18(%eax)
		h->b_lock = 0;								// 缓冲块锁定标志.
    c5d7:	c6 40 e9 00          	movb   $0x0,-0x17(%eax)
		h->b_uptodate = 0;							// 缓冲块更新标志(或称数据有效标志).
    c5db:	c6 40 e6 00          	movb   $0x0,-0x1a(%eax)
		h->b_wait = NULL;							// 指向等待该缓冲块解锁的进程.
    c5df:	c7 40 ec 00 00 00 00 	movl   $0x0,-0x14(%eax)
		h->b_next = NULL;							// 指向具有相同hash值的下一个缓冲头.
    c5e6:	c7 40 f4 00 00 00 00 	movl   $0x0,-0xc(%eax)
		h->b_prev = NULL;							// 指向具有相同hash值的前一个缓冲头.
    c5ed:	c7 40 f0 00 00 00 00 	movl   $0x0,-0x10(%eax)
		h->b_data = (char *) b;						// 指向对应缓冲块数据块(1024字节).
    c5f4:	89 50 dc             	mov    %edx,-0x24(%eax)
		h->b_prev_free = h - 1;						// 指向链表中前一项.
    c5f7:	89 68 f8             	mov    %ebp,-0x8(%eax)
		h->b_next_free = h + 1;						// 指向链表中下一项.
    c5fa:	89 40 fc             	mov    %eax,-0x4(%eax)
		if (b == (void *) 0x100000)					// 若b递减到等于1MB,则跳过384KB
    c5fd:	75 05                	jne    c604 <buffer_init+0x85>
			b = (void *) 0xA0000;					// 让b指向地址0xA0000(640KB)处.
    c5ff:	ba 00 00 0a 00       	mov    $0xa0000,%edx
    c604:	47                   	inc    %edi
    c605:	c6 44 24 03 01       	movb   $0x1,0x3(%esp)
	struct buffer_head * h = start_buffer;
    c60a:	89 c3                	mov    %eax,%ebx
    c60c:	eb a5                	jmp    c5b3 <buffer_init+0x34>
    c60e:	80 7c 24 03 00       	cmpb   $0x0,0x3(%esp)
    c613:	74 06                	je     c61b <buffer_init+0x9c>
    c615:	89 b9 00 40 00 00    	mov    %edi,0x4000(%ecx)
	free_list = start_buffer;						// 让空闲链表头指向头一个缓冲块.
	free_list->b_prev_free = h;     				// 链表头的b_prev_free指向前一项（即最后一项）。
	h->b_next_free = free_list;     				// h的下一项指针指向第一项，形成一个环链。
	// 最后初始化hash表(哈希表、散列表),置表中所有指针为NULL。
	for (i = 0; i < NR_HASH; i++)
		hash_table[i] = NULL;
    c61b:	c7 c2 20 46 03 00    	mov    $0x34620,%edx
	free_list->b_prev_free = h;     				// 链表头的b_prev_free指向前一项（即最后一项）。
    c621:	89 6e 1c             	mov    %ebp,0x1c(%esi)
	for (i = 0; i < NR_HASH; i++)
    c624:	31 c0                	xor    %eax,%eax
	free_list = start_buffer;						// 让空闲链表头指向头一个缓冲块.
    c626:	89 b1 08 40 00 00    	mov    %esi,0x4008(%ecx)
	h->b_next_free = free_list;     				// h的下一项指针指向第一项，形成一个环链。
    c62c:	89 73 fc             	mov    %esi,-0x4(%ebx)
		hash_table[i] = NULL;
    c62f:	c7 04 82 00 00 00 00 	movl   $0x0,(%edx,%eax,4)
	for (i = 0; i < NR_HASH; i++)
    c636:	40                   	inc    %eax
    c637:	3d 33 01 00 00       	cmp    $0x133,%eax
    c63c:	75 f1                	jne    c62f <buffer_init+0xb0>
}
    c63e:	58                   	pop    %eax
    c63f:	5b                   	pop    %ebx
    c640:	5e                   	pop    %esi
    c641:	5f                   	pop    %edi
    c642:	5d                   	pop    %ebp
    c643:	c3                   	ret    

0000c644 <free_super>:

//　对指定超级块解锁
//　复位超级块的锁定标志,并明确地唤醒等待此超级块等待队列s_wait上的所有进程.
//　如果使用unlock_super这个名称则可能更妥帖.
static void free_super(struct super_block * sb)
{
    c644:	53                   	push   %ebx
    c645:	e8 e2 a3 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c64a:	81 c3 b6 49 01 00    	add    $0x149b6,%ebx
    c650:	83 ec 14             	sub    $0x14,%esp
	cli();
    c653:	fa                   	cli    
	sb->s_lock = 0;											// 复位锁定标志.
    c654:	c6 40 68 00          	movb   $0x0,0x68(%eax)
	wake_up(&(sb->s_wait));									// 唤醒等待该超级块的进程.
    c658:	83 c0 64             	add    $0x64,%eax
    c65b:	50                   	push   %eax
    c65c:	e8 32 a8 ff ff       	call   6e93 <wake_up>
	sti();													// wake_up()在kernel/sched.c
    c661:	fb                   	sti    
}
    c662:	83 c4 18             	add    $0x18,%esp
    c665:	5b                   	pop    %ebx
    c666:	c3                   	ret    

0000c667 <get_super>:
}

// 取指定设备的超级块.
// 在超级块表(数组)中搜索指定设备dev的超级块结构信息.若找到则返回超级块的指针,否则返回空指针.
struct super_block * get_super(int dev)
{
    c667:	55                   	push   %ebp
    c668:	57                   	push   %edi
    c669:	56                   	push   %esi
    c66a:	53                   	push   %ebx
    c66b:	e8 bc a3 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c670:	81 c3 90 49 01 00    	add    $0x14990,%ebx
    c676:	83 ec 0c             	sub    $0xc,%esp
    c679:	8b 7c 24 20          	mov    0x20(%esp),%edi
	struct super_block * s;									// s是超级块数据结构指针.

	// 首先判断参数给出设备的有效性.若设备号为0则返回空指针.然后让s指向超级块数组起始处,开始搜索整个超级块数组,以寻找指定设备dev的超级块.
	// 第62行上的指针赋值语句"s = 0+super_block"等同于"s = super_block","s = &super_block[0]".
	if (!dev)
    c67d:	85 ff                	test   %edi,%edi
    c67f:	75 04                	jne    c685 <get_super+0x1e>
		return NULL;
    c681:	31 f6                	xor    %esi,%esi
    c683:	eb 44                	jmp    c6c9 <get_super+0x62>
	s = 0 + super_block;
    c685:	c7 c6 00 4b 03 00    	mov    $0x34b00,%esi
    c68b:	89 f5                	mov    %esi,%ebp
	while (s < NR_SUPER + super_block)
		// 如果当前搜索项是指定设备的超级块,即该超级块的设备号字段值与函数参数指定的相同,则先等待该超级块解锁(若已被其他进程上锁的话).在等待期间,
		// 该超级块项有可能被其他设备使用,因此等待返回之后需再判断一次是否是指定设备的超级块,如果是则返回该超级块的指针.否则就重新对超级块数组再
		// 搜索一遍,因此此时s需重又指向超级块数组开始处.
		if (s->s_dev == dev) {
    c68d:	0f b7 46 54          	movzwl 0x54(%esi),%eax
    c691:	39 c7                	cmp    %eax,%edi
    c693:	75 25                	jne    c6ba <get_super+0x53>
	cli();
    c695:	fa                   	cli    
	while (sb->s_lock)										// 如果超级块已经上锁,则睡眠等待.
    c696:	80 7e 68 00          	cmpb   $0x0,0x68(%esi)
    c69a:	74 11                	je     c6ad <get_super+0x46>
		sleep_on(&(sb->s_wait));
    c69c:	8d 46 64             	lea    0x64(%esi),%eax
    c69f:	83 ec 0c             	sub    $0xc,%esp
    c6a2:	50                   	push   %eax
    c6a3:	e8 dd a7 ff ff       	call   6e85 <sleep_on>
    c6a8:	83 c4 10             	add    $0x10,%esp
    c6ab:	eb e9                	jmp    c696 <get_super+0x2f>
	sti();
    c6ad:	fb                   	sti    
			wait_on_super(s);
			if (s->s_dev == dev)
    c6ae:	0f b7 46 54          	movzwl 0x54(%esi),%eax
    c6b2:	39 c7                	cmp    %eax,%edi
    c6b4:	74 13                	je     c6c9 <get_super+0x62>
				return s;
			s = 0 + super_block;
    c6b6:	89 ee                	mov    %ebp,%esi
    c6b8:	eb d3                	jmp    c68d <get_super+0x26>
	while (s < NR_SUPER + super_block)
    c6ba:	8d 85 60 03 00 00    	lea    0x360(%ebp),%eax
		// 如果当前搜索项不是,则检查下一项.如果没有找到指定的超级块,则返回空指针.
		} else
			s++;
    c6c0:	83 c6 6c             	add    $0x6c,%esi
	while (s < NR_SUPER + super_block)
    c6c3:	39 c6                	cmp    %eax,%esi
    c6c5:	72 c6                	jb     c68d <get_super+0x26>
    c6c7:	eb b8                	jmp    c681 <get_super+0x1a>
	return NULL;
}
    c6c9:	83 c4 0c             	add    $0xc,%esp
    c6cc:	89 f0                	mov    %esi,%eax
    c6ce:	5b                   	pop    %ebx
    c6cf:	5e                   	pop    %esi
    c6d0:	5f                   	pop    %edi
    c6d1:	5d                   	pop    %ebp
    c6d2:	c3                   	ret    

0000c6d3 <read_super>:

// 读取指定设备的超级块.
// 如果指定设备dev上的文件系统超级块已经在超级块表中,则直接返回该超级块项的指针.否则就从设备dev上读取超级块到缓冲块中,并复制到超级块表中.并
// 返回超级块指针.
static struct super_block * read_super(int dev)
{
    c6d3:	55                   	push   %ebp
    c6d4:	57                   	push   %edi
    c6d5:	56                   	push   %esi
    c6d6:	53                   	push   %ebx
    c6d7:	e8 50 a3 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c6dc:	81 c3 24 49 01 00    	add    $0x14924,%ebx
    c6e2:	83 ec 1c             	sub    $0x1c,%esp
	struct buffer_head * bh;
	int i, block;

	// 首先判断参数的有效性.如果没有指明设备,则返回空指针.然后检查该设备是否可更换过盘片(也即是否是软盘设备).如果更换过盘,则高速缓冲区有关该设备的所有
	// 缓冲块均失效,需要进行失效处理,即释放原来加载的文件系统.
	if (!dev)
    c6e5:	85 c0                	test   %eax,%eax
    c6e7:	75 0d                	jne    c6f6 <read_super+0x23>
		return NULL;
    c6e9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    c6f0:	00 
    c6f1:	e9 f1 01 00 00       	jmp    c8e7 <read_super+0x214>
    c6f6:	89 44 24 04          	mov    %eax,0x4(%esp)
	check_disk_change(dev);
    c6fa:	83 ec 0c             	sub    $0xc,%esp
    c6fd:	ff 74 24 10          	pushl  0x10(%esp)
    c701:	e8 f9 f9 ff ff       	call   c0ff <check_disk_change>
    c706:	5e                   	pop    %esi
	// 如果设备的超级块已经在超级块表中,则直接返回该超级块的指针.否则,首先在超级块数组中找出一个空项(也即字段s_dev=0的项).如果数组已经占满则返回空指针.
	if (s = get_super(dev))
    c707:	ff 74 24 10          	pushl  0x10(%esp)
    c70b:	e8 57 ff ff ff       	call   c667 <get_super>
    c710:	83 c4 10             	add    $0x10,%esp
    c713:	85 c0                	test   %eax,%eax
    c715:	89 44 24 08          	mov    %eax,0x8(%esp)
    c719:	0f 85 c8 01 00 00    	jne    c8e7 <read_super+0x214>
		return s;
	for (s = 0 + super_block ;; s++) {
    c71f:	c7 c5 00 4b 03 00    	mov    $0x34b00,%ebp
		if (s >= NR_SUPER + super_block)
    c725:	8d 85 60 03 00 00    	lea    0x360(%ebp),%eax
			return NULL;
		if (!s->s_dev)
    c72b:	66 83 7d 54 00       	cmpw   $0x0,0x54(%ebp)
    c730:	74 09                	je     c73b <read_super+0x68>
	for (s = 0 + super_block ;; s++) {
    c732:	83 c5 6c             	add    $0x6c,%ebp
		if (s >= NR_SUPER + super_block)
    c735:	39 c5                	cmp    %eax,%ebp
    c737:	75 f2                	jne    c72b <read_super+0x58>
    c739:	eb ae                	jmp    c6e9 <read_super+0x16>
			break;
	}
	// 在超级块数组中找到空项之后,就将该超级块项用于指定设备dev上的文件系统.于是对该超级块结构中的内存字段进行部分初始化处理.
	s->s_dev = dev;										// 用于dev设备上的文件系统.
    c73b:	8b 44 24 04          	mov    0x4(%esp),%eax
	s->s_isup = NULL;
    c73f:	c7 45 58 00 00 00 00 	movl   $0x0,0x58(%ebp)
	s->s_imount = NULL;
    c746:	c7 45 5c 00 00 00 00 	movl   $0x0,0x5c(%ebp)
	s->s_time = 0;
    c74d:	c7 45 60 00 00 00 00 	movl   $0x0,0x60(%ebp)
	s->s_rd_only = 0;
    c754:	66 c7 45 69 00 00    	movw   $0x0,0x69(%ebp)
	s->s_dev = dev;										// 用于dev设备上的文件系统.
    c75a:	66 89 45 54          	mov    %ax,0x54(%ebp)
	cli();													//　关中断
    c75e:	fa                   	cli    
	while (sb->s_lock)										//　如果该超级块已经上锁,则睡眠等待.
    c75f:	80 7d 68 00          	cmpb   $0x0,0x68(%ebp)
    c763:	74 11                	je     c776 <read_super+0xa3>
		sleep_on(&(sb->s_wait));
    c765:	8d 45 64             	lea    0x64(%ebp),%eax
    c768:	83 ec 0c             	sub    $0xc,%esp
    c76b:	50                   	push   %eax
    c76c:	e8 14 a7 ff ff       	call   6e85 <sleep_on>
    c771:	83 c4 10             	add    $0x10,%esp
    c774:	eb e9                	jmp    c75f <read_super+0x8c>
	sb->s_lock = 1;											//　给该超级块加锁(置锁定标志)
    c776:	c6 45 68 01          	movb   $0x1,0x68(%ebp)
	sti();													//　开中断.
    c77a:	fb                   	sti    
	s->s_dirt = 0;
	//　然后锁定该超级块,并从设备上读取超级块信息到bh指向的缓冲块中.超级块位于块设备的第２个逻辑块(１号块)中,(第１个是引导盘块).如果读超级块操作失败,则释放
	//　上面选定的超级块数组中的项(即置s_dev=0),并解锁该项,返回空指针退出.否则就将设备上读取的超级块信息从缓冲块数据区复制到超级块数组相应项结构中.并释放存放
	//　读取信息的高速缓冲块.
	lock_super(s);
	if (!(bh = bread(dev, 1))) {
    c77b:	51                   	push   %ecx
    c77c:	51                   	push   %ecx
    c77d:	6a 01                	push   $0x1
    c77f:	ff 74 24 10          	pushl  0x10(%esp)
    c783:	e8 28 fc ff ff       	call   c3b0 <bread>
    c788:	83 c4 10             	add    $0x10,%esp
    c78b:	85 c0                	test   %eax,%eax
    c78d:	0f 84 2a 01 00 00    	je     c8bd <read_super+0x1ea>
		s->s_dev = 0;
		free_super(s);
		return NULL;
	}
	*((struct d_super_block *) s) =
    c793:	8b 30                	mov    (%eax),%esi
    c795:	b9 05 00 00 00       	mov    $0x5,%ecx
    c79a:	89 ef                	mov    %ebp,%edi
    c79c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		*((struct d_super_block *) bh->b_data);
	brelse(bh);
    c79e:	83 ec 0c             	sub    $0xc,%esp
    c7a1:	50                   	push   %eax
    c7a2:	e8 b7 fb ff ff       	call   c35e <brelse>
    c7a7:	83 c4 10             	add    $0x10,%esp
	// 现在我们从设备dev上得到了文件系统的超级块,于是开始检查这个超级块的有效性并从设备上读取i节点位图和逻辑块位图等信息.如果所读取的超级块的文件系统魔数字段不对,
	// 说明设备上不是正确的文件系统,因此向上面一样,释放上面选定的超级块数组中的项,并解锁该项,返回空指针退出.
	// 对于该版Linux内核,只支持MINIX文件系统1.0版本,其魔数是0x137f.
	if (s->s_magic != SUPER_MAGIC) {
    c7aa:	66 81 7d 10 7f 13    	cmpw   $0x137f,0x10(%ebp)
    c7b0:	0f 85 07 01 00 00    	jne    c8bd <read_super+0x1ea>
		return NULL;
	}
	// 下面开始读取设备上i节点位图和逻辑块位图数据.首先初始化内存超级块结构中位图空间.然后从设备上读取i节点位图和逻辑块位图信息,并存放在超级块对应字段中.i节点位图
	// 保存在设备上2号块开始的逻辑块中,共占用s_imap_blocks个块.逻辑块位图在i节点位图所在块的后续块中,共占用s_zmap_blocks个块.
	for (i = 0; i < I_MAP_SLOTS; i++)					// 初始化操作.
		s->s_imap[i] = NULL;
    c7b6:	c7 45 14 00 00 00 00 	movl   $0x0,0x14(%ebp)
    c7bd:	c7 45 18 00 00 00 00 	movl   $0x0,0x18(%ebp)
	for (i = 0; i < Z_MAP_SLOTS; i++)
		s->s_zmap[i] = NULL;
	block = 2;
    c7c4:	be 02 00 00 00       	mov    $0x2,%esi
		s->s_imap[i] = NULL;
    c7c9:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
    c7d0:	c7 45 20 00 00 00 00 	movl   $0x0,0x20(%ebp)
    c7d7:	c7 45 24 00 00 00 00 	movl   $0x0,0x24(%ebp)
    c7de:	c7 45 28 00 00 00 00 	movl   $0x0,0x28(%ebp)
    c7e5:	c7 45 2c 00 00 00 00 	movl   $0x0,0x2c(%ebp)
    c7ec:	c7 45 30 00 00 00 00 	movl   $0x0,0x30(%ebp)
		s->s_zmap[i] = NULL;
    c7f3:	c7 45 34 00 00 00 00 	movl   $0x0,0x34(%ebp)
    c7fa:	c7 45 38 00 00 00 00 	movl   $0x0,0x38(%ebp)
    c801:	c7 45 3c 00 00 00 00 	movl   $0x0,0x3c(%ebp)
    c808:	c7 45 40 00 00 00 00 	movl   $0x0,0x40(%ebp)
    c80f:	c7 45 44 00 00 00 00 	movl   $0x0,0x44(%ebp)
    c816:	c7 45 48 00 00 00 00 	movl   $0x0,0x48(%ebp)
    c81d:	c7 45 4c 00 00 00 00 	movl   $0x0,0x4c(%ebp)
    c824:	c7 45 50 00 00 00 00 	movl   $0x0,0x50(%ebp)
	// 从第二逻辑块号开始读取i节点位图
	for (i = 0 ; i < s->s_imap_blocks ; i++)			// 读取设备中i节点位图.
    c82b:	0f b7 55 04          	movzwl 0x4(%ebp),%edx
    c82f:	8d 46 fe             	lea    -0x2(%esi),%eax
    c832:	39 c2                	cmp    %eax,%edx
    c834:	7e 17                	jle    c84d <read_super+0x17a>
		if (s->s_imap[i] = bread(dev, block))
    c836:	52                   	push   %edx
    c837:	52                   	push   %edx
    c838:	56                   	push   %esi
    c839:	ff 74 24 10          	pushl  0x10(%esp)
    c83d:	e8 6e fb ff ff       	call   c3b0 <bread>
    c842:	83 c4 10             	add    $0x10,%esp
    c845:	85 c0                	test   %eax,%eax
    c847:	89 44 b5 0c          	mov    %eax,0xc(%ebp,%esi,4)
    c84b:	75 04                	jne    c851 <read_super+0x17e>
	block = 2;
    c84d:	31 ff                	xor    %edi,%edi
    c84f:	eb 23                	jmp    c874 <read_super+0x1a1>
			block++;
    c851:	46                   	inc    %esi
    c852:	eb d7                	jmp    c82b <read_super+0x158>
		else
			break;
	// 从i节点位图之后开始读取逻辑块位图
	for (i = 0 ; i < s->s_zmap_blocks ; i++)			// 读取设备中逻辑块位图.
		if (s->s_zmap[i] = bread(dev, block))
    c854:	50                   	push   %eax
    c855:	50                   	push   %eax
    c856:	52                   	push   %edx
    c857:	89 54 24 18          	mov    %edx,0x18(%esp)
    c85b:	ff 74 24 10          	pushl  0x10(%esp)
    c85f:	e8 4c fb ff ff       	call   c3b0 <bread>
    c864:	83 c4 10             	add    $0x10,%esp
    c867:	85 c0                	test   %eax,%eax
    c869:	89 44 bd 34          	mov    %eax,0x34(%ebp,%edi,4)
    c86d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    c871:	74 0c                	je     c87f <read_super+0x1ac>
	for (i = 0 ; i < s->s_zmap_blocks ; i++)			// 读取设备中逻辑块位图.
    c873:	47                   	inc    %edi
    c874:	0f b7 45 06          	movzwl 0x6(%ebp),%eax
    c878:	8d 14 37             	lea    (%edi,%esi,1),%edx
    c87b:	39 c7                	cmp    %eax,%edi
    c87d:	7c d5                	jl     c854 <read_super+0x181>
			block++;
		else
			break;
	// 如果读出的位图个数不等于位图应该占有的逻辑块数,说明文件系统位图信息有问题,超级块初始化失败.因此只能释放前面申请并占用的所有资源,即释放i节点位图和逻辑块位图占用
	// 的高速缓冲块,释放上面选定的超级块数组项,解锁该超级块项,并返回空指针退出.
	if (block != 2 + s->s_imap_blocks + s->s_zmap_blocks) {
    c87f:	0f b7 4d 04          	movzwl 0x4(%ebp),%ecx
    c883:	0f b7 45 06          	movzwl 0x6(%ebp),%eax
    c887:	8d 44 01 02          	lea    0x2(%ecx,%eax,1),%eax
    c88b:	39 d0                	cmp    %edx,%eax
    c88d:	74 3d                	je     c8cc <read_super+0x1f9>
		for(i = 0; i < I_MAP_SLOTS; i++)				// 释放位图占用的高速缓冲块.
    c88f:	31 f6                	xor    %esi,%esi
			brelse(s->s_imap[i]);
    c891:	83 ec 0c             	sub    $0xc,%esp
    c894:	ff 74 b5 14          	pushl  0x14(%ebp,%esi,4)
		for(i = 0; i < I_MAP_SLOTS; i++)				// 释放位图占用的高速缓冲块.
    c898:	46                   	inc    %esi
			brelse(s->s_imap[i]);
    c899:	e8 c0 fa ff ff       	call   c35e <brelse>
    c89e:	83 c4 10             	add    $0x10,%esp
		for(i = 0; i < I_MAP_SLOTS; i++)				// 释放位图占用的高速缓冲块.
    c8a1:	83 fe 08             	cmp    $0x8,%esi
    c8a4:	75 eb                	jne    c891 <read_super+0x1be>
		for(i = 0; i < Z_MAP_SLOTS; i++)
    c8a6:	31 f6                	xor    %esi,%esi
			brelse(s->s_zmap[i]);
    c8a8:	83 ec 0c             	sub    $0xc,%esp
    c8ab:	ff 74 b5 34          	pushl  0x34(%ebp,%esi,4)
		for(i = 0; i < Z_MAP_SLOTS; i++)
    c8af:	46                   	inc    %esi
			brelse(s->s_zmap[i]);
    c8b0:	e8 a9 fa ff ff       	call   c35e <brelse>
    c8b5:	83 c4 10             	add    $0x10,%esp
		for(i = 0; i < Z_MAP_SLOTS; i++)
    c8b8:	83 fe 08             	cmp    $0x8,%esi
    c8bb:	75 eb                	jne    c8a8 <read_super+0x1d5>
		s->s_dev = 0;									// 释放选定的超级块数组项.
    c8bd:	66 c7 45 54 00 00    	movw   $0x0,0x54(%ebp)
		free_super(s);									// 解锁该超级块项.
    c8c3:	89 e8                	mov    %ebp,%eax
    c8c5:	e8 7a fd ff ff       	call   c644 <free_super>
    c8ca:	eb 1b                	jmp    c8e7 <read_super+0x214>
		return NULL;
	}
	// 否则一切成功.另外,由于对于申请空闲i节点的函数来讲,如果设备所有的i节点已经全被使用,则查找函数会返回0值.因此0号i节点是不能用的,所以这里将位图中第1块的最低位设置为
	// 1,以防止文件系统分配0号i节点.同样的道理,也将逻辑块位图的最低位设置为1.最后函数解锁该超级块,并返回超级块指针.
	s->s_imap[0]->b_data[0] |= 1;
    c8cc:	8b 45 14             	mov    0x14(%ebp),%eax
    c8cf:	8b 00                	mov    (%eax),%eax
    c8d1:	80 08 01             	orb    $0x1,(%eax)
	s->s_zmap[0]->b_data[0] |= 1;
    c8d4:	8b 45 34             	mov    0x34(%ebp),%eax
    c8d7:	8b 00                	mov    (%eax),%eax
    c8d9:	80 08 01             	orb    $0x1,(%eax)
	free_super(s);
    c8dc:	89 e8                	mov    %ebp,%eax
    c8de:	e8 61 fd ff ff       	call   c644 <free_super>
    c8e3:	89 6c 24 08          	mov    %ebp,0x8(%esp)
	return s;
}
    c8e7:	8b 44 24 08          	mov    0x8(%esp),%eax
    c8eb:	83 c4 1c             	add    $0x1c,%esp
    c8ee:	5b                   	pop    %ebx
    c8ef:	5e                   	pop    %esi
    c8f0:	5f                   	pop    %edi
    c8f1:	5d                   	pop    %ebp
    c8f2:	c3                   	ret    

0000c8f3 <put_super>:
{
    c8f3:	57                   	push   %edi
    c8f4:	56                   	push   %esi
    c8f5:	53                   	push   %ebx
    c8f6:	8b 44 24 10          	mov    0x10(%esp),%eax
    c8fa:	e8 2d a1 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c8ff:	81 c3 01 47 01 00    	add    $0x14701,%ebx
	if (dev == ROOT_DEV) {
    c905:	39 83 0c 40 00 00    	cmp    %eax,0x400c(%ebx)
    c90b:	75 0b                	jne    c918 <put_super+0x25>
		printk("root diskette changed: prepare for armageddon\n\r");
    c90d:	83 ec 0c             	sub    $0xc,%esp
    c910:	8d 83 c4 73 ff ff    	lea    -0x8c3c(%ebx),%eax
    c916:	eb 21                	jmp    c939 <put_super+0x46>
	if (!(sb = get_super(dev)))
    c918:	83 ec 0c             	sub    $0xc,%esp
    c91b:	50                   	push   %eax
    c91c:	e8 46 fd ff ff       	call   c667 <get_super>
    c921:	83 c4 10             	add    $0x10,%esp
    c924:	85 c0                	test   %eax,%eax
    c926:	89 c6                	mov    %eax,%esi
    c928:	74 75                	je     c99f <put_super+0xac>
	if (sb->s_imount) {
    c92a:	83 78 5c 00          	cmpl   $0x0,0x5c(%eax)
    c92e:	74 14                	je     c944 <put_super+0x51>
		printk("Mounted disk changed - tssk, tssk\n\r");
    c930:	8d 83 f4 73 ff ff    	lea    -0x8c0c(%ebx),%eax
    c936:	83 ec 0c             	sub    $0xc,%esp
    c939:	50                   	push   %eax
    c93a:	e8 e2 b7 ff ff       	call   8121 <printk>
    c93f:	83 c4 10             	add    $0x10,%esp
    c942:	eb 5b                	jmp    c99f <put_super+0xac>
	cli();													//　关中断
    c944:	fa                   	cli    
	while (sb->s_lock)										//　如果该超级块已经上锁,则睡眠等待.
    c945:	80 7e 68 00          	cmpb   $0x0,0x68(%esi)
    c949:	74 11                	je     c95c <put_super+0x69>
		sleep_on(&(sb->s_wait));
    c94b:	8d 46 64             	lea    0x64(%esi),%eax
    c94e:	83 ec 0c             	sub    $0xc,%esp
    c951:	50                   	push   %eax
    c952:	e8 2e a5 ff ff       	call   6e85 <sleep_on>
    c957:	83 c4 10             	add    $0x10,%esp
    c95a:	eb e9                	jmp    c945 <put_super+0x52>
	sb->s_lock = 1;											//　给该超级块加锁(置锁定标志)
    c95c:	c6 46 68 01          	movb   $0x1,0x68(%esi)
	sti();													//　开中断.
    c960:	fb                   	sti    
	for(i = 0; i < I_MAP_SLOTS; i++)
    c961:	31 ff                	xor    %edi,%edi
	sb->s_dev = 0;                          		// 置超级块空闲。
    c963:	66 c7 46 54 00 00    	movw   $0x0,0x54(%esi)
		brelse(sb->s_imap[i]);
    c969:	83 ec 0c             	sub    $0xc,%esp
    c96c:	ff 74 be 14          	pushl  0x14(%esi,%edi,4)
	for(i = 0; i < I_MAP_SLOTS; i++)
    c970:	47                   	inc    %edi
		brelse(sb->s_imap[i]);
    c971:	e8 e8 f9 ff ff       	call   c35e <brelse>
    c976:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < I_MAP_SLOTS; i++)
    c979:	83 ff 08             	cmp    $0x8,%edi
    c97c:	75 eb                	jne    c969 <put_super+0x76>
	for(i = 0; i < Z_MAP_SLOTS; i++)
    c97e:	31 ff                	xor    %edi,%edi
		brelse(sb->s_zmap[i]);
    c980:	83 ec 0c             	sub    $0xc,%esp
    c983:	ff 74 be 34          	pushl  0x34(%esi,%edi,4)
	for(i = 0; i < Z_MAP_SLOTS; i++)
    c987:	47                   	inc    %edi
		brelse(sb->s_zmap[i]);
    c988:	e8 d1 f9 ff ff       	call   c35e <brelse>
    c98d:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < Z_MAP_SLOTS; i++)
    c990:	83 ff 08             	cmp    $0x8,%edi
    c993:	75 eb                	jne    c980 <put_super+0x8d>
}
    c995:	5b                   	pop    %ebx
	free_super(sb);
    c996:	89 f0                	mov    %esi,%eax
}
    c998:	5e                   	pop    %esi
    c999:	5f                   	pop    %edi
	free_super(sb);
    c99a:	e9 a5 fc ff ff       	jmp    c644 <free_super>
}
    c99f:	5b                   	pop    %ebx
    c9a0:	5e                   	pop    %esi
    c9a1:	5f                   	pop    %edi
    c9a2:	c3                   	ret    

0000c9a3 <sys_umount>:
// 卸载文件系统（系统调用）。
// 参数dev_name是文件系统所在设备的设备文件名。
// 该函数首先根据参数给出的块设备文件名获得设备号，然后复位文件系统超级块中的相应字段，释放超级块和位图占用的缓冲块，最后对该
// 设备执行高速缓冲与设备上数据的同步操作。若卸载操作成功则返回0，否则返回出错码。
int sys_umount(char * dev_name)
{
    c9a3:	55                   	push   %ebp
    c9a4:	57                   	push   %edi
    c9a5:	56                   	push   %esi
    c9a6:	53                   	push   %ebx
    c9a7:	e8 80 a0 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    c9ac:	81 c3 54 46 01 00    	add    $0x14654,%ebx
    c9b2:	83 ec 18             	sub    $0x18,%esp
	int dev;

	// 首先根据设备文件名找到对应的i节点，并取其中的设备号。设备文件所定义设备号是保存在其i节点的i_zone[0]中的。参见后面namei.c
	// 程序中系统调用sys_mknod()的代码第445行。另外，由于文件系统需要存放在块设备上，因此如果不是块设备文件，则放回刚申请的i节点
	// dev_i，返回出错码。
	if (!(inode = namei(dev_name)))
    c9b5:	ff 74 24 2c          	pushl  0x2c(%esp)
    c9b9:	e8 7a 1f 00 00       	call   e938 <namei>
    c9be:	83 c4 10             	add    $0x10,%esp
    c9c1:	85 c0                	test   %eax,%eax
    c9c3:	75 0a                	jne    c9cf <sys_umount+0x2c>
		return -ENOENT;
    c9c5:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    c9ca:	e9 d6 00 00 00       	jmp    caa5 <sys_umount+0x102>
	dev = inode->i_zone[0];
	if (!S_ISBLK(inode->i_mode)) {
    c9cf:	8b 10                	mov    (%eax),%edx
	dev = inode->i_zone[0];
    c9d1:	0f b7 70 0e          	movzwl 0xe(%eax),%esi
	if (!S_ISBLK(inode->i_mode)) {
    c9d5:	66 81 e2 00 f0       	and    $0xf000,%dx
    c9da:	66 81 fa 00 60       	cmp    $0x6000,%dx
	dev = inode->i_zone[0];
    c9df:	89 f7                	mov    %esi,%edi
	if (!S_ISBLK(inode->i_mode)) {
    c9e1:	74 16                	je     c9f9 <sys_umount+0x56>
		iput(inode);                    				// fs/inode.c。
    c9e3:	83 ec 0c             	sub    $0xc,%esp
    c9e6:	50                   	push   %eax
    c9e7:	e8 3c f1 ff ff       	call   bb28 <iput>
    c9ec:	83 c4 10             	add    $0x10,%esp
		return -ENOTBLK;
    c9ef:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    c9f4:	e9 ac 00 00 00       	jmp    caa5 <sys_umount+0x102>
	}
	// OK，现在上面为了得到设备号而取得的i节点已完成了它的使命，因此这里放回该设备文件的i节点。接着我们来检查一下卸载该文件系统的
	// 条件是否满足。如果设备上是根文件系统，则不能卸载，返回忙出错号。
	iput(inode);
    c9f9:	83 ec 0c             	sub    $0xc,%esp
    c9fc:	50                   	push   %eax
    c9fd:	e8 26 f1 ff ff       	call   bb28 <iput>
    ca02:	83 c4 10             	add    $0x10,%esp
	if (dev == ROOT_DEV)
    ca05:	39 b3 0c 40 00 00    	cmp    %esi,0x400c(%ebx)
    ca0b:	75 0a                	jne    ca17 <sys_umount+0x74>
		return -EBUSY;
    ca0d:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    ca12:	e9 8e 00 00 00       	jmp    caa5 <sys_umount+0x102>
	// 如果在超级块表中没有找到该设备上文件系统的超级块，或者已找到但是该设备上文件系统没有安装过，则返回出错码。如果超级块所指明
	// 被安装到的i节点并没有置位其安装标志i_mount，则显示警告信息。然后查找一下i节点表，看看是否有进程在使用该设备上的文件，如果
	// 有则返回忙出错码。
	if (!(sb = get_super(dev)) || !(sb->s_imount))
    ca17:	83 ec 0c             	sub    $0xc,%esp
    ca1a:	56                   	push   %esi
    ca1b:	e8 47 fc ff ff       	call   c667 <get_super>
    ca20:	83 c4 10             	add    $0x10,%esp
    ca23:	85 c0                	test   %eax,%eax
    ca25:	89 c5                	mov    %eax,%ebp
    ca27:	74 9c                	je     c9c5 <sys_umount+0x22>
    ca29:	8b 40 5c             	mov    0x5c(%eax),%eax
    ca2c:	85 c0                	test   %eax,%eax
    ca2e:	74 95                	je     c9c5 <sys_umount+0x22>
		return -ENOENT;
	if (!sb->s_imount->i_mount)
    ca30:	80 78 39 00          	cmpb   $0x0,0x39(%eax)
    ca34:	75 12                	jne    ca48 <sys_umount+0xa5>
		printk("Mounted inode has i_mount=0\n");
    ca36:	8d 83 18 74 ff ff    	lea    -0x8be8(%ebx),%eax
    ca3c:	83 ec 0c             	sub    $0xc,%esp
    ca3f:	50                   	push   %eax
    ca40:	e8 dc b6 ff ff       	call   8121 <printk>
    ca45:	83 c4 10             	add    $0x10,%esp
	for (inode = inode_table + 0 ; inode < inode_table + NR_INODE ; inode++)
		if (inode->i_dev == dev && inode->i_count)
    ca48:	c7 c2 00 41 02 00    	mov    $0x24100,%edx
{
    ca4e:	31 c0                	xor    %eax,%eax
		if (inode->i_dev == dev && inode->i_count)
    ca50:	66 3b 7c 10 30       	cmp    0x30(%eax,%edx,1),%di
    ca55:	75 08                	jne    ca5f <sys_umount+0xbc>
    ca57:	66 83 7c 10 34 00    	cmpw   $0x0,0x34(%eax,%edx,1)
    ca5d:	75 ae                	jne    ca0d <sys_umount+0x6a>
    ca5f:	83 c0 3c             	add    $0x3c,%eax
	for (inode = inode_table + 0 ; inode < inode_table + NR_INODE ; inode++)
    ca62:	3d 00 0f 00 00       	cmp    $0xf00,%eax
    ca67:	75 e7                	jne    ca50 <sys_umount+0xad>
				return -EBUSY;
	// 现在该设备上文件系统的卸载条件均得到满足，因此我们可以开始实施真正的卸载操作了。首先复位被安装到的i节点的安装标志，释放该
	// i节点。然后置超级块中被安装i节点字段为空，并放回设备文件系统的根i节点，接着置超级块中被安装系统根i节点指针为空。
	sb->s_imount->i_mount = 0;
    ca69:	8b 45 5c             	mov    0x5c(%ebp),%eax
	iput(sb->s_imount);
    ca6c:	83 ec 0c             	sub    $0xc,%esp
	sb->s_imount->i_mount = 0;
    ca6f:	c6 40 39 00          	movb   $0x0,0x39(%eax)
	iput(sb->s_imount);
    ca73:	50                   	push   %eax
    ca74:	e8 af f0 ff ff       	call   bb28 <iput>
    ca79:	58                   	pop    %eax
	sb->s_imount = NULL;
    ca7a:	c7 45 5c 00 00 00 00 	movl   $0x0,0x5c(%ebp)
	iput(sb->s_isup);
    ca81:	ff 75 58             	pushl  0x58(%ebp)
    ca84:	e8 9f f0 ff ff       	call   bb28 <iput>
	sb->s_isup = NULL;
    ca89:	c7 45 58 00 00 00 00 	movl   $0x0,0x58(%ebp)
	// 最后我们释放该设备上的超级块以及位图占用的高速缓冲块，并对该设备执行高速缓冲与设备上数据的同步操作。然后返回0（卸载成功）。
	put_super(dev);
    ca90:	89 34 24             	mov    %esi,(%esp)
    ca93:	e8 5b fe ff ff       	call   c8f3 <put_super>
	sync_dev(dev);
    ca98:	89 34 24             	mov    %esi,(%esp)
    ca9b:	e8 6f f5 ff ff       	call   c00f <sync_dev>
    caa0:	83 c4 10             	add    $0x10,%esp
	return 0;
    caa3:	31 c0                	xor    %eax,%eax
}
    caa5:	83 c4 0c             	add    $0xc,%esp
    caa8:	5b                   	pop    %ebx
    caa9:	5e                   	pop    %esi
    caaa:	5f                   	pop    %edi
    caab:	5d                   	pop    %ebp
    caac:	c3                   	ret    

0000caad <sys_mount>:

// 安装文件系统（系统调用）。
// 参数dev_name是设备文件名，dir_name是安装到的目录名，rw_flag被安装文件系统的可读写标志。将被加载的地方必须是一
// 个目录名，并且对应的i节点没有被其他程序占用。若操作成功则返回0,否则返回出错号。
int sys_mount(char * dev_name, char * dir_name, int rw_flag)
{
    caad:	57                   	push   %edi
    caae:	56                   	push   %esi
    caaf:	53                   	push   %ebx
    cab0:	e8 77 9f ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    cab5:	81 c3 4b 45 01 00    	add    $0x1454b,%ebx
	struct super_block * sb;
	int dev;

	// 首先根据设备文件名找到对应的i节点，以取得其中的设备号。对于块特殊设备文件，设备号在其i节点的i_zone[0]中。另外，
	// 由于文件系统必须在块设备中，因此如果不是块设备文件，则放回刚得的i节点dev_i，返回出错码。
	if (!(dev_i = namei(dev_name)))
    cabb:	83 ec 0c             	sub    $0xc,%esp
    cabe:	ff 74 24 1c          	pushl  0x1c(%esp)
    cac2:	e8 71 1e 00 00       	call   e938 <namei>
    cac7:	83 c4 10             	add    $0x10,%esp
    caca:	85 c0                	test   %eax,%eax
    cacc:	75 0a                	jne    cad8 <sys_mount+0x2b>
		return -ENOENT;
    cace:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    cad3:	e9 96 00 00 00       	jmp    cb6e <sys_mount+0xc1>
	dev = dev_i->i_zone[0];
	if (!S_ISBLK(dev_i->i_mode)) {
    cad8:	8b 10                	mov    (%eax),%edx
	dev = dev_i->i_zone[0];
    cada:	0f b7 78 0e          	movzwl 0xe(%eax),%edi
	if (!S_ISBLK(dev_i->i_mode)) {
    cade:	66 81 e2 00 f0       	and    $0xf000,%dx
    cae3:	66 81 fa 00 60       	cmp    $0x6000,%dx
    cae8:	74 06                	je     caf0 <sys_mount+0x43>
		iput(dev_i);
    caea:	83 ec 0c             	sub    $0xc,%esp
    caed:	50                   	push   %eax
    caee:	eb 3a                	jmp    cb2a <sys_mount+0x7d>
	}
	// OK，现在上面为了得到设备号而取得的i节点dev_i已经完成了它的使命，因此这里放回该设备文件的i节点。接着我们来检查一
	// 下文件系统安装到的目录名是否有效。于是根据给定的目录文件名找到对应的i节点dir_i。如果该i节点的引用计数不为1（仅在
	// 这里引用），或者该i节点的节点号是根文件系统的节点号1,则放回该i节点返回出错码。另外，如果该节点不是一个目录文件节点，
	// 则也放回该i节点，返回出错码。因为文件系统只能安装在一个目录名上。
	iput(dev_i);
    caf0:	83 ec 0c             	sub    $0xc,%esp
    caf3:	50                   	push   %eax
    caf4:	e8 2f f0 ff ff       	call   bb28 <iput>
    caf9:	58                   	pop    %eax
	if (!(dir_i = namei(dir_name)))
    cafa:	ff 74 24 20          	pushl  0x20(%esp)
    cafe:	e8 35 1e 00 00       	call   e938 <namei>
    cb03:	83 c4 10             	add    $0x10,%esp
    cb06:	85 c0                	test   %eax,%eax
    cb08:	89 c6                	mov    %eax,%esi
    cb0a:	74 c2                	je     cace <sys_mount+0x21>
		return -ENOENT;
	if (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) {
    cb0c:	66 83 78 34 01       	cmpw   $0x1,0x34(%eax)
    cb11:	75 35                	jne    cb48 <sys_mount+0x9b>
    cb13:	66 83 78 32 01       	cmpw   $0x1,0x32(%eax)
    cb18:	74 2e                	je     cb48 <sys_mount+0x9b>
		iput(dir_i);
		return -EBUSY;
	}
	if (!S_ISDIR(dir_i->i_mode)) {          			// 安装点需要是一个目录名。
    cb1a:	8b 00                	mov    (%eax),%eax
    cb1c:	66 25 00 f0          	and    $0xf000,%ax
    cb20:	66 3d 00 40          	cmp    $0x4000,%ax
    cb24:	74 11                	je     cb37 <sys_mount+0x8a>
		iput(dir_i);
    cb26:	83 ec 0c             	sub    $0xc,%esp
    cb29:	56                   	push   %esi
    cb2a:	e8 f9 ef ff ff       	call   bb28 <iput>
    cb2f:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    cb32:	83 c8 ff             	or     $0xffffffff,%eax
    cb35:	eb 37                	jmp    cb6e <sys_mount+0xc1>
	}
	// 现在安装点也检查完毕，我们开始读取要安装文件系统的超级块信息。如果读超级块操作失败，则放回该安装点i节点dir_i并返回
	// 出错码。一个文件系统的超级块会首先从超级块表中进行搜索，如果不在超级块表中就从设备上读取。
	if (!(sb = read_super(dev))) {
    cb37:	89 f8                	mov    %edi,%eax
    cb39:	e8 95 fb ff ff       	call   c6d3 <read_super>
    cb3e:	85 c0                	test   %eax,%eax
    cb40:	74 06                	je     cb48 <sys_mount+0x9b>
		iput(dir_i);
		return -EBUSY;
	}
	// 在等到了文件系统超级块之后，我们对它先进行检测一番。如果将要被安装的文件系统已经安装在其他地方，则放回该i节点，返回
	// 出错码。如果将要安装到的i节点已经安装了文件系统（安装标志已经置位），则放回该i节点，也返回出错码。
	if (sb->s_imount) {
    cb42:	83 78 5c 00          	cmpl   $0x0,0x5c(%eax)
    cb46:	74 13                	je     cb5b <sys_mount+0xae>
		iput(dir_i);
    cb48:	83 ec 0c             	sub    $0xc,%esp
    cb4b:	56                   	push   %esi
    cb4c:	e8 d7 ef ff ff       	call   bb28 <iput>
    cb51:	83 c4 10             	add    $0x10,%esp
		return -EBUSY;
    cb54:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    cb59:	eb 13                	jmp    cb6e <sys_mount+0xc1>
	}
	if (dir_i->i_mount) {
    cb5b:	80 7e 39 00          	cmpb   $0x0,0x39(%esi)
    cb5f:	75 c5                	jne    cb26 <sys_mount+0x79>
		iput(dir_i);
		return -EPERM;
	}
	// 最后设置被安装文件系统超级块的“被安装到i节点”字段指向安装到的目录名的i节点。并设置安装位置i节点的安装标志和节点已修改
	// 标志。然后返回0（安装成功）。
	sb->s_imount = dir_i;
    cb61:	89 70 5c             	mov    %esi,0x5c(%eax)
	dir_i->i_mount = 1;
    cb64:	c6 46 39 01          	movb   $0x1,0x39(%esi)
	dir_i->i_dirt = 1;									/* NOTE! we don't iput(dir_i) */        /* 注意！这里没有用iput(dir_i) */
	return 0;											/* we do that in umount */      /* 这将在umount内操作 */
    cb68:	31 c0                	xor    %eax,%eax
	dir_i->i_dirt = 1;									/* NOTE! we don't iput(dir_i) */        /* 注意！这里没有用iput(dir_i) */
    cb6a:	c6 46 37 01          	movb   $0x1,0x37(%esi)
}
    cb6e:	5b                   	pop    %ebx
    cb6f:	5e                   	pop    %esi
    cb70:	5f                   	pop    %edi
    cb71:	c3                   	ret    

0000cb72 <mount_root>:

// 安装根文件系统.
// 该函数属于系统初始化操作的一部分.函数首先初始化文件表数组file_table[]和超级块表(数组),然后读取根文件系统超级块,并取得文件系统根i
// 节点.最后统计并显示出根文件系统上的可用资源(空闲块数和空闲i节点数0.该函数会在系统开机进行初始化设置时(sys_setup())调用(blk_drv/hd.c)>
void mount_root(void)
{
    cb72:	55                   	push   %ebp
    cb73:	57                   	push   %edi
    cb74:	31 c0                	xor    %eax,%eax
    cb76:	56                   	push   %esi
    cb77:	53                   	push   %ebx
    cb78:	e8 af 9e ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    cb7d:	81 c3 83 44 01 00    	add    $0x14483,%ebx
    cb83:	83 ec 1c             	sub    $0x1c,%esp
	if (32 != sizeof (struct d_inode))
		panic("bad i-node size");
	// 首先初始化文件表数组(共64项,即系统同时只能打开64个文件)和超级块表.这里将所有文件结构中的引用计数设置为0(表示空闲),并把超级块表中各项结构
	// 的设备字段初始化为0(也表示空闲).如果根文件系统所在设备是软盘的话,就提示"插入根文件系统盘,并按回车键",并等待按键.
	for(i = 0; i < NR_FILE; i++)									// 初始化文件表.
		file_table[i].f_count = 0;
    cb86:	c7 c2 60 4e 03 00    	mov    $0x34e60,%edx
    cb8c:	66 c7 44 10 04 00 00 	movw   $0x0,0x4(%eax,%edx,1)
    cb93:	83 c0 10             	add    $0x10,%eax
	for(i = 0; i < NR_FILE; i++)									// 初始化文件表.
    cb96:	3d 00 04 00 00       	cmp    $0x400,%eax
    cb9b:	75 ef                	jne    cb8c <mount_root+0x1a>
	if (MAJOR(ROOT_DEV) == 2) {										// 提示插入根文件系统盘.
    cb9d:	8b 83 0c 40 00 00    	mov    0x400c(%ebx),%eax
    cba3:	c1 e8 08             	shr    $0x8,%eax
    cba6:	83 f8 02             	cmp    $0x2,%eax
    cba9:	75 17                	jne    cbc2 <mount_root+0x50>
		printk("Insert root floppy and press ENTER\r\n");
    cbab:	8d 83 35 74 ff ff    	lea    -0x8bcb(%ebx),%eax
    cbb1:	83 ec 0c             	sub    $0xc,%esp
    cbb4:	50                   	push   %eax
    cbb5:	e8 67 b5 ff ff       	call   8121 <printk>
    cbba:	83 c4 10             	add    $0x10,%esp
		wait_for_keypress();
    cbbd:	e8 9a 56 00 00       	call   1225c <wait_for_keypress>
{
    cbc2:	c7 c0 00 4b 03 00    	mov    $0x34b00,%eax
	}
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
    cbc8:	8d 90 60 03 00 00    	lea    0x360(%eax),%edx
		p->s_dev = 0;												// 初始化超级块表
    cbce:	66 c7 40 54 00 00    	movw   $0x0,0x54(%eax)
		p->s_lock = 0;
    cbd4:	c6 40 68 00          	movb   $0x0,0x68(%eax)
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
    cbd8:	83 c0 6c             	add    $0x6c,%eax
		p->s_wait = NULL;
    cbdb:	c7 40 f8 00 00 00 00 	movl   $0x0,-0x8(%eax)
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {
    cbe2:	39 d0                	cmp    %edx,%eax
    cbe4:	72 e8                	jb     cbce <mount_root+0x5c>
	}
	// 做好以上"份外"的初始化工作之后,我们开始安装根文件系统.于是从根设备上读取文件系统超级块,并取得文件系统的根i节点(1号节点)在内存i节点表中的指针.
	// 如果读根设备上超级块失败或取根节点失败,则都显示信息并停机.
	if (!(p = read_super(ROOT_DEV)))
    cbe6:	8b 83 0c 40 00 00    	mov    0x400c(%ebx),%eax
    cbec:	e8 e2 fa ff ff       	call   c6d3 <read_super>
    cbf1:	85 c0                	test   %eax,%eax
    cbf3:	89 c6                	mov    %eax,%esi
    cbf5:	75 12                	jne    cc09 <mount_root+0x97>
		panic("Unable to mount root");
    cbf7:	8d 83 5a 74 ff ff    	lea    -0x8ba6(%ebx),%eax
    cbfd:	83 ec 0c             	sub    $0xc,%esp
    cc00:	50                   	push   %eax
    cc01:	e8 cc b4 ff ff       	call   80d2 <panic>
    cc06:	83 c4 10             	add    $0x10,%esp
	if (!(mi = iget(ROOT_DEV, ROOT_INO)))							// 在fs.h中ROOT_INO定义为1.
    cc09:	50                   	push   %eax
    cc0a:	50                   	push   %eax
    cc0b:	6a 01                	push   $0x1
    cc0d:	ff b3 0c 40 00 00    	pushl  0x400c(%ebx)
    cc13:	e8 12 f1 ff ff       	call   bd2a <iget>
    cc18:	83 c4 10             	add    $0x10,%esp
    cc1b:	85 c0                	test   %eax,%eax
    cc1d:	89 c7                	mov    %eax,%edi
    cc1f:	75 12                	jne    cc33 <mount_root+0xc1>
		panic("Unable to read root i-node");
    cc21:	8d 83 6f 74 ff ff    	lea    -0x8b91(%ebx),%eax
    cc27:	83 ec 0c             	sub    $0xc,%esp
    cc2a:	50                   	push   %eax
    cc2b:	e8 a2 b4 ff ff       	call   80d2 <panic>
    cc30:	83 c4 10             	add    $0x10,%esp
	// 现在我们对超级块和根i节点进行设置.把根i节点引用次数递增3次.因为下面266行上也引用了该i节点.另外,iget()函数中i节点引用计数已被设置为1.然后置该
	// 超级块的被安装文件系统i节点和被安装到i节点字段为该i节点.再设置当前进程的当前工作目录和根目录i节点.此时当前进程是1号进程(init进程).
	mi->i_count += 3 ;												/* NOTE! it is logically used 4 times, not 1 */
                                									/* 注意!从逻辑上讲,它已被引用了4次,而不是1次 */
	p->s_isup = p->s_imount = mi;
	current->pwd = mi;
    cc33:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	mi->i_count += 3 ;												/* NOTE! it is logically used 4 times, not 1 */
    cc39:	66 83 47 34 03       	addw   $0x3,0x34(%edi)
	p->s_isup = p->s_imount = mi;
    cc3e:	89 7e 5c             	mov    %edi,0x5c(%esi)
    cc41:	89 7e 58             	mov    %edi,0x58(%esi)
	current->root = mi;
	// 然后我们对根文件系统上的资源作统计工作.统计该设备上空闲块数和空闲i节点数.首先令i等于超级块中表明的设备逻辑块总数.然后根据逻辑块位图中相应位的占用情况统计出空闲块数.
	// 这里宏函数set_bit()只是在测试位,而非设置位."i&8191"用于取得i节点号在当前位图块中对应的位偏移值."i>>13"是将i除以8192,也即除一个磁盘块包含的位数.
	free = 0;
    cc44:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    cc4b:	00 
	current->pwd = mi;
    cc4c:	8b 00                	mov    (%eax),%eax
    cc4e:	89 b8 34 03 00 00    	mov    %edi,0x334(%eax)
	current->root = mi;
    cc54:	89 b8 38 03 00 00    	mov    %edi,0x338(%eax)
	i = p->s_nzones;
    cc5a:	0f b7 7e 02          	movzwl 0x2(%esi),%edi
    cc5e:	89 fa                	mov    %edi,%edx
	while (-- i >= 0)
    cc60:	4a                   	dec    %edx
    cc61:	83 fa ff             	cmp    $0xffffffff,%edx
    cc64:	74 27                	je     cc8d <mount_root+0x11b>
		if (!set_bit(i & 8191, p->s_zmap[i >> 13]->b_data))
    cc66:	89 d0                	mov    %edx,%eax
    cc68:	25 ff 1f 00 00       	and    $0x1fff,%eax
    cc6d:	89 c1                	mov    %eax,%ecx
    cc6f:	89 d0                	mov    %edx,%eax
    cc71:	c1 f8 0d             	sar    $0xd,%eax
    cc74:	8b 44 86 34          	mov    0x34(%esi,%eax,4),%eax
    cc78:	8b 28                	mov    (%eax),%ebp
    cc7a:	31 c0                	xor    %eax,%eax
    cc7c:	0f a3 4d 00          	bt     %ecx,0x0(%ebp)
    cc80:	0f 92 c0             	setb   %al
    cc83:	85 c0                	test   %eax,%eax
    cc85:	75 d9                	jne    cc60 <mount_root+0xee>
			free++;
    cc87:	ff 44 24 0c          	incl   0xc(%esp)
    cc8b:	eb d3                	jmp    cc60 <mount_root+0xee>
	// 打印当前主设备上空闲和总的逻辑块数
	Log(LOG_INFO_TYPE, "<<<<< %d/%d free blocks >>>>>\n\r", free, p->s_nzones);
    cc8d:	8d 83 8a 74 ff ff    	lea    -0x8b76(%ebx),%eax
    cc93:	57                   	push   %edi
    cc94:	ff 74 24 10          	pushl  0x10(%esp)
    cc98:	50                   	push   %eax
    cc99:	6a 00                	push   $0x0
    cc9b:	e8 ef a7 00 00       	call   1748f <Log>
	// 在显示过设备上空闲逻辑块数/逻辑块总数之后.我们再统计设备上空闲i节点数.首先令i等于超级块中表明的设备上i中总数+1.加1是将0节点也统计进去.然后根据i节点位图中相应位的
	// 占用情况计算出空闲i节点数.最后再显示设备上可用空闲i节点数和i节点总数.
	free = 0;
	i = p->s_ninodes + 1;
    cca0:	0f b7 3e             	movzwl (%esi),%edi
	Log(LOG_INFO_TYPE, "<<<<< %d/%d free blocks >>>>>\n\r", free, p->s_nzones);
    cca3:	83 c4 10             	add    $0x10,%esp
	free = 0;
    cca6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    ccad:	00 
	i = p->s_ninodes + 1;
    ccae:	8d 57 01             	lea    0x1(%edi),%edx
	while (-- i >= 0)
    ccb1:	4a                   	dec    %edx
    ccb2:	83 fa ff             	cmp    $0xffffffff,%edx
    ccb5:	74 27                	je     ccde <mount_root+0x16c>
		if (!set_bit(i & 8191, p->s_imap[i >> 13]->b_data))
    ccb7:	89 d0                	mov    %edx,%eax
    ccb9:	25 ff 1f 00 00       	and    $0x1fff,%eax
    ccbe:	89 c1                	mov    %eax,%ecx
    ccc0:	89 d0                	mov    %edx,%eax
    ccc2:	c1 f8 0d             	sar    $0xd,%eax
    ccc5:	8b 44 86 14          	mov    0x14(%esi,%eax,4),%eax
    ccc9:	8b 28                	mov    (%eax),%ebp
    cccb:	31 c0                	xor    %eax,%eax
    cccd:	0f a3 4d 00          	bt     %ecx,0x0(%ebp)
    ccd1:	0f 92 c0             	setb   %al
    ccd4:	85 c0                	test   %eax,%eax
    ccd6:	75 d9                	jne    ccb1 <mount_root+0x13f>
			free++;
    ccd8:	ff 44 24 0c          	incl   0xc(%esp)
    ccdc:	eb d3                	jmp    ccb1 <mount_root+0x13f>
	// 打印当前主设备上i节点空闲和总的数量
	Log(LOG_INFO_TYPE, "<<<<< %d/%d free inodes >>>>>\n\r", free, p->s_ninodes);
    ccde:	8d 83 aa 74 ff ff    	lea    -0x8b56(%ebx),%eax
    cce4:	57                   	push   %edi
    cce5:	ff 74 24 10          	pushl  0x10(%esp)
    cce9:	50                   	push   %eax
    ccea:	6a 00                	push   $0x0
    ccec:	e8 9e a7 00 00       	call   1748f <Log>
}
    ccf1:	83 c4 2c             	add    $0x2c,%esp
    ccf4:	5b                   	pop    %ebx
    ccf5:	5e                   	pop    %esi
    ccf6:	5f                   	pop    %edi
    ccf7:	5d                   	pop    %ebp
    ccf8:	c3                   	ret    

0000ccf9 <block_write>:
// 返回已写入字节数。若没有写入任何字节或出错，则返回出错号。
// 对于内核来说，写操作是向高速缓冲区中写入数据。什么时候数据最终写入设备是高速缓冲管理程序决定并处理的。另外，因为
// 块设备是以块为单位进行读写，因此对于写开始位置不处于块起始处时，需要先将开始字节所在整个块读出，然后将需要写的数据
// 从开始处填写满该块，再将完整的一块数据写盘（即交由高速缓冲程序去处理）。
int block_write(int dev, long * pos, char * buf, int count)
{
    ccf9:	55                   	push   %ebp
    ccfa:	57                   	push   %edi
    ccfb:	56                   	push   %esi
    ccfc:	53                   	push   %ebx
    ccfd:	e8 2a 9d ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    cd02:	81 c3 fe 42 01 00    	add    $0x142fe,%ebx
    cd08:	83 ec 1c             	sub    $0x1c,%esp
	// 首先由文件中位置pos换算成开始写盘块的块序号block，并求出需写第1字节在该块中的偏移位置offset。
	int block = *pos >> BLOCK_SIZE_BITS;            			// pos所在文件数据块号。
    cd0b:	8b 44 24 34          	mov    0x34(%esp),%eax
	register char * p;               	       					// 局部寄存器变量，被存放在寄存器中。

	// 在写一个块设备文件时，要求写的总数据块数当然不能超过指定设备上容许的最大数据块总数。因此这里首先取出指定
	// 设备的块总数size来比较和限制函数参数给定的读入数据长度。如果系统中没有对设备指定长度，就使用默认长度
	// 0x7fffffff（2GB个块）。
	if (blk_size[MAJOR(dev)])
    cd0f:	8b 54 24 30          	mov    0x30(%esp),%edx
		size = blk_size[MAJOR(dev)][MINOR(dev)];
	else
		size = 0x7fffffff;
    cd13:	c7 44 24 0c ff ff ff 	movl   $0x7fffffff,0xc(%esp)
    cd1a:	7f 
	int block = *pos >> BLOCK_SIZE_BITS;            			// pos所在文件数据块号。
    cd1b:	8b 28                	mov    (%eax),%ebp
	if (blk_size[MAJOR(dev)])
    cd1d:	c7 c0 20 50 02 00    	mov    $0x25020,%eax
    cd23:	c1 ea 08             	shr    $0x8,%edx
    cd26:	8b 04 90             	mov    (%eax,%edx,4),%eax
	int block = *pos >> BLOCK_SIZE_BITS;            			// pos所在文件数据块号。
    cd29:	89 ef                	mov    %ebp,%edi
	int offset = *pos & (BLOCK_SIZE - 1);             			// pos在数据块中偏移值。
    cd2b:	81 e5 ff 03 00 00    	and    $0x3ff,%ebp
	int block = *pos >> BLOCK_SIZE_BITS;            			// pos所在文件数据块号。
    cd31:	c1 ff 0a             	sar    $0xa,%edi
	if (blk_size[MAJOR(dev)])
    cd34:	85 c0                	test   %eax,%eax
    cd36:	74 0c                	je     cd44 <block_write+0x4b>
		size = blk_size[MAJOR(dev)][MINOR(dev)];
    cd38:	0f b6 54 24 30       	movzbl 0x30(%esp),%edx
    cd3d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    cd40:	89 44 24 0c          	mov    %eax,0xc(%esp)
		size = 0x7fffffff;
    cd44:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    cd4b:	00 
	// 然后针对要写入的字节数count，循环执行以下操作，直到数据全部写入。在循环执行过程中，若当前写入数据的块号
	// 已经大于或等于指定设备的总块数，则返回已写字节数并退出。然后再计算在当前处理的数据块中可写入的字节数。如果
	// 需要写入的字节数填不满一块，那么就只需写count字节。如果正好写1块数据内容，则直接申请1块高速缓冲块，并把
	// 用户数据放入即可。否则就需要读入将被写入部分数据的数据块，并预读下两块数据。然后将块号递增1,为下次操作做好
	// 准备。如果缓冲块操作失败，则返回已写字节数，如果没有写入任何字节，则返回出错号（负数）。
	while (count > 0) {
    cd4c:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    cd51:	0f 8e a8 00 00 00    	jle    cdff <block_write+0x106>
		if (block >= size)
    cd57:	3b 7c 24 0c          	cmp    0xc(%esp),%edi
    cd5b:	7c 18                	jl     cd75 <block_write+0x7c>
			return written ? written : -EIO;
    cd5d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
    cd62:	0f 85 97 00 00 00    	jne    cdff <block_write+0x106>
    cd68:	c7 44 24 08 fb ff ff 	movl   $0xfffffffb,0x8(%esp)
    cd6f:	ff 
    cd70:	e9 8a 00 00 00       	jmp    cdff <block_write+0x106>
		chars = BLOCK_SIZE - offset;
    cd75:	be 00 04 00 00       	mov    $0x400,%esi
    cd7a:	29 ee                	sub    %ebp,%esi
		if (chars > count)
    cd7c:	39 74 24 3c          	cmp    %esi,0x3c(%esp)
    cd80:	7c 19                	jl     cd9b <block_write+0xa2>
			chars = count;
		if (chars == BLOCK_SIZE)
    cd82:	81 fe 00 04 00 00    	cmp    $0x400,%esi
    cd88:	75 15                	jne    cd9f <block_write+0xa6>
			bh = getblk(dev, block);
    cd8a:	50                   	push   %eax
    cd8b:	50                   	push   %eax
    cd8c:	57                   	push   %edi
    cd8d:	ff 74 24 3c          	pushl  0x3c(%esp)
    cd91:	e8 21 f4 ff ff       	call   c1b7 <getblk>
    cd96:	83 c4 10             	add    $0x10,%esp
    cd99:	eb 1e                	jmp    cdb9 <block_write+0xc0>
    cd9b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
		else
			bh = breada(dev, block, block + 1, block + 2, -1);
    cd9f:	8d 47 02             	lea    0x2(%edi),%eax
    cda2:	83 ec 0c             	sub    $0xc,%esp
    cda5:	6a ff                	push   $0xffffffff
    cda7:	50                   	push   %eax
    cda8:	8d 47 01             	lea    0x1(%edi),%eax
    cdab:	50                   	push   %eax
    cdac:	57                   	push   %edi
    cdad:	ff 74 24 4c          	pushl  0x4c(%esp)
    cdb1:	e8 14 f7 ff ff       	call   c4ca <breada>
    cdb6:	83 c4 20             	add    $0x20,%esp
		block++;
    cdb9:	47                   	inc    %edi
		if (!bh)
    cdba:	85 c0                	test   %eax,%eax
    cdbc:	74 9f                	je     cd5d <block_write+0x64>
		// 并累加这些要写的字节数到统计值written中。再把还需要写的计数值count减去此次要写的字节数chars。然后我们从
		// 用户缓冲区复制chars个字节到p指向的高速缓冲块中开始写入的位置处。复制完后就设置该缓冲区块已修改标志，并释放
		// 该缓冲区（即该缓冲区引用计数递减1）。
		p = offset + bh->b_data;
		offset = 0;
		*pos += chars;
    cdbe:	8b 4c 24 34          	mov    0x34(%esp),%ecx
		p = offset + bh->b_data;
    cdc2:	03 28                	add    (%eax),%ebp
		written += chars;               						// 累计写入字节数。
		count -= chars;
		while (chars-- > 0)
    cdc4:	31 d2                	xor    %edx,%edx
		written += chars;               						// 累计写入字节数。
    cdc6:	01 74 24 08          	add    %esi,0x8(%esp)
		count -= chars;
    cdca:	29 74 24 3c          	sub    %esi,0x3c(%esp)
		*pos += chars;
    cdce:	01 31                	add    %esi,(%ecx)
    cdd0:	8b 4c 24 38          	mov    0x38(%esp),%ecx
    cdd4:	01 d1                	add    %edx,%ecx
		while (chars-- > 0)
    cdd6:	39 f2                	cmp    %esi,%edx
    cdd8:	74 0a                	je     cde4 <block_write+0xeb>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    cdda:	64 8a 09             	mov    %fs:(%ecx),%cl
			*(p++) = get_fs_byte(buf++);
    cddd:	88 4c 15 00          	mov    %cl,0x0(%ebp,%edx,1)
    cde1:	42                   	inc    %edx
    cde2:	eb ec                	jmp    cdd0 <block_write+0xd7>
    cde4:	89 4c 24 38          	mov    %ecx,0x38(%esp)
		bh->b_dirt = 1;
		brelse(bh);
    cde8:	83 ec 0c             	sub    $0xc,%esp
		bh->b_dirt = 1;
    cdeb:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
    cdef:	50                   	push   %eax
		offset = 0;
    cdf0:	31 ed                	xor    %ebp,%ebp
		brelse(bh);
    cdf2:	e8 67 f5 ff ff       	call   c35e <brelse>
    cdf7:	83 c4 10             	add    $0x10,%esp
    cdfa:	e9 4d ff ff ff       	jmp    cd4c <block_write+0x53>
	}
	return written;                         					// 返回已写入的字节数，正常退出。
}
    cdff:	8b 44 24 08          	mov    0x8(%esp),%eax
    ce03:	83 c4 1c             	add    $0x1c,%esp
    ce06:	5b                   	pop    %ebx
    ce07:	5e                   	pop    %esi
    ce08:	5f                   	pop    %edi
    ce09:	5d                   	pop    %ebp
    ce0a:	c3                   	ret    

0000ce0b <block_read>:

// 数据块读函数 - 从指定设备和位置处读入指定长度数据到用户缓冲区中。
// 参数：dev - 设备号；pos - 设备文件中领衔量指针；buf - 用户空间中缓冲区地址；count - 要传送的字节数。
// 返回已读入字节数。若没有读入任何字节或出错，则返回出错号。
int block_read(int dev, unsigned long * pos, char * buf, int count)
{
    ce0b:	55                   	push   %ebp
    ce0c:	57                   	push   %edi
    ce0d:	56                   	push   %esi
    ce0e:	53                   	push   %ebx
    ce0f:	e8 66 d0 ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
    ce14:	05 ec 41 01 00       	add    $0x141ec,%eax
    ce19:	83 ec 1c             	sub    $0x1c,%esp
    ce1c:	89 44 24 04          	mov    %eax,0x4(%esp)
	int block = *pos >> BLOCK_SIZE_BITS;
    ce20:	8b 44 24 34          	mov    0x34(%esp),%eax
	register char * p;              							// 局部寄存器变量，被存放在寄存器中。

	// 在读一个块设备文件时，要求读的总数据块数当然不能超过指定设备上容许的最大数据块总数。因此这里首先取出指定
	// 设备的块总数size来比较和限制函数参数给定的读入数据长度。如果系统中没有对设备指定长度，就使用默认长度
	// 0x7fffffff（2GB个块）。
	if (blk_size[MAJOR(dev)])
    ce24:	8b 7c 24 04          	mov    0x4(%esp),%edi
    ce28:	8b 4c 24 30          	mov    0x30(%esp),%ecx
		size = blk_size[MAJOR(dev)][MINOR(dev)];
	else
		size = 0x7fffffff;
    ce2c:	c7 44 24 0c ff ff ff 	movl   $0x7fffffff,0xc(%esp)
    ce33:	7f 
	int block = *pos >> BLOCK_SIZE_BITS;
    ce34:	8b 10                	mov    (%eax),%edx
	if (blk_size[MAJOR(dev)])
    ce36:	c1 e9 08             	shr    $0x8,%ecx
	int block = *pos >> BLOCK_SIZE_BITS;
    ce39:	89 d0                	mov    %edx,%eax
	int offset = *pos & (BLOCK_SIZE - 1);
    ce3b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
    ce41:	89 d5                	mov    %edx,%ebp
	if (blk_size[MAJOR(dev)])
    ce43:	c7 c2 20 50 02 00    	mov    $0x25020,%edx
	int block = *pos >> BLOCK_SIZE_BITS;
    ce49:	c1 e8 0a             	shr    $0xa,%eax
	if (blk_size[MAJOR(dev)])
    ce4c:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
    ce4f:	85 d2                	test   %edx,%edx
    ce51:	74 0c                	je     ce5f <block_read+0x54>
		size = blk_size[MAJOR(dev)][MINOR(dev)];
    ce53:	0f b6 4c 24 30       	movzbl 0x30(%esp),%ecx
    ce58:	8b 1c 8a             	mov    (%edx,%ecx,4),%ebx
    ce5b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
		size = 0x7fffffff;
    ce5f:	31 ff                	xor    %edi,%edi
	// 然后针对要读入的字节数count，循环执行以下操作，直到数据全部读入。在循环执行过程中，若当前读入数据的块号已经
	// 大于或等于指定设备的总块数，则返回已读字节数并退出。然后再计算在当前处理的数据块中需读入的字节数。如果需要读
	// 入的字节数还不满一块，那么就只需读count字节。然后调用读块函数breada()读入需要的数据块，并预读下两块数据，
	// 如果读操作出错，则返回已读字节数，如果没有读入任何字节，则返回出错号。然后将块号递增1。为下次操作做好准备。如
	// 果缓冲块担操失败，则返回已写字节数，如果没有读入任何字节，则返回出错号（负数）。
	while (count > 0) {
    ce61:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    ce66:	0f 8e 9a 00 00 00    	jle    cf06 <block_read+0xfb>
		if (block >= size)
    ce6c:	3b 44 24 0c          	cmp    0xc(%esp),%eax
    ce70:	7c 12                	jl     ce84 <block_read+0x79>
			return read ? read : -EIO;
    ce72:	85 ff                	test   %edi,%edi
    ce74:	0f 85 8c 00 00 00    	jne    cf06 <block_read+0xfb>
    ce7a:	bf fb ff ff ff       	mov    $0xfffffffb,%edi
    ce7f:	e9 82 00 00 00       	jmp    cf06 <block_read+0xfb>
		chars = BLOCK_SIZE - offset;
		if (chars > count)
			chars = count;
		if (!(bh = breada(dev, block, block + 1, block + 2, -1)))
    ce84:	8d 58 01             	lea    0x1(%eax),%ebx
		chars = BLOCK_SIZE - offset;
    ce87:	be 00 04 00 00       	mov    $0x400,%esi
		if (!(bh = breada(dev, block, block + 1, block + 2, -1)))
    ce8c:	8d 50 02             	lea    0x2(%eax),%edx
		chars = BLOCK_SIZE - offset;
    ce8f:	29 ee                	sub    %ebp,%esi
    ce91:	39 74 24 3c          	cmp    %esi,0x3c(%esp)
		if (!(bh = breada(dev, block, block + 1, block + 2, -1)))
    ce95:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    ce99:	0f 4e 74 24 3c       	cmovle 0x3c(%esp),%esi
    ce9e:	83 ec 0c             	sub    $0xc,%esp
    cea1:	6a ff                	push   $0xffffffff
    cea3:	52                   	push   %edx
    cea4:	ff 74 24 1c          	pushl  0x1c(%esp)
    cea8:	50                   	push   %eax
    cea9:	ff 74 24 4c          	pushl  0x4c(%esp)
    cead:	8b 5c 24 24          	mov    0x24(%esp),%ebx
    ceb1:	e8 14 f6 ff ff       	call   c4ca <breada>
    ceb6:	83 c4 20             	add    $0x20,%esp
    ceb9:	85 c0                	test   %eax,%eax
    cebb:	74 b5                	je     ce72 <block_read+0x67>
		block++;
		// 接着先把指针p指向读出盘块中开始读入数据的位置处。若最后一次循环读操作的数据不足一块，则需从块起始处读取所需字
		// 节，因此这里需预先设置offset为零。此后将文件中偏移指针pos前移此次将要读的字节数chars，并且累加这些要读的字节
		// 数到统计值read中。再把还需要读的计数值count减去此次要读的字节数chars。然后我们从高速缓冲块中p指向的开始读的
		// 位置处复制chars个字节到用户缓冲区中，同时把用户缓冲区指针前移。本次复制完后就释放该缓冲块。
		p = offset + bh->b_data;
    cebd:	8b 10                	mov    (%eax),%edx
		offset = 0;
		*pos += chars;
    cebf:	8b 5c 24 34          	mov    0x34(%esp),%ebx
		read += chars;                  						// 累计读入字节数。
    cec3:	01 f7                	add    %esi,%edi
		count -= chars;
    cec5:	29 74 24 3c          	sub    %esi,0x3c(%esp)
		*pos += chars;
    cec9:	01 33                	add    %esi,(%ebx)
		p = offset + bh->b_data;
    cecb:	01 ea                	add    %ebp,%edx
		while (chars-- > 0)
    cecd:	31 db                	xor    %ebx,%ebx
    cecf:	8b 6c 24 38          	mov    0x38(%esp),%ebp
    ced3:	89 f1                	mov    %esi,%ecx
    ced5:	29 d9                	sub    %ebx,%ecx
    ced7:	01 dd                	add    %ebx,%ebp
    ced9:	85 c9                	test   %ecx,%ecx
    cedb:	7e 0a                	jle    cee7 <block_read+0xdc>
//// 将一字节存放在fs段中指定内存地址处.
// 参数:val - 字节值;addr - 内存地址.
// %0 - 寄存器(字节值val);%1 - (内存地址addr).
static inline void put_fs_byte(char val,char *addr)
{
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    cedd:	8a 0c 1a             	mov    (%edx,%ebx,1),%cl
    cee0:	64 88 4d 00          	mov    %cl,%fs:0x0(%ebp)
    cee4:	43                   	inc    %ebx
    cee5:	eb e8                	jmp    cecf <block_read+0xc4>
    cee7:	01 74 24 38          	add    %esi,0x38(%esp)
			put_fs_byte(*(p++), buf++);
		brelse(bh);
    ceeb:	83 ec 0c             	sub    $0xc,%esp
		offset = 0;
    ceee:	31 ed                	xor    %ebp,%ebp
		brelse(bh);
    cef0:	50                   	push   %eax
    cef1:	8b 5c 24 14          	mov    0x14(%esp),%ebx
    cef5:	e8 64 f4 ff ff       	call   c35e <brelse>
    cefa:	83 c4 10             	add    $0x10,%esp
		block++;
    cefd:	8b 44 24 08          	mov    0x8(%esp),%eax
    cf01:	e9 5b ff ff ff       	jmp    ce61 <block_read+0x56>
	}
	return read;                            					// 返回已读取的字节数，正常退出。
}
    cf06:	83 c4 1c             	add    $0x1c,%esp
    cf09:	89 f8                	mov    %edi,%eax
    cf0b:	5b                   	pop    %ebx
    cf0c:	5e                   	pop    %esi
    cf0d:	5f                   	pop    %edi
    cf0e:	5d                   	pop    %ebp
    cf0f:	c3                   	ret    

0000cf10 <rw_memory>:
	return i;
}

// 内存读写操作函数。
static int rw_memory(int rw, unsigned minor, char * buf, int count, off_t * pos)
{
    cf10:	55                   	push   %ebp
    cf11:	57                   	push   %edi
    cf12:	56                   	push   %esi
    cf13:	53                   	push   %ebx
    cf14:	8b 44 24 18          	mov    0x18(%esp),%eax
    cf18:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    cf1c:	8b 74 24 20          	mov    0x20(%esp),%esi
	// 根据内存设备子设备号，分别调用不同的内存读写函数。
	switch(minor) {
    cf20:	83 f8 03             	cmp    $0x3,%eax
    cf23:	74 17                	je     cf3c <rw_memory+0x2c>
    cf25:	83 f8 04             	cmp    $0x4,%eax
    cf28:	75 4b                	jne    cf75 <rw_memory+0x65>
	int i = *pos;
    cf2a:	8b 44 24 24          	mov    0x24(%esp),%eax
    cf2e:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
    cf32:	8b 18                	mov    (%eax),%ebx
    cf34:	89 da                	mov    %ebx,%edx
    cf36:	29 df                	sub    %ebx,%edi
	while (count-- > 0 && i < 65536) {
    cf38:	01 de                	add    %ebx,%esi
    cf3a:	eb 19                	jmp    cf55 <rw_memory+0x45>
		case 1:
			return rw_mem(rw, buf, count, pos);
		case 2:
			return rw_kmem(rw, buf, count, pos);
		case 3:
			return (rw == READ) ? 0 : count;					/* rw_null */
    cf3c:	85 c9                	test   %ecx,%ecx
    cf3e:	0f 45 ce             	cmovne %esi,%ecx
    cf41:	eb 37                	jmp    cf7a <rw_memory+0x6a>
	while (count-- > 0 && i < 65536) {
    cf43:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
    cf49:	7f 1e                	jg     cf69 <rw_memory+0x59>
		if (rw == READ)
    cf4b:	85 c9                	test   %ecx,%ecx
    cf4d:	75 13                	jne    cf62 <rw_memory+0x52>
			put_fs_byte(inb(i), buf++);
    cf4f:	ec                   	in     (%dx),%al
    cf50:	64 88 45 00          	mov    %al,%fs:0x0(%ebp)
		i++;            						// 前移一个端口。[好奇怪，端口地址为什么会变化？]
    cf54:	42                   	inc    %edx
	while (count-- > 0 && i < 65536) {
    cf55:	89 f0                	mov    %esi,%eax
    cf57:	8d 2c 17             	lea    (%edi,%edx,1),%ebp
    cf5a:	29 d0                	sub    %edx,%eax
    cf5c:	85 c0                	test   %eax,%eax
    cf5e:	7f e3                	jg     cf43 <rw_memory+0x33>
    cf60:	eb 07                	jmp    cf69 <rw_memory+0x59>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    cf62:	64 8a 45 00          	mov    %fs:0x0(%ebp),%al
			outb(get_fs_byte(buf++), i);
    cf66:	ee                   	out    %al,(%dx)
    cf67:	eb eb                	jmp    cf54 <rw_memory+0x44>
	*pos += i;
    cf69:	8b 44 24 24          	mov    0x24(%esp),%eax
	i -= *pos;
    cf6d:	89 d1                	mov    %edx,%ecx
    cf6f:	29 d9                	sub    %ebx,%ecx
	*pos += i;
    cf71:	89 10                	mov    %edx,(%eax)
		case 4:
			return rw_port(rw, buf, count, pos);
    cf73:	eb 05                	jmp    cf7a <rw_memory+0x6a>
			return rw_ram(rw, buf, count, pos);
    cf75:	b9 fb ff ff ff       	mov    $0xfffffffb,%ecx
		default:
			return -EIO;
	}
}
    cf7a:	5b                   	pop    %ebx
    cf7b:	89 c8                	mov    %ecx,%eax
    cf7d:	5e                   	pop    %esi
    cf7e:	5f                   	pop    %edi
    cf7f:	5d                   	pop    %ebp
    cf80:	c3                   	ret    

0000cf81 <rw_ttyx>:
{
    cf81:	53                   	push   %ebx
    cf82:	e8 a5 9a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    cf87:	81 c3 79 40 01 00    	add    $0x14079,%ebx
    cf8d:	83 ec 08             	sub    $0x8,%esp
	return ((rw == READ) ? tty_read(minor, buf, count): tty_write(minor, buf, count));
    cf90:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
{
    cf95:	8b 44 24 14          	mov    0x14(%esp),%eax
    cf99:	8b 54 24 18          	mov    0x18(%esp),%edx
    cf9d:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
	return ((rw == READ) ? tty_read(minor, buf, count): tty_write(minor, buf, count));
    cfa1:	75 0d                	jne    cfb0 <rw_ttyx+0x2f>
    cfa3:	83 ec 04             	sub    $0x4,%esp
    cfa6:	51                   	push   %ecx
    cfa7:	52                   	push   %edx
    cfa8:	50                   	push   %eax
    cfa9:	e8 20 57 00 00       	call   126ce <tty_read>
    cfae:	eb 0b                	jmp    cfbb <rw_ttyx+0x3a>
    cfb0:	83 ec 04             	sub    $0x4,%esp
    cfb3:	51                   	push   %ecx
    cfb4:	52                   	push   %edx
    cfb5:	50                   	push   %eax
    cfb6:	e8 31 5a 00 00       	call   129ec <tty_write>
    cfbb:	83 c4 10             	add    $0x10,%esp
}
    cfbe:	83 c4 08             	add    $0x8,%esp
    cfc1:	5b                   	pop    %ebx
    cfc2:	c3                   	ret    

0000cfc3 <rw_tty>:
{
    cfc3:	e8 b2 ce ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
    cfc8:	05 38 40 01 00       	add    $0x14038,%eax
	if (current->tty < 0)
    cfcd:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    cfd3:	8b 00                	mov    (%eax),%eax
    cfd5:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
    cfdb:	85 c0                	test   %eax,%eax
    cfdd:	78 06                	js     cfe5 <rw_tty+0x22>
	return rw_ttyx(rw, current->tty, buf, count, pos);
    cfdf:	89 44 24 08          	mov    %eax,0x8(%esp)
    cfe3:	eb 9c                	jmp    cf81 <rw_ttyx>
}
    cfe5:	83 c8 ff             	or     $0xffffffff,%eax
    cfe8:	c3                   	ret    

0000cfe9 <rw_char>:

// 字符设备读写操作函数
// 参数:rw - 读写命令;dev - 设备号;buf - 缓冲区;count - 读写字节数;pos - 读写指针.
// 返回:实际读/写字节数.
int rw_char(int rw, int dev, char * buf, int count, off_t * pos)
{
    cfe9:	8b 44 24 08          	mov    0x8(%esp),%eax
    cfed:	e8 8c ce ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
    cff2:	81 c1 0e 40 01 00    	add    $0x1400e,%ecx
	crw_ptr call_addr;

	// 如果设备号超出系统设备数,则返回出错码.如果该设备没有对应的读/写函数,也返回出错码.否则调用对应设备的读写操作函数,并返回实际读/写的字节数.
	if (MAJOR(dev) >= NRDEVS)
    cff8:	89 c2                	mov    %eax,%edx
    cffa:	c1 ea 08             	shr    $0x8,%edx
    cffd:	83 fa 07             	cmp    $0x7,%edx
    d000:	77 14                	ja     d016 <rw_char+0x2d>
		return -ENODEV;
	if (!(call_addr = crw_table[MAJOR(dev)]))
    d002:	8b 94 91 a0 ff ff ff 	mov    -0x60(%ecx,%edx,4),%edx
    d009:	85 d2                	test   %edx,%edx
    d00b:	74 09                	je     d016 <rw_char+0x2d>
		return -ENODEV;
	return call_addr(rw, MINOR(dev), buf, count, pos);
    d00d:	0f b6 c0             	movzbl %al,%eax
    d010:	89 44 24 08          	mov    %eax,0x8(%esp)
    d014:	ff e2                	jmp    *%edx
}
    d016:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    d01b:	c3                   	ret    

0000d01c <file_read>:

// 文件读函数 - 根据i节点和文件结构，读取文件中数据。
// 由i节点我们可以知道设备号，由filp结构可以知道文件中当前读写指针位置。buf指定用户空间中缓冲区的位置，count是需要读取的字节数。
// 返回值是实际读取的字节数，或出错号（小于0）。
int file_read(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    d01c:	55                   	push   %ebp
    d01d:	57                   	push   %edi
	// 首先判断参数的有效性。若需要读取的字节计数count小于等于零，则返回0.若还需要读取的字节数不等于0,就循环执行下面操作，直到数据全
	// 部读出或遇到问题。在读循环操作过程中，我们根据i节点和文件表结构信息，并利用bmap()得到包含文件当前读写位置的数据块在设备上对应
	// 的逻辑块号nr。若nr不为0,则从i节点指定的设备上读取该逻辑块。如果读操作失败则退出循环。若nr为0,表示指定的数据块不存在，置缓冲
	// 块指针为NULL。
	if ((left = count) <= 0)
		return 0;
    d01e:	31 c0                	xor    %eax,%eax
{
    d020:	56                   	push   %esi
    d021:	53                   	push   %ebx
    d022:	e8 05 9a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d027:	81 c3 d9 3f 01 00    	add    $0x13fd9,%ebx
    d02d:	83 ec 1c             	sub    $0x1c,%esp
	if ((left = count) <= 0)
    d030:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
{
    d035:	8b 7c 24 34          	mov    0x34(%esp),%edi
	if ((left = count) <= 0)
    d039:	0f 8e 2e 01 00 00    	jle    d16d <file_read+0x151>
    d03f:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
	while (left) {
		// 根据文件的读写偏移位置得到当前写位置对应的逻辑块号
		if (nr = bmap(inode, (filp->f_pos) / BLOCK_SIZE)) {
    d043:	51                   	push   %ecx
    d044:	51                   	push   %ecx
    d045:	b9 00 04 00 00       	mov    $0x400,%ecx
    d04a:	8b 47 0c             	mov    0xc(%edi),%eax
    d04d:	99                   	cltd   
    d04e:	f7 f9                	idiv   %ecx
    d050:	50                   	push   %eax
    d051:	ff 74 24 3c          	pushl  0x3c(%esp)
    d055:	e8 b2 e9 ff ff       	call   ba0c <bmap>
    d05a:	83 c4 10             	add    $0x10,%esp
    d05d:	85 c0                	test   %eax,%eax
			// 得到该逻辑块号对应的高速缓冲区
			if (!(bh = bread(inode->i_dev, nr)))
				break;
		} else
			bh = NULL;
    d05f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    d066:	00 
		if (nr = bmap(inode, (filp->f_pos) / BLOCK_SIZE)) {
    d067:	74 20                	je     d089 <file_read+0x6d>
			if (!(bh = bread(inode->i_dev, nr)))
    d069:	52                   	push   %edx
    d06a:	52                   	push   %edx
    d06b:	50                   	push   %eax
    d06c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    d070:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    d074:	50                   	push   %eax
    d075:	e8 36 f3 ff ff       	call   c3b0 <bread>
    d07a:	83 c4 10             	add    $0x10,%esp
    d07d:	85 c0                	test   %eax,%eax
    d07f:	89 44 24 04          	mov    %eax,0x4(%esp)
    d083:	0f 84 ab 00 00 00    	je     d134 <file_read+0x118>
		// 接着我们计算文件读写指针在数据块中的偏移值nr，则在该数据块中我们希望读取的字节数为（BLOCK_SIZE - nr）。然后和现在还需读取的
		// 字节数left作比较，其中小值即为本次操作需读取的字节数chars。如果（BLOCK_SIZE - nr）> left，则说明该块是需要读取的最后一块
		// 数据，反之还需要读取下一块数据。之后调整读写文件指针。指针前移此次将读取的字节数chars。剩余字节数left相应减去chars。
		nr = filp->f_pos % BLOCK_SIZE;
    d089:	8b 47 0c             	mov    0xc(%edi),%eax
    d08c:	be 00 04 00 00       	mov    $0x400,%esi
    d091:	99                   	cltd   
    d092:	f7 fe                	idiv   %esi
		chars = MIN( BLOCK_SIZE - nr , left );
    d094:	29 d6                	sub    %edx,%esi
    d096:	39 ee                	cmp    %ebp,%esi
    d098:	89 f0                	mov    %esi,%eax
		filp->f_pos += chars;
    d09a:	8b 77 0c             	mov    0xc(%edi),%esi
		chars = MIN( BLOCK_SIZE - nr , left );
    d09d:	0f 4f c5             	cmovg  %ebp,%eax
		left -= chars;
    d0a0:	29 c5                	sub    %eax,%ebp
		filp->f_pos += chars;
    d0a2:	01 c6                	add    %eax,%esi
		// 若上面从设备上读到了数据，则将p指向缓冲块中开始读取数据的位置，并且复制chars字节到用户缓冲区buf中。否则往用户缓冲区中填入chars
		// 个值字节。
		if (bh) {
    d0a4:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
		filp->f_pos += chars;
    d0a9:	89 77 0c             	mov    %esi,0xc(%edi)
		if (bh) {
    d0ac:	74 4e                	je     d0fc <file_read+0xe0>
			char * p = nr + bh->b_data;
    d0ae:	8b 74 24 04          	mov    0x4(%esp),%esi
    d0b2:	03 16                	add    (%esi),%edx
			while (chars-- > 0)
    d0b4:	31 f6                	xor    %esi,%esi
			char * p = nr + bh->b_data;
    d0b6:	89 54 24 08          	mov    %edx,0x8(%esp)
    d0ba:	8b 4c 24 38          	mov    0x38(%esp),%ecx
    d0be:	01 f1                	add    %esi,%ecx
    d0c0:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    d0c4:	89 c1                	mov    %eax,%ecx
    d0c6:	29 f1                	sub    %esi,%ecx
			while (chars-- > 0)
    d0c8:	85 c9                	test   %ecx,%ecx
    d0ca:	7e 11                	jle    d0dd <file_read+0xc1>
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    d0cc:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    d0d0:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d0d4:	8a 0c 31             	mov    (%ecx,%esi,1),%cl
    d0d7:	64 88 0a             	mov    %cl,%fs:(%edx)
    d0da:	46                   	inc    %esi
    d0db:	eb dd                	jmp    d0ba <file_read+0x9e>
    d0dd:	85 c0                	test   %eax,%eax
    d0df:	ba 00 00 00 00       	mov    $0x0,%edx
    d0e4:	0f 48 c2             	cmovs  %edx,%eax
    d0e7:	01 44 24 38          	add    %eax,0x38(%esp)
				put_fs_byte(*(p++), buf++);
			brelse(bh);
    d0eb:	83 ec 0c             	sub    $0xc,%esp
    d0ee:	ff 74 24 10          	pushl  0x10(%esp)
    d0f2:	e8 67 f2 ff ff       	call   c35e <brelse>
    d0f7:	83 c4 10             	add    $0x10,%esp
    d0fa:	eb 30                	jmp    d12c <file_read+0x110>
    d0fc:	8b 54 24 38          	mov    0x38(%esp),%edx
    d100:	89 c6                	mov    %eax,%esi
    d102:	01 d6                	add    %edx,%esi
    d104:	89 f1                	mov    %esi,%ecx
    d106:	29 d1                	sub    %edx,%ecx
		} else {
			while (chars-- > 0)
    d108:	85 c9                	test   %ecx,%ecx
    d10a:	7e 12                	jle    d11e <file_read+0x102>
				put_fs_byte(0, buf++);
    d10c:	8d 4a 01             	lea    0x1(%edx),%ecx
    d10f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    d113:	31 c9                	xor    %ecx,%ecx
    d115:	64 88 0a             	mov    %cl,%fs:(%edx)
    d118:	8b 54 24 04          	mov    0x4(%esp),%edx
    d11c:	eb e6                	jmp    d104 <file_read+0xe8>
    d11e:	85 c0                	test   %eax,%eax
    d120:	ba 00 00 00 00       	mov    $0x0,%edx
    d125:	0f 48 c2             	cmovs  %edx,%eax
    d128:	01 44 24 38          	add    %eax,0x38(%esp)
	while (left) {
    d12c:	85 ed                	test   %ebp,%ebp
    d12e:	0f 85 0f ff ff ff    	jne    d043 <file_read+0x27>
		}
	}
	// 修改该i节点的访问时间为当前时间。返回读取的字节数，若读取字节数为0,则返回出错号。
	// CURRENT_TIME是定义在include/linux/sched.h上的宏，用于计算UNIX时间。即从1970年1月1日0时0秒开始，到当前时间。单位是秒。
	inode->i_atime = CURRENT_TIME;
    d134:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    d13a:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    d140:	b9 64 00 00 00       	mov    $0x64,%ecx
    d145:	8b 7c 24 30          	mov    0x30(%esp),%edi
    d149:	8b 00                	mov    (%eax),%eax
    d14b:	03 02                	add    (%edx),%eax
    d14d:	31 d2                	xor    %edx,%edx
    d14f:	f7 f1                	div    %ecx
    d151:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    d157:	03 02                	add    (%edx),%eax
	return (count - left) ? (count-left) : -ERROR;
    d159:	3b 6c 24 3c          	cmp    0x3c(%esp),%ebp
	inode->i_atime = CURRENT_TIME;
    d15d:	89 47 28             	mov    %eax,0x28(%edi)
	return (count - left) ? (count-left) : -ERROR;
    d160:	b8 9d ff ff ff       	mov    $0xffffff9d,%eax
    d165:	74 06                	je     d16d <file_read+0x151>
    d167:	8b 44 24 3c          	mov    0x3c(%esp),%eax
    d16b:	29 e8                	sub    %ebp,%eax
}
    d16d:	83 c4 1c             	add    $0x1c,%esp
    d170:	5b                   	pop    %ebx
    d171:	5e                   	pop    %esi
    d172:	5f                   	pop    %edi
    d173:	5d                   	pop    %ebp
    d174:	c3                   	ret    

0000d175 <file_write>:

// 文件写函数 - 根据i节点和文件结构信息，将用户数据写入文件中。
// 由i节点我们可以知道设备号，而由file结构可以知道文件中当前读写指针位置。buf指定用户态中缓冲区的位置，count为需要写入的字节数。
// 返回值是实际写入的字节数，或出错号（小于0).
int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
    d175:	55                   	push   %ebp
    d176:	57                   	push   %edi
    d177:	56                   	push   %esi
    d178:	53                   	push   %ebx
    d179:	e8 ae 98 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d17e:	81 c3 82 3e 01 00    	add    $0x13e82,%ebx
    d184:	83 ec 1c             	sub    $0x1c,%esp
	 */
	/*
	 * OK，当许多进程同时写时，append操作可能不行，但那又怎样。不管怎样那样做会导致混乱一团。
	 */
	// 首先确定数据写入文件的位置。如果是要向文件后添加数据，则将文件读写指针移到文件尾部。否则就将在文件当前读写指针处写入。
	if (filp->f_flags & O_APPEND)
    d187:	8b 44 24 34          	mov    0x34(%esp),%eax
{
    d18b:	8b 74 24 30          	mov    0x30(%esp),%esi
	if (filp->f_flags & O_APPEND)
    d18f:	f6 40 03 04          	testb  $0x4,0x3(%eax)
    d193:	74 05                	je     d19a <file_write+0x25>
		pos = inode->i_size;
    d195:	8b 6e 04             	mov    0x4(%esi),%ebp
    d198:	eb 07                	jmp    d1a1 <file_write+0x2c>
	else
		pos = filp->f_pos;
    d19a:	8b 44 24 34          	mov    0x34(%esp),%eax
    d19e:	8b 68 0c             	mov    0xc(%eax),%ebp
		if (pos > inode->i_size) {
			inode->i_size = pos;
			inode->i_dirt = 1;
		}
		i += c;
		while (c-- > 0)
    d1a1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	while (i < count) {
    d1a8:	8b 04 24             	mov    (%esp),%eax
    d1ab:	3b 44 24 3c          	cmp    0x3c(%esp),%eax
    d1af:	7d 1e                	jge    d1cf <file_write+0x5a>
		if (!(block = create_block(inode, pos / BLOCK_SIZE)))
    d1b1:	89 e8                	mov    %ebp,%eax
    d1b3:	bf 00 04 00 00       	mov    $0x400,%edi
    d1b8:	51                   	push   %ecx
    d1b9:	99                   	cltd   
    d1ba:	51                   	push   %ecx
    d1bb:	f7 ff                	idiv   %edi
    d1bd:	89 54 24 10          	mov    %edx,0x10(%esp)
    d1c1:	50                   	push   %eax
    d1c2:	56                   	push   %esi
    d1c3:	e8 aa e8 ff ff       	call   ba72 <create_block>
    d1c8:	83 c4 10             	add    $0x10,%esp
    d1cb:	85 c0                	test   %eax,%eax
    d1cd:	75 57                	jne    d226 <file_write+0xb1>
		brelse(bh);
    }
	// 当数据已经全部写入文件或者在写操作过程中发生问题时就会退出循环。此时我们更改文件修改时间为当前时间，并调整文件读写指针。如果
	// 此次操作不是在文件尾添加数据，则把文件读写指针调整到当前读写位置pos处，并更改文件i节点的修改时间为当前时间。最后返回写入的
	// 字节数，若写入字节数为0,则返回出错号-1。
	inode->i_mtime = CURRENT_TIME;
    d1cf:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    d1d5:	c7 c7 6c 2a 02 00    	mov    $0x22a6c,%edi
    d1db:	8b 0a                	mov    (%edx),%ecx
    d1dd:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    d1e3:	8b 07                	mov    (%edi),%eax
    d1e5:	8b 1a                	mov    (%edx),%ebx
    d1e7:	31 d2                	xor    %edx,%edx
    d1e9:	01 c8                	add    %ecx,%eax
    d1eb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
    d1ef:	bb 64 00 00 00       	mov    $0x64,%ebx
    d1f4:	f7 f3                	div    %ebx
    d1f6:	03 44 24 04          	add    0x4(%esp),%eax
    d1fa:	89 46 08             	mov    %eax,0x8(%esi)
	if (!(filp->f_flags & O_APPEND)) {
    d1fd:	8b 44 24 34          	mov    0x34(%esp),%eax
    d201:	f6 40 03 04          	testb  $0x4,0x3(%eax)
    d205:	0f 85 a5 00 00 00    	jne    d2b0 <file_write+0x13b>
		filp->f_pos = pos;
    d20b:	8b 44 24 34          	mov    0x34(%esp),%eax
		inode->i_ctime = CURRENT_TIME;
    d20f:	31 d2                	xor    %edx,%edx
		filp->f_pos = pos;
    d211:	89 68 0c             	mov    %ebp,0xc(%eax)
		inode->i_ctime = CURRENT_TIME;
    d214:	8b 07                	mov    (%edi),%eax
    d216:	01 c8                	add    %ecx,%eax
    d218:	f7 f3                	div    %ebx
    d21a:	03 44 24 04          	add    0x4(%esp),%eax
    d21e:	89 46 2c             	mov    %eax,0x2c(%esi)
    d221:	e9 8a 00 00 00       	jmp    d2b0 <file_write+0x13b>
		if (!(bh = bread(inode->i_dev, block)))
    d226:	52                   	push   %edx
    d227:	52                   	push   %edx
    d228:	50                   	push   %eax
    d229:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    d22d:	50                   	push   %eax
    d22e:	e8 7d f1 ff ff       	call   c3b0 <bread>
    d233:	83 c4 10             	add    $0x10,%esp
    d236:	85 c0                	test   %eax,%eax
    d238:	89 44 24 04          	mov    %eax,0x4(%esp)
    d23c:	74 91                	je     d1cf <file_write+0x5a>
		c = BLOCK_SIZE - c;
    d23e:	2b 7c 24 08          	sub    0x8(%esp),%edi
		if (c > count - i) c = count - i;
    d242:	8b 54 24 3c          	mov    0x3c(%esp),%edx
    d246:	2b 14 24             	sub    (%esp),%edx
		p = c + bh->b_data;
    d249:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    d24d:	8b 44 24 08          	mov    0x8(%esp),%eax
    d251:	03 01                	add    (%ecx),%eax
		bh->b_dirt = 1;
    d253:	c6 41 0b 01          	movb   $0x1,0xb(%ecx)
    d257:	39 fa                	cmp    %edi,%edx
    d259:	0f 4f d7             	cmovg  %edi,%edx
		pos += c;
    d25c:	01 d5                	add    %edx,%ebp
		if (pos > inode->i_size) {
    d25e:	39 6e 04             	cmp    %ebp,0x4(%esi)
		p = c + bh->b_data;
    d261:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if (pos > inode->i_size) {
    d265:	73 07                	jae    d26e <file_write+0xf9>
			inode->i_size = pos;
    d267:	89 6e 04             	mov    %ebp,0x4(%esi)
			inode->i_dirt = 1;
    d26a:	c6 46 37 01          	movb   $0x1,0x37(%esi)
		i += c;
    d26e:	01 14 24             	add    %edx,(%esp)
		while (c-- > 0)
    d271:	31 c9                	xor    %ecx,%ecx
    d273:	8b 7c 24 38          	mov    0x38(%esp),%edi
    d277:	89 d0                	mov    %edx,%eax
    d279:	29 c8                	sub    %ecx,%eax
    d27b:	01 cf                	add    %ecx,%edi
    d27d:	85 c0                	test   %eax,%eax
    d27f:	7e 0d                	jle    d28e <file_write+0x119>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    d281:	64 8a 07             	mov    %fs:(%edi),%al
			*(p++) = get_fs_byte(buf++);
    d284:	8b 7c 24 0c          	mov    0xc(%esp),%edi
    d288:	88 04 0f             	mov    %al,(%edi,%ecx,1)
    d28b:	41                   	inc    %ecx
    d28c:	eb e5                	jmp    d273 <file_write+0xfe>
    d28e:	85 d2                	test   %edx,%edx
    d290:	b9 00 00 00 00       	mov    $0x0,%ecx
    d295:	0f 48 d1             	cmovs  %ecx,%edx
    d298:	01 54 24 38          	add    %edx,0x38(%esp)
		brelse(bh);
    d29c:	83 ec 0c             	sub    $0xc,%esp
    d29f:	ff 74 24 10          	pushl  0x10(%esp)
    d2a3:	e8 b6 f0 ff ff       	call   c35e <brelse>
    d2a8:	83 c4 10             	add    $0x10,%esp
    d2ab:	e9 f8 fe ff ff       	jmp    d1a8 <file_write+0x33>
	}
	return (i ? i : -1);
    d2b0:	83 3c 24 00          	cmpl   $0x0,(%esp)
    d2b4:	75 07                	jne    d2bd <file_write+0x148>
    d2b6:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
}
    d2bd:	8b 04 24             	mov    (%esp),%eax
    d2c0:	83 c4 1c             	add    $0x1c,%esp
    d2c3:	5b                   	pop    %ebx
    d2c4:	5e                   	pop    %esi
    d2c5:	5f                   	pop    %edi
    d2c6:	5d                   	pop    %ebp
    d2c7:	c3                   	ret    

0000d2c8 <cp_stat>:
#include <asm/segment.h>

// 复制文件状态信息。
// 参数inode是文件i节点，statbuf是用户数据空间中stat文件状态结构指针，用于存放取得的状态信息。
static void cp_stat(struct m_inode * inode, struct stat * statbuf)
{
    d2c8:	57                   	push   %edi
    d2c9:	56                   	push   %esi
    d2ca:	89 c6                	mov    %eax,%esi
    d2cc:	53                   	push   %ebx
    d2cd:	89 d7                	mov    %edx,%edi
    d2cf:	e8 58 97 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d2d4:	81 c3 2c 3d 01 00    	add    $0x13d2c,%ebx
    d2da:	83 ec 28             	sub    $0x28,%esp
	struct stat tmp;
	int i;

	// 首先验证（或分配）存放数据的内存空间。然后临时复制相应节点上的信息。
	verify_area(statbuf, sizeof (struct stat));
    d2dd:	6a 20                	push   $0x20
    d2df:	52                   	push   %edx
    d2e0:	e8 06 a9 ff ff       	call   7beb <verify_area>
	tmp.st_dev = inode->i_dev;              						// 文件所在设备号。
    d2e5:	8b 46 30             	mov    0x30(%esi),%eax
	verify_area(statbuf, sizeof (struct stat));
    d2e8:	83 c4 10             	add    $0x10,%esp
	tmp.st_dev = inode->i_dev;              						// 文件所在设备号。
    d2eb:	66 89 04 24          	mov    %ax,(%esp)
	tmp.st_ino = inode->i_num;              						// 文件i节点号。
    d2ef:	66 8b 46 32          	mov    0x32(%esi),%ax
    d2f3:	66 89 44 24 02       	mov    %ax,0x2(%esp)
	tmp.st_mode = inode->i_mode;            						// 文件属性。
    d2f8:	8b 06                	mov    (%esi),%eax
    d2fa:	66 89 44 24 04       	mov    %ax,0x4(%esp)
	tmp.st_nlink = inode->i_nlinks;         						// 文件连接数。
    d2ff:	8a 46 0d             	mov    0xd(%esi),%al
    d302:	88 44 24 06          	mov    %al,0x6(%esp)
	tmp.st_uid = inode->i_uid;              						// 文件的用户ID。
    d306:	66 8b 46 02          	mov    0x2(%esi),%ax
    d30a:	66 89 44 24 08       	mov    %ax,0x8(%esp)
	tmp.st_gid = inode->i_gid;              						// 文件的组ID。
    d30f:	0f b6 46 0c          	movzbl 0xc(%esi),%eax
    d313:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
	tmp.st_rdev = inode->i_zone[0];         						// 设备号（若是特殊字符文件或块设备文件)。
    d318:	66 8b 46 0e          	mov    0xe(%esi),%ax
    d31c:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
	tmp.st_size = inode->i_size;            						// 文件字节长度（如果文件是常规文件）。
    d321:	8b 46 04             	mov    0x4(%esi),%eax
    d324:	89 44 24 10          	mov    %eax,0x10(%esp)
	tmp.st_atime = inode->i_atime;          						// 最后访问时间。
    d328:	8b 46 28             	mov    0x28(%esi),%eax
    d32b:	89 44 24 14          	mov    %eax,0x14(%esp)
	tmp.st_mtime = inode->i_mtime;          						// 最后修改时间。
    d32f:	8b 46 08             	mov    0x8(%esi),%eax
    d332:	89 44 24 18          	mov    %eax,0x18(%esp)
	tmp.st_ctime = inode->i_ctime;          						// 最后i节点修改时间。
    d336:	8b 46 2c             	mov    0x2c(%esi),%eax
    d339:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	// 最后将这些状态信息复制到用户缓冲区中。
	for (i = 0 ; i<sizeof (tmp) ; i++)
    d33d:	31 c0                	xor    %eax,%eax
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    d33f:	8a 14 04             	mov    (%esp,%eax,1),%dl
    d342:	64 88 14 07          	mov    %dl,%fs:(%edi,%eax,1)
    d346:	40                   	inc    %eax
    d347:	83 f8 20             	cmp    $0x20,%eax
    d34a:	75 f3                	jne    d33f <cp_stat+0x77>
		put_fs_byte(((char *) &tmp)[i], i + (char *) statbuf);
}
    d34c:	83 c4 20             	add    $0x20,%esp
    d34f:	5b                   	pop    %ebx
    d350:	5e                   	pop    %esi
    d351:	5f                   	pop    %edi
    d352:	c3                   	ret    

0000d353 <sys_stat>:
// 文件状态系统调用。
// 根据给定的文件名获取相关文件状态信息。
// 参数filename是指定的文件名，statbuf是存放状态信息的缓冲区指针。
// 返回：成功返回0,若出错则返回出错码。
int sys_stat(char * filename, struct stat * statbuf)
{
    d353:	56                   	push   %esi
    d354:	53                   	push   %ebx
    d355:	e8 d2 96 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d35a:	81 c3 a6 3c 01 00    	add    $0x13ca6,%ebx
    d360:	83 ec 10             	sub    $0x10,%esp
	struct m_inode * inode;

	// 首先根据文件名找出对应的i节点。然后将i节点上的文件状态信息复制到用户缓冲区中，并放回i节点。
	if (!(inode = namei(filename)))
    d363:	ff 74 24 1c          	pushl  0x1c(%esp)
    d367:	e8 cc 15 00 00       	call   e938 <namei>
    d36c:	89 c6                	mov    %eax,%esi
    d36e:	83 c4 10             	add    $0x10,%esp
    d371:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    d376:	85 f6                	test   %esi,%esi
    d378:	74 19                	je     d393 <sys_stat+0x40>
		return -ENOENT;
	cp_stat(inode, statbuf);
    d37a:	8b 54 24 14          	mov    0x14(%esp),%edx
    d37e:	89 f0                	mov    %esi,%eax
    d380:	e8 43 ff ff ff       	call   d2c8 <cp_stat>
	iput(inode);
    d385:	83 ec 0c             	sub    $0xc,%esp
    d388:	56                   	push   %esi
    d389:	e8 9a e7 ff ff       	call   bb28 <iput>
    d38e:	83 c4 10             	add    $0x10,%esp
	return 0;
    d391:	31 c0                	xor    %eax,%eax
}
    d393:	5a                   	pop    %edx
    d394:	5b                   	pop    %ebx
    d395:	5e                   	pop    %esi
    d396:	c3                   	ret    

0000d397 <sys_lstat>:

// 文件状态系统调用。
// 根据给定的文件名获取相关文件状态信息。文件路径名中有符号链接文件名，则取符号文件的状态。
// 参数：filename是指定的文件名，statbuf是存放状态信息的缓冲区指针。
int sys_lstat(char * filename, struct stat * statbuf)
{
    d397:	56                   	push   %esi
    d398:	53                   	push   %ebx
    d399:	e8 8e 96 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d39e:	81 c3 62 3c 01 00    	add    $0x13c62,%ebx
    d3a4:	83 ec 10             	sub    $0x10,%esp
	struct m_inode * inode;

	// 首先根据文件名找出对应的i节点。然后将i节点上的文件状态信息复制到用户缓冲区中，并放回该i节点。
	if (!(inode = lnamei(filename)))        					// 取指定路径名i节点，不跟随符号链接。
    d3a7:	ff 74 24 1c          	pushl  0x1c(%esp)
    d3ab:	e8 7b 15 00 00       	call   e92b <lnamei>
    d3b0:	89 c6                	mov    %eax,%esi
    d3b2:	83 c4 10             	add    $0x10,%esp
    d3b5:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    d3ba:	85 f6                	test   %esi,%esi
    d3bc:	74 19                	je     d3d7 <sys_lstat+0x40>
		return -ENOENT;
	cp_stat(inode, statbuf);
    d3be:	8b 54 24 14          	mov    0x14(%esp),%edx
    d3c2:	89 f0                	mov    %esi,%eax
    d3c4:	e8 ff fe ff ff       	call   d2c8 <cp_stat>
	iput(inode);
    d3c9:	83 ec 0c             	sub    $0xc,%esp
    d3cc:	56                   	push   %esi
    d3cd:	e8 56 e7 ff ff       	call   bb28 <iput>
    d3d2:	83 c4 10             	add    $0x10,%esp
	return 0;
    d3d5:	31 c0                	xor    %eax,%eax
}
    d3d7:	5a                   	pop    %edx
    d3d8:	5b                   	pop    %ebx
    d3d9:	5e                   	pop    %esi
    d3da:	c3                   	ret    

0000d3db <sys_fstat>:
// 文件状态系统调用。
// 根据给定的文件句柄获取相关文件状态信息。
// 参数fd是指定文件的句柄（描述符），statbuf是存放状态信息的缓冲区指针。
// 返回：成功返回0,若出错则返回出错码。
int sys_fstat(unsigned int fd, struct stat * statbuf)
{
    d3db:	83 ec 0c             	sub    $0xc,%esp

	// 首先取文件句柄对应的文件结构，然后从中得到文件的i节点。然后将i节点上的文件状态信息复制到用户缓冲区中。如果
	// 文件句柄值大于一个程序最多打开文件数NR_OPEN，或者该句柄的文件结构指针为空，或者对应文件结构的i节点字段为空，
	// 则出错，返回出错码并退出。
	if (fd >= NR_OPEN || !(f = current->filp[fd]) || !(inode = f->f_inode))
		return -EBADF;
    d3de:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
{
    d3e3:	8b 44 24 10          	mov    0x10(%esp),%eax
    d3e7:	e8 92 ca ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
    d3ec:	81 c1 14 3c 01 00    	add    $0x13c14,%ecx
	if (fd >= NR_OPEN || !(f = current->filp[fd]) || !(inode = f->f_inode))
    d3f2:	83 f8 13             	cmp    $0x13,%eax
    d3f5:	77 2a                	ja     d421 <sys_fstat+0x46>
    d3f7:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    d3fd:	8b 12                	mov    (%edx),%edx
    d3ff:	8b 84 82 48 03 00 00 	mov    0x348(%edx,%eax,4),%eax
		return -EBADF;
    d406:	ba f7 ff ff ff       	mov    $0xfffffff7,%edx
	if (fd >= NR_OPEN || !(f = current->filp[fd]) || !(inode = f->f_inode))
    d40b:	85 c0                	test   %eax,%eax
    d40d:	74 12                	je     d421 <sys_fstat+0x46>
    d40f:	8b 40 08             	mov    0x8(%eax),%eax
    d412:	85 c0                	test   %eax,%eax
    d414:	74 0b                	je     d421 <sys_fstat+0x46>
	cp_stat(inode, statbuf);
    d416:	8b 54 24 14          	mov    0x14(%esp),%edx
    d41a:	e8 a9 fe ff ff       	call   d2c8 <cp_stat>
	return 0;
    d41f:	31 d2                	xor    %edx,%edx
}
    d421:	89 d0                	mov    %edx,%eax
    d423:	83 c4 0c             	add    $0xc,%esp
    d426:	c3                   	ret    

0000d427 <sys_readlink>:
// 该调用读取符号链接文件的内容（即该符号链接所指向文件的路径名字符串），并放到指定长度的用户缓冲区中。若缓冲区
// 太小，就会截断符号链接的内容。
// 参数：path -- 符号链接文件路径名；buf -- 用户缓冲区；bufsiz -- 缓冲区长度。
// 返回：成功则返回放入缓冲区中的字符数；若失败则返回出错码。
int sys_readlink(const char * path, char * buf, int bufsiz)
{
    d427:	55                   	push   %ebp
    d428:	57                   	push   %edi
    d429:	56                   	push   %esi
    d42a:	53                   	push   %ebx
	char c;

	// 首先检查和验证函数参数的有效性，并对其进行调整。用户缓冲区字节长度bufsiz必须在1--1023之间。然后取得符号链接
	// 文件名的i节点，并读取该文件的第1块数据内容。之后放回i节点。
	if (bufsiz <= 0)
		return -EBADF;
    d42b:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
    d430:	e8 f7 95 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d435:	81 c3 cb 3b 01 00    	add    $0x13bcb,%ebx
{
    d43b:	83 ec 1c             	sub    $0x1c,%esp
    d43e:	8b 7c 24 38          	mov    0x38(%esp),%edi
	if (bufsiz <= 0)
    d442:	85 ff                	test   %edi,%edi
    d444:	0f 8e 8d 00 00 00    	jle    d4d7 <sys_readlink+0xb0>
    d44a:	81 ff ff 03 00 00    	cmp    $0x3ff,%edi
    d450:	b8 ff 03 00 00       	mov    $0x3ff,%eax
	if (bufsiz > 1023)
		bufsiz = 1023;
	verify_area(buf, bufsiz);
    d455:	56                   	push   %esi
    d456:	0f 4f f8             	cmovg  %eax,%edi
    d459:	56                   	push   %esi
	if (!(inode = lnamei(path)))
		return -ENOENT;
    d45a:	be fe ff ff ff       	mov    $0xfffffffe,%esi
	verify_area(buf, bufsiz);
    d45f:	57                   	push   %edi
    d460:	ff 74 24 40          	pushl  0x40(%esp)
    d464:	e8 82 a7 ff ff       	call   7beb <verify_area>
    d469:	5d                   	pop    %ebp
	if (!(inode = lnamei(path)))
    d46a:	ff 74 24 3c          	pushl  0x3c(%esp)
    d46e:	e8 b8 14 00 00       	call   e92b <lnamei>
    d473:	83 c4 10             	add    $0x10,%esp
    d476:	85 c0                	test   %eax,%eax
    d478:	89 c2                	mov    %eax,%edx
    d47a:	74 5b                	je     d4d7 <sys_readlink+0xb0>
	if (inode->i_zone[0])
    d47c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
		bh = bread(inode->i_dev, inode->i_zone[0]);
	else
		bh = NULL;
    d480:	31 ed                	xor    %ebp,%ebp
	if (inode->i_zone[0])
    d482:	66 85 c0             	test   %ax,%ax
    d485:	74 1a                	je     d4a1 <sys_readlink+0x7a>
		bh = bread(inode->i_dev, inode->i_zone[0]);
    d487:	51                   	push   %ecx
    d488:	51                   	push   %ecx
    d489:	50                   	push   %eax
    d48a:	0f b7 42 30          	movzwl 0x30(%edx),%eax
    d48e:	89 54 24 18          	mov    %edx,0x18(%esp)
    d492:	50                   	push   %eax
    d493:	e8 18 ef ff ff       	call   c3b0 <bread>
    d498:	83 c4 10             	add    $0x10,%esp
    d49b:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d49f:	89 c5                	mov    %eax,%ebp
	iput(inode);
    d4a1:	83 ec 0c             	sub    $0xc,%esp
	// 如果读取文件数据内容成功，则从内容中复制最多bufsiz个字符到用户缓冲区中，不复制NULL字符。最后释放缓冲块，并返回
	// 复制的字节数。
	if (!bh)
		return 0;
    d4a4:	31 f6                	xor    %esi,%esi
	iput(inode);
    d4a6:	52                   	push   %edx
    d4a7:	e8 7c e6 ff ff       	call   bb28 <iput>
    d4ac:	83 c4 10             	add    $0x10,%esp
	if (!bh)
    d4af:	85 ed                	test   %ebp,%ebp
    d4b1:	74 24                	je     d4d7 <sys_readlink+0xb0>
	i = 0;
	while (i < bufsiz && (c = bh->b_data[i])) {
    d4b3:	8b 55 00             	mov    0x0(%ebp),%edx
    d4b6:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    d4ba:	8a 04 32             	mov    (%edx,%esi,1),%al
    d4bd:	01 f1                	add    %esi,%ecx
    d4bf:	84 c0                	test   %al,%al
    d4c1:	74 08                	je     d4cb <sys_readlink+0xa4>
		i++;
    d4c3:	46                   	inc    %esi
    d4c4:	64 88 01             	mov    %al,%fs:(%ecx)
	while (i < bufsiz && (c = bh->b_data[i])) {
    d4c7:	39 fe                	cmp    %edi,%esi
    d4c9:	7c eb                	jl     d4b6 <sys_readlink+0x8f>
		put_fs_byte(c, buf++);
	}
	brelse(bh);
    d4cb:	83 ec 0c             	sub    $0xc,%esp
    d4ce:	55                   	push   %ebp
    d4cf:	e8 8a ee ff ff       	call   c35e <brelse>
    d4d4:	83 c4 10             	add    $0x10,%esp
	return i;
}
    d4d7:	83 c4 1c             	add    $0x1c,%esp
    d4da:	89 f0                	mov    %esi,%eax
    d4dc:	5b                   	pop    %ebx
    d4dd:	5e                   	pop    %esi
    d4de:	5f                   	pop    %edi
    d4df:	5d                   	pop    %ebp
    d4e0:	c3                   	ret    

0000d4e1 <copy_strings>:
// 并始终指向参数字符串的头部.字符串来源标志from_kmem应该是TYT为了给execve()增添执行脚本文件的功能而新加的参数.当没有运行
// 脚本文件的功能时,所有参数字符串都在用户数据空间中。
// 返回:参数和环境空间当前头部指针.若出错则返回0.
static unsigned long copy_strings(int argc, char ** argv, unsigned long *page,
		unsigned long p, int from_kmem)
{
    d4e1:	55                   	push   %ebp
    d4e2:	57                   	push   %edi
    d4e3:	56                   	push   %esi
    d4e4:	53                   	push   %ebx
    d4e5:	e8 42 95 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d4ea:	81 c3 16 3b 01 00    	add    $0x13b16,%ebx
    d4f0:	83 ec 3c             	sub    $0x3c,%esp
    d4f3:	8b 74 24 50          	mov    0x50(%esp),%esi
	char *tmp, *pag;
	int len, offset = 0;
	unsigned long old_fs, new_fs;

	if (!p)
    d4f7:	85 f6                	test   %esi,%esi
    d4f9:	75 07                	jne    d502 <copy_strings+0x21>
		return 0;												/* bullet-proofing */	/* 偏移指针验证 */
    d4fb:	31 f6                	xor    %esi,%esi
    d4fd:	e9 47 01 00 00       	jmp    d649 <copy_strings+0x168>
    d502:	89 c7                	mov    %eax,%edi
//// 取ds面寄存器值.
// 返回:ds段寄存器值.
static inline unsigned long get_ds()
{
	unsigned short _v;
	__asm__("mov %%ds,%%ax":"=a" (_v):);
    d504:	66 8c d8             	mov    %ds,%ax
    d507:	66 89 44 24 18       	mov    %ax,0x18(%esp)
	__asm__("mov %%fs,%%ax":"=a" (_v):);
    d50c:	66 8c e0             	mov    %fs,%ax
	// 首先取当前段寄存器ds(指向内核数据段)和fs值,分别保存到变量new_fs和old_fs中.如果字符串和字符串数组(指针)来自内核空间,则设置fs段寄存器指向内核数据段.
	new_fs = get_ds();
	old_fs = get_fs();
	if (from_kmem == 2)											// 若串指针在内核空间则设置fs指向内核空间.
    d50f:	83 7c 24 54 02       	cmpl   $0x2,0x54(%esp)
    d514:	66 89 44 24 1a       	mov    %ax,0x1a(%esp)
    d519:	75 06                	jne    d521 <copy_strings+0x40>

//// 设置fs段寄存器.
// 参数:val - 段值(选择符).
static inline void set_fs(unsigned long val)
{
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
    d51b:	8b 44 24 18          	mov    0x18(%esp),%eax
    d51f:	8e e0                	mov    %eax,%fs
    d521:	8d 04 ba             	lea    (%edx,%edi,4),%eax
    d524:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    d528:	89 7c 24 14          	mov    %edi,0x14(%esp)
    d52c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    d533:	00 
    d534:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		set_fs(new_fs);
	// 然后循环处理各个参数,从最后一个参数逆向开始复制,复制到指定偏移地址处.在循环中,首先取需要复制的当前字符串指针.如果字符串
	// 在用户空间而字符串数组(字符串指针)在内核空间,则设置fs段寄存器指向内核数据段(ds).并在内核数据空间中取了字符串指针tmp之
	// 后就立刻恢复fs段寄存器原值(fs再指回用户空间).否则不用修改fs值而直接从用户空间取字符串指针到tmp.
	while (argc-- > 0) {
    d538:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    d53d:	0f 8e f8 00 00 00    	jle    d63b <copy_strings+0x15a>
		if (from_kmem == 1)										// 若串指针在内核空间,则fs指向内核空间.
    d543:	83 7c 24 54 01       	cmpl   $0x1,0x54(%esp)
    d548:	75 06                	jne    d550 <copy_strings+0x6f>
    d54a:	8b 44 24 18          	mov    0x18(%esp),%eax
    d54e:	8e e0                	mov    %eax,%fs
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    d550:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d554:	64 8b 40 fc          	mov    %fs:-0x4(%eax),%eax
			set_fs(new_fs);
		if (!(tmp = (char *)get_fs_long(((unsigned long *)argv) + argc)))
    d558:	85 c0                	test   %eax,%eax
    d55a:	89 c7                	mov    %eax,%edi
    d55c:	75 12                	jne    d570 <copy_strings+0x8f>
			panic("argc is wrong");
    d55e:	8d 83 ca 74 ff ff    	lea    -0x8b36(%ebx),%eax
    d564:	83 ec 0c             	sub    $0xc,%esp
    d567:	50                   	push   %eax
    d568:	e8 65 ab ff ff       	call   80d2 <panic>
    d56d:	83 c4 10             	add    $0x10,%esp
    d570:	31 ed                	xor    %ebp,%ebp
		if (from_kmem == 1)										// 若串指针在内核空间,则fs指回用户空间.
    d572:	83 7c 24 54 01       	cmpl   $0x1,0x54(%esp)
    d577:	75 07                	jne    d580 <copy_strings+0x9f>
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
    d579:	66 8b 44 24 1a       	mov    0x1a(%esp),%ax
    d57e:	8e e0                	mov    %eax,%fs
    d580:	8d 44 3d 00          	lea    0x0(%ebp,%edi,1),%eax
		// 然后从用户空间取该字符串,并计算参数字符串长度len.此后tmp指向该字符串末端.如果该字符串长度超过此时参数和环境空间中还剩余
		// 的空闲长度,则空间不够了.于是恢复fs段寄存器值(如果被改变的话)并返回0.不过因为参数和环境空间留128KB,所以通常不可能发生这
		// 种情况.
		len = 0;												/* remember zero-padding */
		do {													/* 我们知道串是以NULL字节结尾的 */
			len++;
    d584:	45                   	inc    %ebp
    d585:	8d 54 3d 00          	lea    0x0(%ebp,%edi,1),%edx
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    d589:	64 8a 00             	mov    %fs:(%eax),%al
		} while (get_fs_byte(tmp++));
    d58c:	84 c0                	test   %al,%al
    d58e:	89 54 24 24          	mov    %edx,0x24(%esp)
    d592:	75 ec                	jne    d580 <copy_strings+0x9f>
    d594:	89 f7                	mov    %esi,%edi
		}
		// 接着我们逆向逐个字符地把字符串复制到参数和环境空间末端处.在循环复制字符串的字符过程中,我们首先要判断参数和环境空间中相应位
		// 置处是否已经有内存页面.如果还没有就先为其申请1页内存页面.偏移量offset被用途为在一个页面中的当前指针偏移值.因为刚开始执行
		// 本函数时,偏移变量offset被初始化为0,所以(offset-1 < 0)肯定成立而使得offset重新被设置为当前p指针在页面范围内的偏移值.
		while (len) {
			--p; --tmp; --len;
    d596:	4f                   	dec    %edi
    d597:	8b 4c 24 24          	mov    0x24(%esp),%ecx
			if (--offset < 0) {
    d59b:	ff 4c 24 0c          	decl   0xc(%esp)
    d59f:	89 f8                	mov    %edi,%eax
    d5a1:	29 f0                	sub    %esi,%eax
    d5a3:	01 c1                	add    %eax,%ecx
    d5a5:	83 7c 24 0c ff       	cmpl   $0xffffffff,0xc(%esp)
    d5aa:	89 44 24 20          	mov    %eax,0x20(%esp)
    d5ae:	75 61                	jne    d611 <copy_strings+0x130>
				offset = p % PAGE_SIZE;
    d5b0:	89 f8                	mov    %edi,%eax
    d5b2:	25 ff 0f 00 00       	and    $0xfff,%eax
				if (from_kmem == 2)								// 若串在内核空间则fs指回用户空间.
    d5b7:	83 7c 24 54 02       	cmpl   $0x2,0x54(%esp)
				offset = p % PAGE_SIZE;
    d5bc:	89 44 24 0c          	mov    %eax,0xc(%esp)
				if (from_kmem == 2)								// 若串在内核空间则fs指回用户空间.
    d5c0:	75 07                	jne    d5c9 <copy_strings+0xe8>
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
    d5c2:	66 8b 44 24 1a       	mov    0x1a(%esp),%ax
    d5c7:	8e e0                	mov    %eax,%fs
					set_fs(old_fs);
				// 如果当前偏移值p所在的串空间页面指针数组项page[p/PAGE_SIZE] == 0,表示此时p指针所处的空间内存页面还不存在,则需申请一空闲
				// 内存页,并将该页面指针填入指针数组,同时也使页面指针pag指向该新页面.若申请不到空闲页面则返回0.
				if (!(pag = (char *) page[p / PAGE_SIZE]) &&
    d5c9:	8b 54 24 28          	mov    0x28(%esp),%edx
    d5cd:	89 f8                	mov    %edi,%eax
    d5cf:	c1 e8 0c             	shr    $0xc,%eax
    d5d2:	8d 14 82             	lea    (%edx,%eax,4),%edx
    d5d5:	8b 02                	mov    (%edx),%eax
    d5d7:	85 c0                	test   %eax,%eax
    d5d9:	74 06                	je     d5e1 <copy_strings+0x100>
    d5db:	89 44 24 10          	mov    %eax,0x10(%esp)
    d5df:	eb 23                	jmp    d604 <copy_strings+0x123>
    d5e1:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
    d5e5:	89 54 24 10          	mov    %edx,0x10(%esp)
				    !(pag = (char *) (page[p / PAGE_SIZE] =
				      get_free_page())))
    d5e9:	e8 17 d5 ff ff       	call   ab05 <get_free_page>
				    !(pag = (char *) (page[p / PAGE_SIZE] =
    d5ee:	8b 54 24 10          	mov    0x10(%esp),%edx
				if (!(pag = (char *) page[p / PAGE_SIZE]) &&
    d5f2:	85 c0                	test   %eax,%eax
				    !(pag = (char *) (page[p / PAGE_SIZE] =
    d5f4:	89 44 24 10          	mov    %eax,0x10(%esp)
				if (!(pag = (char *) page[p / PAGE_SIZE]) &&
    d5f8:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
				    !(pag = (char *) (page[p / PAGE_SIZE] =
    d5fc:	89 02                	mov    %eax,(%edx)
				if (!(pag = (char *) page[p / PAGE_SIZE]) &&
    d5fe:	0f 84 f7 fe ff ff    	je     d4fb <copy_strings+0x1a>
					return 0;
				if (from_kmem == 2)								// 若串在内核空间则fs指向内核空间.
    d604:	83 7c 24 54 02       	cmpl   $0x2,0x54(%esp)
    d609:	75 06                	jne    d611 <copy_strings+0x130>
    d60b:	8b 44 24 18          	mov    0x18(%esp),%eax
    d60f:	8e e0                	mov    %eax,%fs
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    d611:	64 8a 01             	mov    %fs:(%ecx),%al
					set_fs(new_fs);

			}
			// 然后从fs段中复制字符串的1字节到参数和环境空间内存页面pag的offset处.
			*(pag + offset) = get_fs_byte(tmp);
    d614:	8b 54 24 0c          	mov    0xc(%esp),%edx
    d618:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    d61c:	88 04 11             	mov    %al,(%ecx,%edx,1)
		while (len) {
    d61f:	8b 44 24 20          	mov    0x20(%esp),%eax
    d623:	01 e8                	add    %ebp,%eax
    d625:	0f 85 6b ff ff ff    	jne    d596 <copy_strings+0xb5>
    d62b:	ff 4c 24 14          	decl   0x14(%esp)
    d62f:	83 6c 24 1c 04       	subl   $0x4,0x1c(%esp)
			--p; --tmp; --len;
    d634:	89 fe                	mov    %edi,%esi
    d636:	e9 fd fe ff ff       	jmp    d538 <copy_strings+0x57>
		}
	}
	// 如果字符串和字符串数组在内核空间,则恢复fs段寄存器原值.最后,返回参数和环境空间中已复制参数的头部偏移值.
	if (from_kmem == 2)
    d63b:	83 7c 24 54 02       	cmpl   $0x2,0x54(%esp)
    d640:	75 07                	jne    d649 <copy_strings+0x168>
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
    d642:	66 8b 44 24 1a       	mov    0x1a(%esp),%ax
    d647:	8e e0                	mov    %eax,%fs
		set_fs(old_fs);
	return p;
}
    d649:	83 c4 3c             	add    $0x3c,%esp
    d64c:	89 f0                	mov    %esi,%eax
    d64e:	5b                   	pop    %ebx
    d64f:	5e                   	pop    %esi
    d650:	5f                   	pop    %edi
    d651:	5d                   	pop    %ebp
    d652:	c3                   	ret    

0000d653 <sys_uselib>:
{
    d653:	57                   	push   %edi
	if (get_limit(0x17) != TASK_SIZE)
    d654:	ba 17 00 00 00       	mov    $0x17,%edx
{
    d659:	56                   	push   %esi
	if (get_limit(0x17) != TASK_SIZE)
    d65a:	0f 03 d2             	lsl    %dx,%edx
    d65d:	42                   	inc    %edx
{
    d65e:	53                   	push   %ebx
		return -EINVAL;
    d65f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
    d664:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    d668:	e8 bf 93 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d66d:	81 c3 93 39 01 00    	add    $0x13993,%ebx
	if (get_limit(0x17) != TASK_SIZE)
    d673:	81 fa 00 00 00 04    	cmp    $0x4000000,%edx
    d679:	75 77                	jne    d6f2 <sys_uselib+0x9f>
	if (library) {
    d67b:	85 c9                	test   %ecx,%ecx
    d67d:	74 19                	je     d698 <sys_uselib+0x45>
		if (!(inode = namei(library)))							/* get library inode */
    d67f:	83 ec 0c             	sub    $0xc,%esp
    d682:	51                   	push   %ecx
    d683:	e8 b0 12 00 00       	call   e938 <namei>
    d688:	89 c6                	mov    %eax,%esi
    d68a:	83 c4 10             	add    $0x10,%esp
			return -ENOENT;                 					/* 取库文件i节点 */
    d68d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		if (!(inode = namei(library)))							/* get library inode */
    d692:	85 f6                	test   %esi,%esi
    d694:	75 04                	jne    d69a <sys_uselib+0x47>
    d696:	eb 5a                	jmp    d6f2 <sys_uselib+0x9f>
		inode = NULL;
    d698:	31 f6                	xor    %esi,%esi
	iput(current->library);
    d69a:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
    d6a0:	83 ec 0c             	sub    $0xc,%esp
    d6a3:	8b 07                	mov    (%edi),%eax
    d6a5:	ff b0 40 03 00 00    	pushl  0x340(%eax)
    d6ab:	e8 78 e4 ff ff       	call   bb28 <iput>
    d6b0:	58                   	pop    %eax
	current->library = NULL;
    d6b1:	8b 07                	mov    (%edi),%eax
	iput(current->library);
    d6b3:	5a                   	pop    %edx
	base = get_base(current->ldt[2]);
    d6b4:	8a b0 af 03 00 00    	mov    0x3af(%eax),%dh
    d6ba:	8a 90 ac 03 00 00    	mov    0x3ac(%eax),%dl
    d6c0:	c1 e2 10             	shl    $0x10,%edx
    d6c3:	66 8b 90 aa 03 00 00 	mov    0x3aa(%eax),%dx
	base += LIBRARY_OFFSET;
    d6ca:	81 c2 00 00 c0 03    	add    $0x3c00000,%edx
	current->library = NULL;
    d6d0:	c7 80 40 03 00 00 00 	movl   $0x0,0x340(%eax)
    d6d7:	00 00 00 
	free_page_tables(base, LIBRARY_SIZE);
    d6da:	68 00 00 40 00       	push   $0x400000
    d6df:	52                   	push   %edx
    d6e0:	e8 d6 c8 ff ff       	call   9fbb <free_page_tables>
	current->library = inode;
    d6e5:	8b 07                	mov    (%edi),%eax
	free_page_tables(base, LIBRARY_SIZE);
    d6e7:	83 c4 10             	add    $0x10,%esp
	current->library = inode;
    d6ea:	89 b0 40 03 00 00    	mov    %esi,0x340(%eax)
	return 0;
    d6f0:	31 c0                	xor    %eax,%eax
}
    d6f2:	5b                   	pop    %ebx
    d6f3:	5e                   	pop    %esi
    d6f4:	5f                   	pop    %edi
    d6f5:	c3                   	ret    

0000d6f6 <do_execve>:
// argv - 命令行参数指针数组的指针;
// envp - 环境变更指针数组的指针.
// 返回:如果调用成功,则不返回;否则设置出错号,并返回-1.
int do_execve(unsigned long * eip, long tmp, char * filename,
	char ** argv, char ** envp)
{
    d6f6:	55                   	push   %ebp
    d6f7:	57                   	push   %edi
	int sh_bang = 0;											// 控制是否需要执行脚本程序.
	unsigned long p = PAGE_SIZE * MAX_ARG_PAGES - 4;			// p指向参数和环境空间的最后部.

	// 在内核中打印要执行的文件的文件名字
	char s, filename1[128];
	int index = 0;
    d6f8:	31 c0                	xor    %eax,%eax
{
    d6fa:	56                   	push   %esi
    d6fb:	53                   	push   %ebx
    d6fc:	e8 2b 93 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    d701:	81 c3 ff 38 01 00    	add    $0x138ff,%ebx
    d707:	81 ec cc 01 00 00    	sub    $0x1cc,%esp
	while (1) {
		s = get_fs_byte(filename + index);
    d70d:	8b 8c 24 e8 01 00 00 	mov    0x1e8(%esp),%ecx
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    d714:	64 8a 14 01          	mov    %fs:(%ecx,%eax,1),%dl
		if (s) {
    d718:	84 d2                	test   %dl,%dl
    d71a:	74 0a                	je     d726 <do_execve+0x30>
			*(filename1 + index) = s;
    d71c:	88 94 04 c0 00 00 00 	mov    %dl,0xc0(%esp,%eax,1)
			index++;
    d723:	40                   	inc    %eax
		s = get_fs_byte(filename + index);
    d724:	eb ee                	jmp    d714 <do_execve+0x1e>
		} else {
			break;
		}
	}
	*(filename1 + index + 1) = '\0';
    d726:	c6 84 04 c1 00 00 00 	movb   $0x0,0xc1(%esp,%eax,1)
    d72d:	00 
	Log(LOG_INFO_TYPE, "<<<<< process pid = %d do_execve : %s >>>>>\n", current->pid, filename1);
    d72e:	8d 84 24 c0 00 00 00 	lea    0xc0(%esp),%eax
    d735:	50                   	push   %eax
    d736:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    d73c:	8b 00                	mov    (%eax),%eax
    d73e:	ff b0 2c 02 00 00    	pushl  0x22c(%eax)
    d744:	8d 83 d8 74 ff ff    	lea    -0x8b28(%ebx),%eax
    d74a:	50                   	push   %eax
    d74b:	6a 00                	push   $0x0
    d74d:	e8 3d 9d 00 00       	call   1748f <Log>
    d752:	83 c4 10             	add    $0x10,%esp
	// 上行把p初始设置成位于128KB空间的最后1个长字处.在初始参数和环境空间的操作过程中,p将用来指明在128KB空间中的当前位置.
	// 另外,参数eip[1]是调用本次系统调用的原用户程序代码段寄存器CS值,其中的段选择符当然必须是当前任务的代码段选择符(0x000f).
	// 若不是该值,那么CS只能会是内核代码段的选择符0x0008.但这是绝对不允许的,因为内核代码是常驻内存而不能被替换掉的.因此下面根据
	// eip[1]的值确认是否符合正常情况.然后再初始化128KB的参数和环境串空间,把所有字节清零,并取出执行文件的i节点.再根据函数参数
	// 分别计算出命令行参数和环境字符串的个数argc和envc.另外,执行文件必须是常规文件.
	if ((0xffff & eip[1]) != 0x000f)
    d755:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
    d75c:	66 83 78 04 0f       	cmpw   $0xf,0x4(%eax)
    d761:	74 12                	je     d775 <do_execve+0x7f>
		panic("execve called from supervisor mode");
    d763:	8d 83 05 75 ff ff    	lea    -0x8afb(%ebx),%eax
    d769:	83 ec 0c             	sub    $0xc,%esp
    d76c:	50                   	push   %eax
    d76d:	e8 60 a9 ff ff       	call   80d2 <panic>
    d772:	83 c4 10             	add    $0x10,%esp
	int index = 0;
    d775:	31 c0                	xor    %eax,%eax
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)						/* clear page-table */
		page[i] = 0;
    d777:	c7 44 84 40 00 00 00 	movl   $0x0,0x40(%esp,%eax,4)
    d77e:	00 
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)						/* clear page-table */
    d77f:	40                   	inc    %eax
    d780:	83 f8 20             	cmp    $0x20,%eax
    d783:	75 f2                	jne    d777 <do_execve+0x81>
	if (!(inode = namei(filename)))								/* get executables inode */
    d785:	83 ec 0c             	sub    $0xc,%esp
		return -ENOENT;
    d788:	be fe ff ff ff       	mov    $0xfffffffe,%esi
	if (!(inode = namei(filename)))								/* get executables inode */
    d78d:	ff b4 24 f4 01 00 00 	pushl  0x1f4(%esp)
    d794:	e8 9f 11 00 00       	call   e938 <namei>
    d799:	83 c4 10             	add    $0x10,%esp
    d79c:	85 c0                	test   %eax,%eax
    d79e:	89 c5                	mov    %eax,%ebp
    d7a0:	0f 84 f8 06 00 00    	je     de9e <do_execve+0x7a8>
	if (tmp = argv)
    d7a6:	83 bc 24 ec 01 00 00 	cmpl   $0x0,0x1ec(%esp)
    d7ad:	00 
    d7ae:	75 09                	jne    d7b9 <do_execve+0xc3>
	int i = 0;
    d7b0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
    d7b7:	eb 1f                	jmp    d7d8 <do_execve+0xe2>
	if (tmp = argv)
    d7b9:	8b 84 24 ec 01 00 00 	mov    0x1ec(%esp),%eax
	int i = 0;
    d7c0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
		while (get_fs_long((unsigned long *) (tmp++)))
    d7c7:	8d 50 04             	lea    0x4(%eax),%edx
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
    d7ca:	64 8b 00             	mov    %fs:(%eax),%eax
    d7cd:	85 c0                	test   %eax,%eax
    d7cf:	74 07                	je     d7d8 <do_execve+0xe2>
			i++;
    d7d1:	ff 04 24             	incl   (%esp)
		while (get_fs_long((unsigned long *) (tmp++)))
    d7d4:	89 d0                	mov    %edx,%eax
    d7d6:	eb ef                	jmp    d7c7 <do_execve+0xd1>
	if (tmp = argv)
    d7d8:	83 bc 24 f0 01 00 00 	cmpl   $0x0,0x1f0(%esp)
    d7df:	00 
    d7e0:	75 0a                	jne    d7ec <do_execve+0xf6>
	int i = 0;
    d7e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    d7e9:	00 
    d7ea:	eb 21                	jmp    d80d <do_execve+0x117>
	if (tmp = argv)
    d7ec:	8b 84 24 f0 01 00 00 	mov    0x1f0(%esp),%eax
	int i = 0;
    d7f3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    d7fa:	00 
		while (get_fs_long((unsigned long *) (tmp++)))
    d7fb:	8d 50 04             	lea    0x4(%eax),%edx
    d7fe:	64 8b 00             	mov    %fs:(%eax),%eax
    d801:	85 c0                	test   %eax,%eax
    d803:	74 08                	je     d80d <do_execve+0x117>
			i++;
    d805:	ff 44 24 04          	incl   0x4(%esp)
		while (get_fs_long((unsigned long *) (tmp++)))
    d809:	89 d0                	mov    %edx,%eax
    d80b:	eb ee                	jmp    d7fb <do_execve+0x105>
    d80d:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	int i = 0;
    d813:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
    d81a:	00 
	unsigned long p = PAGE_SIZE * MAX_ARG_PAGES - 4;			// p指向参数和环境空间的最后部.
    d81b:	c7 44 24 08 fc ff 01 	movl   $0x1fffc,0x8(%esp)
    d822:	00 
	int sh_bang = 0;											// 控制是否需要执行脚本程序.
    d823:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
    d82a:	00 
    d82b:	89 44 24 20          	mov    %eax,0x20(%esp)
	argc = count(argv);											// 命令行参数个数.
	envc = count(envp);											// 环境字符串变量个数.

restart_interp:
	if (!S_ISREG(inode->i_mode)) {								/* must be regular file */
    d82f:	0f b7 75 00          	movzwl 0x0(%ebp),%esi
    d833:	89 f2                	mov    %esi,%edx
    d835:	89 f0                	mov    %esi,%eax
    d837:	66 81 e2 00 f0       	and    $0xf000,%dx
    d83c:	66 81 fa 00 80       	cmp    $0x8000,%dx
    d841:	0f 85 e2 04 00 00    	jne    dd29 <do_execve+0x633>
    d847:	8b 7c 24 20          	mov    0x20(%esp),%edi
    d84b:	66 8b 4d 02          	mov    0x2(%ebp),%cx
	// 个标志主要是让一般用户能够执行特权用户(如超级用户root)的程序,例如改变密码的程序passwd等.如果set-user-ID标志置位,则
	// 后面执行进程的有效用户ID(euid)就设置成执行文件的用户ID,否则设置成当前进程的euid.如果执行文件set-group-id被置位的话,
	// 则执行进程的有效组ID(egid)就设置为执行执行文件的组ID.否则设置成当前进程的egid.这里暂把这两个判断出来的值保存在变量
	// e_uid和e_gid中.
	i = inode->i_mode;
	e_uid = (i & S_ISUID) ? inode->i_uid : current->euid;
    d84f:	f6 c4 08             	test   $0x8,%ah
    d852:	8b 3f                	mov    (%edi),%edi
    d854:	66 89 4c 24 1c       	mov    %cx,0x1c(%esp)
    d859:	0f b7 97 ce 02 00 00 	movzwl 0x2ce(%edi),%edx
    d860:	89 d1                	mov    %edx,%ecx
    d862:	89 54 24 14          	mov    %edx,0x14(%esp)
    d866:	74 09                	je     d871 <do_execve+0x17b>
    d868:	0f b7 54 24 1c       	movzwl 0x1c(%esp),%edx
    d86d:	89 54 24 14          	mov    %edx,0x14(%esp)
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
    d871:	f6 c4 04             	test   $0x4,%ah
    d874:	74 06                	je     d87c <do_execve+0x186>
    d876:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    d87a:	eb 07                	jmp    d883 <do_execve+0x18d>
    d87c:	0f b7 87 d4 02 00 00 	movzwl 0x2d4(%edi),%eax
	// 现在根据进程的euid和egid和执行文件的访问属性进行比较.如果执行文件属于运行进程的用户,则把文件属性值i右移6位,此时其最低3
	// 位是文件宿主的访问权限标志.否则的话如果执行文件与当前进程的用户属于同组,则使属性最低3位是执行文件组用户的访问权限标志.否则
	// 此时属性字最低3位就是其他用户访问该执行文件的权限.然后我们根据属性字i的最低3位值来判断当前进程是否有权限运行这个执行文件.
	// 如果选出的相应用户没有运行该文件的权力(位0是执行权限),并且其他用户也没有任何权限或者当前进程用户不是超级用户,则表明当前进
	// 程没有权力运行这个执行文件.于是置不可执行出错码,并跳转到exec_error2处去作退出处理.
	if (current->euid == inode->i_uid)
    d883:	66 3b 4c 24 1c       	cmp    0x1c(%esp),%cx
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
    d888:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (current->euid == inode->i_uid)
    d88c:	75 05                	jne    d893 <do_execve+0x19d>
		i >>= 6;
    d88e:	c1 fe 06             	sar    $0x6,%esi
    d891:	eb 17                	jmp    d8aa <do_execve+0x1b4>
	else if (in_group_p(inode->i_gid))
    d893:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    d897:	83 ec 0c             	sub    $0xc,%esp
    d89a:	50                   	push   %eax
    d89b:	e8 c4 b2 ff ff       	call   8b64 <in_group_p>
    d8a0:	83 c4 10             	add    $0x10,%esp
    d8a3:	85 c0                	test   %eax,%eax
    d8a5:	74 03                	je     d8aa <do_execve+0x1b4>
		i >>= 3;
    d8a7:	c1 fe 03             	sar    $0x3,%esi
	if (!(i & 1) &&
    d8aa:	83 e6 01             	and    $0x1,%esi
    d8ad:	75 20                	jne    d8cf <do_execve+0x1d9>
    d8af:	f6 45 00 49          	testb  $0x49,0x0(%ebp)
    d8b3:	75 0a                	jne    d8bf <do_execve+0x1c9>
	    !((inode->i_mode & 0111) && suser())) {
		retval = -ENOEXEC;
    d8b5:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
    d8ba:	e9 76 04 00 00       	jmp    dd35 <do_execve+0x63f>
	    !((inode->i_mode & 0111) && suser())) {
    d8bf:	8b 44 24 20          	mov    0x20(%esp),%eax
    d8c3:	8b 00                	mov    (%eax),%eax
    d8c5:	66 83 b8 ce 02 00 00 	cmpw   $0x0,0x2ce(%eax)
    d8cc:	00 
    d8cd:	75 e6                	jne    d8b5 <do_execve+0x1bf>
	// 的解释程序名及后面的参数(若有的话),然后将这些参数和脚本文件名放进执行文件(此时是解释程序)的命令行参数空间中.在这之前我们当然
	// 需要先把函数指定的原有命令行参数和环境字符串放到128KB空间中,而这里建立起来的命令行参数则放到它们前面位置处(因为是逆向放置).
	// 最后让内核执行脚本文件的解释程序.下面就是在设置好解释程序的脚本文件名等参数后,取出解释程序的i节点并跳转到229行支执行解释程序.
	// 由于我们需要跳转到执行过的代码229行支.因此在下面确认并处理了脚本文件之后需要设置一个禁止再次执行下面的脚本处理代码标志sh_bang.
	// 在后面的代码中该标志也用来表示我们已经设置好执行文件的命令行参数,不要重复设置.
	if (!(bh = bread(inode->i_dev, inode->i_zone[0]))) {
    d8cf:	50                   	push   %eax
    d8d0:	50                   	push   %eax
    d8d1:	0f b7 45 0e          	movzwl 0xe(%ebp),%eax
    d8d5:	50                   	push   %eax
    d8d6:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    d8da:	50                   	push   %eax
    d8db:	e8 d0 ea ff ff       	call   c3b0 <bread>
    d8e0:	83 c4 10             	add    $0x10,%esp
    d8e3:	85 c0                	test   %eax,%eax
    d8e5:	89 c2                	mov    %eax,%edx
    d8e7:	0f 84 3c 04 00 00    	je     dd29 <do_execve+0x633>
		retval = -EACCES;
		goto exec_error2;
	}
	ex = *((struct exec *) bh->b_data);								/* read exec-header */
    d8ed:	8b 00                	mov    (%eax),%eax
	if ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) {
    d8ef:	80 38 23             	cmpb   $0x23,(%eax)
    d8f2:	0f 85 95 00 00 00    	jne    d98d <do_execve+0x297>
    d8f8:	80 78 01 21          	cmpb   $0x21,0x1(%eax)
    d8fc:	0f 85 8b 00 00 00    	jne    d98d <do_execve+0x297>
    d902:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
    d907:	74 7c                	je     d985 <do_execve+0x28f>
		unsigned long old_fs;

		// 从这里开始，我们从脚本文件中提取解释程序名及其参数，并把解释程序名、解释程序的参数和脚本文件名组合放入环境参数块中。首先复制脚本
		// 文件头1行字符‘#!’后面的字符串到buf中，其中含有脚本解释程序名（例如/bin/sh），也可能还包含解释程序的几个参数。然后对buf中的内容
		// 进行处理。删除开始的空格、制表符。
		strncpy(buf, bh->b_data + 2, 127);
    d909:	8d 70 02             	lea    0x2(%eax),%esi
__asm__(
    d90c:	8d bc 24 40 01 00 00 	lea    0x140(%esp),%edi
    d913:	b9 7f 00 00 00       	mov    $0x7f,%ecx
    d918:	fc                   	cld    
    d919:	49                   	dec    %ecx
    d91a:	78 08                	js     d924 <do_execve+0x22e>
    d91c:	ac                   	lods   %ds:(%esi),%al
    d91d:	aa                   	stos   %al,%es:(%edi)
    d91e:	84 c0                	test   %al,%al
    d920:	75 f7                	jne    d919 <do_execve+0x223>
    d922:	f3 aa                	rep stos %al,%es:(%edi)
		brelse(bh);             									// 释放缓冲块并放回脚本文件i节点。
    d924:	83 ec 0c             	sub    $0xc,%esp
__asm__(
    d927:	89 fe                	mov    %edi,%esi
    d929:	52                   	push   %edx
    d92a:	e8 2f ea ff ff       	call   c35e <brelse>
		iput(inode);
    d92f:	89 2c 24             	mov    %ebp,(%esp)
    d932:	e8 f1 e1 ff ff       	call   bb28 <iput>
    d937:	83 c4 10             	add    $0x10,%esp
    d93a:	b0 0a                	mov    $0xa,%al
		buf[127] = '\0';
    d93c:	c6 84 24 bf 01 00 00 	movb   $0x0,0x1bf(%esp)
    d943:	00 
    d944:	fc                   	cld    
    d945:	88 c4                	mov    %al,%ah
    d947:	ac                   	lods   %ds:(%esi),%al
    d948:	38 e0                	cmp    %ah,%al
    d94a:	74 09                	je     d955 <do_execve+0x25f>
    d94c:	84 c0                	test   %al,%al
    d94e:	75 f7                	jne    d947 <do_execve+0x251>
    d950:	be 01 00 00 00       	mov    $0x1,%esi
    d955:	89 f0                	mov    %esi,%eax
    d957:	48                   	dec    %eax
		if (cp = strchr(buf, '\n')) {
    d958:	85 c0                	test   %eax,%eax
    d95a:	74 1f                	je     d97b <do_execve+0x285>
			*cp = '\0';     										// 第1个换行符换成NULL并去掉行头空格制表符。
    d95c:	c6 00 00             	movb   $0x0,(%eax)
			for (cp = buf; (*cp == ' ') || (*cp == '\t'); cp++);
    d95f:	89 fd                	mov    %edi,%ebp
    d961:	8a 55 00             	mov    0x0(%ebp),%dl
    d964:	80 fa 20             	cmp    $0x20,%dl
    d967:	0f 94 c1             	sete   %cl
    d96a:	80 fa 09             	cmp    $0x9,%dl
    d96d:	0f 94 c0             	sete   %al
    d970:	08 c8                	or     %cl,%al
    d972:	0f 84 e5 03 00 00    	je     dd5d <do_execve+0x667>
    d978:	45                   	inc    %ebp
    d979:	eb e6                	jmp    d961 <do_execve+0x26b>
		}
		if (!cp || *cp == '\0') {       							// 若该行没有其他内容，则出错。
			retval = -ENOEXEC; 										/* No interpreter name found */
    d97b:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
    d980:	e9 bc 03 00 00       	jmp    dd41 <do_execve+0x64b>
    d985:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
    d98c:	00 
	ex = *((struct exec *) bh->b_data);								/* read exec-header */
    d98d:	8b 38                	mov    (%eax),%edi
    d98f:	8b 48 08             	mov    0x8(%eax),%ecx
	// 此时缓冲块中的执行文件头结构已经复制到了ex中.于是先释放该缓冲块,并开始对ex中的执行头信息进行判断处理.对于Linux0.12内核来说,
	// 它仅支持ZMAGIC执行格式,并且执行文件代码都从逻辑地址0开始执行,因此不支持含有代码或数据重定位信息的执行文件.当然,如果执行文件
	// 实在太大或者执行文件残缺不全,那么我们也不能运行它.因此对于下列情况将不执行程序:如果执行文件不是需求页可执行文件(ZMAGIC),或者
	// 代码和数据重定位部分长度不等于0,或者(代码段+数据段+堆)长度超过50MB,或者执行文件长度小于(代码段+数据段+符号表长度+执行头部分)
	// 长度的总和.
	brelse(bh);
    d992:	83 ec 0c             	sub    $0xc,%esp
	ex = *((struct exec *) bh->b_data);								/* read exec-header */
    d995:	8b 70 10             	mov    0x10(%eax),%esi
    d998:	89 7c 24 34          	mov    %edi,0x34(%esp)
    d99c:	89 4c 24 18          	mov    %ecx,0x18(%esp)
    d9a0:	8b 78 04             	mov    0x4(%eax),%edi
    d9a3:	8b 48 14             	mov    0x14(%eax),%ecx
    d9a6:	89 7c 24 2c          	mov    %edi,0x2c(%esp)
    d9aa:	89 4c 24 30          	mov    %ecx,0x30(%esp)
    d9ae:	8b 78 0c             	mov    0xc(%eax),%edi
    d9b1:	8b 48 18             	mov    0x18(%eax),%ecx
    d9b4:	89 7c 24 28          	mov    %edi,0x28(%esp)
    d9b8:	89 4c 24 38          	mov    %ecx,0x38(%esp)
    d9bc:	8b 78 1c             	mov    0x1c(%eax),%edi
	brelse(bh);
    d9bf:	52                   	push   %edx
    d9c0:	e8 99 e9 ff ff       	call   c35e <brelse>
    d9c5:	83 c4 10             	add    $0x10,%esp
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
    d9c8:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
    d9cc:	85 c9                	test   %ecx,%ecx
    d9ce:	0f 95 c1             	setne  %cl
    d9d1:	81 7c 24 28 0b 01 00 	cmpl   $0x10b,0x28(%esp)
    d9d8:	00 
    d9d9:	0f 95 c2             	setne  %dl
    d9dc:	08 d1                	or     %dl,%cl
    d9de:	0f 85 d1 fe ff ff    	jne    d8b5 <do_execve+0x1bf>
    d9e4:	85 ff                	test   %edi,%edi
    d9e6:	0f 85 c9 fe ff ff    	jne    d8b5 <do_execve+0x1bf>
		ex.a_text + ex.a_data + ex.a_bss > 0x3000000 ||
    d9ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
    d9f0:	03 44 24 20          	add    0x20(%esp),%eax
    d9f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
    d9f8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    d9fc:	03 44 24 0c          	add    0xc(%esp),%eax
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
    da00:	3d 00 00 00 03       	cmp    $0x3000000,%eax
		ex.a_text + ex.a_data + ex.a_bss > 0x3000000 ||
    da05:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
    da09:	0f 87 a6 fe ff ff    	ja     d8b5 <do_execve+0x1bf>
		inode->i_size < ex.a_text + ex.a_data + ex.a_syms + N_TXTOFF(ex)) {
    da0f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    da13:	8d 84 30 00 04 00 00 	lea    0x400(%eax,%esi,1),%eax
		ex.a_text + ex.a_data + ex.a_bss > 0x3000000 ||
    da1a:	39 45 04             	cmp    %eax,0x4(%ebp)
    da1d:	0f 82 92 fe ff ff    	jb     d8b5 <do_execve+0x1bf>
	}
	// 如果sh_bang标志没有设置,则复制指定个数的命令行参数和环境字符串到参数和环境空间中.若sh_bang标志已经设置,则表明将运行脚本解释程序,
	// 此时一环境变量页面已经复制,无须再复制.同样,若sh_bang没有置位而需要复制的话,那么此时指针p随着复制信息增加而逐渐向小地址方向移动,
	// 因此这两个复制串函数执行完后,环境参数串信息块位于程序参数串信息块的上方,并且p指向程序的第1个参数串.事实上,p是128KB参数和环境空间
	// 中的偏移值.因此如果p=0,则表示环境变量与参数空间页面已经被占满,容纳不下了.
	if (!sh_bang) {
    da23:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
    da28:	75 44                	jne    da6e <do_execve+0x378>
		p = copy_strings(envc, envp, page, p, 0);
    da2a:	8d 74 24 40          	lea    0x40(%esp),%esi
    da2e:	50                   	push   %eax
    da2f:	50                   	push   %eax
    da30:	6a 00                	push   $0x0
    da32:	ff 74 24 14          	pushl  0x14(%esp)
    da36:	8b 94 24 00 02 00 00 	mov    0x200(%esp),%edx
    da3d:	8b 44 24 14          	mov    0x14(%esp),%eax
    da41:	89 f1                	mov    %esi,%ecx
    da43:	e8 99 fa ff ff       	call   d4e1 <copy_strings>
    da48:	5a                   	pop    %edx
    da49:	59                   	pop    %ecx
		p = copy_strings(argc, argv, page, p, 0);
    da4a:	6a 00                	push   $0x0
    da4c:	50                   	push   %eax
    da4d:	89 f1                	mov    %esi,%ecx
    da4f:	8b 94 24 fc 01 00 00 	mov    0x1fc(%esp),%edx
    da56:	8b 44 24 10          	mov    0x10(%esp),%eax
    da5a:	e8 82 fa ff ff       	call   d4e1 <copy_strings>
    da5f:	83 c4 10             	add    $0x10,%esp
		if (!p) {
    da62:	85 c0                	test   %eax,%eax
		p = copy_strings(argc, argv, page, p, 0);
    da64:	89 44 24 08          	mov    %eax,0x8(%esp)
		if (!p) {
    da68:	0f 84 c2 02 00 00    	je     dd30 <do_execve+0x63a>
	// get_free_page()分配了物理内存页来保存数据,并在chang_ldt()函数中使用put_page()到了进程逻辑空间的末端处.另外,在create_tables()
	// 中也会由于在用户栈上存放参数和环境指针表而引起缺页异常,从而内存管理程序也会就此为用户栈空间映射物理内存页.
	//
	// 这里我们首先放回进程原执行程序的i节点,并且让进程executable字段指向新执行文件的i节点.然后复位原进程的所有信号处理句柄,但对于SIG_IGN
	// 句柄无须复位.
	if (current->executable)
    da6e:	c7 c6 60 23 02 00    	mov    $0x22360,%esi
    da74:	8b 06                	mov    (%esi),%eax
    da76:	8b 80 3c 03 00 00    	mov    0x33c(%eax),%eax
    da7c:	85 c0                	test   %eax,%eax
    da7e:	74 0c                	je     da8c <do_execve+0x396>
		iput(current->executable);
    da80:	83 ec 0c             	sub    $0xc,%esp
    da83:	50                   	push   %eax
    da84:	e8 9f e0 ff ff       	call   bb28 <iput>
    da89:	83 c4 10             	add    $0x10,%esp
	current->executable = inode;
    da8c:	8b 16                	mov    (%esi),%edx
    da8e:	89 aa 3c 03 00 00    	mov    %ebp,0x33c(%edx)
	current->signal = 0;
    da94:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
    da9b:	8d 42 10             	lea    0x10(%edx),%eax
    da9e:	81 c2 10 02 00 00    	add    $0x210,%edx
	for (i = 0 ; i < 32 ; i++) {
		current->sigaction[i].sa_mask = 0;
		current->sigaction[i].sa_flags = 0;
		if (current->sigaction[i].sa_handler != SIG_IGN)
    daa4:	83 38 01             	cmpl   $0x1,(%eax)
		current->sigaction[i].sa_mask = 0;
    daa7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		current->sigaction[i].sa_flags = 0;
    daae:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		if (current->sigaction[i].sa_handler != SIG_IGN)
    dab5:	74 06                	je     dabd <do_execve+0x3c7>
			current->sigaction[i].sa_handler = NULL;
    dab7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    dabd:	83 c0 10             	add    $0x10,%eax
	for (i = 0 ; i < 32 ; i++) {
    dac0:	39 d0                	cmp    %edx,%eax
    dac2:	75 e0                	jne    daa4 <do_execve+0x3ae>
	}
	// 再根据设定的执行时关闭文件句柄(close_on_exec)位图标志,关闭指定的打开文件并复位该标志
	for (i = 0 ; i < NR_OPEN ; i++)
    dac4:	31 ff                	xor    %edi,%edi
		if ((current->close_on_exec >> i) & 1)
    dac6:	8b 06                	mov    (%esi),%eax
    dac8:	8b 80 44 03 00 00    	mov    0x344(%eax),%eax
    dace:	0f a3 f8             	bt     %edi,%eax
    dad1:	73 0c                	jae    dadf <do_execve+0x3e9>
			sys_close(i);
    dad3:	83 ec 0c             	sub    $0xc,%esp
    dad6:	57                   	push   %edi
    dad7:	e8 13 d8 ff ff       	call   b2ef <sys_close>
    dadc:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < NR_OPEN ; i++)
    dadf:	47                   	inc    %edi
    dae0:	83 ff 14             	cmp    $0x14,%edi
    dae3:	75 e1                	jne    dac6 <do_execve+0x3d0>
	current->close_on_exec = 0;
    dae5:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
	// 然后根据当前进程指定的基地址和限长,释放原来程序的代码段和数据段所对应的内存页表指定的物理内存页面及页表本身.此时新执行文件并没有占用主
	// 内存区任何页面,因此在处理器真正运行新执行文件代码时就会引起缺页异常中断,此时内存管理程序即会执行缺页处理页为新执行文件申请内存页面和
	// 设置相关页表项,并且把相关执行文件页面读入内存中.如果"上次任务使用了协处理器"指向的是当前进程,则将其置空,并复位使用了协处理器的标志.
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
    daeb:	b8 0f 00 00 00       	mov    $0xf,%eax
    daf0:	0f 03 c0             	lsl    %ax,%eax
    daf3:	40                   	inc    %eax
	current->close_on_exec = 0;
    daf4:	8b 75 00             	mov    0x0(%ebp),%esi
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
    daf7:	8a b6 a7 03 00 00    	mov    0x3a7(%esi),%dh
    dafd:	8a 96 a4 03 00 00    	mov    0x3a4(%esi),%dl
    db03:	c1 e2 10             	shl    $0x10,%edx
    db06:	66 8b 96 a2 03 00 00 	mov    0x3a2(%esi),%dx
	current->close_on_exec = 0;
    db0d:	c7 86 44 03 00 00 00 	movl   $0x0,0x344(%esi)
    db14:	00 00 00 
	free_page_tables(get_base(current->ldt[1]), get_limit(0x0f));
    db17:	56                   	push   %esi
    db18:	56                   	push   %esi
    db19:	50                   	push   %eax
    db1a:	52                   	push   %edx
    db1b:	e8 9b c4 ff ff       	call   9fbb <free_page_tables>
    db20:	5f                   	pop    %edi
    db21:	58                   	pop    %eax
	free_page_tables(get_base(current->ldt[2]), get_limit(0x17));
    db22:	8b 7d 00             	mov    0x0(%ebp),%edi
    db25:	b8 17 00 00 00       	mov    $0x17,%eax
    db2a:	8a b7 af 03 00 00    	mov    0x3af(%edi),%dh
    db30:	8a 97 ac 03 00 00    	mov    0x3ac(%edi),%dl
    db36:	c1 e2 10             	shl    $0x10,%edx
    db39:	66 8b 97 aa 03 00 00 	mov    0x3aa(%edi),%dx
    db40:	0f 03 c0             	lsl    %ax,%eax
    db43:	40                   	inc    %eax
    db44:	50                   	push   %eax
    db45:	52                   	push   %edx
    db46:	e8 70 c4 ff ff       	call   9fbb <free_page_tables>
	if (last_task_used_math == current)
    db4b:	c7 c2 60 2a 02 00    	mov    $0x22a60,%edx
	free_page_tables(get_base(current->ldt[2]), get_limit(0x17));
    db51:	83 c4 10             	add    $0x10,%esp
	if (last_task_used_math == current)
    db54:	8b 45 00             	mov    0x0(%ebp),%eax
    db57:	39 02                	cmp    %eax,(%edx)
    db59:	75 06                	jne    db61 <do_execve+0x46b>
		last_task_used_math = NULL;
    db5b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	code_base = get_base(current->ldt[1]);
    db61:	8a b0 a7 03 00 00    	mov    0x3a7(%eax),%dh
    db67:	8a 90 a4 03 00 00    	mov    0x3a4(%eax),%dl
    db6d:	c1 e2 10             	shl    $0x10,%edx
    db70:	66 8b 90 a2 03 00 00 	mov    0x3a2(%eax),%dx
	current->used_math = 0;
    db77:	66 c7 80 28 03 00 00 	movw   $0x0,0x328(%eax)
    db7e:	00 00 
	code_base = get_base(current->ldt[1]);
    db80:	89 d6                	mov    %edx,%esi
	set_base(current->ldt[1], code_base);
    db82:	66 89 90 a2 03 00 00 	mov    %dx,0x3a2(%eax)
    db89:	c1 ca 10             	ror    $0x10,%edx
    db8c:	88 90 a4 03 00 00    	mov    %dl,0x3a4(%eax)
    db92:	88 b0 a7 03 00 00    	mov    %dh,0x3a7(%eax)
	set_limit(current->ldt[1], code_limit);
    db98:	b9 ff 3f 00 00       	mov    $0x3fff,%ecx
    db9d:	89 ca                	mov    %ecx,%edx
    db9f:	66 89 90 a0 03 00 00 	mov    %dx,0x3a0(%eax)
    dba6:	c1 ca 10             	ror    $0x10,%edx
    dba9:	8a b0 a6 03 00 00    	mov    0x3a6(%eax),%dh
    dbaf:	80 e6 f0             	and    $0xf0,%dh
    dbb2:	08 f2                	or     %dh,%dl
    dbb4:	88 90 a6 03 00 00    	mov    %dl,0x3a6(%eax)
	set_base(current->ldt[2], data_base);
    dbba:	89 f2                	mov    %esi,%edx
    dbbc:	66 89 90 aa 03 00 00 	mov    %dx,0x3aa(%eax)
    dbc3:	c1 ca 10             	ror    $0x10,%edx
    dbc6:	88 90 ac 03 00 00    	mov    %dl,0x3ac(%eax)
    dbcc:	88 b0 af 03 00 00    	mov    %dh,0x3af(%eax)
	set_limit(current->ldt[2], data_limit);
    dbd2:	89 ca                	mov    %ecx,%edx
    dbd4:	66 89 90 a8 03 00 00 	mov    %dx,0x3a8(%eax)
    dbdb:	c1 ca 10             	ror    $0x10,%edx
    dbde:	8a b0 ae 03 00 00    	mov    0x3ae(%eax),%dh
    dbe4:	80 e6 f0             	and    $0xf0,%dh
    dbe7:	08 f2                	or     %dh,%dl
    dbe9:	88 90 ae 03 00 00    	mov    %dl,0x3ae(%eax)
	__asm__("pushl $0x17\n\tpop %%fs"::);
    dbef:	6a 17                	push   $0x17
    dbf1:	0f a1                	pop    %fs
	for (i = MAX_ARG_PAGES - 1 ; i >= 0 ; i--) {
    dbf3:	bf 1f 00 00 00       	mov    $0x1f,%edi
    dbf8:	89 f8                	mov    %edi,%eax
    dbfa:	c1 e0 0c             	shl    $0xc,%eax
    dbfd:	8d 94 06 00 00 be 03 	lea    0x3be0000(%esi,%eax,1),%edx
		if (page[i])									// 若该页面存在,就放置该页面.
    dc04:	8b 44 bc 40          	mov    0x40(%esp,%edi,4),%eax
    dc08:	85 c0                	test   %eax,%eax
    dc0a:	74 0c                	je     dc18 <do_execve+0x522>
			put_dirty_page(page[i], data_base);
    dc0c:	51                   	push   %ecx
    dc0d:	51                   	push   %ecx
    dc0e:	52                   	push   %edx
    dc0f:	50                   	push   %eax
    dc10:	e8 fd c5 ff ff       	call   a212 <put_dirty_page>
    dc15:	83 c4 10             	add    $0x10,%esp
	for (i = MAX_ARG_PAGES - 1 ; i >= 0 ; i--) {
    dc18:	4f                   	dec    %edi
    dc19:	83 ff ff             	cmp    $0xffffffff,%edi
    dc1c:	75 da                	jne    dbf8 <do_execve+0x502>
	sp -= envc + 1;
    dc1e:	8b 7c 24 04          	mov    0x4(%esp),%edi
	// 然后我们根据新执行文件头结构中的代码长度字段a_text的值修改局部表中描述符基址和段限长,并将128KB的参数和环境空间页面放置在数据段末端.
	// 执行下面语句之后,p此时更改成以数据段起始处为原点的偏移值,但仍指向参数和环境空间数据开始处,即已转换成栈指针值.然后调用内部函数create_tables()
	// 在栈空间中创建环境和参数变量指针表,供程序的main()作为参数使用,并返回该栈指针.
	p += change_ldt(ex.a_text, page);
	p -= LIBRARY_SIZE + MAX_ARG_PAGES * PAGE_SIZE;
	p = (unsigned long) create_tables((char *)p, argc, envc);
    dc22:	8b 44 24 08          	mov    0x8(%esp),%eax
	sp -= envc + 1;
    dc26:	8d 4f 01             	lea    0x1(%edi),%ecx
	p = (unsigned long) create_tables((char *)p, argc, envc);
    dc29:	05 00 00 be 03       	add    $0x3be0000,%eax
	sp = (unsigned long *) (0xfffffffc & (unsigned long) p);
    dc2e:	89 c3                	mov    %eax,%ebx
	sp -= envc + 1;
    dc30:	6b d1 fc             	imul   $0xfffffffc,%ecx,%edx
	sp = (unsigned long *) (0xfffffffc & (unsigned long) p);
    dc33:	83 e3 fc             	and    $0xfffffffc,%ebx
	sp -= envc + 1;
    dc36:	8d 0c 13             	lea    (%ebx,%edx,1),%ecx
	sp -= argc + 1;
    dc39:	8b 1c 24             	mov    (%esp),%ebx
    dc3c:	8d 53 01             	lea    0x1(%ebx),%edx
    dc3f:	89 5c 24 10          	mov    %ebx,0x10(%esp)
    dc43:	6b d2 fc             	imul   $0xfffffffc,%edx,%edx
    dc46:	01 ca                	add    %ecx,%edx
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    dc48:	64 89 4a fc          	mov    %ecx,%fs:-0x4(%edx)
    dc4c:	64 89 52 f8          	mov    %edx,%fs:-0x8(%edx)
	put_fs_long((unsigned long)argc, --sp);
    dc50:	8d 5a f4             	lea    -0xc(%edx),%ebx
    dc53:	89 5c 24 08          	mov    %ebx,0x8(%esp)
    dc57:	8b 1c 24             	mov    (%esp),%ebx
    dc5a:	64 89 5a f4          	mov    %ebx,%fs:-0xc(%edx)
	argv = sp;
    dc5e:	89 d3                	mov    %edx,%ebx
	while (argc-- > 0) {
    dc60:	ff 0c 24             	decl   (%esp)
    dc63:	83 3c 24 ff          	cmpl   $0xffffffff,(%esp)
    dc67:	74 1d                	je     dc86 <do_execve+0x590>
		put_fs_long((unsigned long) p, argv++);
    dc69:	8d 73 04             	lea    0x4(%ebx),%esi
    dc6c:	64 89 03             	mov    %eax,%fs:(%ebx)
    dc6f:	89 c3                	mov    %eax,%ebx
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    dc71:	64 8a 1b             	mov    %fs:(%ebx),%bl
		while (get_fs_byte(p++)) /* nothing */ ;	// p指针指向下一个参数串.
    dc74:	40                   	inc    %eax
    dc75:	88 5c 24 28          	mov    %bl,0x28(%esp)
    dc79:	80 7c 24 28 00       	cmpb   $0x0,0x28(%esp)
    dc7e:	89 c3                	mov    %eax,%ebx
    dc80:	75 ef                	jne    dc71 <do_execve+0x57b>
		put_fs_long((unsigned long) p, argv++);
    dc82:	89 f3                	mov    %esi,%ebx
    dc84:	eb da                	jmp    dc60 <do_execve+0x56a>
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    dc86:	31 db                	xor    %ebx,%ebx
    dc88:	8b 74 24 10          	mov    0x10(%esp),%esi
    dc8c:	64 89 1c b2          	mov    %ebx,%fs:(%edx,%esi,4)
	envp = sp;
    dc90:	89 ca                	mov    %ecx,%edx
	while (envc-- > 0) {
    dc92:	ff 4c 24 04          	decl   0x4(%esp)
    dc96:	83 7c 24 04 ff       	cmpl   $0xffffffff,0x4(%esp)
    dc9b:	74 16                	je     dcb3 <do_execve+0x5bd>
		put_fs_long((unsigned long) p, envp++);
    dc9d:	8d 72 04             	lea    0x4(%edx),%esi
    dca0:	64 89 02             	mov    %eax,%fs:(%edx)
    dca3:	89 c2                	mov    %eax,%edx
		while (get_fs_byte(p++)) /* nothing */ ;	// p指针指向下一个参数串.
    dca5:	40                   	inc    %eax
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    dca6:	64 8a 1a             	mov    %fs:(%edx),%bl
    dca9:	84 db                	test   %bl,%bl
    dcab:	89 c2                	mov    %eax,%edx
    dcad:	75 f6                	jne    dca5 <do_execve+0x5af>
		put_fs_long((unsigned long) p, envp++);
    dcaf:	89 f2                	mov    %esi,%edx
    dcb1:	eb df                	jmp    dc92 <do_execve+0x59c>
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    dcb3:	31 c0                	xor    %eax,%eax
    dcb5:	64 89 04 b9          	mov    %eax,%fs:(%ecx,%edi,4)
	// 执行文件的代码段长度加数据段长度(a_data + a_text);并令进程堆结尾字段brk = a_text + a_data + a_bss.brk用于指明进程当前数据段
	// (包括未初始化数据部分)末端位置,供内核为进程分配内存时指定分配开始位置.然后设置进程栈开始字段为栈指针所在页面,并重新设置进程的有效用户
	// id和有效组id.
	current->brk = ex.a_bss +
		(current->end_data = ex.a_data +
		(current->end_code = ex.a_text));
    dcb9:	8b 45 00             	mov    0x0(%ebp),%eax
		(current->end_data = ex.a_data +
    dcbc:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
	current->sgid = current->egid = e_gid;
	// 最后将原调用系统中断的程序在堆栈上的代码指针替换为指向新执行程序的入口点,并将栈指针替换为新执行文件的栈指针.此后返回指令将弹出这些栈数
	// 据并使得CPU去执行新执行文件,因此不会返回到原调用系统中断的程序中去了.
	eip[0] = ex.a_entry;												/* eip, magic happens :-) */	/* eip,魔法起作用了 */
	eip[3] = p;															/* stack pointer */		/* esp,堆栈指针 */
	return 0;
    dcc0:	31 f6                	xor    %esi,%esi
		(current->end_code = ex.a_text));
    dcc2:	8b 7c 24 20          	mov    0x20(%esp),%edi
	current->start_stack = p & 0xfffff000;
    dcc6:	8b 54 24 08          	mov    0x8(%esp),%edx
		(current->end_data = ex.a_data +
    dcca:	89 88 20 02 00 00    	mov    %ecx,0x220(%eax)
	current->suid = current->euid = e_uid;
    dcd0:	8b 4c 24 14          	mov    0x14(%esp),%ecx
		(current->end_code = ex.a_text));
    dcd4:	89 b8 1c 02 00 00    	mov    %edi,0x21c(%eax)
	current->brk = ex.a_bss +
    dcda:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
	current->start_stack = p & 0xfffff000;
    dcde:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
    dce4:	89 90 28 02 00 00    	mov    %edx,0x228(%eax)
	current->suid = current->euid = e_uid;
    dcea:	66 89 88 ce 02 00 00 	mov    %cx,0x2ce(%eax)
    dcf1:	66 89 88 d0 02 00 00 	mov    %cx,0x2d0(%eax)
	current->sgid = current->egid = e_gid;
    dcf8:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	current->brk = ex.a_bss +
    dcfc:	89 b8 24 02 00 00    	mov    %edi,0x224(%eax)
	eip[0] = ex.a_entry;												/* eip, magic happens :-) */	/* eip,魔法起作用了 */
    dd02:	8b 7c 24 24          	mov    0x24(%esp),%edi
	current->sgid = current->egid = e_gid;
    dd06:	66 89 88 d4 02 00 00 	mov    %cx,0x2d4(%eax)
    dd0d:	66 89 88 d6 02 00 00 	mov    %cx,0x2d6(%eax)
	eip[0] = ex.a_entry;												/* eip, magic happens :-) */	/* eip,魔法起作用了 */
    dd14:	8b 84 24 e0 01 00 00 	mov    0x1e0(%esp),%eax
	eip[3] = p;															/* stack pointer */		/* esp,堆栈指针 */
    dd1b:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	eip[0] = ex.a_entry;												/* eip, magic happens :-) */	/* eip,魔法起作用了 */
    dd1f:	89 38                	mov    %edi,(%eax)
	eip[3] = p;															/* stack pointer */		/* esp,堆栈指针 */
    dd21:	89 48 0c             	mov    %ecx,0xc(%eax)
	return 0;
    dd24:	e9 75 01 00 00       	jmp    de9e <do_execve+0x7a8>
		retval = -EACCES;
    dd29:	be f3 ff ff ff       	mov    $0xfffffff3,%esi
    dd2e:	eb 05                	jmp    dd35 <do_execve+0x63f>
			retval = -ENOMEM;
    dd30:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
exec_error2:
	iput(inode);														// 放回i节点.
    dd35:	83 ec 0c             	sub    $0xc,%esp
    dd38:	55                   	push   %ebp
    dd39:	e8 ea dd ff ff       	call   bb28 <iput>
    dd3e:	83 c4 10             	add    $0x10,%esp
exec_error1:
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)
    dd41:	31 ff                	xor    %edi,%edi
		free_page(page[i]);												// 释放存放参数和环境串的内存页面.
    dd43:	83 ec 0c             	sub    $0xc,%esp
    dd46:	ff 74 bc 4c          	pushl  0x4c(%esp,%edi,4)
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)
    dd4a:	47                   	inc    %edi
		free_page(page[i]);												// 释放存放参数和环境串的内存页面.
    dd4b:	e8 03 c2 ff ff       	call   9f53 <free_page>
    dd50:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < MAX_ARG_PAGES ; i++)
    dd53:	83 ff 20             	cmp    $0x20,%edi
    dd56:	75 eb                	jne    dd43 <do_execve+0x64d>
    dd58:	e9 41 01 00 00       	jmp    de9e <do_execve+0x7a8>
		if (!cp || *cp == '\0') {       							// 若该行没有其他内容，则出错。
    dd5d:	84 d2                	test   %dl,%dl
    dd5f:	0f 84 16 fc ff ff    	je     d97b <do_execve+0x285>
		interp = i_name = cp;
    dd65:	89 6c 24 38          	mov    %ebp,0x38(%esp)
		i_arg = 0;
    dd69:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
    dd70:	00 
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
    dd71:	89 ee                	mov    %ebp,%esi
    dd73:	89 ea                	mov    %ebp,%edx
    dd75:	8a 0a                	mov    (%edx),%cl
    dd77:	f6 c1 df             	test   $0xdf,%cl
    dd7a:	74 21                	je     dd9d <do_execve+0x6a7>
    dd7c:	80 f9 09             	cmp    $0x9,%cl
    dd7f:	8d 7a 01             	lea    0x1(%edx),%edi
    dd82:	74 0f                	je     dd93 <do_execve+0x69d>
				i_name = cp+1;
    dd84:	80 f9 2f             	cmp    $0x2f,%cl
    dd87:	b1 01                	mov    $0x1,%cl
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
    dd89:	89 fa                	mov    %edi,%edx
				i_name = cp+1;
    dd8b:	0f 44 f7             	cmove  %edi,%esi
    dd8e:	0f 44 c1             	cmove  %ecx,%eax
    dd91:	eb e2                	jmp    dd75 <do_execve+0x67f>
    dd93:	84 c0                	test   %al,%al
    dd95:	74 12                	je     dda9 <do_execve+0x6b3>
    dd97:	89 74 24 38          	mov    %esi,0x38(%esp)
    dd9b:	eb 0c                	jmp    dda9 <do_execve+0x6b3>
    dd9d:	84 c0                	test   %al,%al
    dd9f:	74 04                	je     dda5 <do_execve+0x6af>
    dda1:	89 74 24 38          	mov    %esi,0x38(%esp)
		if (*cp) {
    dda5:	84 c9                	test   %cl,%cl
    dda7:	74 08                	je     ddb1 <do_execve+0x6bb>
			*cp++ = '\0';           								// 解释程序名尾添加NULL字符。
    dda9:	c6 02 00             	movb   $0x0,(%edx)
    ddac:	42                   	inc    %edx
    ddad:	89 54 24 3c          	mov    %edx,0x3c(%esp)
			p = copy_strings(envc, envp, page, p, 0);
    ddb1:	8d 74 24 40          	lea    0x40(%esp),%esi
    ddb5:	50                   	push   %eax
    ddb6:	50                   	push   %eax
    ddb7:	6a 00                	push   $0x0
    ddb9:	ff 74 24 14          	pushl  0x14(%esp)
    ddbd:	8b 94 24 00 02 00 00 	mov    0x200(%esp),%edx
    ddc4:	8b 44 24 14          	mov    0x14(%esp),%eax
    ddc8:	89 f1                	mov    %esi,%ecx
    ddca:	e8 12 f7 ff ff       	call   d4e1 <copy_strings>
    ddcf:	5a                   	pop    %edx
    ddd0:	59                   	pop    %ecx
			p = copy_strings(--argc, argv + 1, page, p, 0);
    ddd1:	8b bc 24 f4 01 00 00 	mov    0x1f4(%esp),%edi
    ddd8:	89 f1                	mov    %esi,%ecx
    ddda:	8d 57 04             	lea    0x4(%edi),%edx
    dddd:	8b 7c 24 08          	mov    0x8(%esp),%edi
    dde1:	6a 00                	push   $0x0
    dde3:	50                   	push   %eax
    dde4:	4f                   	dec    %edi
    dde5:	89 f8                	mov    %edi,%eax
    dde7:	e8 f5 f6 ff ff       	call   d4e1 <copy_strings>
    ddec:	83 c4 10             	add    $0x10,%esp
		p = copy_strings(1, &filename, page, p, 1);
    ddef:	89 f1                	mov    %esi,%ecx
    ddf1:	8d 94 24 e8 01 00 00 	lea    0x1e8(%esp),%edx
    ddf8:	57                   	push   %edi
    ddf9:	57                   	push   %edi
    ddfa:	6a 01                	push   $0x1
    ddfc:	50                   	push   %eax
    ddfd:	b8 01 00 00 00       	mov    $0x1,%eax
    de02:	e8 da f6 ff ff       	call   d4e1 <copy_strings>
    de07:	83 c4 10             	add    $0x10,%esp
		if (i_arg) {            									// 复制解释程序的多个参数。
    de0a:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
    de0f:	74 1b                	je     de2c <do_execve+0x736>
    de11:	ff 04 24             	incl   (%esp)
			p = copy_strings(1, &i_arg, page, p, 2);
    de14:	8d 54 24 3c          	lea    0x3c(%esp),%edx
    de18:	57                   	push   %edi
    de19:	57                   	push   %edi
    de1a:	6a 02                	push   $0x2
    de1c:	89 f1                	mov    %esi,%ecx
    de1e:	50                   	push   %eax
    de1f:	b8 01 00 00 00       	mov    $0x1,%eax
    de24:	e8 b8 f6 ff ff       	call   d4e1 <copy_strings>
    de29:	83 c4 10             	add    $0x10,%esp
		p = copy_strings(1, &i_name, page, p, 2);
    de2c:	8d 4c 24 40          	lea    0x40(%esp),%ecx
    de30:	8d 54 24 38          	lea    0x38(%esp),%edx
    de34:	56                   	push   %esi
    de35:	56                   	push   %esi
    de36:	6a 02                	push   $0x2
    de38:	50                   	push   %eax
    de39:	b8 01 00 00 00       	mov    $0x1,%eax
    de3e:	e8 9e f6 ff ff       	call   d4e1 <copy_strings>
    de43:	83 c4 10             	add    $0x10,%esp
		if (!p) {
    de46:	85 c0                	test   %eax,%eax
		p = copy_strings(1, &i_name, page, p, 2);
    de48:	89 44 24 08          	mov    %eax,0x8(%esp)
		if (!p) {
    de4c:	74 46                	je     de94 <do_execve+0x79e>
	__asm__("mov %%fs,%%ax":"=a" (_v):);
    de4e:	66 8c e0             	mov    %fs,%ax
    de51:	89 c6                	mov    %eax,%esi
	__asm__("mov %%ds,%%ax":"=a" (_v):);
    de53:	66 8c d8             	mov    %ds,%ax
	__asm__("mov %0,%%fs"::"a" ((unsigned short) val));
    de56:	8e e0                	mov    %eax,%fs
		if (!(inode = namei(interp))) { 						/* get executables inode */
    de58:	83 ec 0c             	sub    $0xc,%esp
    de5b:	55                   	push   %ebp
    de5c:	e8 d7 0a 00 00       	call   e938 <namei>
    de61:	83 c4 10             	add    $0x10,%esp
    de64:	85 c0                	test   %eax,%eax
    de66:	89 c5                	mov    %eax,%ebp
    de68:	75 0e                	jne    de78 <do_execve+0x782>
    de6a:	89 f0                	mov    %esi,%eax
    de6c:	8e e0                	mov    %eax,%fs
			retval = -ENOENT;
    de6e:	be fe ff ff ff       	mov    $0xfffffffe,%esi
			goto exec_error1;
    de73:	e9 c9 fe ff ff       	jmp    dd41 <do_execve+0x64b>
		argc++;
    de78:	ff 04 24             	incl   (%esp)
    de7b:	89 f0                	mov    %esi,%eax
    de7d:	8e e0                	mov    %eax,%fs
		if (sh_bang++ == 0) {
    de7f:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
    de86:	00 
    de87:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
    de8e:	00 
    de8f:	e9 9b f9 ff ff       	jmp    d82f <do_execve+0x139>
			retval = -ENOMEM;
    de94:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
    de99:	e9 a3 fe ff ff       	jmp    dd41 <do_execve+0x64b>
	return(retval);														// 返回出错码.
}
    de9e:	81 c4 cc 01 00 00    	add    $0x1cc,%esp
    dea4:	89 f0                	mov    %esi,%eax
    dea6:	5b                   	pop    %ebx
    dea7:	5e                   	pop    %esi
    dea8:	5f                   	pop    %edi
    dea9:	5d                   	pop    %ebp
    deaa:	c3                   	ret    

0000deab <read_pipe>:
#include <linux/kernel.h>

// 读管道操作函数。
// 参数inode是管道对应的i节点，buf是用户数据缓冲区指针，count是读取的字节数。
int read_pipe(struct m_inode * inode, char * buf, int count)
{
    deab:	55                   	push   %ebp
    deac:	57                   	push   %edi
	int chars, size, read = 0;
    dead:	31 ed                	xor    %ebp,%ebp
{
    deaf:	56                   	push   %esi
    deb0:	53                   	push   %ebx
    deb1:	e8 76 8b ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    deb6:	81 c3 4a 31 01 00    	add    $0x1314a,%ebx
    debc:	83 ec 1c             	sub    $0x1c,%esp
		while (!(size = PIPE_SIZE(*inode))) {     						// 取管道中数据长度值。
			// 唤醒等待向该管道写数据的进程
			wake_up(& PIPE_WRITE_WAIT(*inode));
			if (inode->i_count != 2) 									/* are there any writers? */
				return read;
			if (current->signal & ~current->blocked)
    debf:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
{
    dec5:	8b 74 24 30          	mov    0x30(%esp),%esi
			if (current->signal & ~current->blocked)
    dec9:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (count > 0) {
    decd:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
    ded2:	0f 8e cc 00 00 00    	jle    dfa4 <read_pipe+0xf9>
		while (!(size = PIPE_SIZE(*inode))) {     						// 取管道中数据长度值。
    ded8:	8b 56 10             	mov    0x10(%esi),%edx
    dedb:	66 8b 46 0e          	mov    0xe(%esi),%ax
    dedf:	8d 4e 24             	lea    0x24(%esi),%ecx
    dee2:	29 d0                	sub    %edx,%eax
    dee4:	66 25 ff 0f          	and    $0xfff,%ax
    dee8:	75 4d                	jne    df37 <read_pipe+0x8c>
			wake_up(& PIPE_WRITE_WAIT(*inode));
    deea:	83 ec 0c             	sub    $0xc,%esp
    deed:	51                   	push   %ecx
    deee:	e8 a0 8f ff ff       	call   6e93 <wake_up>
    def3:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) 									/* are there any writers? */
    def6:	66 83 7e 34 02       	cmpw   $0x2,0x34(%esi)
    defb:	0f 85 b2 00 00 00    	jne    dfb3 <read_pipe+0x108>
			if (current->signal & ~current->blocked)
    df01:	8b 44 24 0c          	mov    0xc(%esp),%eax
    df05:	8b 10                	mov    (%eax),%edx
    df07:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
    df0d:	f7 d0                	not    %eax
    df0f:	85 42 0c             	test   %eax,0xc(%edx)
    df12:	74 12                	je     df26 <read_pipe+0x7b>
				return read ? read : -ERESTARTSYS;
    df14:	85 ed                	test   %ebp,%ebp
    df16:	0f 85 97 00 00 00    	jne    dfb3 <read_pipe+0x108>
    df1c:	bd 00 fe ff ff       	mov    $0xfffffe00,%ebp
    df21:	e9 8d 00 00 00       	jmp    dfb3 <read_pipe+0x108>
			// 当前进程没有数据可读则进入睡眠等待
			interruptible_sleep_on(& PIPE_READ_WAIT(*inode));
    df26:	8d 46 20             	lea    0x20(%esi),%eax
    df29:	83 ec 0c             	sub    $0xc,%esp
    df2c:	50                   	push   %eax
    df2d:	e8 45 8f ff ff       	call   6e77 <interruptible_sleep_on>
    df32:	83 c4 10             	add    $0x10,%esp
    df35:	eb a1                	jmp    ded8 <read_pipe+0x2d>
		}
		// 此时说明管道（缓冲区）中有数据。于是我们取管道尾指针到缓冲区末端的字节数chars。如果其大于还需要读取的字节数
		// count，则令其等于count。如果chars大于当前管道中含有数据的长度size，则令其等于size。然后把需读字节数count
		// 减去可读的字节数chars，并累加已读字节数read。
		chars = PAGE_SIZE - PIPE_TAIL(*inode);
    df37:	0f b7 ca             	movzwl %dx,%ecx
    df3a:	bf 00 10 00 00       	mov    $0x1000,%edi
		while (!(size = PIPE_SIZE(*inode))) {     						// 取管道中数据长度值。
    df3f:	0f b7 c0             	movzwl %ax,%eax
		chars = PAGE_SIZE - PIPE_TAIL(*inode);
    df42:	29 cf                	sub    %ecx,%edi
    df44:	3b 44 24 38          	cmp    0x38(%esp),%eax
		// 数据复制到用户缓冲区中。对于管道i节点，其i_size字段中是管道缓冲块指针。
		size = PIPE_TAIL(*inode);
		PIPE_TAIL(*inode) += chars;
		PIPE_TAIL(*inode) &= (PAGE_SIZE - 1);
		while (chars-- > 0)
			put_fs_byte(((char *)inode->i_size)[size++], buf++);
    df48:	89 4c 24 08          	mov    %ecx,0x8(%esp)
    df4c:	0f 4f 44 24 38       	cmovg  0x38(%esp),%eax
    df51:	39 f8                	cmp    %edi,%eax
    df53:	0f 4f c7             	cmovg  %edi,%eax
		count -= chars;
    df56:	29 44 24 38          	sub    %eax,0x38(%esp)
		PIPE_TAIL(*inode) += chars;
    df5a:	01 c2                	add    %eax,%edx
		read += chars;
    df5c:	01 c5                	add    %eax,%ebp
		PIPE_TAIL(*inode) &= (PAGE_SIZE - 1);
    df5e:	66 81 e2 ff 0f       	and    $0xfff,%dx
    df63:	66 89 56 10          	mov    %dx,0x10(%esi)
		while (chars-- > 0)
    df67:	31 d2                	xor    %edx,%edx
    df69:	8b 4c 24 34          	mov    0x34(%esp),%ecx
    df6d:	89 c7                	mov    %eax,%edi
    df6f:	29 d7                	sub    %edx,%edi
    df71:	01 d1                	add    %edx,%ecx
    df73:	85 ff                	test   %edi,%edi
    df75:	89 4c 24 04          	mov    %ecx,0x4(%esp)
    df79:	7e 16                	jle    df91 <read_pipe+0xe6>
			put_fs_byte(((char *)inode->i_size)[size++], buf++);
    df7b:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    df7f:	8d 3c 0a             	lea    (%edx,%ecx,1),%edi
    df82:	03 7e 04             	add    0x4(%esi),%edi
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
    df85:	8a 0f                	mov    (%edi),%cl
    df87:	8b 7c 24 04          	mov    0x4(%esp),%edi
    df8b:	64 88 0f             	mov    %cl,%fs:(%edi)
    df8e:	42                   	inc    %edx
    df8f:	eb d8                	jmp    df69 <read_pipe+0xbe>
    df91:	85 c0                	test   %eax,%eax
    df93:	ba 00 00 00 00       	mov    $0x0,%edx
    df98:	0f 48 c2             	cmovs  %edx,%eax
    df9b:	01 44 24 34          	add    %eax,0x34(%esp)
    df9f:	e9 29 ff ff ff       	jmp    decd <read_pipe+0x22>
	}
	// 当此次读管道操作结束，则唤醒等待该管道的进程，并返回读取的字节数。
	wake_up(& PIPE_WRITE_WAIT(*inode));
    dfa4:	83 ec 0c             	sub    $0xc,%esp
    dfa7:	83 c6 24             	add    $0x24,%esi
    dfaa:	56                   	push   %esi
    dfab:	e8 e3 8e ff ff       	call   6e93 <wake_up>
    dfb0:	83 c4 10             	add    $0x10,%esp
	return read;
}
    dfb3:	83 c4 1c             	add    $0x1c,%esp
    dfb6:	89 e8                	mov    %ebp,%eax
    dfb8:	5b                   	pop    %ebx
    dfb9:	5e                   	pop    %esi
    dfba:	5f                   	pop    %edi
    dfbb:	5d                   	pop    %ebp
    dfbc:	c3                   	ret    

0000dfbd <write_pipe>:

// 管道写操作函数。
// 参数inode是管道对应的i节点，buf是数据缓冲区指针，count是将写入管道的字节数。
int write_pipe(struct m_inode * inode, char * buf, int count)
{
    dfbd:	55                   	push   %ebp
    dfbe:	57                   	push   %edi
	int chars, size, written = 0;
    dfbf:	31 ff                	xor    %edi,%edi
{
    dfc1:	56                   	push   %esi
    dfc2:	53                   	push   %ebx
    dfc3:	e8 64 8a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    dfc8:	81 c3 38 30 01 00    	add    $0x13038,%ebx
    dfce:	83 ec 1c             	sub    $0x1c,%esp
    dfd1:	8b 74 24 30          	mov    0x30(%esp),%esi

	// 如果要写入的字节数count还大于0,那么我们就循环执行以下操作。在循环操作过程中，如果当前管道中已经满了（空闲空间
	// size = 0），则唤醒等待该管道的进程，通常唤醒的是读管道进程。如果已经没有读管道者，即i节点引用计数值小于2,则向
	// 当前进程发送SIGPIPE信号，并返回已写入的字节数退出；若写入0字节，则返回-1。否则让当前进程在该管道上睡眠，以等待
	// 读管道进程来读取数据，从而让管道腾出空间。宏PIPE_SIZE()、PIPE_HEAD()等定义在文件include/linux/fs.h中。
	while (count > 0) {
    dfd5:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
    dfda:	0f 8e cf 00 00 00    	jle    e0af <write_pipe+0xf2>
		while (!(size = (PAGE_SIZE - 1) - PIPE_SIZE(*inode))) {
    dfe0:	66 8b 46 0e          	mov    0xe(%esi),%ax
    dfe4:	8d 4e 20             	lea    0x20(%esi),%ecx
    dfe7:	89 c2                	mov    %eax,%edx
    dfe9:	2b 56 10             	sub    0x10(%esi),%edx
    dfec:	f7 d2                	not    %edx
    dfee:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
    dff4:	75 43                	jne    e039 <write_pipe+0x7c>
			wake_up(& PIPE_READ_WAIT(*inode));
    dff6:	83 ec 0c             	sub    $0xc,%esp
    dff9:	51                   	push   %ecx
    dffa:	e8 94 8e ff ff       	call   6e93 <wake_up>
    dfff:	83 c4 10             	add    $0x10,%esp
			if (inode->i_count != 2) { 								/* no readers */
    e002:	66 83 7e 34 02       	cmpw   $0x2,0x34(%esi)
    e007:	74 1f                	je     e028 <write_pipe+0x6b>
				current->signal |= (1 << (SIGPIPE - 1));
    e009:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    e00f:	8b 00                	mov    (%eax),%eax
    e011:	81 48 0c 00 10 00 00 	orl    $0x1000,0xc(%eax)
				return written ? written : -1;
    e018:	85 ff                	test   %edi,%edi
    e01a:	0f 85 9e 00 00 00    	jne    e0be <write_pipe+0x101>
    e020:	83 cf ff             	or     $0xffffffff,%edi
    e023:	e9 96 00 00 00       	jmp    e0be <write_pipe+0x101>
			}
			sleep_on(& PIPE_WRITE_WAIT(*inode));
    e028:	8d 46 24             	lea    0x24(%esi),%eax
    e02b:	83 ec 0c             	sub    $0xc,%esp
    e02e:	50                   	push   %eax
    e02f:	e8 51 8e ff ff       	call   6e85 <sleep_on>
    e034:	83 c4 10             	add    $0x10,%esp
    e037:	eb a7                	jmp    dfe0 <write_pipe+0x23>
		}
		// 程序执行到这里表示管道缓冲区中有可写空间size。于是我们取管道头指针到缓冲区末端空间字节数chars。写管道操作是从管道
		// 头指针处开始写的。如果chars大于还需要写入的字节数count，则令其等于count。如果chars大于当前管道中空闲空间长度size
		// 则令其等于size。然后把需要写入字节数count减去此次可写入的字节数chars，并把写入字节数累加到written中。
		chars = PAGE_SIZE - PIPE_HEAD(*inode);
    e039:	0f b7 c8             	movzwl %ax,%ecx
    e03c:	bd 00 10 00 00       	mov    $0x1000,%ebp
		// 再令size指向管道数据头指针处，并调整当前管道数据头部指针（前移chars字节）。若头指针超过管道末端则绕回。然后从用户缓冲
		// 区复制chars个字节到管道头指针开始处。对于管道i节点，其i_size字段中是管道缓冲块指针。
		size = PIPE_HEAD(*inode);
		PIPE_HEAD(*inode) += chars;
		PIPE_HEAD(*inode) &= (PAGE_SIZE - 1);
		while (chars-- > 0)
    e041:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    e048:	00 
		chars = PAGE_SIZE - PIPE_HEAD(*inode);
    e049:	29 cd                	sub    %ecx,%ebp
    e04b:	39 54 24 38          	cmp    %edx,0x38(%esp)
			((char *)inode->i_size)[size++] = get_fs_byte(buf++);
    e04f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    e053:	0f 4e 54 24 38       	cmovle 0x38(%esp),%edx
    e058:	39 ea                	cmp    %ebp,%edx
    e05a:	0f 4f d5             	cmovg  %ebp,%edx
		count -= chars;
    e05d:	29 54 24 38          	sub    %edx,0x38(%esp)
		PIPE_HEAD(*inode) += chars;
    e061:	01 d0                	add    %edx,%eax
		written += chars;
    e063:	01 d7                	add    %edx,%edi
		PIPE_HEAD(*inode) &= (PAGE_SIZE - 1);
    e065:	66 25 ff 0f          	and    $0xfff,%ax
    e069:	66 89 46 0e          	mov    %ax,0xe(%esi)
    e06d:	89 d1                	mov    %edx,%ecx
    e06f:	2b 4c 24 08          	sub    0x8(%esp),%ecx
    e073:	8b 6c 24 08          	mov    0x8(%esp),%ebp
    e077:	03 6c 24 34          	add    0x34(%esp),%ebp
		while (chars-- > 0)
    e07b:	85 c9                	test   %ecx,%ecx
    e07d:	7e 1d                	jle    e09c <write_pipe+0xdf>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    e07f:	64 8a 4d 00          	mov    %fs:0x0(%ebp),%cl
			((char *)inode->i_size)[size++] = get_fs_byte(buf++);
    e083:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e087:	89 cd                	mov    %ecx,%ebp
    e089:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    e08d:	ff 44 24 08          	incl   0x8(%esp)
    e091:	01 c1                	add    %eax,%ecx
    e093:	03 4e 04             	add    0x4(%esi),%ecx
    e096:	89 e8                	mov    %ebp,%eax
    e098:	88 01                	mov    %al,(%ecx)
    e09a:	eb d1                	jmp    e06d <write_pipe+0xb0>
    e09c:	85 d2                	test   %edx,%edx
    e09e:	b8 00 00 00 00       	mov    $0x0,%eax
    e0a3:	0f 48 d0             	cmovs  %eax,%edx
    e0a6:	01 54 24 34          	add    %edx,0x34(%esp)
    e0aa:	e9 26 ff ff ff       	jmp    dfd5 <write_pipe+0x18>
	}
	// 当此次写管道操作结束，则唤醒等待管道的进程，返回已写入的字节数，退出。
	wake_up(& PIPE_READ_WAIT(*inode));
    e0af:	83 ec 0c             	sub    $0xc,%esp
    e0b2:	83 c6 20             	add    $0x20,%esi
    e0b5:	56                   	push   %esi
    e0b6:	e8 d8 8d ff ff       	call   6e93 <wake_up>
    e0bb:	83 c4 10             	add    $0x10,%esp
	return written;
}
    e0be:	83 c4 1c             	add    $0x1c,%esp
    e0c1:	89 f8                	mov    %edi,%eax
    e0c3:	5b                   	pop    %ebx
    e0c4:	5e                   	pop    %esi
    e0c5:	5f                   	pop    %edi
    e0c6:	5d                   	pop    %ebp
    e0c7:	c3                   	ret    

0000e0c8 <sys_pipe>:
// 创建管道系统调用。
// 在fildes所指的数组中创建一对句柄（描述符）。这对文件句柄指向一管道i节点。
// 参数：fildes - 文件句柄数组。fildes[0]用于读管道数据，fildes[1]向管道写入数据。
// 成功时返回0,出错时返回-1.
int sys_pipe(unsigned long * fildes)
{
    e0c8:	55                   	push   %ebp
    e0c9:	57                   	push   %edi
	int fd[2];                      						// 文件句柄数组。
	int i, j;

	// 首先从系统文件表中取两个空闲项（引用计数字段为0的项），并分别设置引用计数为1.
	// 若只有1个空闲项，则释放该项（引用计数复位）。若没有找到两个空闲项，则返回-1。
	j = 0;
    e0ca:	31 c0                	xor    %eax,%eax
{
    e0cc:	56                   	push   %esi
    e0cd:	53                   	push   %ebx
	for(i = 0; j < 2 && i < NR_FILE; i++)
    e0ce:	31 c9                	xor    %ecx,%ecx
    e0d0:	e8 57 89 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e0d5:	81 c3 2b 2f 01 00    	add    $0x12f2b,%ebx
{
    e0db:	83 ec 1c             	sub    $0x1c,%esp
    e0de:	c7 c2 60 4e 03 00    	mov    $0x34e60,%edx
	for(i = 0; j < 2 && i < NR_FILE; i++)
    e0e4:	83 f8 01             	cmp    $0x1,%eax
    e0e7:	7f 1c                	jg     e105 <sys_pipe+0x3d>
    e0e9:	83 f9 3f             	cmp    $0x3f,%ecx
    e0ec:	7f 17                	jg     e105 <sys_pipe+0x3d>
		if (!file_table[i].f_count)
    e0ee:	66 83 7a 04 00       	cmpw   $0x0,0x4(%edx)
    e0f3:	75 0a                	jne    e0ff <sys_pipe+0x37>
			(f[j++] = i + file_table)->f_count++;
    e0f5:	89 14 84             	mov    %edx,(%esp,%eax,4)
    e0f8:	66 c7 42 04 01 00    	movw   $0x1,0x4(%edx)
    e0fe:	40                   	inc    %eax
	for(i = 0; j < 2 && i < NR_FILE; i++)
    e0ff:	41                   	inc    %ecx
    e100:	83 c2 10             	add    $0x10,%edx
    e103:	eb df                	jmp    e0e4 <sys_pipe+0x1c>
	if (j == 1)
    e105:	48                   	dec    %eax
    e106:	75 0b                	jne    e113 <sys_pipe+0x4b>
		f[0]->f_count = 0;
    e108:	8b 04 24             	mov    (%esp),%eax
    e10b:	66 c7 40 04 00 00    	movw   $0x0,0x4(%eax)
    e111:	eb 66                	jmp    e179 <sys_pipe+0xb1>
	if (j < 2)
		return -1;
    e113:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	if (j < 2)
    e118:	0f 8e b7 00 00 00    	jle    e1d5 <sys_pipe+0x10d>
	// 针对上面取得的两个文件表结构项，分别分配一文件句柄号，并使进程文件结构指针数组的两项分别指向这两个文件
	// 结构。而文件句柄即是该数组的索引号。类似地，如果只有一个空闲文件句柄，则释放该句柄（置空相应数组项）。如
	// 果没有找到两个空闲句柄，则释放上面获取的两个文件结构项（复位引用计数值），并返回-1。
	j = 0;
	for(i = 0; j < 2 && i < NR_OPEN; i++)
		if (!current->filp[i]) {
    e11e:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
	j = 0;
    e124:	31 c0                	xor    %eax,%eax
	for(i = 0; j < 2 && i < NR_OPEN; i++)
    e126:	31 f6                	xor    %esi,%esi
		if (!current->filp[i]) {
    e128:	8b 0f                	mov    (%edi),%ecx
	for(i = 0; j < 2 && i < NR_OPEN; i++)
    e12a:	83 f8 01             	cmp    $0x1,%eax
    e12d:	7f 21                	jg     e150 <sys_pipe+0x88>
    e12f:	83 fe 13             	cmp    $0x13,%esi
    e132:	7f 1c                	jg     e150 <sys_pipe+0x88>
		if (!current->filp[i]) {
    e134:	83 bc b1 48 03 00 00 	cmpl   $0x0,0x348(%ecx,%esi,4)
    e13b:	00 
    e13c:	75 0f                	jne    e14d <sys_pipe+0x85>
			current->filp[ fd[j] = i ] = f[j];
    e13e:	8b 2c 84             	mov    (%esp,%eax,4),%ebp
    e141:	89 74 84 08          	mov    %esi,0x8(%esp,%eax,4)
			j++;
    e145:	40                   	inc    %eax
			current->filp[ fd[j] = i ] = f[j];
    e146:	89 ac b1 48 03 00 00 	mov    %ebp,0x348(%ecx,%esi,4)
	for(i = 0; j < 2 && i < NR_OPEN; i++)
    e14d:	46                   	inc    %esi
    e14e:	eb da                	jmp    e12a <sys_pipe+0x62>
		}
	if (j == 1)
    e150:	48                   	dec    %eax
    e151:	8b 74 24 04          	mov    0x4(%esp),%esi
    e155:	8b 2c 24             	mov    (%esp),%ebp
    e158:	75 11                	jne    e16b <sys_pipe+0xa3>
		current->filp[fd[0]] = NULL;
    e15a:	8b 44 24 08          	mov    0x8(%esp),%eax
    e15e:	c7 84 81 48 03 00 00 	movl   $0x0,0x348(%ecx,%eax,4)
    e165:	00 00 00 00 
    e169:	eb 02                	jmp    e16d <sys_pipe+0xa5>
	if (j < 2) {
    e16b:	7f 11                	jg     e17e <sys_pipe+0xb6>
		f[0]->f_count = f[1]->f_count = 0;
    e16d:	66 c7 46 04 00 00    	movw   $0x0,0x4(%esi)
    e173:	66 c7 45 04 00 00    	movw   $0x0,0x4(%ebp)
		return -1;
    e179:	83 c8 ff             	or     $0xffffffff,%eax
    e17c:	eb 57                	jmp    e1d5 <sys_pipe+0x10d>
	}
	// 然后利用函数get_pipe_inode()申请一个管道使用的i节点，并为管道分配一页内存作为缓冲区。如果不成功，则
	// 相应释放两个文件句柄和文件结构项，并返回-1.
	if (!(inode = get_pipe_inode())) {                		// fs/inode.c。
    e17e:	e8 61 db ff ff       	call   bce4 <get_pipe_inode>
    e183:	85 c0                	test   %eax,%eax
    e185:	8b 5c 24 08          	mov    0x8(%esp),%ebx
    e189:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    e18d:	75 1a                	jne    e1a9 <sys_pipe+0xe1>
		current->filp[fd[0]] =
			current->filp[fd[1]] = NULL;
    e18f:	8b 07                	mov    (%edi),%eax
    e191:	c7 84 88 48 03 00 00 	movl   $0x0,0x348(%eax,%ecx,4)
    e198:	00 00 00 00 
		current->filp[fd[0]] =
    e19c:	c7 84 98 48 03 00 00 	movl   $0x0,0x348(%eax,%ebx,4)
    e1a3:	00 00 00 00 
    e1a7:	eb c4                	jmp    e16d <sys_pipe+0xa5>
		return -1;
	}
	// 如果管道i节点申请成功，则对两个文件结构进行初始化操作，让它们都指向同一个管道i节点，并把读写指针都置零。
	// 第1个文件结构的文件模式为读，第2个文件结构的文件模式置为写。最后将文件句柄数组复制到对应的用户空间数组中，
	// 成功返回0,退出。
	f[0]->f_inode = f[1]->f_inode = inode;
    e1a9:	89 46 08             	mov    %eax,0x8(%esi)
    e1ac:	89 45 08             	mov    %eax,0x8(%ebp)
	f[0]->f_pos = f[1]->f_pos = 0;
    e1af:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
    e1b6:	8b 44 24 30          	mov    0x30(%esp),%eax
    e1ba:	c7 45 0c 00 00 00 00 	movl   $0x0,0xc(%ebp)
	f[0]->f_mode = 1;										/* read */
    e1c1:	66 c7 45 00 01 00    	movw   $0x1,0x0(%ebp)
	f[1]->f_mode = 2;										/* write */
    e1c7:	66 c7 06 02 00       	movw   $0x2,(%esi)
    e1cc:	64 89 18             	mov    %ebx,%fs:(%eax)
    e1cf:	64 89 48 04          	mov    %ecx,%fs:0x4(%eax)
	put_fs_long(fd[0], 0 + fildes);
	put_fs_long(fd[1], 1 + fildes);
	return 0;
    e1d3:	31 c0                	xor    %eax,%eax
}
    e1d5:	83 c4 1c             	add    $0x1c,%esp
    e1d8:	5b                   	pop    %ebx
    e1d9:	5e                   	pop    %esi
    e1da:	5f                   	pop    %edi
    e1db:	5d                   	pop    %ebp
    e1dc:	c3                   	ret    

0000e1dd <pipe_ioctl>:

// 管道io控制函数。
// 参数：pino - 管道i节点指针；cmd - 控制命令；arg - 参数。
// 函数返回0表示执行成功，否则返回出错码。
int pipe_ioctl(struct m_inode *pino, int cmd, int arg)
{
    e1dd:	57                   	push   %edi
    e1de:	56                   	push   %esi
		case FIONREAD:
			verify_area((void *) arg, 4);
			put_fs_long(PIPE_SIZE(*pino), (unsigned long *) arg);
			return 0;
		default:
			return -EINVAL;
    e1df:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
{
    e1e4:	53                   	push   %ebx
    e1e5:	8b 7c 24 10          	mov    0x10(%esp),%edi
    e1e9:	e8 3e 88 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e1ee:	81 c3 12 2e 01 00    	add    $0x12e12,%ebx
	switch (cmd) {
    e1f4:	81 7c 24 14 1b 54 00 	cmpl   $0x541b,0x14(%esp)
    e1fb:	00 
{
    e1fc:	8b 74 24 18          	mov    0x18(%esp),%esi
	switch (cmd) {
    e200:	75 1e                	jne    e220 <pipe_ioctl+0x43>
			verify_area((void *) arg, 4);
    e202:	50                   	push   %eax
    e203:	50                   	push   %eax
    e204:	6a 04                	push   $0x4
    e206:	56                   	push   %esi
    e207:	e8 df 99 ff ff       	call   7beb <verify_area>
			put_fs_long(PIPE_SIZE(*pino), (unsigned long *) arg);
    e20c:	66 8b 47 0e          	mov    0xe(%edi),%ax
    e210:	2b 47 10             	sub    0x10(%edi),%eax
			verify_area((void *) arg, 4);
    e213:	83 c4 10             	add    $0x10,%esp
			put_fs_long(PIPE_SIZE(*pino), (unsigned long *) arg);
    e216:	25 ff 0f 00 00       	and    $0xfff,%eax
    e21b:	64 89 06             	mov    %eax,%fs:(%esi)
			return 0;
    e21e:	31 c0                	xor    %eax,%eax
	}
}
    e220:	5b                   	pop    %ebx
    e221:	5e                   	pop    %esi
    e222:	5f                   	pop    %edi
    e223:	c3                   	ret    

0000e224 <strcmp>:
{
    e224:	57                   	push   %edi
__asm__(
    e225:	89 c7                	mov    %eax,%edi
{
    e227:	56                   	push   %esi
__asm__(
    e228:	89 d6                	mov    %edx,%esi
    e22a:	fc                   	cld    
    e22b:	ac                   	lods   %ds:(%esi),%al
    e22c:	ae                   	scas   %es:(%edi),%al
    e22d:	75 08                	jne    e237 <strcmp+0x13>
    e22f:	84 c0                	test   %al,%al
    e231:	75 f8                	jne    e22b <strcmp+0x7>
    e233:	31 c0                	xor    %eax,%eax
    e235:	eb 09                	jmp    e240 <strcmp+0x1c>
    e237:	b8 01 00 00 00       	mov    $0x1,%eax
    e23c:	7c 02                	jl     e240 <strcmp+0x1c>
    e23e:	f7 d8                	neg    %eax
}
    e240:	5e                   	pop    %esi
    e241:	5f                   	pop    %edi
    e242:	c3                   	ret    

0000e243 <find_entry>:
// 参数:*dir - 指定目录i节点的指针;name - 文件名;namelen - 文件名长度;该函数在指定目录的数据(文件)中搜索指定文件名的目录项.并对指定
// 文件名是'..'的情况根据当前进行的相关设置进行特殊处理.
// 返回:成功则返回高速缓冲区指针,并在*res_dir处返回的目录项结构指针.失败则返回空指针NULL.
static struct buffer_head * find_entry(struct m_inode ** dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
    e243:	55                   	push   %ebp
    e244:	57                   	push   %edi
    e245:	56                   	push   %esi
    e246:	53                   	push   %ebx
    e247:	89 d6                	mov    %edx,%esi
    e249:	e8 de 87 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e24e:	81 c3 b2 2d 01 00    	add    $0x12db2,%ebx
    e254:	83 ec 1c             	sub    $0x1c,%esp
    e257:	89 44 24 04          	mov    %eax,0x4(%esp)
	if (namelen > NAME_LEN)
		namelen = NAME_LEN;
#endif
	// 首先计算本目录中目录项项数entries.目录i节点i_size字段中含有本目录包含的数据长度,因此其除以一个目录项的长度(16字节)即可得到该目录中目录项数.然后
	// 置空返回目录项结构指针.
	entries = (*dir)->i_size / (sizeof (struct dir_entry));
    e25b:	8b 00                	mov    (%eax),%eax
{
    e25d:	89 0c 24             	mov    %ecx,(%esp)
	*res_dir = NULL;
    e260:	8b 7c 24 30          	mov    0x30(%esp),%edi
	entries = (*dir)->i_size / (sizeof (struct dir_entry));
    e264:	8b 48 04             	mov    0x4(%eax),%ecx
	*res_dir = NULL;
    e267:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	entries = (*dir)->i_size / (sizeof (struct dir_entry));
    e26d:	c1 e9 04             	shr    $0x4,%ecx
	// 只能访问该目录中的项而不能退到其父目录中去.也即对于该进程本目录就如同是文件系统的根目录.因此我们需要将文件名修改为'.'.
	// 否则,如果该目录的i节点号等于ROOT_INO(1号)的话,说明确实是文件系统的根i节点.则取文件系统的超级块.如果被安装到的i节点存在,则先放回原i节点,然后对被
	// 安装到的i节点进行处理.于是我们让*dir指向该被安装到的i节点;并且该i节点的引用数加1.即针对这种情况,我们悄悄进行了"偷梁换柱"工程:)
	/* check for '..', as we might have to do some "magic" for it */
	/* 检查目录项'..',因为我们可能需要对其进行特殊处理 */
	if (namelen == 2 && get_fs_byte(name) == '.' && get_fs_byte(name + 1) == '.') {
    e270:	83 3c 24 02          	cmpl   $0x2,(%esp)
	entries = (*dir)->i_size / (sizeof (struct dir_entry));
    e274:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	if (namelen == 2 && get_fs_byte(name) == '.' && get_fs_byte(name + 1) == '.') {
    e278:	74 12                	je     e28c <find_entry+0x49>
    e27a:	83 3c 24 0e          	cmpl   $0xe,(%esp)
    e27e:	b8 0e 00 00 00       	mov    $0xe,%eax
    e283:	0f 4e 04 24          	cmovle (%esp),%eax
    e287:	89 04 24             	mov    %eax,(%esp)
    e28a:	eb 67                	jmp    e2f3 <find_entry+0xb0>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
    e28c:	64 8a 12             	mov    %fs:(%edx),%dl
    e28f:	80 fa 2e             	cmp    $0x2e,%dl
    e292:	75 5f                	jne    e2f3 <find_entry+0xb0>
    e294:	64 8a 56 01          	mov    %fs:0x1(%esi),%dl
    e298:	80 fa 2e             	cmp    $0x2e,%dl
    e29b:	75 56                	jne    e2f3 <find_entry+0xb0>
		/* '..' in a pseudo-root results in a faked '.' (just change namelen) */
		/* 伪根中的'..'如同一个假'.'(只需改变名字长度) */
		if ((*dir) == current->root)
    e29d:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    e2a3:	8b 12                	mov    (%edx),%edx
    e2a5:	3b 82 38 03 00 00    	cmp    0x338(%edx),%eax
    e2ab:	74 3f                	je     e2ec <find_entry+0xa9>
			namelen = 1;
		else if ((*dir)->i_num == ROOT_INO) {
    e2ad:	66 83 78 32 01       	cmpw   $0x1,0x32(%eax)
    e2b2:	75 3f                	jne    e2f3 <find_entry+0xb0>
			/* '..' over a mount-point results in 'dir' being exchanged for the mounted
			   directory-inode. NOTE! We set mounted, so that we can iput the new dir */
			/* 在一个安装点上的'..'将导致目录交换到被安装文件系统的目录i节点上.注意! 由于我们设置了mounted标志,因而我们能够放回该新目录 */
			sb = get_super((*dir)->i_dev);
    e2b4:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    e2b8:	83 ec 0c             	sub    $0xc,%esp
    e2bb:	50                   	push   %eax
    e2bc:	e8 a6 e3 ff ff       	call   c667 <get_super>
    e2c1:	83 c4 10             	add    $0x10,%esp
			if (sb->s_imount) {
    e2c4:	83 78 5c 00          	cmpl   $0x0,0x5c(%eax)
			sb = get_super((*dir)->i_dev);
    e2c8:	89 c7                	mov    %eax,%edi
			if (sb->s_imount) {
    e2ca:	74 27                	je     e2f3 <find_entry+0xb0>
				iput(*dir);
    e2cc:	83 ec 0c             	sub    $0xc,%esp
    e2cf:	8b 44 24 10          	mov    0x10(%esp),%eax
    e2d3:	ff 30                	pushl  (%eax)
    e2d5:	e8 4e d8 ff ff       	call   bb28 <iput>
    e2da:	83 c4 10             	add    $0x10,%esp
				(*dir)=sb->s_imount;
    e2dd:	8b 47 5c             	mov    0x5c(%edi),%eax
    e2e0:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    e2e4:	89 01                	mov    %eax,(%ecx)
				(*dir)->i_count++;
    e2e6:	66 ff 40 34          	incw   0x34(%eax)
    e2ea:	eb 07                	jmp    e2f3 <find_entry+0xb0>
			namelen = 1;
    e2ec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
		}
	}
	// 现在我们开始正常操作，查找指定文件名的目录项在什么地方。因此我们需要读取目录的数据，即取出目录i节点对应块设备数据区中的数据块（逻辑块）信息。这些逻辑块的
	// 块号保存在i节点结构的i_zone[9]数组中.我们先取其中第1个块号.如果目录i节点指向的第一个直接盘块号为0,则说明该目录竟然不含数据,这不正常.于是返回NULL退出.
	// 否则我们就从节点所在设备读取指定的目录项数据块.当然,如果不成功,则也返回NULL退出.
	if (!(block = (*dir)->i_zone[0]))
    e2f3:	8b 44 24 04          	mov    0x4(%esp),%eax
    e2f7:	8b 00                	mov    (%eax),%eax
    e2f9:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
    e2fd:	85 d2                	test   %edx,%edx
    e2ff:	0f 84 e4 00 00 00    	je     e3e9 <find_entry+0x1a6>
		return NULL;
	if (!(bh = bread((*dir)->i_dev, block)))
    e305:	55                   	push   %ebp
    e306:	55                   	push   %ebp
    e307:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    e30b:	52                   	push   %edx
    e30c:	50                   	push   %eax
    e30d:	e8 9e e0 ff ff       	call   c3b0 <bread>
    e312:	83 c4 10             	add    $0x10,%esp
    e315:	85 c0                	test   %eax,%eax
    e317:	89 c2                	mov    %eax,%edx
    e319:	0f 84 ca 00 00 00    	je     e3e9 <find_entry+0x1a6>
		return NULL;
	// 此时我们就在这个读取的目录i节点数据块中搜索匹配指定文件名的目录项.首先让de指向缓冲块中的数据块部分,并在不超过目录项数据的条件下,循环执行搜索.其中i是目录
	// 中的目录项索引号,在循环开始时初始化为0.
	i = 0;
	de = (struct dir_entry *) bh->b_data;
    e31f:	8b 28                	mov    (%eax),%ebp
	i = 0;
    e321:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    e328:	00 
	while (i < entries) {
    e329:	8b 7c 24 0c          	mov    0xc(%esp),%edi
    e32d:	39 7c 24 08          	cmp    %edi,0x8(%esp)
    e331:	0f 8d a6 00 00 00    	jge    e3dd <find_entry+0x19a>
		// 如果当前目录项数据块已经搜索完,还没有找到匹配的目录项,则释放当前目录项数据块.再读入目录的下一个逻辑块.若这块为空,则只要还没有搜索完目录中的所有目录项,就
		// 跳过该块,继续读目录的下一逻辑块.若该块不空,就让de指向该数据块,然后在其中继续搜索.其中141行上i/DIR_ENTRIES_PER_BLOCK可得到当前搜索的目录项所在目录文件中的
		// 块号,而bmap()函数(inode.c)则可计算出在设备上对应的逻辑块号.
		if ((char *)de >= BLOCK_SIZE + bh->b_data) {
    e337:	8b 02                	mov    (%edx),%eax
    e339:	05 00 04 00 00       	add    $0x400,%eax
    e33e:	39 c5                	cmp    %eax,%ebp
    e340:	72 4c                	jb     e38e <find_entry+0x14b>
			brelse(bh);
    e342:	83 ec 0c             	sub    $0xc,%esp
    e345:	52                   	push   %edx
    e346:	e8 13 e0 ff ff       	call   c35e <brelse>
    e34b:	59                   	pop    %ecx
    e34c:	5f                   	pop    %edi
			bh = NULL;
			if (!(block = bmap(*dir, i / DIR_ENTRIES_PER_BLOCK)) ||
    e34d:	8b 44 24 10          	mov    0x10(%esp),%eax
    e351:	c1 e8 06             	shr    $0x6,%eax
    e354:	50                   	push   %eax
    e355:	8b 44 24 10          	mov    0x10(%esp),%eax
    e359:	ff 30                	pushl  (%eax)
    e35b:	e8 ac d6 ff ff       	call   ba0c <bmap>
    e360:	83 c4 10             	add    $0x10,%esp
    e363:	85 c0                	test   %eax,%eax
    e365:	75 09                	jne    e370 <find_entry+0x12d>
			    !(bh = bread((*dir)->i_dev, block))) {
				i += DIR_ENTRIES_PER_BLOCK;
    e367:	83 44 24 08 40       	addl   $0x40,0x8(%esp)
				continue;
    e36c:	31 d2                	xor    %edx,%edx
    e36e:	eb b9                	jmp    e329 <find_entry+0xe6>
			if (!(block = bmap(*dir, i / DIR_ENTRIES_PER_BLOCK)) ||
    e370:	52                   	push   %edx
    e371:	52                   	push   %edx
    e372:	50                   	push   %eax
			    !(bh = bread((*dir)->i_dev, block))) {
    e373:	8b 44 24 10          	mov    0x10(%esp),%eax
    e377:	8b 00                	mov    (%eax),%eax
    e379:	0f b7 40 30          	movzwl 0x30(%eax),%eax
			if (!(block = bmap(*dir, i / DIR_ENTRIES_PER_BLOCK)) ||
    e37d:	50                   	push   %eax
    e37e:	e8 2d e0 ff ff       	call   c3b0 <bread>
    e383:	83 c4 10             	add    $0x10,%esp
    e386:	85 c0                	test   %eax,%eax
    e388:	89 c2                	mov    %eax,%edx
    e38a:	74 db                	je     e367 <find_entry+0x124>
			}
			de = (struct dir_entry *) bh->b_data;
    e38c:	8b 28                	mov    (%eax),%ebp
	if (!de || !de->inode || len > NAME_LEN)
    e38e:	85 ed                	test   %ebp,%ebp
    e390:	74 3f                	je     e3d1 <find_entry+0x18e>
    e392:	66 83 7d 00 00       	cmpw   $0x0,0x0(%ebp)
    e397:	74 38                	je     e3d1 <find_entry+0x18e>
	if (!len && (de->name[0] == '.') && (de->name[1] == '\0'))
    e399:	83 3c 24 00          	cmpl   $0x0,(%esp)
    e39d:	75 0f                	jne    e3ae <find_entry+0x16b>
    e39f:	66 83 7d 02 2e       	cmpw   $0x2e,0x2(%ebp)
    e3a4:	75 0e                	jne    e3b4 <find_entry+0x171>
		}
		// 如果找到匹配的目录项的话,则返回目录项结构指针de和该目录项i节点指针*dir以及该目录项数据块指针bh,并退出函数.否则继续在目录项数据块中比较下一个目录项.
		if (match(namelen, name, de)) {
			*res_dir = de;
    e3a6:	8b 44 24 30          	mov    0x30(%esp),%eax
    e3aa:	89 28                	mov    %ebp,(%eax)
			return bh;
    e3ac:	eb 3d                	jmp    e3eb <find_entry+0x1a8>
	if (len < NAME_LEN && de->name[len])
    e3ae:	83 3c 24 0e          	cmpl   $0xe,(%esp)
    e3b2:	74 0a                	je     e3be <find_entry+0x17b>
    e3b4:	8b 04 24             	mov    (%esp),%eax
    e3b7:	80 7c 05 02 00       	cmpb   $0x0,0x2(%ebp,%eax,1)
    e3bc:	75 13                	jne    e3d1 <find_entry+0x18e>
	__asm__(\
    e3be:	31 c0                	xor    %eax,%eax
		:"0" (0), "S" ((long) name), "D" ((long) de->name), "c" (len)
    e3c0:	8d 7d 02             	lea    0x2(%ebp),%edi
	__asm__(\
    e3c3:	8b 0c 24             	mov    (%esp),%ecx
    e3c6:	fc                   	cld    
    e3c7:	64 f3 a6             	repz cmpsb %es:(%edi),%fs:(%esi)
    e3ca:	0f 94 c0             	sete   %al
		if (match(namelen, name, de)) {
    e3cd:	85 c0                	test   %eax,%eax
    e3cf:	75 d5                	jne    e3a6 <find_entry+0x163>
		}
		de++;
    e3d1:	83 c5 10             	add    $0x10,%ebp
		i++;
    e3d4:	ff 44 24 08          	incl   0x8(%esp)
    e3d8:	e9 4c ff ff ff       	jmp    e329 <find_entry+0xe6>
	}
	// 如果指定目录中的所有目录项都搜索赛后,还没有找到相应的目录项,则释放目录的数据块,最后返回NULL(失败).
	brelse(bh);
    e3dd:	83 ec 0c             	sub    $0xc,%esp
    e3e0:	52                   	push   %edx
    e3e1:	e8 78 df ff ff       	call   c35e <brelse>
    e3e6:	83 c4 10             	add    $0x10,%esp
	return NULL;
    e3e9:	31 d2                	xor    %edx,%edx
}
    e3eb:	83 c4 1c             	add    $0x1c,%esp
    e3ee:	89 d0                	mov    %edx,%eax
    e3f0:	5b                   	pop    %ebx
    e3f1:	5e                   	pop    %esi
    e3f2:	5f                   	pop    %edi
    e3f3:	5d                   	pop    %ebp
    e3f4:	c3                   	ret    

0000e3f5 <add_entry>:
// 根据指定的目录和文件名添加目录项。
// 参数：dir - 指定目录的i节点；name - 文件名；namelen - 文件名长度；
// 返回：高速缓冲区指针；res_dir - 返回的目录项结构指针。
static struct buffer_head * add_entry(struct m_inode * dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
    e3f5:	55                   	push   %ebp
    e3f6:	57                   	push   %edi
    e3f7:	56                   	push   %esi
    e3f8:	53                   	push   %ebx
    e3f9:	89 c6                	mov    %eax,%esi
    e3fb:	e8 2c 86 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e400:	81 c3 00 2c 01 00    	add    $0x12c00,%ebx
    e406:	83 ec 2c             	sub    $0x2c,%esp
	*res_dir = NULL;                							// 用于返回目录项结构指针。
#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
    e409:	83 f9 0e             	cmp    $0xe,%ecx
	*res_dir = NULL;                							// 用于返回目录项结构指针。
    e40c:	8b 44 24 40          	mov    0x40(%esp),%eax
{
    e410:	89 54 24 14          	mov    %edx,0x14(%esp)
    e414:	89 4c 24 10          	mov    %ecx,0x10(%esp)
	*res_dir = NULL;                							// 用于返回目录项结构指针。
    e418:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if (namelen > NAME_LEN)
    e41e:	7f 09                	jg     e429 <add_entry+0x34>
#endif
	// 现在我们开始操作，向指定目录中添加一个指定文件名的目录项。因此我们需要先读取目录的数据，即取出目录i节点对应块设备
	// 数据区中的数据块（逻辑块）信息。这些逻辑块的块号保存在i节点结构的i_zone[9]数组中。我们先取其第1个块号。如果目录
	// i节点指向的第一个直接磁盘块号为0,则说明该目录竟然不含数据，这不正常。于是返回NULL退出。否则我们就从节点所在设备读取
	// 指定的目录项数据块。如果不成功，则也返回NULL退出。另外，如果参数提供的文件名长度等于0,则也返回NULL退出。
	if (!namelen)
    e420:	85 c9                	test   %ecx,%ecx
    e422:	75 0d                	jne    e431 <add_entry+0x3c>
    e424:	e9 33 01 00 00       	jmp    e55c <add_entry+0x167>
		namelen = NAME_LEN;
    e429:	c7 44 24 10 0e 00 00 	movl   $0xe,0x10(%esp)
    e430:	00 
		return NULL;
	if (!(block = dir->i_zone[0]))
    e431:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
    e435:	85 c0                	test   %eax,%eax
    e437:	0f 84 1f 01 00 00    	je     e55c <add_entry+0x167>
		return NULL;
	if (!(bh = bread(dir->i_dev, block)))
    e43d:	52                   	push   %edx
    e43e:	52                   	push   %edx
    e43f:	50                   	push   %eax
    e440:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    e444:	50                   	push   %eax
    e445:	e8 66 df ff ff       	call   c3b0 <bread>
    e44a:	83 c4 10             	add    $0x10,%esp
    e44d:	85 c0                	test   %eax,%eax
    e44f:	89 c1                	mov    %eax,%ecx
    e451:	0f 84 05 01 00 00    	je     e55c <add_entry+0x167>
		return NULL;
	// 此时我们就在这个目录i节点数据块中循环查找最后未使用的空目录项。首先让目录项结构指针de指向缓冲块中的数据块部分，即第
	// 一个目录项处。其中i是目录中的目录项索引号，在循环开始时初始化为0。
	i = 0;
	de = (struct dir_entry *) bh->b_data;
    e457:	8b 38                	mov    (%eax),%edi
		// 标志，再更新该目录的改变时间为当前时间。
		if (i * sizeof(struct dir_entry) >= dir->i_size) {
			de->inode = 0;
			dir->i_size = (i + 1) * sizeof(struct dir_entry);
			dir->i_dirt = 1;
			dir->i_ctime = CURRENT_TIME;
    e459:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
	i = 0;
    e45f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    e466:	00 
			dir->i_ctime = CURRENT_TIME;
    e467:	89 44 24 18          	mov    %eax,0x18(%esp)
    e46b:	c7 c0 64 2a 02 00    	mov    $0x22a64,%eax
    e471:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if ((char *)de >= BLOCK_SIZE + bh->b_data) {
    e475:	8b 01                	mov    (%ecx),%eax
    e477:	05 00 04 00 00       	add    $0x400,%eax
    e47c:	39 c7                	cmp    %eax,%edi
    e47e:	72 43                	jb     e4c3 <add_entry+0xce>
			brelse(bh);
    e480:	83 ec 0c             	sub    $0xc,%esp
    e483:	51                   	push   %ecx
    e484:	e8 d5 de ff ff       	call   c35e <brelse>
    e489:	59                   	pop    %ecx
    e48a:	5d                   	pop    %ebp
			block = create_block(dir, i / DIR_ENTRIES_PER_BLOCK);
    e48b:	8b 44 24 14          	mov    0x14(%esp),%eax
    e48f:	c1 e8 06             	shr    $0x6,%eax
    e492:	50                   	push   %eax
    e493:	56                   	push   %esi
    e494:	e8 d9 d5 ff ff       	call   ba72 <create_block>
    e499:	83 c4 10             	add    $0x10,%esp
			if (!block)
    e49c:	85 c0                	test   %eax,%eax
    e49e:	0f 84 b8 00 00 00    	je     e55c <add_entry+0x167>
			if (!(bh = bread(dir->i_dev, block))) {          			// 若空则跳过该块继续。
    e4a4:	52                   	push   %edx
    e4a5:	52                   	push   %edx
    e4a6:	50                   	push   %eax
    e4a7:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    e4ab:	50                   	push   %eax
    e4ac:	e8 ff de ff ff       	call   c3b0 <bread>
    e4b1:	83 c4 10             	add    $0x10,%esp
    e4b4:	85 c0                	test   %eax,%eax
    e4b6:	89 c1                	mov    %eax,%ecx
    e4b8:	75 07                	jne    e4c1 <add_entry+0xcc>
				i += DIR_ENTRIES_PER_BLOCK;
    e4ba:	83 44 24 0c 40       	addl   $0x40,0xc(%esp)
				continue;
    e4bf:	eb b4                	jmp    e475 <add_entry+0x80>
			de = (struct dir_entry *) bh->b_data;
    e4c1:	8b 38                	mov    (%eax),%edi
		if (i * sizeof(struct dir_entry) >= dir->i_size) {
    e4c3:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e4c7:	c1 e0 04             	shl    $0x4,%eax
    e4ca:	3b 46 04             	cmp    0x4(%esi),%eax
    e4cd:	72 2f                	jb     e4fe <add_entry+0x109>
			dir->i_size = (i + 1) * sizeof(struct dir_entry);
    e4cf:	83 c0 10             	add    $0x10,%eax
			de->inode = 0;
    e4d2:	66 c7 07 00 00       	movw   $0x0,(%edi)
			dir->i_ctime = CURRENT_TIME;
    e4d7:	8b 54 24 1c          	mov    0x1c(%esp),%edx
			dir->i_size = (i + 1) * sizeof(struct dir_entry);
    e4db:	89 46 04             	mov    %eax,0x4(%esi)
			dir->i_ctime = CURRENT_TIME;
    e4de:	8b 44 24 18          	mov    0x18(%esp),%eax
    e4e2:	bd 64 00 00 00       	mov    $0x64,%ebp
			dir->i_dirt = 1;
    e4e7:	c6 46 37 01          	movb   $0x1,0x37(%esi)
			dir->i_ctime = CURRENT_TIME;
    e4eb:	8b 00                	mov    (%eax),%eax
    e4ed:	03 02                	add    (%edx),%eax
    e4ef:	31 d2                	xor    %edx,%edx
    e4f1:	f7 f5                	div    %ebp
    e4f3:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    e4f9:	03 02                	add    (%edx),%eax
    e4fb:	89 46 2c             	mov    %eax,0x2c(%esi)
		}
		// 若当前搜索的目录项de的i节点为空，则表示找到一个还未使用的空闲目录项或是添加的新目录项。于是更新目录的修改时间为当前
		// 时间，并从用户数据区复制文件名到该目录项的文件名字段，置含有本目录项的相应高速缓冲块已修改标志。返回该目录项的指针以及
		// 该高速缓冲块的指针，退出。
		if (!de->inode) {
    e4fe:	66 83 3f 00          	cmpw   $0x0,(%edi)
    e502:	75 4c                	jne    e550 <add_entry+0x15b>
			dir->i_mtime = CURRENT_TIME;
    e504:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    e50a:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    e510:	bd 64 00 00 00       	mov    $0x64,%ebp
    e515:	8b 00                	mov    (%eax),%eax
    e517:	03 02                	add    (%edx),%eax
    e519:	31 d2                	xor    %edx,%edx
    e51b:	f7 f5                	div    %ebp
    e51d:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    e523:	03 02                	add    (%edx),%eax
    e525:	89 46 08             	mov    %eax,0x8(%esi)
			for (i = 0; i < NAME_LEN ; i++)
    e528:	31 c0                	xor    %eax,%eax
				de->name[i] = (i < namelen) ? get_fs_byte(name + i) : 0;
    e52a:	31 d2                	xor    %edx,%edx
    e52c:	39 44 24 10          	cmp    %eax,0x10(%esp)
    e530:	7e 08                	jle    e53a <add_entry+0x145>
    e532:	8b 74 24 14          	mov    0x14(%esp),%esi
    e536:	64 8a 14 06          	mov    %fs:(%esi,%eax,1),%dl
    e53a:	88 54 07 02          	mov    %dl,0x2(%edi,%eax,1)
			for (i = 0; i < NAME_LEN ; i++)
    e53e:	40                   	inc    %eax
    e53f:	83 f8 0e             	cmp    $0xe,%eax
    e542:	75 e6                	jne    e52a <add_entry+0x135>
			bh->b_dirt = 1;
			*res_dir = de;
    e544:	8b 44 24 40          	mov    0x40(%esp),%eax
			bh->b_dirt = 1;
    e548:	c6 41 0b 01          	movb   $0x1,0xb(%ecx)
			*res_dir = de;
    e54c:	89 38                	mov    %edi,(%eax)
			return bh;
    e54e:	eb 0e                	jmp    e55e <add_entry+0x169>
		}
		de++;           												// 如果该目录项已经被使用，则继续检测下一个目录项。
    e550:	83 c7 10             	add    $0x10,%edi
		i++;
    e553:	ff 44 24 0c          	incl   0xc(%esp)
    e557:	e9 19 ff ff ff       	jmp    e475 <add_entry+0x80>
		return NULL;
    e55c:	31 c9                	xor    %ecx,%ecx
	}
	// 本函数执行不到这里。这也许是Linus在写这段代码时，先复制了上面find_entry()函数的代码，而后修改成本函数的。
	brelse(bh);
	return NULL;
}
    e55e:	83 c4 2c             	add    $0x2c,%esp
    e561:	89 c8                	mov    %ecx,%eax
    e563:	5b                   	pop    %ebx
    e564:	5e                   	pop    %esi
    e565:	5f                   	pop    %edi
    e566:	5d                   	pop    %ebp
    e567:	c3                   	ret    

0000e568 <permission>:
{
    e568:	55                   	push   %ebp
    e569:	57                   	push   %edi
    e56a:	89 c1                	mov    %eax,%ecx
    e56c:	56                   	push   %esi
    e56d:	53                   	push   %ebx
    e56e:	e8 b9 84 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e573:	81 c3 8d 2a 01 00    	add    $0x12a8d,%ebx
    e579:	83 ec 0c             	sub    $0xc,%esp
	if (inode->i_dev && !inode->i_nlinks)
    e57c:	66 83 78 30 00       	cmpw   $0x0,0x30(%eax)
	int mode = inode->i_mode;								// 文件访问属性.
    e581:	0f b7 30             	movzwl (%eax),%esi
	if (inode->i_dev && !inode->i_nlinks)
    e584:	74 08                	je     e58e <permission+0x26>
		return 0;
    e586:	31 c0                	xor    %eax,%eax
	if (inode->i_dev && !inode->i_nlinks)
    e588:	80 79 0d 00          	cmpb   $0x0,0xd(%ecx)
    e58c:	74 55                	je     e5e3 <permission+0x7b>
	else if (current->euid == inode->i_uid)
    e58e:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
    e594:	89 d7                	mov    %edx,%edi
    e596:	66 8b 51 02          	mov    0x2(%ecx),%dx
    e59a:	8b 45 00             	mov    0x0(%ebp),%eax
    e59d:	66 39 90 ce 02 00 00 	cmp    %dx,0x2ce(%eax)
    e5a4:	75 05                	jne    e5ab <permission+0x43>
		mode >>= 6;
    e5a6:	c1 fe 06             	sar    $0x6,%esi
    e5a9:	eb 17                	jmp    e5c2 <permission+0x5a>
	else if (in_group_p(inode->i_gid))
    e5ab:	0f b6 41 0c          	movzbl 0xc(%ecx),%eax
    e5af:	83 ec 0c             	sub    $0xc,%esp
    e5b2:	50                   	push   %eax
    e5b3:	e8 ac a5 ff ff       	call   8b64 <in_group_p>
    e5b8:	83 c4 10             	add    $0x10,%esp
    e5bb:	85 c0                	test   %eax,%eax
    e5bd:	74 03                	je     e5c2 <permission+0x5a>
		mode >>= 3;
    e5bf:	c1 fe 03             	sar    $0x3,%esi
	if (((mode & mask & 0007) == mask) || suser())
    e5c2:	89 f8                	mov    %edi,%eax
    e5c4:	83 e0 07             	and    $0x7,%eax
    e5c7:	21 c6                	and    %eax,%esi
		return 1;
    e5c9:	b8 01 00 00 00       	mov    $0x1,%eax
	if (((mode & mask & 0007) == mask) || suser())
    e5ce:	39 fe                	cmp    %edi,%esi
    e5d0:	74 11                	je     e5e3 <permission+0x7b>
    e5d2:	8b 45 00             	mov    0x0(%ebp),%eax
    e5d5:	66 83 b8 ce 02 00 00 	cmpw   $0x0,0x2ce(%eax)
    e5dc:	00 
    e5dd:	0f 94 c0             	sete   %al
    e5e0:	0f b6 c0             	movzbl %al,%eax
}
    e5e3:	83 c4 0c             	add    $0xc,%esp
    e5e6:	5b                   	pop    %ebx
    e5e7:	5e                   	pop    %esi
    e5e8:	5f                   	pop    %edi
    e5e9:	5d                   	pop    %ebp
    e5ea:	c3                   	ret    

0000e5eb <dir_namei>:
// base - 搜索起始目录的i节点.
// 返回:指定目录名最顶层的i节点指针和最顶层目录名称及长度.出错时返回NULL.
// 注意!!这里"最顶层目录"是指路径名中最靠近末端的目录.
static struct m_inode * dir_namei(const char * pathname,
	int * namelen, const char ** name, struct m_inode * base)
{
    e5eb:	55                   	push   %ebp
    e5ec:	57                   	push   %edi
    e5ed:	56                   	push   %esi
    e5ee:	53                   	push   %ebx
    e5ef:	89 c6                	mov    %eax,%esi
    e5f1:	e8 36 84 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e5f6:	81 c3 0a 2a 01 00    	add    $0x12a0a,%ebx
    e5fc:	83 ec 2c             	sub    $0x2c,%esp
    e5ff:	8b 44 24 40          	mov    0x40(%esp),%eax
    e603:	89 54 24 04          	mov    %edx,0x4(%esp)
    e607:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	if (!inode) {
    e60b:	85 c0                	test   %eax,%eax
    e60d:	89 44 24 18          	mov    %eax,0x18(%esp)
    e611:	75 16                	jne    e629 <dir_namei+0x3e>
		inode = current->pwd;									// 进程的当前工作目录i节点.
    e613:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    e619:	8b 00                	mov    (%eax),%eax
    e61b:	8b 80 34 03 00 00    	mov    0x334(%eax),%eax
		inode->i_count++;
    e621:	66 ff 40 34          	incw   0x34(%eax)
		inode = current->pwd;									// 进程的当前工作目录i节点.
    e625:	89 44 24 18          	mov    %eax,0x18(%esp)
    e629:	64 8a 06             	mov    %fs:(%esi),%al
	if ((c = get_fs_byte(pathname)) == '/') {
    e62c:	3c 2f                	cmp    $0x2f,%al
    e62e:	89 f5                	mov    %esi,%ebp
    e630:	75 28                	jne    e65a <dir_namei+0x6f>
		iput(inode);											// 放回原i节点.
    e632:	83 ec 0c             	sub    $0xc,%esp
		pathname++;
    e635:	8d 6e 01             	lea    0x1(%esi),%ebp
		iput(inode);											// 放回原i节点.
    e638:	ff 74 24 24          	pushl  0x24(%esp)
    e63c:	e8 e7 d4 ff ff       	call   bb28 <iput>
		inode = current->root;									// 为进程指定的根i节点.
    e641:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
		iput(inode);											// 放回原i节点.
    e647:	83 c4 10             	add    $0x10,%esp
		inode = current->root;									// 为进程指定的根i节点.
    e64a:	8b 00                	mov    (%eax),%eax
    e64c:	8b 80 38 03 00 00    	mov    0x338(%eax),%eax
		inode->i_count++;
    e652:	66 ff 40 34          	incw   0x34(%eax)
		inode = current->root;									// 为进程指定的根i节点.
    e656:	89 44 24 18          	mov    %eax,0x18(%esp)
		if (!S_ISDIR(inode->i_mode) || !permission(inode, MAY_EXEC)) {
    e65a:	8b 44 24 18          	mov    0x18(%esp),%eax
    e65e:	8b 10                	mov    (%eax),%edx
    e660:	66 81 e2 00 f0       	and    $0xf000,%dx
    e665:	66 81 fa 00 40       	cmp    $0x4000,%dx
    e66a:	75 3e                	jne    e6aa <dir_namei+0xbf>
    e66c:	ba 01 00 00 00       	mov    $0x1,%edx
    e671:	e8 f2 fe ff ff       	call   e568 <permission>
    e676:	85 c0                	test   %eax,%eax
    e678:	74 30                	je     e6aa <dir_namei+0xbf>
    e67a:	89 ef                	mov    %ebp,%edi
    e67c:	89 f9                	mov    %edi,%ecx
		for(namelen = 0; (c = get_fs_byte(pathname++)) && (c != '/'); namelen++)
    e67e:	8d 57 01             	lea    0x1(%edi),%edx
    e681:	29 e9                	sub    %ebp,%ecx
    e683:	64 8a 07             	mov    %fs:(%edi),%al
    e686:	84 c0                	test   %al,%al
    e688:	74 36                	je     e6c0 <dir_namei+0xd5>
    e68a:	3c 2f                	cmp    $0x2f,%al
    e68c:	89 d7                	mov    %edx,%edi
    e68e:	75 ec                	jne    e67c <dir_namei+0x91>
		if (!(bh = find_entry(&inode, thisname, namelen, &de))) {
    e690:	8d 44 24 18          	lea    0x18(%esp),%eax
    e694:	83 ec 0c             	sub    $0xc,%esp
    e697:	8d 54 24 28          	lea    0x28(%esp),%edx
    e69b:	52                   	push   %edx
    e69c:	89 ea                	mov    %ebp,%edx
    e69e:	e8 a0 fb ff ff       	call   e243 <find_entry>
    e6a3:	83 c4 10             	add    $0x10,%esp
    e6a6:	85 c0                	test   %eax,%eax
    e6a8:	75 49                	jne    e6f3 <dir_namei+0x108>
			iput(inode);
    e6aa:	83 ec 0c             	sub    $0xc,%esp
    e6ad:	ff 74 24 24          	pushl  0x24(%esp)
    e6b1:	e8 72 d4 ff ff       	call   bb28 <iput>
    e6b6:	83 c4 10             	add    $0x10,%esp

	// 首先取得指定路径名最顶层目录的i节点.然后对路径名pathname进行搜索检测,查出最后一个'/'字符后面的名字字符串,计算其长度,并且
	// 返回最顶层目录的i节点指针.注意!如果路径名最后一个字符是斜杠字符'/',那么返回的目录名为空,并且长度为0.但返回的i节点指针仍然
	// 指向最后一个'/'字符前目录名的i节点.
	if (!(dir = get_dir(pathname, base)))					// base是指定的起始目录i节点.
		return NULL;
    e6b9:	31 c0                	xor    %eax,%eax
    e6bb:	e9 95 00 00 00       	jmp    e755 <dir_namei+0x16a>
			return inode;
    e6c0:	8b 44 24 18          	mov    0x18(%esp),%eax
	basename = pathname;
    e6c4:	89 f1                	mov    %esi,%ecx
	if (!(dir = get_dir(pathname, base)))					// base是指定的起始目录i节点.
    e6c6:	85 c0                	test   %eax,%eax
    e6c8:	0f 84 87 00 00 00    	je     e755 <dir_namei+0x16a>
    e6ce:	64 8a 1e             	mov    %fs:(%esi),%bl
	while (c = get_fs_byte(pathname++))
    e6d1:	84 db                	test   %bl,%bl
    e6d3:	8d 56 01             	lea    0x1(%esi),%edx
    e6d6:	74 0a                	je     e6e2 <dir_namei+0xf7>
    e6d8:	80 fb 2f             	cmp    $0x2f,%bl
    e6db:	89 d6                	mov    %edx,%esi
    e6dd:	0f 44 ca             	cmove  %edx,%ecx
    e6e0:	eb ec                	jmp    e6ce <dir_namei+0xe3>
		if (c == '/')
			basename = pathname;
	*namelen = pathname - basename - 1;
    e6e2:	8b 7c 24 04          	mov    0x4(%esp),%edi
	*name = basename;
    e6e6:	8b 74 24 08          	mov    0x8(%esp),%esi
	*namelen = pathname - basename - 1;
    e6ea:	29 ca                	sub    %ecx,%edx
    e6ec:	4a                   	dec    %edx
    e6ed:	89 17                	mov    %edx,(%edi)
	*name = basename;
    e6ef:	89 0e                	mov    %ecx,(%esi)
	return dir;
    e6f1:	eb 62                	jmp    e755 <dir_namei+0x16a>
		inr = de->inode;										// 当前目录名部分的i节点号.
    e6f3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
		brelse(bh);
    e6f7:	83 ec 0c             	sub    $0xc,%esp
		inr = de->inode;										// 当前目录名部分的i节点号.
    e6fa:	0f b7 12             	movzwl (%edx),%edx
    e6fd:	89 54 24 18          	mov    %edx,0x18(%esp)
		brelse(bh);
    e701:	50                   	push   %eax
    e702:	e8 57 dc ff ff       	call   c35e <brelse>
    e707:	58                   	pop    %eax
    e708:	5a                   	pop    %edx
		dir = inode;
    e709:	8b 6c 24 20          	mov    0x20(%esp),%ebp
		if (!(inode = iget(dir->i_dev, inr))) {					// 取i节点内容.
    e70d:	8b 54 24 14          	mov    0x14(%esp),%edx
    e711:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    e715:	52                   	push   %edx
    e716:	50                   	push   %eax
    e717:	e8 0e d6 ff ff       	call   bd2a <iget>
    e71c:	83 c4 10             	add    $0x10,%esp
    e71f:	85 c0                	test   %eax,%eax
    e721:	89 44 24 18          	mov    %eax,0x18(%esp)
    e725:	75 16                	jne    e73d <dir_namei+0x152>
    e727:	89 44 24 04          	mov    %eax,0x4(%esp)
			iput(dir);
    e72b:	83 ec 0c             	sub    $0xc,%esp
    e72e:	55                   	push   %ebp
    e72f:	e8 f4 d3 ff ff       	call   bb28 <iput>
    e734:	83 c4 10             	add    $0x10,%esp
    e737:	8b 44 24 04          	mov    0x4(%esp),%eax
    e73b:	eb 18                	jmp    e755 <dir_namei+0x16a>
		if (!(inode = follow_link(dir, inode)))
    e73d:	89 c2                	mov    %eax,%edx
    e73f:	89 e8                	mov    %ebp,%eax
    e741:	e8 1b 01 00 00       	call   e861 <follow_link>
    e746:	85 c0                	test   %eax,%eax
    e748:	89 44 24 18          	mov    %eax,0x18(%esp)
    e74c:	74 07                	je     e755 <dir_namei+0x16a>
		for(namelen = 0; (c = get_fs_byte(pathname++)) && (c != '/'); namelen++)
    e74e:	89 fd                	mov    %edi,%ebp
    e750:	e9 05 ff ff ff       	jmp    e65a <dir_namei+0x6f>
}
    e755:	83 c4 2c             	add    $0x2c,%esp
    e758:	5b                   	pop    %ebx
    e759:	5e                   	pop    %esi
    e75a:	5f                   	pop    %edi
    e75b:	5d                   	pop    %ebp
    e75c:	c3                   	ret    

0000e75d <_namei>:

// 取指定路径名的i节点内部函数.
// 参数:pathname - 路径名;base - 搜索起点目录i节点;follow_links - 是否跟随符号链接的标志,1 - 需要,0 不需要.
struct m_inode * _namei(const char * pathname, struct m_inode * base,
	int follow_links)
{
    e75d:	57                   	push   %edi
    e75e:	56                   	push   %esi
    e75f:	89 cf                	mov    %ecx,%edi
    e761:	53                   	push   %ebx
    e762:	89 d6                	mov    %edx,%esi
    e764:	e8 c3 82 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e769:	81 c3 97 28 01 00    	add    $0x12897,%ebx
    e76f:	83 ec 20             	sub    $0x20,%esp
    e772:	89 54 24 0c          	mov    %edx,0xc(%esp)
	struct buffer_head * bh;
	struct dir_entry * de;

	// 首先查找指定路径名中最顶层目录的目录名并得到其i节点.若不存在,则返回NULL退出.如果返回的最顶层名字的长度是0,则表示该路径名以一个目录名为
	// 最后一项.因此说明我们已经找到对应目录的i节点,可以直接返回该i节点退出.
	if (!(base = dir_namei(pathname, &namelen, &basename, base)))
    e776:	8d 4c 24 14          	lea    0x14(%esp),%ecx
    e77a:	8d 54 24 18          	lea    0x18(%esp),%edx
    e77e:	83 ec 0c             	sub    $0xc,%esp
    e781:	56                   	push   %esi
    e782:	e8 64 fe ff ff       	call   e5eb <dir_namei>
    e787:	83 c4 10             	add    $0x10,%esp
    e78a:	85 c0                	test   %eax,%eax
    e78c:	89 c6                	mov    %eax,%esi
    e78e:	89 44 24 0c          	mov    %eax,0xc(%esp)
    e792:	0f 84 c0 00 00 00    	je     e858 <_namei+0xfb>
		return NULL;
	if (!namelen)										/* special case: '/usr/' etc */
    e798:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    e79c:	85 c9                	test   %ecx,%ecx
    e79e:	0f 84 b4 00 00 00    	je     e858 <_namei+0xfb>
		return base;									/* 对应于'/usr/'等情况 */
	// 然后在返回的顶层目录中寻找指定文件名目录项的i节点.注意!因为如果最后也是一个目录名,但其后没有加'/',则不会返回该最后目录的i节点!例如:/usr/src/linux,
	// 将只返回src/目录名的i节点.因为函数dir_namei()将不以'/'结束的最后一个名字当作一个文件名来看待,因此这里需要单独对这种情况使用寻找目录项i节点函数
	// find_entry()进行处理.此时de中含有寻找到的目录项指针,而base是包含该目录项的目录的i节点指针.
	bh = find_entry(&base, basename, namelen, &de);
    e7a4:	8d 44 24 0c          	lea    0xc(%esp),%eax
    e7a8:	83 ec 0c             	sub    $0xc,%esp
    e7ab:	8d 54 24 28          	lea    0x28(%esp),%edx
    e7af:	52                   	push   %edx
    e7b0:	8b 54 24 24          	mov    0x24(%esp),%edx
    e7b4:	e8 8a fa ff ff       	call   e243 <find_entry>
    e7b9:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    e7bc:	85 c0                	test   %eax,%eax
    e7be:	75 16                	jne    e7d6 <_namei+0x79>
		iput(base);
    e7c0:	83 ec 0c             	sub    $0xc,%esp
		return NULL;
    e7c3:	31 f6                	xor    %esi,%esi
		iput(base);
    e7c5:	ff 74 24 18          	pushl  0x18(%esp)
    e7c9:	e8 5a d3 ff ff       	call   bb28 <iput>
    e7ce:	83 c4 10             	add    $0x10,%esp
		return NULL;
    e7d1:	e9 82 00 00 00       	jmp    e858 <_namei+0xfb>
	}
	// 接着取该目录项的i节点号,并释放包含该目录项的高速缓冲块并放回目录i节点.然后取对应节点号的i节点,修改其被访问时间为当前时间,并置已修改标志.最后返回
	// 该i节点指针inode.如果当前处理的目录项是一个符号链接名,则使用follow_link()得到其指向的目录项名的i节点.
	inr = de->inode;
    e7d6:	8b 54 24 1c          	mov    0x1c(%esp),%edx
	brelse(bh);
    e7da:	83 ec 0c             	sub    $0xc,%esp
	inr = de->inode;
    e7dd:	0f b7 32             	movzwl (%edx),%esi
	brelse(bh);
    e7e0:	50                   	push   %eax
    e7e1:	e8 78 db ff ff       	call   c35e <brelse>
    e7e6:	58                   	pop    %eax
    e7e7:	5a                   	pop    %edx
	if (!(inode = iget(base->i_dev, inr))) {
    e7e8:	56                   	push   %esi
    e7e9:	8b 44 24 18          	mov    0x18(%esp),%eax
    e7ed:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    e7f1:	50                   	push   %eax
    e7f2:	e8 33 d5 ff ff       	call   bd2a <iget>
    e7f7:	83 c4 10             	add    $0x10,%esp
    e7fa:	85 c0                	test   %eax,%eax
    e7fc:	89 c6                	mov    %eax,%esi
    e7fe:	75 11                	jne    e811 <_namei+0xb4>
		iput(base);
    e800:	83 ec 0c             	sub    $0xc,%esp
    e803:	ff 74 24 18          	pushl  0x18(%esp)
    e807:	e8 1c d3 ff ff       	call   bb28 <iput>
    e80c:	83 c4 10             	add    $0x10,%esp
		return NULL;
    e80f:	eb 47                	jmp    e858 <_namei+0xfb>
	}
	if (follow_links)
    e811:	85 ff                	test   %edi,%edi
    e813:	8b 44 24 0c          	mov    0xc(%esp),%eax
    e817:	74 0b                	je     e824 <_namei+0xc7>
		inode = follow_link(base, inode);
    e819:	89 f2                	mov    %esi,%edx
    e81b:	e8 41 00 00 00       	call   e861 <follow_link>
    e820:	89 c6                	mov    %eax,%esi
    e822:	eb 0c                	jmp    e830 <_namei+0xd3>
	else
		iput(base);
    e824:	83 ec 0c             	sub    $0xc,%esp
    e827:	50                   	push   %eax
    e828:	e8 fb d2 ff ff       	call   bb28 <iput>
    e82d:	83 c4 10             	add    $0x10,%esp
	inode->i_atime = CURRENT_TIME;
    e830:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    e836:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    e83c:	b9 64 00 00 00       	mov    $0x64,%ecx
	inode->i_dirt = 1;
    e841:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	inode->i_atime = CURRENT_TIME;
    e845:	8b 00                	mov    (%eax),%eax
    e847:	03 02                	add    (%edx),%eax
    e849:	31 d2                	xor    %edx,%edx
    e84b:	f7 f1                	div    %ecx
    e84d:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    e853:	03 02                	add    (%edx),%eax
    e855:	89 46 28             	mov    %eax,0x28(%esi)
	return inode;
}
    e858:	83 c4 20             	add    $0x20,%esp
    e85b:	89 f0                	mov    %esi,%eax
    e85d:	5b                   	pop    %ebx
    e85e:	5e                   	pop    %esi
    e85f:	5f                   	pop    %edi
    e860:	c3                   	ret    

0000e861 <follow_link>:
{
    e861:	55                   	push   %ebp
    e862:	57                   	push   %edi
    e863:	89 d5                	mov    %edx,%ebp
    e865:	56                   	push   %esi
    e866:	53                   	push   %ebx
    e867:	89 c6                	mov    %eax,%esi
    e869:	e8 be 81 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e86e:	81 c3 92 27 01 00    	add    $0x12792,%ebx
    e874:	83 ec 1c             	sub    $0x1c,%esp
	if (!dir) {
    e877:	85 c0                	test   %eax,%eax
    e879:	75 12                	jne    e88d <follow_link+0x2c>
		dir = current->root;
    e87b:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    e881:	8b 00                	mov    (%eax),%eax
    e883:	8b b0 38 03 00 00    	mov    0x338(%eax),%esi
		dir->i_count++;
    e889:	66 ff 46 34          	incw   0x34(%esi)
	if (!inode) {
    e88d:	85 ed                	test   %ebp,%ebp
    e88f:	74 0d                	je     e89e <follow_link+0x3d>
	if (!S_ISLNK(inode->i_mode)) {
    e891:	8b 45 00             	mov    0x0(%ebp),%eax
    e894:	66 25 00 f0          	and    $0xf000,%ax
    e898:	66 3d 00 a0          	cmp    $0xa000,%ax
    e89c:	74 0b                	je     e8a9 <follow_link+0x48>
		iput(dir);
    e89e:	83 ec 0c             	sub    $0xc,%esp
    e8a1:	56                   	push   %esi
    e8a2:	e8 81 d2 ff ff       	call   bb28 <iput>
    e8a7:	eb 75                	jmp    e91e <follow_link+0xbd>
	__asm__("mov %%fs, %0":"=r" (fs));
    e8a9:	66 8c e0             	mov    %fs,%ax
	if (fs != 0x17 || !inode->i_zone[0] ||
    e8ac:	66 83 f8 17          	cmp    $0x17,%ax
	__asm__("mov %%fs, %0":"=r" (fs));
    e8b0:	66 89 44 24 0e       	mov    %ax,0xe(%esp)
	if (fs != 0x17 || !inode->i_zone[0] ||
    e8b5:	74 18                	je     e8cf <follow_link+0x6e>
		iput(dir);
    e8b7:	83 ec 0c             	sub    $0xc,%esp
    e8ba:	56                   	push   %esi
    e8bb:	e8 68 d2 ff ff       	call   bb28 <iput>
		iput(inode);
    e8c0:	89 2c 24             	mov    %ebp,(%esp)
		return NULL;
    e8c3:	31 ed                	xor    %ebp,%ebp
		iput(inode);
    e8c5:	e8 5e d2 ff ff       	call   bb28 <iput>
    e8ca:	83 c4 10             	add    $0x10,%esp
		return NULL;
    e8cd:	eb 52                	jmp    e921 <follow_link+0xc0>
	if (fs != 0x17 || !inode->i_zone[0] ||
    e8cf:	0f b7 45 0e          	movzwl 0xe(%ebp),%eax
    e8d3:	66 85 c0             	test   %ax,%ax
    e8d6:	74 df                	je     e8b7 <follow_link+0x56>
    e8d8:	52                   	push   %edx
    e8d9:	52                   	push   %edx
    e8da:	50                   	push   %eax
	   !(bh = bread(inode->i_dev, inode->i_zone[0]))) {
    e8db:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
	if (fs != 0x17 || !inode->i_zone[0] ||
    e8df:	50                   	push   %eax
    e8e0:	e8 cb da ff ff       	call   c3b0 <bread>
    e8e5:	83 c4 10             	add    $0x10,%esp
    e8e8:	85 c0                	test   %eax,%eax
    e8ea:	89 c7                	mov    %eax,%edi
    e8ec:	74 c9                	je     e8b7 <follow_link+0x56>
	iput(inode);
    e8ee:	83 ec 0c             	sub    $0xc,%esp
    e8f1:	55                   	push   %ebp
    e8f2:	e8 31 d2 ff ff       	call   bb28 <iput>
    e8f7:	83 c4 10             	add    $0x10,%esp
	__asm__("mov %0, %%fs"::"r" ((unsigned short) 0x10));
    e8fa:	b8 10 00 00 00       	mov    $0x10,%eax
    e8ff:	8e e0                	mov    %eax,%fs
	inode = _namei(bh->b_data,dir,0);
    e901:	8b 07                	mov    (%edi),%eax
    e903:	31 c9                	xor    %ecx,%ecx
    e905:	89 f2                	mov    %esi,%edx
    e907:	e8 51 fe ff ff       	call   e75d <_namei>
    e90c:	89 c5                	mov    %eax,%ebp
	__asm__("mov %0, %%fs"::"r" (fs));
    e90e:	66 8b 44 24 0e       	mov    0xe(%esp),%ax
    e913:	8e e0                	mov    %eax,%fs
	brelse(bh);
    e915:	83 ec 0c             	sub    $0xc,%esp
    e918:	57                   	push   %edi
    e919:	e8 40 da ff ff       	call   c35e <brelse>
    e91e:	83 c4 10             	add    $0x10,%esp
}
    e921:	83 c4 1c             	add    $0x1c,%esp
    e924:	89 e8                	mov    %ebp,%eax
    e926:	5b                   	pop    %ebx
    e927:	5e                   	pop    %esi
    e928:	5f                   	pop    %edi
    e929:	5d                   	pop    %ebp
    e92a:	c3                   	ret    

0000e92b <lnamei>:
// 取指定路径名的i节点，不跟随符号链接。
// 参数：pathname - 路径名。
// 返回：对应的i节点。
struct m_inode * lnamei(const char * pathname)
{
	return _namei(pathname, NULL, 0);
    e92b:	8b 44 24 04          	mov    0x4(%esp),%eax
    e92f:	31 c9                	xor    %ecx,%ecx
    e931:	31 d2                	xor    %edx,%edx
    e933:	e9 25 fe ff ff       	jmp    e75d <_namei>

0000e938 <namei>:
// 取指定路径名的i节点,跟随符号链接.
// 参数:pathname - 路径名.
// 返回:对应的i节点.
struct m_inode * namei(const char * pathname)
{
	return _namei(pathname, NULL, 1);
    e938:	8b 44 24 04          	mov    0x4(%esp),%eax
    e93c:	b9 01 00 00 00       	mov    $0x1,%ecx
    e941:	31 d2                	xor    %edx,%edx
    e943:	e9 15 fe ff ff       	jmp    e75d <_namei>

0000e948 <open_namei>:
// 执行)等等.对于新创建的文件,这些属性只应用于将来对文件的访问,创建了只读文件的打开调用也将返回一个读写的文件句柄.如果调用
// 操作成功,则返回文件句柄(文件描述符),否则返回出错码.参见sys/stat.h,fcntl.h.
// 返回:成功返回0,否则返回出错码;res_inode - 返回对应文件路径名的i节点指针.
int open_namei(const char * pathname, int flag, int mode,
	struct m_inode ** res_inode)
{
    e948:	55                   	push   %ebp
    e949:	57                   	push   %edi
    e94a:	56                   	push   %esi
    e94b:	53                   	push   %ebx
    e94c:	e8 db 80 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    e951:	81 c3 af 26 01 00    	add    $0x126af,%ebx
    e957:	83 ec 2c             	sub    $0x2c,%esp
    e95a:	8b 74 24 44          	mov    0x44(%esp),%esi
	struct buffer_head * bh;
	struct dir_entry * de;

	// 首先对函数参数进行合理的处理.如果文件访问模式标志是只读(O),但是文件截零标志O_TRUNC却置位了,则在文件打开标志中添加只写标志
	// O_WRONLY.这样做的原因是由于截零标志O_TRUNC必须在文件可写情况下有效.
	if ((flag & O_TRUNC) && !(flag & O_ACCMODE))
    e95e:	89 f0                	mov    %esi,%eax
    e960:	25 03 02 00 00       	and    $0x203,%eax
    e965:	3d 00 02 00 00       	cmp    $0x200,%eax
    e96a:	75 03                	jne    e96f <open_namei+0x27>
		flag |= O_WRONLY;
    e96c:	83 ce 01             	or     $0x1,%esi
	// 使用当前进程的文件访问许可屏蔽码,屏蔽掉给定模式中的相应位,并添上普通文件标志I_REGULAR.
	// 该标志将用于打开的文件不存在而需要创建文件时,作为新文件的默认属性
	mode &= 0777 & ~current->umask;
    e96f:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
	mode |= I_REGULAR;													// 常规文件标志.见参见include/const.h文件.
	// 然后根据指定的路径名寻找到对应的i节点,以及最顶端目录名及其长度.此时如果最顶端目录名长度为0(例如'/usr/'这种路径名的情况),那么
	// 若操作不是读写,创建和文件长度截0,则表示是在打开一个目录名文件操作.于是直接返回该目录的i节点并返回0退出.否则说明进程操作非法,于是
	// 放回该i节点,返回出错码.
	if (!(dir = dir_namei(pathname, &namelen, &basename, NULL)))
    e975:	8d 4c 24 10          	lea    0x10(%esp),%ecx
    e979:	8d 54 24 14          	lea    0x14(%esp),%edx
    e97d:	83 ec 0c             	sub    $0xc,%esp
		return -ENOENT;
    e980:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
	mode &= 0777 & ~current->umask;
    e985:	8b 45 00             	mov    0x0(%ebp),%eax
    e988:	8b 80 30 03 00 00    	mov    0x330(%eax),%eax
    e98e:	66 89 44 24 18       	mov    %ax,0x18(%esp)
	if (!(dir = dir_namei(pathname, &namelen, &basename, NULL)))
    e993:	6a 00                	push   $0x0
    e995:	8b 44 24 50          	mov    0x50(%esp),%eax
    e999:	e8 4d fc ff ff       	call   e5eb <dir_namei>
    e99e:	83 c4 10             	add    $0x10,%esp
    e9a1:	85 c0                	test   %eax,%eax
    e9a3:	89 44 24 18          	mov    %eax,0x18(%esp)
    e9a7:	0f 84 28 02 00 00    	je     ebd5 <open_namei+0x28d>
	// 文件名字为空，则返回
	if (!namelen) {														/* special case: '/usr/' etc */
    e9ad:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    e9b1:	85 c9                	test   %ecx,%ecx
    e9b3:	75 2b                	jne    e9e0 <open_namei+0x98>
		if (!(flag & (O_ACCMODE | O_CREAT | O_TRUNC))) {
    e9b5:	89 f7                	mov    %esi,%edi
    e9b7:	81 e7 43 02 00 00    	and    $0x243,%edi
    e9bd:	75 0b                	jne    e9ca <open_namei+0x82>
			*res_inode = dir;
    e9bf:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
    e9c3:	89 01                	mov    %eax,(%ecx)
			return 0;
    e9c5:	e9 0b 02 00 00       	jmp    ebd5 <open_namei+0x28d>
		}
		iput(dir);
    e9ca:	83 ec 0c             	sub    $0xc,%esp
		return -EISDIR;
    e9cd:	bf eb ff ff ff       	mov    $0xffffffeb,%edi
		iput(dir);
    e9d2:	50                   	push   %eax
    e9d3:	e8 50 d1 ff ff       	call   bb28 <iput>
    e9d8:	83 c4 10             	add    $0x10,%esp
		return -EISDIR;
    e9db:	e9 f5 01 00 00       	jmp    ebd5 <open_namei+0x28d>
	}
	// 接着根据上面得到的最顶层目录名的i节点dir,在其中查找取得路径名字符串中最后的文件名对应的目录项结构de,并同时得到该目录项所在的高速缓冲
	// 区指针.如果该高速缓冲指针为NULL,则表示没有找到对应文件名的目录项,因此只可能是创建文件操作.此时如果不是创建文件,则放回该目录的i节点,返回
	// 出错号退出.如果用户在该目录没有写的权力,则放回该目录的i节点,返回出错号退出.
	bh = find_entry(&dir, basename, namelen, &de);
    e9e0:	8d 44 24 18          	lea    0x18(%esp),%eax
    e9e4:	83 ec 0c             	sub    $0xc,%esp
    e9e7:	8d 7c 24 28          	lea    0x28(%esp),%edi
    e9eb:	57                   	push   %edi
    e9ec:	8b 54 24 20          	mov    0x20(%esp),%edx
    e9f0:	e8 4e f8 ff ff       	call   e243 <find_entry>
    e9f5:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    e9f8:	85 c0                	test   %eax,%eax
    e9fa:	8b 4c 24 18          	mov    0x18(%esp),%ecx
    e9fe:	0f 85 f6 00 00 00    	jne    eafa <open_namei+0x1b2>
		if (!(flag & O_CREAT)) {                						// 不是创建文件，放回i节点
    ea04:	83 e6 40             	and    $0x40,%esi
    ea07:	75 16                	jne    ea1f <open_namei+0xd7>
			iput(dir);
    ea09:	83 ec 0c             	sub    $0xc,%esp
			return -ENOENT;
    ea0c:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
			iput(dir);
    ea11:	51                   	push   %ecx
    ea12:	e8 11 d1 ff ff       	call   bb28 <iput>
    ea17:	83 c4 10             	add    $0x10,%esp
			return -ENOENT;
    ea1a:	e9 b6 01 00 00       	jmp    ebd5 <open_namei+0x28d>
		}
		if (!permission(dir, MAY_WRITE)) {       						// 没有写权限，放回i节点
    ea1f:	ba 02 00 00 00       	mov    $0x2,%edx
    ea24:	89 c8                	mov    %ecx,%eax
    ea26:	e8 3d fb ff ff       	call   e568 <permission>
    ea2b:	85 c0                	test   %eax,%eax
    ea2d:	75 14                	jne    ea43 <open_namei+0xfb>
			iput(dir);
    ea2f:	83 ec 0c             	sub    $0xc,%esp
    ea32:	ff 74 24 24          	pushl  0x24(%esp)
    ea36:	e8 ed d0 ff ff       	call   bb28 <iput>
    ea3b:	83 c4 10             	add    $0x10,%esp
    ea3e:	e9 8d 01 00 00       	jmp    ebd0 <open_namei+0x288>
			return -EACCES;
		}
		// 现在我们确定了是创建操作并且有写操作许可。因此我们就在目录i节点对应设备上申请一个新的i节点给路径名上指定的文件使用。
		// 若失败则放回目录的i节点，并返回没有空间出错码。否则使用该新i节点，对其进行初始设置：置节点的用户id；对应节点访问模式；
		// 置已修改标志。然后并在指定目录dir中添加一个新目录项。
		inode = new_inode(dir->i_dev);
    ea43:	83 ec 0c             	sub    $0xc,%esp
    ea46:	8b 44 24 24          	mov    0x24(%esp),%eax
    ea4a:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    ea4e:	50                   	push   %eax
    ea4f:	e8 01 12 00 00       	call   fc55 <new_inode>
    ea54:	83 c4 10             	add    $0x10,%esp
		if (!inode) {
    ea57:	85 c0                	test   %eax,%eax
		inode = new_inode(dir->i_dev);
    ea59:	89 c6                	mov    %eax,%esi
		if (!inode) {
    ea5b:	75 05                	jne    ea62 <open_namei+0x11a>
			iput(dir);
    ea5d:	83 ec 0c             	sub    $0xc,%esp
    ea60:	eb 50                	jmp    eab2 <open_namei+0x16a>
			return -ENOSPC;
		}
		inode->i_uid = current->euid;
    ea62:	8b 45 00             	mov    0x0(%ebp),%eax
		inode->i_mode = mode;
		inode->i_dirt = 1;
		bh = add_entry(dir, basename, namelen, &de);
    ea65:	83 ec 0c             	sub    $0xc,%esp
		inode->i_uid = current->euid;
    ea68:	66 8b 80 ce 02 00 00 	mov    0x2ce(%eax),%ax
		inode->i_dirt = 1;
    ea6f:	c6 46 37 01          	movb   $0x1,0x37(%esi)
		inode->i_uid = current->euid;
    ea73:	66 89 46 02          	mov    %ax,0x2(%esi)
	mode &= 0777 & ~current->umask;
    ea77:	8b 44 24 18          	mov    0x18(%esp),%eax
    ea7b:	f7 d0                	not    %eax
    ea7d:	25 ff 01 00 00       	and    $0x1ff,%eax
    ea82:	23 44 24 54          	and    0x54(%esp),%eax
	mode |= I_REGULAR;													// 常规文件标志.见参见include/const.h文件.
    ea86:	80 cc 80             	or     $0x80,%ah
		inode->i_mode = mode;
    ea89:	66 89 06             	mov    %ax,(%esi)
		bh = add_entry(dir, basename, namelen, &de);
    ea8c:	57                   	push   %edi
    ea8d:	8b 4c 24 24          	mov    0x24(%esp),%ecx
    ea91:	8b 54 24 20          	mov    0x20(%esp),%edx
    ea95:	8b 44 24 28          	mov    0x28(%esp),%eax
    ea99:	e8 57 f9 ff ff       	call   e3f5 <add_entry>
    ea9e:	83 c4 10             	add    $0x10,%esp
		// 如果返回的应该含有新目录项的调整缓冲区指针为NULL，则表示添加目录项操作失败。于是将该新i节点的引用连接计数减1,放回该
		// i节点与目录的i节点并返回出错码退出。否则说明添加目录项操作成功。于是我们来设置该新目录项的一些初始值：置i节点号为新申
		// 请到的i节点的号码；并置高速缓冲区修改标志。然后释放该高速缓冲区，放回目录的i节点。返回新目录项的i节点指针，并成功退出。
		if (!bh) {
    eaa1:	85 c0                	test   %eax,%eax
    eaa3:	75 23                	jne    eac8 <open_namei+0x180>
			inode->i_nlinks--;
    eaa5:	fe 4e 0d             	decb   0xd(%esi)
			iput(inode);
    eaa8:	83 ec 0c             	sub    $0xc,%esp
    eaab:	56                   	push   %esi
    eaac:	e8 77 d0 ff ff       	call   bb28 <iput>
    eab1:	59                   	pop    %ecx
			iput(dir);
    eab2:	ff 74 24 24          	pushl  0x24(%esp)
			return -ENOSPC;
    eab6:	bf e4 ff ff ff       	mov    $0xffffffe4,%edi
			iput(dir);
    eabb:	e8 68 d0 ff ff       	call   bb28 <iput>
    eac0:	83 c4 10             	add    $0x10,%esp
			return -ENOSPC;
    eac3:	e9 0d 01 00 00       	jmp    ebd5 <open_namei+0x28d>
		}
		de->inode = inode->i_num;
    eac8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
    eacc:	66 8b 4e 32          	mov    0x32(%esi),%cx
		bh->b_dirt = 1;
		brelse(bh);
    ead0:	83 ec 0c             	sub    $0xc,%esp
		iput(dir);
		*res_inode = inode;
		return 0;
    ead3:	31 ff                	xor    %edi,%edi
		de->inode = inode->i_num;
    ead5:	66 89 0a             	mov    %cx,(%edx)
		bh->b_dirt = 1;
    ead8:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
		brelse(bh);
    eadc:	50                   	push   %eax
    eadd:	e8 7c d8 ff ff       	call   c35e <brelse>
    eae2:	5a                   	pop    %edx
		iput(dir);
    eae3:	ff 74 24 24          	pushl  0x24(%esp)
    eae7:	e8 3c d0 ff ff       	call   bb28 <iput>
    eaec:	83 c4 10             	add    $0x10,%esp
		*res_inode = inode;
    eaef:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    eaf3:	89 30                	mov    %esi,(%eax)
		return 0;
    eaf5:	e9 db 00 00 00       	jmp    ebd5 <open_namei+0x28d>
    }
	// 若上面(411行)在目录中取文件名对应目录项结构的操作成功(即bh不为NULL),则说明指定打开的文件已经存在.于是取出该目录项的i节点和其所在设备号,并释放
	// 该高速缓冲区以及放回目录的i节点.如果此时独占操作标志O_EXCL置位,但现在文件已经存在,则返回文件已存在出错码退出.
	inr = de->inode;
    eafa:	8b 54 24 1c          	mov    0x1c(%esp),%edx
	dev = dir->i_dev;
	brelse(bh);
    eafe:	83 ec 0c             	sub    $0xc,%esp
	if (flag & O_EXCL) {
    eb01:	89 f7                	mov    %esi,%edi
	inr = de->inode;
    eb03:	0f b7 2a             	movzwl (%edx),%ebp
	dev = dir->i_dev;
    eb06:	0f b7 51 30          	movzwl 0x30(%ecx),%edx
    eb0a:	89 54 24 18          	mov    %edx,0x18(%esp)
	brelse(bh);
    eb0e:	50                   	push   %eax
    eb0f:	e8 4a d8 ff ff       	call   c35e <brelse>
    eb14:	83 c4 10             	add    $0x10,%esp
	if (flag & O_EXCL) {
    eb17:	81 e7 80 00 00 00    	and    $0x80,%edi
    eb1d:	8b 54 24 0c          	mov    0xc(%esp),%edx
    eb21:	74 19                	je     eb3c <open_namei+0x1f4>
		iput(dir);
    eb23:	83 ec 0c             	sub    $0xc,%esp
		return -EEXIST;
    eb26:	bf ef ff ff ff       	mov    $0xffffffef,%edi
		iput(dir);
    eb2b:	ff 74 24 24          	pushl  0x24(%esp)
    eb2f:	e8 f4 cf ff ff       	call   bb28 <iput>
    eb34:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
    eb37:	e9 99 00 00 00       	jmp    ebd5 <open_namei+0x28d>
	}
	// 然后我们读取该目录项的i节点内容.若该i节点是一个目录的i节点并且访问模式是只写或读写,或者没有访问的许可权限,则放回该i节点,返回访问权限出错码退出.
	if (!(inode = follow_link(dir, iget(dev, inr))))
    eb3c:	50                   	push   %eax
    eb3d:	50                   	push   %eax
    eb3e:	55                   	push   %ebp
    eb3f:	52                   	push   %edx
    eb40:	e8 e5 d1 ff ff       	call   bd2a <iget>
    eb45:	83 c4 10             	add    $0x10,%esp
    eb48:	89 c2                	mov    %eax,%edx
    eb4a:	8b 44 24 18          	mov    0x18(%esp),%eax
    eb4e:	e8 0e fd ff ff       	call   e861 <follow_link>
    eb53:	85 c0                	test   %eax,%eax
    eb55:	89 c5                	mov    %eax,%ebp
    eb57:	74 77                	je     ebd0 <open_namei+0x288>
		return -EACCES;
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
    eb59:	8b 00                	mov    (%eax),%eax
    eb5b:	89 f2                	mov    %esi,%edx
    eb5d:	83 e2 03             	and    $0x3,%edx
    eb60:	66 25 00 f0          	and    $0xf000,%ax
    eb64:	66 3d 00 40          	cmp    $0x4000,%ax
    eb68:	75 15                	jne    eb7f <open_namei+0x237>
    eb6a:	85 d2                	test   %edx,%edx
    eb6c:	74 11                	je     eb7f <open_namei+0x237>
	    !permission(inode, ACC_MODE(flag))) {
		iput(inode);
    eb6e:	83 ec 0c             	sub    $0xc,%esp
		return -EPERM;
    eb71:	83 cf ff             	or     $0xffffffff,%edi
		iput(inode);
    eb74:	55                   	push   %ebp
    eb75:	e8 ae cf ff ff       	call   bb28 <iput>
    eb7a:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    eb7d:	eb 56                	jmp    ebd5 <open_namei+0x28d>
	    !permission(inode, ACC_MODE(flag))) {
    eb7f:	0f be 94 13 28 75 ff 	movsbl -0x8ad8(%ebx,%edx,1),%edx
    eb86:	ff 
    eb87:	89 e8                	mov    %ebp,%eax
    eb89:	e8 da f9 ff ff       	call   e568 <permission>
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
    eb8e:	85 c0                	test   %eax,%eax
    eb90:	74 dc                	je     eb6e <open_namei+0x226>
	}
	// 接着我们更新该i节点的访问时间字段值为当前时间.如果设立了截0标志,则将该i节点的文件长度截为0.最后返回该目录项i节点的指针.并返回0(成功).
	inode->i_atime = CURRENT_TIME;
    eb92:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    eb98:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    eb9e:	b9 64 00 00 00       	mov    $0x64,%ecx
    eba3:	8b 00                	mov    (%eax),%eax
    eba5:	03 02                	add    (%edx),%eax
    eba7:	31 d2                	xor    %edx,%edx
    eba9:	f7 f1                	div    %ecx
    ebab:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    ebb1:	03 02                	add    (%edx),%eax
	if (flag & O_TRUNC)
    ebb3:	0f ba e6 09          	bt     $0x9,%esi
	inode->i_atime = CURRENT_TIME;
    ebb7:	89 45 28             	mov    %eax,0x28(%ebp)
	if (flag & O_TRUNC)
    ebba:	73 0c                	jae    ebc8 <open_namei+0x280>
		truncate(inode);
    ebbc:	83 ec 0c             	sub    $0xc,%esp
    ebbf:	55                   	push   %ebp
    ebc0:	e8 86 14 00 00       	call   1004b <truncate>
    ebc5:	83 c4 10             	add    $0x10,%esp
	*res_inode = inode;
    ebc8:	8b 44 24 4c          	mov    0x4c(%esp),%eax
    ebcc:	89 28                	mov    %ebp,(%eax)
	return 0;
    ebce:	eb 05                	jmp    ebd5 <open_namei+0x28d>
		return -EACCES;
    ebd0:	bf f3 ff ff ff       	mov    $0xfffffff3,%edi
}
    ebd5:	83 c4 2c             	add    $0x2c,%esp
    ebd8:	89 f8                	mov    %edi,%eax
    ebda:	5b                   	pop    %ebx
    ebdb:	5e                   	pop    %esi
    ebdc:	5f                   	pop    %edi
    ebdd:	5d                   	pop    %ebp
    ebde:	c3                   	ret    

0000ebdf <sys_mknod>:

// 创建一个设备特殊文件或普通文件节点（node）。
// 该函数创建名称为filename，由mode和dev指定的文件系统节点（普通文件、设备特殊文件或命名管道）。
// 参数：filename - 路径名；mode - 指定使用许可以及所创建节点的类型；dev - 设备号。
int sys_mknod(const char * filename, int mode, int dev)
{
    ebdf:	55                   	push   %ebp
    ebe0:	57                   	push   %edi
	struct dir_entry * de;

	// 首先检查操作许可和参数的有效性并取路径名中顶层目录的i节点。如果不是超级用户，则返回访问许可出错码。
	// 如果不是超级用户，则返回访问许可出错码。
	if (!suser())
		return -EPERM;
    ebe1:	83 ca ff             	or     $0xffffffff,%edx
{
    ebe4:	56                   	push   %esi
    ebe5:	53                   	push   %ebx
    ebe6:	e8 41 7e ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ebeb:	81 c3 15 24 01 00    	add    $0x12415,%ebx
    ebf1:	83 ec 1c             	sub    $0x1c,%esp
	if (!suser())
    ebf4:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
{
    ebfa:	8b 7c 24 34          	mov    0x34(%esp),%edi
	if (!suser())
    ebfe:	8b 00                	mov    (%eax),%eax
    ec00:	66 83 b8 ce 02 00 00 	cmpw   $0x0,0x2ce(%eax)
    ec07:	00 
    ec08:	0f 85 81 01 00 00    	jne    ed8f <sys_mknod+0x1b0>
	// 如果找不到对应路径名中顶层目录的i节点，则返回出错码。
	if (!(dir = dir_namei(filename, &namelen, &basename, NULL)))
    ec0e:	8d 54 24 04          	lea    0x4(%esp),%edx
    ec12:	89 e1                	mov    %esp,%ecx
    ec14:	83 ec 0c             	sub    $0xc,%esp
    ec17:	6a 00                	push   $0x0
    ec19:	8b 44 24 40          	mov    0x40(%esp),%eax
    ec1d:	e8 c9 f9 ff ff       	call   e5eb <dir_namei>
    ec22:	83 c4 10             	add    $0x10,%esp
    ec25:	85 c0                	test   %eax,%eax
    ec27:	89 44 24 08          	mov    %eax,0x8(%esp)
		return -ENOENT;
    ec2b:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
	if (!(dir = dir_namei(filename, &namelen, &basename, NULL)))
    ec30:	0f 84 59 01 00 00    	je     ed8f <sys_mknod+0x1b0>
	// 如果最顶端的文件名长度为0，则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。
	if (!namelen) {
    ec36:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    ec3b:	75 16                	jne    ec53 <sys_mknod+0x74>
		iput(dir);
    ec3d:	83 ec 0c             	sub    $0xc,%esp
    ec40:	50                   	push   %eax
    ec41:	e8 e2 ce ff ff       	call   bb28 <iput>
    ec46:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
    ec49:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    ec4e:	e9 3c 01 00 00       	jmp    ed8f <sys_mknod+0x1b0>
	}
	// 如果在该目录中没有写的权限，则放回该目录的i节点，返回访问许可出错码退出。
	if (!permission(dir, MAY_WRITE)) {
    ec53:	ba 02 00 00 00       	mov    $0x2,%edx
    ec58:	e8 0b f9 ff ff       	call   e568 <permission>
    ec5d:	85 c0                	test   %eax,%eax
    ec5f:	75 17                	jne    ec78 <sys_mknod+0x99>
		iput(dir);
    ec61:	83 ec 0c             	sub    $0xc,%esp
    ec64:	ff 74 24 14          	pushl  0x14(%esp)
    ec68:	e8 bb ce ff ff       	call   bb28 <iput>
    ec6d:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    ec70:	83 ca ff             	or     $0xffffffff,%edx
    ec73:	e9 17 01 00 00       	jmp    ed8f <sys_mknod+0x1b0>
	}
	// 然后我们搜索一下路径名指定的文件是否已经存在。若已经存在则不能创建同名文件节点。如果对应路径名上最后的文件名的
	// 目录项已经存在，则释放包含该目录项的缓冲区块并放回目录的i节点，返回文件已经存在的出错退出。
	bh = find_entry(&dir, basename, namelen, &de);
    ec78:	8d 44 24 08          	lea    0x8(%esp),%eax
    ec7c:	83 ec 0c             	sub    $0xc,%esp
    ec7f:	8d 6c 24 18          	lea    0x18(%esp),%ebp
    ec83:	55                   	push   %ebp
    ec84:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    ec88:	8b 54 24 10          	mov    0x10(%esp),%edx
    ec8c:	e8 b2 f5 ff ff       	call   e243 <find_entry>
    ec91:	83 c4 10             	add    $0x10,%esp
	if (bh) {
    ec94:	85 c0                	test   %eax,%eax
    ec96:	74 20                	je     ecb8 <sys_mknod+0xd9>
		brelse(bh);
    ec98:	83 ec 0c             	sub    $0xc,%esp
    ec9b:	50                   	push   %eax
    ec9c:	e8 bd d6 ff ff       	call   c35e <brelse>
    eca1:	58                   	pop    %eax
		iput(dir);
    eca2:	ff 74 24 14          	pushl  0x14(%esp)
    eca6:	e8 7d ce ff ff       	call   bb28 <iput>
    ecab:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
    ecae:	ba ef ff ff ff       	mov    $0xffffffef,%edx
    ecb3:	e9 d7 00 00 00       	jmp    ed8f <sys_mknod+0x1b0>
	}
	// 否则我们就申请一个新的i节点，并设置该i节点的属性模式。
	inode = new_inode(dir->i_dev);
    ecb8:	83 ec 0c             	sub    $0xc,%esp
    ecbb:	8b 44 24 14          	mov    0x14(%esp),%eax
    ecbf:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    ecc3:	50                   	push   %eax
    ecc4:	e8 8c 0f 00 00       	call   fc55 <new_inode>
    ecc9:	83 c4 10             	add    $0x10,%esp
	if (!inode) {
    eccc:	85 c0                	test   %eax,%eax
	inode = new_inode(dir->i_dev);
    ecce:	89 c6                	mov    %eax,%esi
	if (!inode) {
    ecd0:	75 09                	jne    ecdb <sys_mknod+0xfc>
		iput(dir);
    ecd2:	83 ec 0c             	sub    $0xc,%esp
    ecd5:	ff 74 24 14          	pushl  0x14(%esp)
    ecd9:	eb 75                	jmp    ed50 <sys_mknod+0x171>
		return -ENOSPC;
	}
	inode->i_mode = mode;
    ecdb:	66 89 38             	mov    %di,(%eax)
	// 如果要创建的是块设备文件或者是字符设备文件，则令i节点的直接逻辑块指针0等于设备号。即对于设备文件来说，
	// 其i节点的i_zone[0]中存放的是该设备文件所定义设备的设备号。
	if (S_ISBLK(mode) || S_ISCHR(mode))
    ecde:	81 e7 00 b0 00 00    	and    $0xb000,%edi
    ece4:	81 ff 00 20 00 00    	cmp    $0x2000,%edi
    ecea:	75 08                	jne    ecf4 <sys_mknod+0x115>
		inode->i_zone[0] = dev;
    ecec:	8b 44 24 38          	mov    0x38(%esp),%eax
    ecf0:	66 89 46 0e          	mov    %ax,0xe(%esi)
	// 设置该i节点的修改时间、访问时间为当前时间，并设置i节点已修改标志。
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
    ecf4:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    ecfa:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    ed00:	b9 64 00 00 00       	mov    $0x64,%ecx
	inode->i_dirt = 1;
	// 接着为这个新的i节点在目录中新添加一个目录项。如果失败（包含该目录项的高速缓冲块指针为NULL），则放回目录的i节点；
	// 把所申请的i节点引用连接计数复位，并放回该i节点，返回出错码退出。
	bh = add_entry(dir, basename, namelen, &de);
    ed05:	83 ec 0c             	sub    $0xc,%esp
	inode->i_dirt = 1;
    ed08:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
    ed0c:	8b 00                	mov    (%eax),%eax
    ed0e:	03 02                	add    (%edx),%eax
    ed10:	31 d2                	xor    %edx,%edx
    ed12:	f7 f1                	div    %ecx
    ed14:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    ed1a:	03 02                	add    (%edx),%eax
    ed1c:	89 46 28             	mov    %eax,0x28(%esi)
    ed1f:	89 46 08             	mov    %eax,0x8(%esi)
	bh = add_entry(dir, basename, namelen, &de);
    ed22:	55                   	push   %ebp
    ed23:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    ed27:	8b 54 24 10          	mov    0x10(%esp),%edx
    ed2b:	8b 44 24 18          	mov    0x18(%esp),%eax
    ed2f:	e8 c1 f6 ff ff       	call   e3f5 <add_entry>
    ed34:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    ed37:	85 c0                	test   %eax,%eax
	bh = add_entry(dir, basename, namelen, &de);
    ed39:	89 c7                	mov    %eax,%edi
	if (!bh) {
    ed3b:	75 22                	jne    ed5f <sys_mknod+0x180>
		iput(dir);
    ed3d:	83 ec 0c             	sub    $0xc,%esp
    ed40:	ff 74 24 14          	pushl  0x14(%esp)
    ed44:	e8 df cd ff ff       	call   bb28 <iput>
		inode->i_nlinks = 0;
    ed49:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
		iput(inode);
    ed4d:	89 34 24             	mov    %esi,(%esp)
    ed50:	e8 d3 cd ff ff       	call   bb28 <iput>
    ed55:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
    ed58:	ba e4 ff ff ff       	mov    $0xffffffe4,%edx
    ed5d:	eb 30                	jmp    ed8f <sys_mknod+0x1b0>
	}
	// 现在添加目录项操作也成功了，于是我们来设置这个目录项内容。令该目录项的i节点字段等于新i节点号，并置高速缓冲区已修
	// 改标志，放回目录和新的i节点，释放高速缓冲区，最后返回0（成功）。
	de->inode = inode->i_num;
    ed5f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    ed63:	66 8b 56 32          	mov    0x32(%esi),%dx
	bh->b_dirt = 1;
	iput(dir);
    ed67:	83 ec 0c             	sub    $0xc,%esp
	de->inode = inode->i_num;
    ed6a:	66 89 10             	mov    %dx,(%eax)
	bh->b_dirt = 1;
    ed6d:	c6 47 0b 01          	movb   $0x1,0xb(%edi)
	iput(dir);
    ed71:	ff 74 24 14          	pushl  0x14(%esp)
    ed75:	e8 ae cd ff ff       	call   bb28 <iput>
	iput(inode);
    ed7a:	89 34 24             	mov    %esi,(%esp)
    ed7d:	e8 a6 cd ff ff       	call   bb28 <iput>
	brelse(bh);
    ed82:	89 3c 24             	mov    %edi,(%esp)
    ed85:	e8 d4 d5 ff ff       	call   c35e <brelse>
    ed8a:	83 c4 10             	add    $0x10,%esp
	return 0;
    ed8d:	31 d2                	xor    %edx,%edx
}
    ed8f:	83 c4 1c             	add    $0x1c,%esp
    ed92:	89 d0                	mov    %edx,%eax
    ed94:	5b                   	pop    %ebx
    ed95:	5e                   	pop    %esi
    ed96:	5f                   	pop    %edi
    ed97:	5d                   	pop    %ebp
    ed98:	c3                   	ret    

0000ed99 <sys_mkdir>:

// 创建一个目录。
// 参数：pathname - 路径名；mode - 目录使用的权限属性。
// 返回：成功则返回0,否则返回出错码。
int sys_mkdir(const char * pathname, int mode)
{
    ed99:	55                   	push   %ebp
    ed9a:	57                   	push   %edi
    ed9b:	56                   	push   %esi
    ed9c:	53                   	push   %ebx
    ed9d:	e8 8a 7c ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    eda2:	81 c3 5e 22 01 00    	add    $0x1225e,%ebx
    eda8:	83 ec 2c             	sub    $0x2c,%esp
	struct m_inode * dir, * inode;
	struct buffer_head * bh, *dir_block;
	struct dir_entry * de;

	// 首先检查参数的有效性并取路径名中顶层目录的i节点。如果找不到对应路径名中顶层目录的i节点，则返回出错码。
	if (!(dir = dir_namei(pathname,&namelen,&basename, NULL)))
    edab:	8d 54 24 14          	lea    0x14(%esp),%edx
    edaf:	8d 4c 24 10          	lea    0x10(%esp),%ecx
    edb3:	83 ec 0c             	sub    $0xc,%esp
    edb6:	6a 00                	push   $0x0
    edb8:	8b 44 24 50          	mov    0x50(%esp),%eax
    edbc:	e8 2a f8 ff ff       	call   e5eb <dir_namei>
    edc1:	83 c4 10             	add    $0x10,%esp
    edc4:	85 c0                	test   %eax,%eax
    edc6:	89 44 24 18          	mov    %eax,0x18(%esp)
		return -ENOENT;
    edca:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
	if (!(dir = dir_namei(pathname,&namelen,&basename, NULL)))
    edcf:	0f 84 35 02 00 00    	je     f00a <sys_mkdir+0x271>
	// 如果最顶端文件名长度为0,则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。
	if (!namelen) {
    edd5:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    edda:	75 16                	jne    edf2 <sys_mkdir+0x59>
		iput(dir);
    eddc:	83 ec 0c             	sub    $0xc,%esp
    eddf:	50                   	push   %eax
    ede0:	e8 43 cd ff ff       	call   bb28 <iput>
    ede5:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
    ede8:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    eded:	e9 18 02 00 00       	jmp    f00a <sys_mkdir+0x271>
	}
	// 如果在该目录中没有写的权限，则放回该目录i节点，返回访问许可出错码退出。
	// 如果不是超级用户，则返回访问许可出错码。
	if (!permission(dir, MAY_WRITE)) {
    edf2:	ba 02 00 00 00       	mov    $0x2,%edx
    edf7:	e8 6c f7 ff ff       	call   e568 <permission>
    edfc:	85 c0                	test   %eax,%eax
    edfe:	75 17                	jne    ee17 <sys_mkdir+0x7e>
		iput(dir);
    ee00:	83 ec 0c             	sub    $0xc,%esp
    ee03:	ff 74 24 24          	pushl  0x24(%esp)
    ee07:	e8 1c cd ff ff       	call   bb28 <iput>
    ee0c:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    ee0f:	83 ca ff             	or     $0xffffffff,%edx
    ee12:	e9 f3 01 00 00       	jmp    f00a <sys_mkdir+0x271>
	}
	// 然后我们搜索一下路径名指定的目录名是否已经存在。若已经存在则不能创建同名目录节点。如果对应路径名上最后的目录名的目录
	// 项已经存在，则释放包含该目录项的缓冲区块并放回目录的i节点，返回文件已经存在 的出错码退出。否则我们就申请一个新的i节
	// 点，并设置该i节点的属性模式：置该新i节点对应的文件长度为32字节（2个目录项的大小）、置节点已修改标志，以及节点的修改
	// 时间和访问时间。2个目录项分别用于'.'和'..'目录。
	bh = find_entry(&dir, basename, namelen, &de);
    ee17:	8d 44 24 18          	lea    0x18(%esp),%eax
    ee1b:	83 ec 0c             	sub    $0xc,%esp
    ee1e:	8d 7c 24 28          	lea    0x28(%esp),%edi
    ee22:	89 7c 24 18          	mov    %edi,0x18(%esp)
    ee26:	57                   	push   %edi
    ee27:	8b 4c 24 24          	mov    0x24(%esp),%ecx
    ee2b:	8b 54 24 20          	mov    0x20(%esp),%edx
    ee2f:	e8 0f f4 ff ff       	call   e243 <find_entry>
    ee34:	83 c4 10             	add    $0x10,%esp
	if (bh) {
    ee37:	85 c0                	test   %eax,%eax
    ee39:	74 20                	je     ee5b <sys_mkdir+0xc2>
		brelse(bh);
    ee3b:	83 ec 0c             	sub    $0xc,%esp
    ee3e:	50                   	push   %eax
    ee3f:	e8 1a d5 ff ff       	call   c35e <brelse>
    ee44:	59                   	pop    %ecx
		iput(dir);
    ee45:	ff 74 24 24          	pushl  0x24(%esp)
    ee49:	e8 da cc ff ff       	call   bb28 <iput>
    ee4e:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
    ee51:	ba ef ff ff ff       	mov    $0xffffffef,%edx
    ee56:	e9 af 01 00 00       	jmp    f00a <sys_mkdir+0x271>
	}
	inode = new_inode(dir->i_dev);
    ee5b:	83 ec 0c             	sub    $0xc,%esp
    ee5e:	8b 44 24 24          	mov    0x24(%esp),%eax
    ee62:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    ee66:	50                   	push   %eax
    ee67:	e8 e9 0d 00 00       	call   fc55 <new_inode>
    ee6c:	83 c4 10             	add    $0x10,%esp
	if (!inode) {           						// 若不成功则放回目录的i节点，返回无空间出错码。
    ee6f:	85 c0                	test   %eax,%eax
	inode = new_inode(dir->i_dev);
    ee71:	89 c5                	mov    %eax,%ebp
	if (!inode) {           						// 若不成功则放回目录的i节点，返回无空间出错码。
    ee73:	75 09                	jne    ee7e <sys_mkdir+0xe5>
		iput(dir);
    ee75:	83 ec 0c             	sub    $0xc,%esp
    ee78:	ff 74 24 24          	pushl  0x24(%esp)
    ee7c:	eb 5d                	jmp    eedb <sys_mkdir+0x142>
		return -ENOSPC;
	}
	inode->i_size = 32;
	inode->i_dirt = 1;
    ee7e:	c6 40 37 01          	movb   $0x1,0x37(%eax)
	inode->i_size = 32;
    ee82:	c7 40 04 20 00 00 00 	movl   $0x20,0x4(%eax)
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
    ee89:	b9 64 00 00 00       	mov    $0x64,%ecx
    ee8e:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    ee94:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
	// 接着为该新i节点申请一用于保存目录项数据的磁盘块，并令i节点的第一个直接块指针等于该块号。如果申请失败则放回对应目录
	// 的i节点；复位新申请的i节点连接计数；放回该新的i节点，返回没有空间出错码退出。否则置该新的i节点已修改标志。
	if (!(inode->i_zone[0] = new_block(inode->i_dev))) {
    ee9a:	83 ec 0c             	sub    $0xc,%esp
	inode->i_mtime = inode->i_atime = CURRENT_TIME;
    ee9d:	8b 00                	mov    (%eax),%eax
    ee9f:	03 02                	add    (%edx),%eax
    eea1:	31 d2                	xor    %edx,%edx
    eea3:	f7 f1                	div    %ecx
    eea5:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    eeab:	03 02                	add    (%edx),%eax
    eead:	89 45 28             	mov    %eax,0x28(%ebp)
    eeb0:	89 45 08             	mov    %eax,0x8(%ebp)
	if (!(inode->i_zone[0] = new_block(inode->i_dev))) {
    eeb3:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    eeb7:	50                   	push   %eax
    eeb8:	e8 3f 0b 00 00       	call   f9fc <new_block>
    eebd:	83 c4 10             	add    $0x10,%esp
    eec0:	66 85 c0             	test   %ax,%ax
    eec3:	66 89 45 0e          	mov    %ax,0xe(%ebp)
    eec7:	75 24                	jne    eeed <sys_mkdir+0x154>
		iput(dir);
    eec9:	83 ec 0c             	sub    $0xc,%esp
    eecc:	ff 74 24 24          	pushl  0x24(%esp)
    eed0:	e8 53 cc ff ff       	call   bb28 <iput>
		inode->i_nlinks--;
    eed5:	fe 4d 0d             	decb   0xd(%ebp)
		iput(inode);
    eed8:	89 2c 24             	mov    %ebp,(%esp)
    eedb:	e8 48 cc ff ff       	call   bb28 <iput>
    eee0:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
    eee3:	ba e4 ff ff ff       	mov    $0xffffffe4,%edx
    eee8:	e9 1d 01 00 00       	jmp    f00a <sys_mkdir+0x271>
	}
	inode->i_dirt = 1;
	// 从设备上读取新申请的磁盘块（目的是把对应块放到高速缓冲区中）。若出错，则放回对应目录的i节点；释放申请的磁盘块；复位新
	// 申请的i节点连接计数；放回该新的i节点，返回没有空间出错码退出。
	if (!(dir_block = bread(inode->i_dev, inode->i_zone[0]))) {
    eeed:	0f b7 c0             	movzwl %ax,%eax
	inode->i_dirt = 1;
    eef0:	c6 45 37 01          	movb   $0x1,0x37(%ebp)
	if (!(dir_block = bread(inode->i_dev, inode->i_zone[0]))) {
    eef4:	52                   	push   %edx
    eef5:	52                   	push   %edx
    eef6:	50                   	push   %eax
    eef7:	0f b7 45 30          	movzwl 0x30(%ebp),%eax
    eefb:	50                   	push   %eax
    eefc:	e8 af d4 ff ff       	call   c3b0 <bread>
    ef01:	83 c4 10             	add    $0x10,%esp
    ef04:	85 c0                	test   %eax,%eax
    ef06:	89 c2                	mov    %eax,%edx
    ef08:	75 24                	jne    ef2e <sys_mkdir+0x195>
		iput(dir);
    ef0a:	83 ec 0c             	sub    $0xc,%esp
    ef0d:	ff 74 24 24          	pushl  0x24(%esp)
    ef11:	e8 12 cc ff ff       	call   bb28 <iput>
		inode->i_nlinks--;
    ef16:	fe 4d 0d             	decb   0xd(%ebp)
		iput(inode);
    ef19:	89 2c 24             	mov    %ebp,(%esp)
    ef1c:	e8 07 cc ff ff       	call   bb28 <iput>
    ef21:	83 c4 10             	add    $0x10,%esp
		return -ERROR;
    ef24:	ba 9d ff ff ff       	mov    $0xffffff9d,%edx
    ef29:	e9 dc 00 00 00       	jmp    f00a <sys_mkdir+0x271>
	}
	// 然后我们在缓冲块中建立起所创建目录文件中的2个默认的新目录项（'.'和'..'）结构数据。首先令de指向存放目录项的数据块，然
	// 后置该目录项的i节点号字段等于新申请的i节点号，名字字段等于“.”。然后de指向下一个目录项结构，并在该结构中存放上级目录的
	// i节点号和名字“..”。然后设置该高速缓冲块已修改标志，并释放该缓冲区块。再初始化设置新i节点的模式字段，并置该i节点已修改
	// 标志。
	de = (struct dir_entry *) dir_block->b_data;
    ef2e:	8b 08                	mov    (%eax),%ecx
	de->inode = inode->i_num;         				// 设置'.'目录项。
    ef30:	66 8b 45 32          	mov    0x32(%ebp),%ax
__asm__(
    ef34:	8d b3 2e 75 ff ff    	lea    -0x8ad2(%ebx),%esi
    ef3a:	66 89 01             	mov    %ax,(%ecx)
	strcpy(de->name, ".");
    ef3d:	8d 79 02             	lea    0x2(%ecx),%edi
    ef40:	fc                   	cld    
    ef41:	ac                   	lods   %ds:(%esi),%al
    ef42:	aa                   	stos   %al,%es:(%edi)
    ef43:	84 c0                	test   %al,%al
    ef45:	75 fa                	jne    ef41 <sys_mkdir+0x1a8>
	de++;
    ef47:	8d 41 10             	lea    0x10(%ecx),%eax
	de->inode = dir->i_num;         				// 设置'..'目录项。
	strcpy(de->name, "..");
    ef4a:	8d 79 12             	lea    0x12(%ecx),%edi
    ef4d:	8d b3 2d 75 ff ff    	lea    -0x8ad3(%ebx),%esi
	de++;
    ef53:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	de->inode = dir->i_num;         				// 设置'..'目录项。
    ef57:	8b 44 24 18          	mov    0x18(%esp),%eax
    ef5b:	66 8b 40 32          	mov    0x32(%eax),%ax
    ef5f:	66 89 41 10          	mov    %ax,0x10(%ecx)
    ef63:	fc                   	cld    
    ef64:	ac                   	lods   %ds:(%esi),%al
    ef65:	aa                   	stos   %al,%es:(%edi)
    ef66:	84 c0                	test   %al,%al
    ef68:	75 fa                	jne    ef64 <sys_mkdir+0x1cb>
	inode->i_nlinks = 2;
	dir_block->b_dirt = 1;
	brelse(dir_block);
    ef6a:	83 ec 0c             	sub    $0xc,%esp
	inode->i_nlinks = 2;
    ef6d:	c6 45 0d 02          	movb   $0x2,0xd(%ebp)
	dir_block->b_dirt = 1;
    ef71:	c6 42 0b 01          	movb   $0x1,0xb(%edx)
	brelse(dir_block);
    ef75:	52                   	push   %edx
    ef76:	e8 e3 d3 ff ff       	call   c35e <brelse>
    ef7b:	58                   	pop    %eax
	inode->i_mode = I_DIRECTORY | (mode & 0777 & ~current->umask);
    ef7c:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    ef82:	8b 00                	mov    (%eax),%eax
    ef84:	8b 80 30 03 00 00    	mov    0x330(%eax),%eax
	inode->i_dirt = 1;
    ef8a:	c6 45 37 01          	movb   $0x1,0x37(%ebp)
	inode->i_mode = I_DIRECTORY | (mode & 0777 & ~current->umask);
    ef8e:	f7 d0                	not    %eax
    ef90:	23 44 24 50          	and    0x50(%esp),%eax
    ef94:	66 25 ff 01          	and    $0x1ff,%ax
    ef98:	80 cc 40             	or     $0x40,%ah
    ef9b:	66 89 45 00          	mov    %ax,0x0(%ebp)
	// 现在我们在指定目录中新添加一个目录项，用于存放新建目录的i节点和目录名。如果失败（包含该目录项的高速缓冲区指针为NULL），
	// 则放回目录的i节点；所申请的i节点引用连接计数复位，并放回该i节点。返回出错码退出。
	bh = add_entry(dir, basename, namelen, &de);
    ef9f:	ff 74 24 18          	pushl  0x18(%esp)
    efa3:	8b 4c 24 24          	mov    0x24(%esp),%ecx
    efa7:	8b 54 24 20          	mov    0x20(%esp),%edx
    efab:	8b 44 24 28          	mov    0x28(%esp),%eax
    efaf:	e8 41 f4 ff ff       	call   e3f5 <add_entry>
    efb4:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    efb7:	85 c0                	test   %eax,%eax
	bh = add_entry(dir, basename, namelen, &de);
    efb9:	89 c6                	mov    %eax,%esi
	if (!bh) {
    efbb:	75 15                	jne    efd2 <sys_mkdir+0x239>
		iput(dir);
    efbd:	83 ec 0c             	sub    $0xc,%esp
    efc0:	ff 74 24 24          	pushl  0x24(%esp)
    efc4:	e8 5f cb ff ff       	call   bb28 <iput>
		inode->i_nlinks = 0;
    efc9:	c6 45 0d 00          	movb   $0x0,0xd(%ebp)
    efcd:	e9 06 ff ff ff       	jmp    eed8 <sys_mkdir+0x13f>
		iput(inode);
		return -ENOSPC;
	}
	// 最后令该新目录项的i节点字段等于新i节点号，并置高速缓冲块已修改标志，放回目录和新的i节点，释放高速缓冲区，最后返回0（成功）。
	de->inode = inode->i_num;
    efd2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    efd6:	66 8b 55 32          	mov    0x32(%ebp),%dx
	bh->b_dirt = 1;
	dir->i_nlinks++;
	dir->i_dirt = 1;
	iput(dir);
    efda:	83 ec 0c             	sub    $0xc,%esp
	de->inode = inode->i_num;
    efdd:	66 89 10             	mov    %dx,(%eax)
	dir->i_nlinks++;
    efe0:	8b 54 24 24          	mov    0x24(%esp),%edx
	bh->b_dirt = 1;
    efe4:	c6 46 0b 01          	movb   $0x1,0xb(%esi)
	dir->i_nlinks++;
    efe8:	fe 42 0d             	incb   0xd(%edx)
	dir->i_dirt = 1;
    efeb:	c6 42 37 01          	movb   $0x1,0x37(%edx)
	iput(dir);
    efef:	52                   	push   %edx
    eff0:	e8 33 cb ff ff       	call   bb28 <iput>
	iput(inode);
    eff5:	89 2c 24             	mov    %ebp,(%esp)
    eff8:	e8 2b cb ff ff       	call   bb28 <iput>
	brelse(bh);
    effd:	89 34 24             	mov    %esi,(%esp)
    f000:	e8 59 d3 ff ff       	call   c35e <brelse>
    f005:	83 c4 10             	add    $0x10,%esp
	return 0;
    f008:	31 d2                	xor    %edx,%edx
}
    f00a:	83 c4 2c             	add    $0x2c,%esp
    f00d:	89 d0                	mov    %edx,%eax
    f00f:	5b                   	pop    %ebx
    f010:	5e                   	pop    %esi
    f011:	5f                   	pop    %edi
    f012:	5d                   	pop    %ebp
    f013:	c3                   	ret    

0000f014 <sys_rmdir>:

// 删除目录。
// 参数：name - 目录名（路径名）。
// 返回：返回0表示成功，否则返回出错号。
int sys_rmdir(const char * name)
{
    f014:	55                   	push   %ebp
    f015:	57                   	push   %edi

	// 首先检查参数的有效性并取路径名中顶层目录的i节点。如果找不到对应路径名中顶层目录的i节点，则返回出错码。如果最顶端
	// 文件名长度为0,则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。如果在该目录中没有写的权限，
	// 则放回该目录i节点，返回访问许可出错码退出。如果不是超级用户，则返回访问许可出错码。
	if (!(dir = dir_namei(name, &namelen, &basename, NULL)))
		return -ENOENT;
    f016:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
{
    f01b:	56                   	push   %esi
    f01c:	53                   	push   %ebx
    f01d:	e8 0a 7a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    f022:	81 c3 de 1f 01 00    	add    $0x11fde,%ebx
    f028:	83 ec 2c             	sub    $0x2c,%esp
	if (!(dir = dir_namei(name, &namelen, &basename, NULL)))
    f02b:	8d 4c 24 10          	lea    0x10(%esp),%ecx
    f02f:	8d 54 24 14          	lea    0x14(%esp),%edx
    f033:	83 ec 0c             	sub    $0xc,%esp
    f036:	6a 00                	push   $0x0
    f038:	8b 44 24 50          	mov    0x50(%esp),%eax
    f03c:	e8 aa f5 ff ff       	call   e5eb <dir_namei>
    f041:	83 c4 10             	add    $0x10,%esp
    f044:	85 c0                	test   %eax,%eax
    f046:	89 44 24 18          	mov    %eax,0x18(%esp)
    f04a:	0f 84 eb 02 00 00    	je     f33b <sys_rmdir+0x327>
	if (!namelen) {
    f050:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
    f055:	75 09                	jne    f060 <sys_rmdir+0x4c>
		iput(dir);
    f057:	83 ec 0c             	sub    $0xc,%esp
    f05a:	50                   	push   %eax
    f05b:	e9 d3 02 00 00       	jmp    f333 <sys_rmdir+0x31f>
		return -ENOENT;
	}
	if (!permission(dir,MAY_WRITE)) {
    f060:	ba 02 00 00 00       	mov    $0x2,%edx
    f065:	e8 fe f4 ff ff       	call   e568 <permission>
    f06a:	85 c0                	test   %eax,%eax
    f06c:	75 0e                	jne    f07c <sys_rmdir+0x68>
		iput(dir);
    f06e:	83 ec 0c             	sub    $0xc,%esp
    f071:	ff 74 24 24          	pushl  0x24(%esp)
    f075:	e8 ae ca ff ff       	call   bb28 <iput>
    f07a:	eb 73                	jmp    f0ef <sys_rmdir+0xdb>
	}
	// 然后根据指定目录的i节点和目录名利用函数find_entry()寻找对应目录项，并返回包含该目录项的缓冲块指针bh、包含该目录
	// 项的目录的i节点指针dir和该目录项指针de。再根据该目录项de中的i节点号利用iget()函数得到对应的i节点inode。如果对应
	// 路径名上最后目录的名的目录项不存在，则释放包含该目录项的高速缓冲区，放回目录的i节点，返回文件不存在出错码，并退出。
	// 如果取目录项的i节点出错，则放回目录的i节点，并释放含有目录项的高速缓冲区，返回出错号。
	bh = find_entry(&dir, basename, namelen, &de);
    f07c:	8d 44 24 18          	lea    0x18(%esp),%eax
    f080:	83 ec 0c             	sub    $0xc,%esp
    f083:	8d 54 24 28          	lea    0x28(%esp),%edx
    f087:	52                   	push   %edx
    f088:	8b 4c 24 24          	mov    0x24(%esp),%ecx
    f08c:	8b 54 24 20          	mov    0x20(%esp),%edx
    f090:	e8 ae f1 ff ff       	call   e243 <find_entry>
    f095:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    f098:	85 c0                	test   %eax,%eax
	bh = find_entry(&dir, basename, namelen, &de);
    f09a:	89 04 24             	mov    %eax,(%esp)
	if (!bh) {
    f09d:	75 19                	jne    f0b8 <sys_rmdir+0xa4>
		iput(dir);
    f09f:	83 ec 0c             	sub    $0xc,%esp
		return -ENOENT;
    f0a2:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
		iput(dir);
    f0a7:	ff 74 24 24          	pushl  0x24(%esp)
    f0ab:	e8 78 ca ff ff       	call   bb28 <iput>
    f0b0:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
    f0b3:	e9 83 02 00 00       	jmp    f33b <sys_rmdir+0x327>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
    f0b8:	50                   	push   %eax
    f0b9:	50                   	push   %eax
    f0ba:	8b 44 24 24          	mov    0x24(%esp),%eax
    f0be:	0f b7 00             	movzwl (%eax),%eax
    f0c1:	50                   	push   %eax
    f0c2:	8b 44 24 24          	mov    0x24(%esp),%eax
    f0c6:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f0ca:	50                   	push   %eax
    f0cb:	e8 5a cc ff ff       	call   bd2a <iget>
    f0d0:	83 c4 10             	add    $0x10,%esp
    f0d3:	85 c0                	test   %eax,%eax
    f0d5:	89 c6                	mov    %eax,%esi
    f0d7:	75 21                	jne    f0fa <sys_rmdir+0xe6>
		iput(dir);
    f0d9:	83 ec 0c             	sub    $0xc,%esp
    f0dc:	ff 74 24 24          	pushl  0x24(%esp)
    f0e0:	e8 43 ca ff ff       	call   bb28 <iput>
    f0e5:	58                   	pop    %eax
		brelse(bh);
    f0e6:	ff 74 24 0c          	pushl  0xc(%esp)
    f0ea:	e8 6f d2 ff ff       	call   c35e <brelse>
    f0ef:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    f0f2:	83 cf ff             	or     $0xffffffff,%edi
    f0f5:	e9 41 02 00 00       	jmp    f33b <sys_rmdir+0x327>
	// 此时我们已有包含要被删除目录项的目录i节点dir、要被删除目录项的i节点inode和要被删除目录项指针de。下面我们通过对这3
	// 个对象中信息的检查来验证删除操作的可行性。
	// 若该目录设置了受限删除标志并且进程的有效用户id（euid）不是root，并且进程的有效用户id（euid）不等于该i节点的用户
	// id，则表示当前进程没有权限删除该目录，于是放回包含要删除目录名的目录i节点和该要删除目录的i节点，然后释放高速缓冲区，
	// 返回出错码。
	if ((dir->i_mode & S_ISVTX) && current->euid &&
    f0fa:	8b 44 24 18          	mov    0x18(%esp),%eax
    f0fe:	66 f7 00 00 02       	testw  $0x200,(%eax)
    f103:	74 1a                	je     f11f <sys_rmdir+0x10b>
    f105:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    f10b:	8b 12                	mov    (%edx),%edx
    f10d:	66 8b 92 ce 02 00 00 	mov    0x2ce(%edx),%dx
    f114:	66 85 d2             	test   %dx,%dx
    f117:	74 06                	je     f11f <sys_rmdir+0x10b>
    f119:	66 3b 56 02          	cmp    0x2(%esi),%dx
    f11d:	75 11                	jne    f130 <sys_rmdir+0x11c>
		brelse(bh);
		return -EPERM;
	}
	// 如果要被删除的目录项i节点的设备号不等于包含该目录项的目录的设备号，或者该被删除目录的引用连接计数大于1（表示有符号连
	// 接等），则不能删除该目录。于是释放包含要删除目录名的目录i节点和该要删除目录的i节点，释放高速缓冲块，返回出错码。
	if (inode->i_dev != dir->i_dev || inode->i_count > 1) {
    f11f:	0f b7 56 30          	movzwl 0x30(%esi),%edx
    f123:	66 3b 50 30          	cmp    0x30(%eax),%dx
    f127:	75 07                	jne    f130 <sys_rmdir+0x11c>
    f129:	66 83 7e 34 01       	cmpw   $0x1,0x34(%esi)
    f12e:	76 0e                	jbe    f13e <sys_rmdir+0x12a>
		iput(dir);
    f130:	83 ec 0c             	sub    $0xc,%esp
    f133:	50                   	push   %eax
    f134:	e8 ef c9 ff ff       	call   bb28 <iput>
		iput(inode);
    f139:	89 34 24             	mov    %esi,(%esp)
    f13c:	eb a2                	jmp    f0e0 <sys_rmdir+0xcc>
		brelse(bh);
		return -EPERM;
	}
	// 如果要被删除目录的目录项i节点就等于包含该需删除目录的目录i节点，则表示试图删除“.”目录，这是不允许的。于是放回包含要删
	// 除目录名的目录i节点和要删除目录的i节点，释放高速缓冲块，返回出错码。
	if (inode == dir) {						/* we may not delete ".", but "../dir" is ok */
    f13e:	39 f0                	cmp    %esi,%eax
    f140:	75 0c                	jne    f14e <sys_rmdir+0x13a>
		iput(inode);
    f142:	83 ec 0c             	sub    $0xc,%esp
    f145:	50                   	push   %eax
    f146:	e8 dd c9 ff ff       	call   bb28 <iput>
    f14b:	58                   	pop    %eax
    f14c:	eb 8e                	jmp    f0dc <sys_rmdir+0xc8>
		brelse(bh);
		return -EPERM;
	}
	// 若要被删除目录i节点的属性表明这不是一个目录，则本删除操作的前提完全不存在。于是放回包含删除目录名的目录i节点和该要删除
	// 目录的i节点，释放高速缓冲块，返回出错码。
	if (!S_ISDIR(inode->i_mode)) {
    f14e:	8b 06                	mov    (%esi),%eax
    f150:	66 25 00 f0          	and    $0xf000,%ax
    f154:	66 3d 00 40          	cmp    $0x4000,%ax
    f158:	74 2a                	je     f184 <sys_rmdir+0x170>
		iput(inode);
    f15a:	83 ec 0c             	sub    $0xc,%esp
		iput(dir);
		brelse(bh);
		return -ENOTDIR;
    f15d:	bf ec ff ff ff       	mov    $0xffffffec,%edi
		iput(inode);
    f162:	56                   	push   %esi
    f163:	e8 c0 c9 ff ff       	call   bb28 <iput>
    f168:	5d                   	pop    %ebp
		iput(dir);
    f169:	ff 74 24 24          	pushl  0x24(%esp)
    f16d:	e8 b6 c9 ff ff       	call   bb28 <iput>
    f172:	58                   	pop    %eax
		brelse(bh);
    f173:	ff 74 24 0c          	pushl  0xc(%esp)
    f177:	e8 e2 d1 ff ff       	call   c35e <brelse>
    f17c:	83 c4 10             	add    $0x10,%esp
		return -ENOTDIR;
    f17f:	e9 b7 01 00 00       	jmp    f33b <sys_rmdir+0x327>
	len = inode->i_size / sizeof (struct dir_entry);        		// 目录中目录项个数。
    f184:	8b 46 04             	mov    0x4(%esi),%eax
    f187:	c1 e8 04             	shr    $0x4,%eax
	if (len < 2 || !inode->i_zone[0] ||
    f18a:	83 f8 01             	cmp    $0x1,%eax
	len = inode->i_size / sizeof (struct dir_entry);        		// 目录中目录项个数。
    f18d:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (len < 2 || !inode->i_zone[0] ||
    f191:	76 53                	jbe    f1e6 <sys_rmdir+0x1d2>
    f193:	0f b7 46 0e          	movzwl 0xe(%esi),%eax
    f197:	66 85 c0             	test   %ax,%ax
    f19a:	74 4a                	je     f1e6 <sys_rmdir+0x1d2>
    f19c:	57                   	push   %edi
    f19d:	57                   	push   %edi
    f19e:	50                   	push   %eax
    f19f:	52                   	push   %edx
    f1a0:	e8 0b d2 ff ff       	call   c3b0 <bread>
    f1a5:	83 c4 10             	add    $0x10,%esp
    f1a8:	85 c0                	test   %eax,%eax
    f1aa:	89 c5                	mov    %eax,%ebp
    f1ac:	74 38                	je     f1e6 <sys_rmdir+0x1d2>
	de = (struct dir_entry *) bh->b_data;
    f1ae:	8b 08                	mov    (%eax),%ecx
	if (de[0].inode != inode->i_num || !de[1].inode ||
    f1b0:	66 8b 46 32          	mov    0x32(%esi),%ax
    f1b4:	66 39 01             	cmp    %ax,(%ecx)
    f1b7:	75 2d                	jne    f1e6 <sys_rmdir+0x1d2>
    f1b9:	66 83 79 10 00       	cmpw   $0x0,0x10(%ecx)
    f1be:	74 26                	je     f1e6 <sys_rmdir+0x1d2>
	    strcmp(".", de[0].name) || strcmp("..", de[1].name)) {
    f1c0:	8d 51 02             	lea    0x2(%ecx),%edx
    f1c3:	8d 83 2e 75 ff ff    	lea    -0x8ad2(%ebx),%eax
    f1c9:	e8 56 f0 ff ff       	call   e224 <strcmp>
	if (de[0].inode != inode->i_num || !de[1].inode ||
    f1ce:	85 c0                	test   %eax,%eax
    f1d0:	75 14                	jne    f1e6 <sys_rmdir+0x1d2>
	    strcmp(".", de[0].name) || strcmp("..", de[1].name)) {
    f1d2:	8d 51 12             	lea    0x12(%ecx),%edx
    f1d5:	8d 83 2d 75 ff ff    	lea    -0x8ad3(%ebx),%eax
    f1db:	e8 44 f0 ff ff       	call   e224 <strcmp>
    f1e0:	85 c0                	test   %eax,%eax
    f1e2:	89 c7                	mov    %eax,%edi
    f1e4:	74 15                	je     f1fb <sys_rmdir+0x1e7>
	    	printk("warning - bad directory on dev %04x\n", inode->i_dev);
    f1e6:	51                   	push   %ecx
    f1e7:	51                   	push   %ecx
    f1e8:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    f1ec:	50                   	push   %eax
    f1ed:	8d 83 30 75 ff ff    	lea    -0x8ad0(%ebx),%eax
    f1f3:	50                   	push   %eax
    f1f4:	e8 28 8f ff ff       	call   8121 <printk>
    f1f9:	eb 5f                	jmp    f25a <sys_rmdir+0x246>
	de += 2;
    f1fb:	83 c1 20             	add    $0x20,%ecx
	nr = 2;
    f1fe:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
    f205:	00 
    f206:	eb 2d                	jmp    f235 <sys_rmdir+0x221>
    f208:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
			brelse(bh);
    f20c:	83 ec 0c             	sub    $0xc,%esp
    f20f:	55                   	push   %ebp
    f210:	e8 49 d1 ff ff       	call   c35e <brelse>
    f215:	58                   	pop    %eax
    f216:	5a                   	pop    %edx
			block = bmap(inode, nr / DIR_ENTRIES_PER_BLOCK);
    f217:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f21b:	c1 e8 06             	shr    $0x6,%eax
    f21e:	50                   	push   %eax
    f21f:	56                   	push   %esi
    f220:	e8 e7 c7 ff ff       	call   ba0c <bmap>
    f225:	83 c4 10             	add    $0x10,%esp
			if (!block) {
    f228:	85 c0                	test   %eax,%eax
    f22a:	75 33                	jne    f25f <sys_rmdir+0x24b>
				nr += DIR_ENTRIES_PER_BLOCK;
    f22c:	83 44 24 04 40       	addl   $0x40,0x4(%esp)
    f231:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
	while (nr < len) {
    f235:	8b 54 24 04          	mov    0x4(%esp),%edx
    f239:	39 54 24 08          	cmp    %edx,0x8(%esp)
    f23d:	7e 43                	jle    f282 <sys_rmdir+0x26e>
		if ((void *) de >= (void *) (bh->b_data + BLOCK_SIZE)) {
    f23f:	8b 45 00             	mov    0x0(%ebp),%eax
    f242:	05 00 04 00 00       	add    $0x400,%eax
    f247:	39 c1                	cmp    %eax,%ecx
    f249:	73 bd                	jae    f208 <sys_rmdir+0x1f4>
		if (de->inode) {
    f24b:	66 83 39 00          	cmpw   $0x0,(%ecx)
    f24f:	74 28                	je     f279 <sys_rmdir+0x265>
			brelse(bh);
    f251:	83 ec 0c             	sub    $0xc,%esp
    f254:	55                   	push   %ebp
    f255:	e8 04 d1 ff ff       	call   c35e <brelse>
    f25a:	83 c4 10             	add    $0x10,%esp
    f25d:	eb 4b                	jmp    f2aa <sys_rmdir+0x296>
			if (!(bh = bread(inode->i_dev, block)))
    f25f:	55                   	push   %ebp
    f260:	55                   	push   %ebp
    f261:	50                   	push   %eax
    f262:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    f266:	50                   	push   %eax
    f267:	e8 44 d1 ff ff       	call   c3b0 <bread>
    f26c:	83 c4 10             	add    $0x10,%esp
    f26f:	85 c0                	test   %eax,%eax
    f271:	89 c5                	mov    %eax,%ebp
    f273:	74 35                	je     f2aa <sys_rmdir+0x296>
			de = (struct dir_entry *) bh->b_data;
    f275:	8b 08                	mov    (%eax),%ecx
    f277:	eb d2                	jmp    f24b <sys_rmdir+0x237>
		de++;
    f279:	83 c1 10             	add    $0x10,%ecx
		nr++;
    f27c:	ff 44 24 04          	incl   0x4(%esp)
    f280:	eb b3                	jmp    f235 <sys_rmdir+0x221>
	brelse(bh);
    f282:	83 ec 0c             	sub    $0xc,%esp
    f285:	55                   	push   %ebp
    f286:	e8 d3 d0 ff ff       	call   c35e <brelse>
		return -ENOTEMPTY;
	}
	// 对于一个空目录，其目录项链接数应该为2（链接到上层目录和本目录）。若该需被删除目录的i节点的连接数不等于2,则显示警告信息，
	// 但删除操作仍然执行。于是置该需删除目录的目录项的i节点号字段为0,表示该目录项不再使用，并置含有该目录项的调整缓冲块已修改
	// 标志，并释放该缓冲块。然后再置被删除目录i节点的链接数为0（表示空闲），并置i节点已修改标志。
	if (inode->i_nlinks != 2)
    f28b:	0f b6 46 0d          	movzbl 0xd(%esi),%eax
	brelse(bh);
    f28f:	83 c4 10             	add    $0x10,%esp
	if (inode->i_nlinks != 2)
    f292:	3c 02                	cmp    $0x2,%al
    f294:	74 3b                	je     f2d1 <sys_rmdir+0x2bd>
		printk("empty directory has nlink!=2 (%d)", inode->i_nlinks);
    f296:	52                   	push   %edx
    f297:	52                   	push   %edx
    f298:	50                   	push   %eax
    f299:	8d 83 55 75 ff ff    	lea    -0x8aab(%ebx),%eax
    f29f:	50                   	push   %eax
    f2a0:	e8 7c 8e ff ff       	call   8121 <printk>
    f2a5:	83 c4 10             	add    $0x10,%esp
    f2a8:	eb 27                	jmp    f2d1 <sys_rmdir+0x2bd>
		iput(inode);
    f2aa:	83 ec 0c             	sub    $0xc,%esp
		return -ENOTEMPTY;
    f2ad:	bf d9 ff ff ff       	mov    $0xffffffd9,%edi
		iput(inode);
    f2b2:	56                   	push   %esi
    f2b3:	e8 70 c8 ff ff       	call   bb28 <iput>
    f2b8:	59                   	pop    %ecx
		iput(dir);
    f2b9:	ff 74 24 24          	pushl  0x24(%esp)
    f2bd:	e8 66 c8 ff ff       	call   bb28 <iput>
    f2c2:	5e                   	pop    %esi
		brelse(bh);
    f2c3:	ff 74 24 0c          	pushl  0xc(%esp)
    f2c7:	e8 92 d0 ff ff       	call   c35e <brelse>
    f2cc:	83 c4 10             	add    $0x10,%esp
		return -ENOTEMPTY;
    f2cf:	eb 6a                	jmp    f33b <sys_rmdir+0x327>
	de->inode = 0;
    f2d1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
	bh->b_dirt = 1;
	brelse(bh);
    f2d5:	83 ec 0c             	sub    $0xc,%esp
	inode->i_nlinks = 0;
	inode->i_dirt = 1;
	// 再将包含被删除目录名的目录的i节点链接计数减1,修改其改变时间和修改时间为当前时间，并置该节点已修改标志。最后放回包含要删除
	// 目录名的目录i节点和该要删除目录的i节点，返回0（删除操作成功）。
	dir->i_nlinks--;
	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
    f2d8:	bd 64 00 00 00       	mov    $0x64,%ebp
	de->inode = 0;
    f2dd:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
    f2e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    f2e6:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
    f2ea:	ff 74 24 0c          	pushl  0xc(%esp)
    f2ee:	e8 6b d0 ff ff       	call   c35e <brelse>
	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
    f2f3:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    f2f9:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
	dir->i_nlinks--;
    f2ff:	8b 4c 24 28          	mov    0x28(%esp),%ecx
	inode->i_nlinks = 0;
    f303:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
	inode->i_dirt = 1;
    f307:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
    f30b:	8b 00                	mov    (%eax),%eax
    f30d:	03 02                	add    (%edx),%eax
    f30f:	31 d2                	xor    %edx,%edx
	dir->i_nlinks--;
    f311:	fe 49 0d             	decb   0xd(%ecx)
	dir->i_dirt = 1;
    f314:	c6 41 37 01          	movb   $0x1,0x37(%ecx)
	dir->i_ctime = dir->i_mtime = CURRENT_TIME;
    f318:	f7 f5                	div    %ebp
    f31a:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    f320:	03 02                	add    (%edx),%eax
    f322:	89 41 08             	mov    %eax,0x8(%ecx)
    f325:	89 41 2c             	mov    %eax,0x2c(%ecx)
	iput(dir);
    f328:	89 0c 24             	mov    %ecx,(%esp)
    f32b:	e8 f8 c7 ff ff       	call   bb28 <iput>
	iput(inode);
    f330:	89 34 24             	mov    %esi,(%esp)
    f333:	e8 f0 c7 ff ff       	call   bb28 <iput>
    f338:	83 c4 10             	add    $0x10,%esp
	return 0;
}
    f33b:	83 c4 2c             	add    $0x2c,%esp
    f33e:	89 f8                	mov    %edi,%eax
    f340:	5b                   	pop    %ebx
    f341:	5e                   	pop    %esi
    f342:	5f                   	pop    %edi
    f343:	5d                   	pop    %ebp
    f344:	c3                   	ret    

0000f345 <sys_unlink>:
// 删除（释放）文件名对应的目录项。
// 从文件系统删除一个名字。如果是文件的最后一个链接，并且没有进程正打开该文件，则该文件也将被删除，并释放所占用的设备空间。
// 参数：name - 文件名（路径名）。
// 返回：成功则返回0,否则返回出错号。
int sys_unlink(const char * name)
{
    f345:	57                   	push   %edi
    f346:	56                   	push   %esi
    f347:	53                   	push   %ebx
    f348:	e8 df 76 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    f34d:	81 c3 b3 1c 01 00    	add    $0x11cb3,%ebx
    f353:	83 ec 10             	sub    $0x10,%esp
	struct dir_entry * de;

	// 首先检查参数的有效性并取路径名中顶层目录的i节点。如果找不到对应路径名中顶层目录的i节点，则返回出错码。如果最顶端
	// 文件名长度为0,则说明给出的路径名最后没有指定文件名，放回该目录i节点，返回出错码退出。如果在该目录中没有写的权限，
	// 则放回该目录i节点，返回访问许可出错码退出。如果不是超级用户，则返回访问许可出错码。
	if (!(dir = dir_namei(name, &namelen, &basename, NULL)))
    f356:	8d 54 24 04          	lea    0x4(%esp),%edx
    f35a:	89 e1                	mov    %esp,%ecx
    f35c:	83 ec 0c             	sub    $0xc,%esp
    f35f:	6a 00                	push   $0x0
    f361:	8b 44 24 30          	mov    0x30(%esp),%eax
    f365:	e8 81 f2 ff ff       	call   e5eb <dir_namei>
    f36a:	83 c4 10             	add    $0x10,%esp
    f36d:	85 c0                	test   %eax,%eax
    f36f:	89 44 24 08          	mov    %eax,0x8(%esp)
		return -ENOENT;
    f373:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
	if (!(dir = dir_namei(name, &namelen, &basename, NULL)))
    f378:	0f 84 83 01 00 00    	je     f501 <sys_unlink+0x1bc>
	if (!namelen) {
    f37e:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
    f383:	75 06                	jne    f38b <sys_unlink+0x46>
		iput(dir);
    f385:	83 ec 0c             	sub    $0xc,%esp
    f388:	50                   	push   %eax
    f389:	eb 48                	jmp    f3d3 <sys_unlink+0x8e>
		return -ENOENT;
	}
	if (!permission(dir, MAY_WRITE)) {
    f38b:	ba 02 00 00 00       	mov    $0x2,%edx
    f390:	e8 d3 f1 ff ff       	call   e568 <permission>
    f395:	85 c0                	test   %eax,%eax
    f397:	75 11                	jne    f3aa <sys_unlink+0x65>
		iput(dir);
    f399:	83 ec 0c             	sub    $0xc,%esp
    f39c:	ff 74 24 14          	pushl  0x14(%esp)
    f3a0:	e8 83 c7 ff ff       	call   bb28 <iput>
    f3a5:	e9 d2 00 00 00       	jmp    f47c <sys_unlink+0x137>
	}
	// 然后根据指定目录的i节点和目录名利用函数find_entry()寻找对应目录项，并返回包含该目录项的缓冲块指针bh、包含该目录
	// 项的目录的i节点指针dir和该目录项指针de。再根据该目录项de中的i节点号利用iget()函数得到对应的i节点inode。如果对应
	// 路径名上最后目录的名的目录项不存在，则释放包含该目录项的高速缓冲区，放回目录的i节点，返回文件不存在出错码，并退出。
	// 如果取目录项的i节点出错，则放回目录的i节点，并释放含有目录项的高速缓冲区，返回出错号。
	bh = find_entry(&dir, basename, namelen, &de);
    f3aa:	8d 44 24 08          	lea    0x8(%esp),%eax
    f3ae:	83 ec 0c             	sub    $0xc,%esp
    f3b1:	8d 54 24 18          	lea    0x18(%esp),%edx
    f3b5:	52                   	push   %edx
    f3b6:	8b 4c 24 14          	mov    0x14(%esp),%ecx
    f3ba:	8b 54 24 10          	mov    0x10(%esp),%edx
    f3be:	e8 80 ee ff ff       	call   e243 <find_entry>
    f3c3:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    f3c6:	85 c0                	test   %eax,%eax
	bh = find_entry(&dir, basename, namelen, &de);
    f3c8:	89 c7                	mov    %eax,%edi
	if (!bh) {
    f3ca:	75 19                	jne    f3e5 <sys_unlink+0xa0>
		iput(dir);
    f3cc:	83 ec 0c             	sub    $0xc,%esp
    f3cf:	ff 74 24 14          	pushl  0x14(%esp)
    f3d3:	e8 50 c7 ff ff       	call   bb28 <iput>
    f3d8:	83 c4 10             	add    $0x10,%esp
		return -ENOENT;
    f3db:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
    f3e0:	e9 1c 01 00 00       	jmp    f501 <sys_unlink+0x1bc>
	}
	if (!(inode = iget(dir->i_dev, de->inode))) {
    f3e5:	51                   	push   %ecx
    f3e6:	51                   	push   %ecx
    f3e7:	8b 44 24 14          	mov    0x14(%esp),%eax
    f3eb:	0f b7 00             	movzwl (%eax),%eax
    f3ee:	50                   	push   %eax
    f3ef:	8b 44 24 14          	mov    0x14(%esp),%eax
    f3f3:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f3f7:	50                   	push   %eax
    f3f8:	e8 2d c9 ff ff       	call   bd2a <iget>
    f3fd:	83 c4 10             	add    $0x10,%esp
    f400:	85 c0                	test   %eax,%eax
    f402:	89 c6                	mov    %eax,%esi
    f404:	75 16                	jne    f41c <sys_unlink+0xd7>
		iput(dir);
    f406:	83 ec 0c             	sub    $0xc,%esp
    f409:	ff 74 24 14          	pushl  0x14(%esp)
    f40d:	e8 16 c7 ff ff       	call   bb28 <iput>
		brelse(bh);
    f412:	89 3c 24             	mov    %edi,(%esp)
    f415:	e8 44 cf ff ff       	call   c35e <brelse>
    f41a:	eb bc                	jmp    f3d8 <sys_unlink+0x93>
	// 此时我们已有包含要被删除目录项的目录i节点dir、要被删除目录项的i节点inode和要被删除目录项指针de。下面我们通过对这3
	// 个对象中信息的检查来验证删除操作的可行性。
	// 若该目录设置了受限删除标志并且进程的有效用户id（euid）不是root，并且进程的有效用户id（euid）不等于该i节点的用户
	// id，并且进程的euid也不等于目录i节点的用户id，则表示当前进程没有权限删除该目录，于是放回包含要删除目录名的目录i节点
	// 和该要删除目录的i节点，然后释放高速缓冲区，返回出错码。
	if ((dir->i_mode & S_ISVTX) && !suser() &&
    f41c:	8b 44 24 08          	mov    0x8(%esp),%eax
    f420:	66 f7 00 00 02       	testw  $0x200,(%eax)
    f425:	74 2e                	je     f455 <sys_unlink+0x110>
    f427:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    f42d:	8b 12                	mov    (%edx),%edx
    f42f:	66 8b 92 ce 02 00 00 	mov    0x2ce(%edx),%dx
    f436:	66 85 d2             	test   %dx,%dx
    f439:	74 1a                	je     f455 <sys_unlink+0x110>
    f43b:	66 3b 56 02          	cmp    0x2(%esi),%dx
    f43f:	74 14                	je     f455 <sys_unlink+0x110>
	    current->euid != inode->i_uid &&
    f441:	66 3b 50 02          	cmp    0x2(%eax),%dx
    f445:	74 0e                	je     f455 <sys_unlink+0x110>
	    current->euid != dir->i_uid) {
		iput(dir);
    f447:	83 ec 0c             	sub    $0xc,%esp
    f44a:	50                   	push   %eax
    f44b:	e8 d8 c6 ff ff       	call   bb28 <iput>
		iput(inode);
    f450:	89 34 24             	mov    %esi,(%esp)
    f453:	eb 1a                	jmp    f46f <sys_unlink+0x12a>
		brelse(bh);
		return -EPERM;
	}
	// 如果该指定文件名是一个目录，则也不能删除。放回该目录i节点和该文件名目录项的i节点，释放包含该目录项的缓冲块，返回出错号。
	if (S_ISDIR(inode->i_mode)) {
    f455:	8b 06                	mov    (%esi),%eax
    f457:	66 25 00 f0          	and    $0xf000,%ax
    f45b:	66 3d 00 40          	cmp    $0x4000,%ax
    f45f:	75 23                	jne    f484 <sys_unlink+0x13f>
		iput(inode);
    f461:	83 ec 0c             	sub    $0xc,%esp
    f464:	56                   	push   %esi
    f465:	e8 be c6 ff ff       	call   bb28 <iput>
    f46a:	5a                   	pop    %edx
		iput(dir);
    f46b:	ff 74 24 14          	pushl  0x14(%esp)
    f46f:	e8 b4 c6 ff ff       	call   bb28 <iput>
		brelse(bh);
    f474:	89 3c 24             	mov    %edi,(%esp)
    f477:	e8 e2 ce ff ff       	call   c35e <brelse>
    f47c:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    f47f:	83 ca ff             	or     $0xffffffff,%edx
    f482:	eb 7d                	jmp    f501 <sys_unlink+0x1bc>
	}
	// 如果该i节点的链接计数值已经为0,则显示警告信息，并修正其为1。
	if (!inode->i_nlinks) {
    f484:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
    f488:	75 1f                	jne    f4a9 <sys_unlink+0x164>
		printk("Deleting nonexistent file (%04x:%d), %d\n",
    f48a:	0f b7 46 32          	movzwl 0x32(%esi),%eax
    f48e:	6a 00                	push   $0x0
    f490:	50                   	push   %eax
    f491:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    f495:	50                   	push   %eax
    f496:	8d 83 77 75 ff ff    	lea    -0x8a89(%ebx),%eax
    f49c:	50                   	push   %eax
    f49d:	e8 7f 8c ff ff       	call   8121 <printk>
    f4a2:	83 c4 10             	add    $0x10,%esp
			inode->i_dev, inode->i_num, inode->i_nlinks);
		inode->i_nlinks = 1;
    f4a5:	c6 46 0d 01          	movb   $0x1,0xd(%esi)
	}
	// 现在我们可以删除文件名对应的目录项了。于是将该文件名目录项中的i节点号字段置为0,表示释放该目录项，并设置包含该目录项的缓
	// 冲块已修改标志，释放该高速缓冲块。
	de->inode = 0;
    f4a9:	8b 44 24 0c          	mov    0xc(%esp),%eax
	bh->b_dirt = 1;
	brelse(bh);
    f4ad:	83 ec 0c             	sub    $0xc,%esp
	de->inode = 0;
    f4b0:	66 c7 00 00 00       	movw   $0x0,(%eax)
	bh->b_dirt = 1;
    f4b5:	c6 47 0b 01          	movb   $0x1,0xb(%edi)
	brelse(bh);
    f4b9:	57                   	push   %edi
    f4ba:	e8 9f ce ff ff       	call   c35e <brelse>
	// 然后把文件名对应i节点的链接数减1,置已修改标志，更新改变时间为当前时间。最后放回该i节点和目录的i节点，返回0（成功）。如果
	// 是文件的最后一个链接，即i节点链接数减1后等于0,并且此时没有进程正打开该文件，那么在调用iput()放回i节点时，该文件也将被删除
	// 并释放所占用的设备空间。参见fs/inode.c。
	inode->i_nlinks--;
	inode->i_dirt = 1;
	inode->i_ctime = CURRENT_TIME;
    f4bf:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    f4c5:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    f4cb:	b9 64 00 00 00       	mov    $0x64,%ecx
	inode->i_nlinks--;
    f4d0:	fe 4e 0d             	decb   0xd(%esi)
	inode->i_dirt = 1;
    f4d3:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	inode->i_ctime = CURRENT_TIME;
    f4d7:	8b 00                	mov    (%eax),%eax
    f4d9:	03 02                	add    (%edx),%eax
    f4db:	31 d2                	xor    %edx,%edx
    f4dd:	f7 f1                	div    %ecx
    f4df:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    f4e5:	03 02                	add    (%edx),%eax
    f4e7:	89 46 2c             	mov    %eax,0x2c(%esi)
	iput(inode);
    f4ea:	89 34 24             	mov    %esi,(%esp)
    f4ed:	e8 36 c6 ff ff       	call   bb28 <iput>
    f4f2:	58                   	pop    %eax
	iput(dir);
    f4f3:	ff 74 24 14          	pushl  0x14(%esp)
    f4f7:	e8 2c c6 ff ff       	call   bb28 <iput>
    f4fc:	83 c4 10             	add    $0x10,%esp
	return 0;
    f4ff:	31 d2                	xor    %edx,%edx
}
    f501:	83 c4 10             	add    $0x10,%esp
    f504:	89 d0                	mov    %edx,%eax
    f506:	5b                   	pop    %ebx
    f507:	5e                   	pop    %esi
    f508:	5f                   	pop    %edi
    f509:	c3                   	ret    

0000f50a <sys_symlink>:
// 建立符号链接。
// 为一个已存在文件创建一个符号链接（也称为软连接 - hard link）。
// 参数：oldname - 原路径名；newname - 新的路径名。
// 返回：若成功则返回0，否则返回出错号。
int sys_symlink(const char * oldname, const char * newname)
{
    f50a:	55                   	push   %ebp
    f50b:	57                   	push   %edi
    f50c:	56                   	push   %esi
    f50d:	53                   	push   %ebx
    f50e:	e8 19 75 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    f513:	81 c3 ed 1a 01 00    	add    $0x11aed,%ebx
    f519:	83 ec 1c             	sub    $0x1c,%esp
	char c;

	// 首先查找新路径名的最顶层目录的i节点dir，并返回最后的文件名及其长度。如果目录的i节点没有找到，则返回出错号。如果新路径名
	// 中不包括文件名，则放回新路径名目录的i节点，返回出错号。另外，如果用户没有在新目录中写的权限，则也不能建立连接，于是放回
	// 新路径名目录的i节点，返回出错号。
	dir = dir_namei(newname, &namelen, &basename, NULL);
    f51c:	8d 54 24 0c          	lea    0xc(%esp),%edx
    f520:	8d 4c 24 08          	lea    0x8(%esp),%ecx
    f524:	83 ec 0c             	sub    $0xc,%esp
    f527:	6a 00                	push   $0x0
    f529:	8b 44 24 44          	mov    0x44(%esp),%eax
    f52d:	e8 b9 f0 ff ff       	call   e5eb <dir_namei>
    f532:	83 c4 10             	add    $0x10,%esp
	if (!dir)
    f535:	85 c0                	test   %eax,%eax
	dir = dir_namei(newname, &namelen, &basename, NULL);
    f537:	89 44 24 04          	mov    %eax,0x4(%esp)
		return -EACCES;
    f53b:	ba f3 ff ff ff       	mov    $0xfffffff3,%edx
	if (!dir)
    f540:	0f 84 e3 01 00 00    	je     f729 <sys_symlink+0x21f>
	if (!namelen) {
    f546:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f54b:	75 14                	jne    f561 <sys_symlink+0x57>
		iput(dir);
    f54d:	83 ec 0c             	sub    $0xc,%esp
    f550:	50                   	push   %eax
    f551:	e8 d2 c5 ff ff       	call   bb28 <iput>
    f556:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    f559:	83 ca ff             	or     $0xffffffff,%edx
    f55c:	e9 c8 01 00 00       	jmp    f729 <sys_symlink+0x21f>
	}
	if (!permission(dir, MAY_WRITE)) {
    f561:	ba 02 00 00 00       	mov    $0x2,%edx
    f566:	e8 fd ef ff ff       	call   e568 <permission>
    f56b:	85 c0                	test   %eax,%eax
    f56d:	75 19                	jne    f588 <sys_symlink+0x7e>
		iput(dir);
    f56f:	83 ec 0c             	sub    $0xc,%esp
    f572:	ff 74 24 10          	pushl  0x10(%esp)
    f576:	e8 ad c5 ff ff       	call   bb28 <iput>
    f57b:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    f57e:	ba f3 ff ff ff       	mov    $0xfffffff3,%edx
    f583:	e9 a1 01 00 00       	jmp    f729 <sys_symlink+0x21f>
	}
	// 现在我们在目录指定设备上申请一个新的i节点，并设置该i节点模式为符号链接类型以及进程规定的模式屏蔽码。并且设置该i节点已修
	// 改标志。
	if (!(inode = new_inode(dir->i_dev))) {
    f588:	83 ec 0c             	sub    $0xc,%esp
    f58b:	8b 44 24 10          	mov    0x10(%esp),%eax
    f58f:	0f b7 40 30          	movzwl 0x30(%eax),%eax
    f593:	50                   	push   %eax
    f594:	e8 bc 06 00 00       	call   fc55 <new_inode>
    f599:	83 c4 10             	add    $0x10,%esp
    f59c:	85 c0                	test   %eax,%eax
    f59e:	89 c6                	mov    %eax,%esi
    f5a0:	75 08                	jne    f5aa <sys_symlink+0xa0>
		iput(dir);
    f5a2:	83 ec 0c             	sub    $0xc,%esp
    f5a5:	e9 48 01 00 00       	jmp    f6f2 <sys_symlink+0x1e8>
		return -ENOSPC;
	}
	inode->i_mode = S_IFLNK | (0777 & ~current->umask);
    f5aa:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
	inode->i_dirt = 1;
	// 为了保存符号链接路径名字符串信息，我们需要为该i节点申请一个磁盘块，并让i节点的第1个直接块号i_zone[0]等于得到的逻辑块号。
	// 然后置i节点已修改标志。如果申请失败则放回对应目录的i节点；复位新申请的i节点链接计数；放回该新的i节点，返回没有空间出错码
	// 退出。
	if (!(inode->i_zone[0] = new_block(inode->i_dev))) {
    f5b0:	83 ec 0c             	sub    $0xc,%esp
	inode->i_mode = S_IFLNK | (0777 & ~current->umask);
    f5b3:	8b 00                	mov    (%eax),%eax
    f5b5:	8b 80 30 03 00 00    	mov    0x330(%eax),%eax
	inode->i_dirt = 1;
    f5bb:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	inode->i_mode = S_IFLNK | (0777 & ~current->umask);
    f5bf:	f7 d0                	not    %eax
    f5c1:	66 25 ff 01          	and    $0x1ff,%ax
    f5c5:	66 0d 00 a0          	or     $0xa000,%ax
    f5c9:	66 89 06             	mov    %ax,(%esi)
	if (!(inode->i_zone[0] = new_block(inode->i_dev))) {
    f5cc:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    f5d0:	50                   	push   %eax
    f5d1:	e8 26 04 00 00       	call   f9fc <new_block>
    f5d6:	83 c4 10             	add    $0x10,%esp
    f5d9:	66 85 c0             	test   %ax,%ax
    f5dc:	66 89 46 0e          	mov    %ax,0xe(%esi)
    f5e0:	75 24                	jne    f606 <sys_symlink+0xfc>
		iput(dir);
    f5e2:	83 ec 0c             	sub    $0xc,%esp
    f5e5:	ff 74 24 10          	pushl  0x10(%esp)
    f5e9:	e8 3a c5 ff ff       	call   bb28 <iput>
		inode->i_nlinks--;
    f5ee:	fe 4e 0d             	decb   0xd(%esi)
		iput(inode);
    f5f1:	89 34 24             	mov    %esi,(%esp)
    f5f4:	e8 2f c5 ff ff       	call   bb28 <iput>
    f5f9:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
    f5fc:	ba e4 ff ff ff       	mov    $0xffffffe4,%edx
    f601:	e9 23 01 00 00       	jmp    f729 <sys_symlink+0x21f>
	}
	inode->i_dirt = 1;
	// 然后从设备上读取新申请的磁盘块（目的是把对应块放到高速缓冲区中）。若出错，则放回对应目录的i节点；复位新申请的i节点链接计数；
	// 放回该新的i节点，返回没有空间出错码退出。
	if (!(name_block = bread(inode->i_dev, inode->i_zone[0]))) {
    f606:	0f b7 c0             	movzwl %ax,%eax
	inode->i_dirt = 1;
    f609:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	if (!(name_block = bread(inode->i_dev, inode->i_zone[0]))) {
    f60d:	57                   	push   %edi
    f60e:	57                   	push   %edi
    f60f:	50                   	push   %eax
	}
	// 现在我们可以把符号链接名字字符串放入这个盘块中了。盘块长度为1024字节，因此默认符号链接名长度最大也只能是1024字节。我们把用
	// 户空间中的符号链接名字符串复制到盘块所在的缓冲块中，并置缓冲块已修改标志。为防止用户提供的字符串没有以NULL结尾，我们在缓冲块
	// 数据区最后一个字节处放上一个NULL。然后释放该缓冲块，并设置i节点对应文件中数据长度等于符号链接名字符串长度，并置i节点已修改
	// 标志。
	i = 0;
    f610:	31 ff                	xor    %edi,%edi
	if (!(name_block = bread(inode->i_dev, inode->i_zone[0]))) {
    f612:	0f b7 46 30          	movzwl 0x30(%esi),%eax
    f616:	50                   	push   %eax
    f617:	e8 94 cd ff ff       	call   c3b0 <bread>
    f61c:	83 c4 10             	add    $0x10,%esp
    f61f:	85 c0                	test   %eax,%eax
    f621:	75 2f                	jne    f652 <sys_symlink+0x148>
		iput(dir);
    f623:	83 ec 0c             	sub    $0xc,%esp
    f626:	ff 74 24 10          	pushl  0x10(%esp)
    f62a:	e8 f9 c4 ff ff       	call   bb28 <iput>
		inode->i_nlinks--;
    f62f:	fe 4e 0d             	decb   0xd(%esi)
		iput(inode);
    f632:	89 34 24             	mov    %esi,(%esp)
    f635:	e8 ee c4 ff ff       	call   bb28 <iput>
    f63a:	83 c4 10             	add    $0x10,%esp
		return -ERROR;
    f63d:	ba 9d ff ff ff       	mov    $0xffffff9d,%edx
    f642:	e9 e2 00 00 00       	jmp    f729 <sys_symlink+0x21f>
	while (i < 1023 && (c = get_fs_byte(oldname++)))
		name_block->b_data[i++] = c;
    f647:	47                   	inc    %edi
    f648:	88 11                	mov    %dl,(%ecx)
	while (i < 1023 && (c = get_fs_byte(oldname++)))
    f64a:	81 ff ff 03 00 00    	cmp    $0x3ff,%edi
    f650:	74 10                	je     f662 <sys_symlink+0x158>
    f652:	8b 4c 24 30          	mov    0x30(%esp),%ecx
    f656:	64 8a 14 39          	mov    %fs:(%ecx,%edi,1),%dl
    f65a:	8b 08                	mov    (%eax),%ecx
    f65c:	01 f9                	add    %edi,%ecx
    f65e:	84 d2                	test   %dl,%dl
    f660:	75 e5                	jne    f647 <sys_symlink+0x13d>
	name_block->b_data[i] = 0;
    f662:	8b 10                	mov    (%eax),%edx
	name_block->b_dirt = 1;
	brelse(name_block);
    f664:	83 ec 0c             	sub    $0xc,%esp
	name_block->b_data[i] = 0;
    f667:	c6 04 3a 00          	movb   $0x0,(%edx,%edi,1)
	name_block->b_dirt = 1;
    f66b:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(name_block);
    f66f:	50                   	push   %eax
    f670:	e8 e9 cc ff ff       	call   c35e <brelse>
    f675:	83 c4 10             	add    $0x10,%esp
	inode->i_size = i;
    f678:	89 7e 04             	mov    %edi,0x4(%esi)
	inode->i_dirt = 1;
    f67b:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	// 然后我们搜索一下路径名指定的符号链接名是否已经存在。若已经存在则不能创建同名目录项i节点。如果对应符号链接文件名已经存在，则
	// 释放包含该目录项的缓冲区块，复位新申请的i节点连接计数，并施加目录的i节点，返回文件已经存在的出错码退出。
	bh = find_entry(&dir, basename, namelen, &de);
    f67f:	8d 44 24 04          	lea    0x4(%esp),%eax
    f683:	83 ec 0c             	sub    $0xc,%esp
    f686:	8d 7c 24 0c          	lea    0xc(%esp),%edi
    f68a:	57                   	push   %edi
    f68b:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    f68f:	8b 54 24 18          	mov    0x18(%esp),%edx
    f693:	e8 ab eb ff ff       	call   e243 <find_entry>
    f698:	83 c4 10             	add    $0x10,%esp
	if (bh) {
    f69b:	85 c0                	test   %eax,%eax
	bh = find_entry(&dir, basename, namelen, &de);
    f69d:	89 c5                	mov    %eax,%ebp
	if (bh) {
    f69f:	74 28                	je     f6c9 <sys_symlink+0x1bf>
		inode->i_nlinks--;
    f6a1:	fe 4e 0d             	decb   0xd(%esi)
		iput(inode);
    f6a4:	83 ec 0c             	sub    $0xc,%esp
    f6a7:	56                   	push   %esi
    f6a8:	e8 7b c4 ff ff       	call   bb28 <iput>
		brelse(bh);
    f6ad:	89 2c 24             	mov    %ebp,(%esp)
    f6b0:	e8 a9 cc ff ff       	call   c35e <brelse>
    f6b5:	59                   	pop    %ecx
		iput(dir);
    f6b6:	ff 74 24 10          	pushl  0x10(%esp)
    f6ba:	e8 69 c4 ff ff       	call   bb28 <iput>
    f6bf:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
    f6c2:	ba ef ff ff ff       	mov    $0xffffffef,%edx
    f6c7:	eb 60                	jmp    f729 <sys_symlink+0x21f>
	}
	// 现在我们在指定目录中新添加一个目录项，用于存放新建符号链接文件名的i节点号和目录名。如果失败（包含该目录项的高速缓冲区指针为
	// NULL），则放回目录的i节点；所申请的i节点引用链接计数复位，并放回该i节点。返回出错码退出。
	bh = add_entry(dir, basename, namelen, &de);
    f6c9:	83 ec 0c             	sub    $0xc,%esp
    f6cc:	57                   	push   %edi
    f6cd:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    f6d1:	8b 54 24 18          	mov    0x18(%esp),%edx
    f6d5:	8b 44 24 14          	mov    0x14(%esp),%eax
    f6d9:	e8 17 ed ff ff       	call   e3f5 <add_entry>
    f6de:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    f6e1:	85 c0                	test   %eax,%eax
    f6e3:	75 16                	jne    f6fb <sys_symlink+0x1f1>
		inode->i_nlinks--;
    f6e5:	fe 4e 0d             	decb   0xd(%esi)
		iput(inode);
    f6e8:	83 ec 0c             	sub    $0xc,%esp
    f6eb:	56                   	push   %esi
    f6ec:	e8 37 c4 ff ff       	call   bb28 <iput>
    f6f1:	5a                   	pop    %edx
		iput(dir);
    f6f2:	ff 74 24 10          	pushl  0x10(%esp)
    f6f6:	e9 f9 fe ff ff       	jmp    f5f4 <sys_symlink+0xea>
		return -ENOSPC;
	}
	// 最后令该新目录项的i节点字段等于新i节点号，并置高速缓冲块已修改标志，释放高速缓冲块，放回目录和新的i节点，最后返回0（成功）。
	de->inode = inode->i_num;
    f6fb:	8b 14 24             	mov    (%esp),%edx
    f6fe:	66 8b 4e 32          	mov    0x32(%esi),%cx
	bh->b_dirt = 1;
	brelse(bh);
    f702:	83 ec 0c             	sub    $0xc,%esp
	de->inode = inode->i_num;
    f705:	66 89 0a             	mov    %cx,(%edx)
	bh->b_dirt = 1;
    f708:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
    f70c:	50                   	push   %eax
    f70d:	e8 4c cc ff ff       	call   c35e <brelse>
    f712:	58                   	pop    %eax
	iput(dir);
    f713:	ff 74 24 10          	pushl  0x10(%esp)
    f717:	e8 0c c4 ff ff       	call   bb28 <iput>
	iput(inode);
    f71c:	89 34 24             	mov    %esi,(%esp)
    f71f:	e8 04 c4 ff ff       	call   bb28 <iput>
    f724:	83 c4 10             	add    $0x10,%esp
	return 0;
    f727:	31 d2                	xor    %edx,%edx
}
    f729:	83 c4 1c             	add    $0x1c,%esp
    f72c:	89 d0                	mov    %edx,%eax
    f72e:	5b                   	pop    %ebx
    f72f:	5e                   	pop    %esi
    f730:	5f                   	pop    %edi
    f731:	5d                   	pop    %ebp
    f732:	c3                   	ret    

0000f733 <sys_link>:
// 为文件建立一个文件名目录项。
// 为一个已存在的文件创建一个新链接（也称为硬连接 - hard link）。
// 参数：oldname - 原路径名；newname - 新的路径名。
// 返回：若成功则返回0,否则返回出错号。
int sys_link(const char * oldname, const char * newname)
{
    f733:	57                   	push   %edi
    f734:	56                   	push   %esi
    f735:	53                   	push   %ebx
    f736:	e8 f1 72 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    f73b:	81 c3 c5 18 01 00    	add    $0x118c5,%ebx
    f741:	83 ec 1c             	sub    $0x1c,%esp
	const char * basename;
	int namelen;

	// 首先对原文件名进行有效性验证，它应该存在并且不是一个目录名。所以我们先取原文件路径名对应的i节点oldinode。如果为0，则
	// 表示出错，返回出错号。如果原路径名对应的是一个目录名，则放回该i节点，也返回出错号。
	oldinode = namei(oldname);
    f744:	ff 74 24 2c          	pushl  0x2c(%esp)
    f748:	e8 eb f1 ff ff       	call   e938 <namei>
    f74d:	89 c6                	mov    %eax,%esi
    f74f:	83 c4 10             	add    $0x10,%esp
	if (!oldinode)
		return -ENOENT;
    f752:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
	if (!oldinode)
    f757:	85 f6                	test   %esi,%esi
    f759:	0f 84 8f 01 00 00    	je     f8ee <sys_link+0x1bb>
	if (S_ISDIR(oldinode->i_mode)) {
    f75f:	8b 06                	mov    (%esi),%eax
    f761:	66 25 00 f0          	and    $0xf000,%ax
    f765:	66 3d 00 40          	cmp    $0x4000,%ax
    f769:	75 06                	jne    f771 <sys_link+0x3e>
		iput(oldinode);
    f76b:	83 ec 0c             	sub    $0xc,%esp
    f76e:	56                   	push   %esi
    f76f:	eb 3c                	jmp    f7ad <sys_link+0x7a>
		return -EPERM;
	}
	// 然后查找新路径名的最顶层目录的i节点dir，并返回最后的文件名及其长度。如果目录的i节点没有找到，则放回原路径名的i节点，返
	// 回出错号。如果新路径名中不包括文件名，则放回原路径名i节点和新路径名目录的i节点，返回出错号。
	dir = dir_namei(newname, &namelen, &basename, NULL);
    f771:	8d 4c 24 08          	lea    0x8(%esp),%ecx
    f775:	8d 54 24 0c          	lea    0xc(%esp),%edx
    f779:	83 ec 0c             	sub    $0xc,%esp
    f77c:	6a 00                	push   $0x0
    f77e:	8b 44 24 34          	mov    0x34(%esp),%eax
    f782:	e8 64 ee ff ff       	call   e5eb <dir_namei>
    f787:	83 c4 10             	add    $0x10,%esp
	if (!dir) {
    f78a:	85 c0                	test   %eax,%eax
	dir = dir_namei(newname, &namelen, &basename, NULL);
    f78c:	89 44 24 04          	mov    %eax,0x4(%esp)
	if (!dir) {
    f790:	75 06                	jne    f798 <sys_link+0x65>
		iput(oldinode);
    f792:	83 ec 0c             	sub    $0xc,%esp
    f795:	56                   	push   %esi
    f796:	eb 69                	jmp    f801 <sys_link+0xce>
		return -EACCES;
	}
	if (!namelen) {
    f798:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
    f79d:	75 1e                	jne    f7bd <sys_link+0x8a>
		iput(oldinode);
    f79f:	83 ec 0c             	sub    $0xc,%esp
    f7a2:	56                   	push   %esi
    f7a3:	e8 80 c3 ff ff       	call   bb28 <iput>
    f7a8:	59                   	pop    %ecx
		iput(dir);
    f7a9:	ff 74 24 10          	pushl  0x10(%esp)
    f7ad:	e8 76 c3 ff ff       	call   bb28 <iput>
    f7b2:	83 c4 10             	add    $0x10,%esp
		return -EPERM;
    f7b5:	83 c8 ff             	or     $0xffffffff,%eax
    f7b8:	e9 31 01 00 00       	jmp    f8ee <sys_link+0x1bb>
	}
	// 我们不能跨设备建立硬链接。因此如果新路径名顶层目录的设备号与原路径名的设备号不一样，则放回新路径名目录的i节点和原路径名
	// 的i节点，返回出错号。另外，如果用户没有在新目录中写的权限，则也不能建立连接，于是放回新路径名目录的i节点和原路径名的i节点
	// 返回出错号。
	if (dir->i_dev != oldinode->i_dev) {
    f7bd:	8b 7e 30             	mov    0x30(%esi),%edi
    f7c0:	66 39 78 30          	cmp    %di,0x30(%eax)
    f7c4:	74 1e                	je     f7e4 <sys_link+0xb1>
		iput(dir);
    f7c6:	83 ec 0c             	sub    $0xc,%esp
    f7c9:	50                   	push   %eax
    f7ca:	e8 59 c3 ff ff       	call   bb28 <iput>
		iput(oldinode);
    f7cf:	89 34 24             	mov    %esi,(%esp)
    f7d2:	e8 51 c3 ff ff       	call   bb28 <iput>
    f7d7:	83 c4 10             	add    $0x10,%esp
		return -EXDEV;
    f7da:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
    f7df:	e9 0a 01 00 00       	jmp    f8ee <sys_link+0x1bb>
	}
	if (!permission(dir, MAY_WRITE)) {
    f7e4:	ba 02 00 00 00       	mov    $0x2,%edx
    f7e9:	e8 7a ed ff ff       	call   e568 <permission>
    f7ee:	85 c0                	test   %eax,%eax
    f7f0:	75 21                	jne    f813 <sys_link+0xe0>
		iput(dir);
    f7f2:	83 ec 0c             	sub    $0xc,%esp
    f7f5:	ff 74 24 10          	pushl  0x10(%esp)
    f7f9:	e8 2a c3 ff ff       	call   bb28 <iput>
		iput(oldinode);
    f7fe:	89 34 24             	mov    %esi,(%esp)
    f801:	e8 22 c3 ff ff       	call   bb28 <iput>
    f806:	83 c4 10             	add    $0x10,%esp
		return -EACCES;
    f809:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f80e:	e9 db 00 00 00       	jmp    f8ee <sys_link+0x1bb>
	}
	// 现在查询该新路径名是否已经存在，如果存在则也不能建立链接。于是释放包含该已存在目录项的高速缓冲块，放回新路径名目录的i节点
	// 和原路径名的i节点，返回出错号。
	bh = find_entry(&dir, basename, namelen, &de);
    f813:	8d 44 24 04          	lea    0x4(%esp),%eax
    f817:	83 ec 0c             	sub    $0xc,%esp
    f81a:	8d 7c 24 0c          	lea    0xc(%esp),%edi
    f81e:	57                   	push   %edi
    f81f:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    f823:	8b 54 24 18          	mov    0x18(%esp),%edx
    f827:	e8 17 ea ff ff       	call   e243 <find_entry>
    f82c:	83 c4 10             	add    $0x10,%esp
	if (bh) {
    f82f:	85 c0                	test   %eax,%eax
    f831:	74 28                	je     f85b <sys_link+0x128>
		brelse(bh);
    f833:	83 ec 0c             	sub    $0xc,%esp
    f836:	50                   	push   %eax
    f837:	e8 22 cb ff ff       	call   c35e <brelse>
    f83c:	5a                   	pop    %edx
		iput(dir);
    f83d:	ff 74 24 10          	pushl  0x10(%esp)
    f841:	e8 e2 c2 ff ff       	call   bb28 <iput>
		iput(oldinode);
    f846:	89 34 24             	mov    %esi,(%esp)
    f849:	e8 da c2 ff ff       	call   bb28 <iput>
    f84e:	83 c4 10             	add    $0x10,%esp
		return -EEXIST;
    f851:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
    f856:	e9 93 00 00 00       	jmp    f8ee <sys_link+0x1bb>
	}
	// 现在所有条件都满足了，于是我们在新目录中添加一个目录项。若失败则放回该目录的i节点和原路径名的i节点，返回出错号。否则初始
	// 设置该目录项的i节点号等于原路径名的i节点号，并置包含该新添目录的缓冲块已修改标志，释放该缓冲块，放回目录的i节点。
	bh = add_entry(dir, basename, namelen, &de);
    f85b:	83 ec 0c             	sub    $0xc,%esp
    f85e:	57                   	push   %edi
    f85f:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
    f863:	8b 54 24 18          	mov    0x18(%esp),%edx
    f867:	8b 44 24 14          	mov    0x14(%esp),%eax
    f86b:	e8 85 eb ff ff       	call   e3f5 <add_entry>
    f870:	83 c4 10             	add    $0x10,%esp
	if (!bh) {
    f873:	85 c0                	test   %eax,%eax
    f875:	75 1e                	jne    f895 <sys_link+0x162>
		iput(dir);
    f877:	83 ec 0c             	sub    $0xc,%esp
    f87a:	ff 74 24 10          	pushl  0x10(%esp)
    f87e:	e8 a5 c2 ff ff       	call   bb28 <iput>
		iput(oldinode);
    f883:	89 34 24             	mov    %esi,(%esp)
    f886:	e8 9d c2 ff ff       	call   bb28 <iput>
    f88b:	83 c4 10             	add    $0x10,%esp
		return -ENOSPC;
    f88e:	b8 e4 ff ff ff       	mov    $0xffffffe4,%eax
    f893:	eb 59                	jmp    f8ee <sys_link+0x1bb>
	}
	de->inode = oldinode->i_num;
    f895:	8b 14 24             	mov    (%esp),%edx
    f898:	66 8b 4e 32          	mov    0x32(%esi),%cx
	bh->b_dirt = 1;
	brelse(bh);
    f89c:	83 ec 0c             	sub    $0xc,%esp
	de->inode = oldinode->i_num;
    f89f:	66 89 0a             	mov    %cx,(%edx)
	bh->b_dirt = 1;
    f8a2:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	brelse(bh);
    f8a6:	50                   	push   %eax
    f8a7:	e8 b2 ca ff ff       	call   c35e <brelse>
    f8ac:	58                   	pop    %eax
	iput(dir);
    f8ad:	ff 74 24 10          	pushl  0x10(%esp)
    f8b1:	e8 72 c2 ff ff       	call   bb28 <iput>
	// 再将原节点的链接计数加1,修改其改变时间为当前时间，并设置i节点已修改标志。最后放回原路径名的i节点，并返回0（成功）。
	oldinode->i_nlinks++;
	oldinode->i_ctime = CURRENT_TIME;
    f8b6:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
    f8bc:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
    f8c2:	b9 64 00 00 00       	mov    $0x64,%ecx
	oldinode->i_nlinks++;
    f8c7:	fe 46 0d             	incb   0xd(%esi)
	oldinode->i_dirt = 1;
    f8ca:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	oldinode->i_ctime = CURRENT_TIME;
    f8ce:	8b 00                	mov    (%eax),%eax
    f8d0:	03 02                	add    (%edx),%eax
    f8d2:	31 d2                	xor    %edx,%edx
    f8d4:	f7 f1                	div    %ecx
    f8d6:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    f8dc:	03 02                	add    (%edx),%eax
    f8de:	89 46 2c             	mov    %eax,0x2c(%esi)
	iput(oldinode);
    f8e1:	89 34 24             	mov    %esi,(%esp)
    f8e4:	e8 3f c2 ff ff       	call   bb28 <iput>
    f8e9:	83 c4 10             	add    $0x10,%esp
	return 0;
    f8ec:	31 c0                	xor    %eax,%eax
}
    f8ee:	83 c4 10             	add    $0x10,%esp
    f8f1:	5b                   	pop    %ebx
    f8f2:	5e                   	pop    %esi
    f8f3:	5f                   	pop    %edi
    f8f4:	c3                   	ret    

0000f8f5 <free_block>:

// 释放设备dev上数据区中的逻辑块block。
// 复位指定逻辑块block对应的逻辑块位图位。成功则返回1,否则返回0.
// 参数：dev是设备号，block是逻辑块号（盘块号）。
int free_block(int dev, int block)
{
    f8f5:	55                   	push   %ebp
    f8f6:	57                   	push   %edi
    f8f7:	56                   	push   %esi
    f8f8:	53                   	push   %ebx
    f8f9:	e8 2e 71 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    f8fe:	81 c3 02 17 01 00    	add    $0x11702,%ebx
    f904:	83 ec 18             	sub    $0x18,%esp
    f907:	8b 74 24 30          	mov    0x30(%esp),%esi
	struct buffer_head * bh;

	// 首先取设备dev上文件系统的超级块信息，根据其中数据区开始逻辑块号和文件系统中逻辑块总数信息判断参数block的有效
	// 性。如果指定设备超级块不存在，则出错停机。若逻辑块号小于盘上数据区第1个逻辑块号或者大于设备上总逻辑块数，也出
	// 错停机。
	if (!(sb = get_super(dev)))             						// fs/super.c
    f90b:	ff 74 24 2c          	pushl  0x2c(%esp)
    f90f:	e8 53 cd ff ff       	call   c667 <get_super>
    f914:	83 c4 10             	add    $0x10,%esp
    f917:	85 c0                	test   %eax,%eax
    f919:	89 c7                	mov    %eax,%edi
    f91b:	75 12                	jne    f92f <free_block+0x3a>
		panic("trying to free block on nonexistent device");
    f91d:	8d 83 a0 75 ff ff    	lea    -0x8a60(%ebx),%eax
    f923:	83 ec 0c             	sub    $0xc,%esp
    f926:	50                   	push   %eax
    f927:	e8 a6 87 ff ff       	call   80d2 <panic>
    f92c:	83 c4 10             	add    $0x10,%esp
	if (block < sb->s_firstdatazone || block >= sb->s_nzones)
    f92f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
    f933:	39 f0                	cmp    %esi,%eax
    f935:	7f 08                	jg     f93f <free_block+0x4a>
    f937:	0f b7 47 02          	movzwl 0x2(%edi),%eax
    f93b:	39 f0                	cmp    %esi,%eax
    f93d:	7f 12                	jg     f951 <free_block+0x5c>
		panic("trying to free block not in datazone");
    f93f:	8d 83 cb 75 ff ff    	lea    -0x8a35(%ebx),%eax
    f945:	83 ec 0c             	sub    $0xc,%esp
    f948:	50                   	push   %eax
    f949:	e8 84 87 ff ff       	call   80d2 <panic>
    f94e:	83 c4 10             	add    $0x10,%esp
	bh = get_hash_table(dev, block);
    f951:	52                   	push   %edx
    f952:	52                   	push   %edx
    f953:	56                   	push   %esi
    f954:	ff 74 24 2c          	pushl  0x2c(%esp)
    f958:	e8 20 c8 ff ff       	call   c17d <get_hash_table>
    f95d:	83 c4 10             	add    $0x10,%esp
	// 然后从hash表中寻找该块数据。若找到了则判断其有效性，并清已修改和更新标志，释放该数据块。该段代码的主要用途是如果
	// 该逻辑块目前存在于高速缓冲区中，就释放对应的缓冲块。
	if (bh) {
    f960:	85 c0                	test   %eax,%eax
    f962:	74 2e                	je     f992 <free_block+0x9d>
		if (bh->b_count > 1) {          							// 如果引用次数大于1,则调用brelse()。
    f964:	8a 50 0c             	mov    0xc(%eax),%dl
    f967:	80 fa 01             	cmp    $0x1,%dl
    f96a:	76 10                	jbe    f97c <free_block+0x87>
			brelse(bh);             								// b_count--后退出，该块还有人用。
    f96c:	83 ec 0c             	sub    $0xc,%esp
    f96f:	50                   	push   %eax
    f970:	e8 e9 c9 ff ff       	call   c35e <brelse>
    f975:	83 c4 10             	add    $0x10,%esp
			return 0;
    f978:	31 c0                	xor    %eax,%eax
    f97a:	eb 78                	jmp    f9f4 <free_block+0xff>
		}
		bh->b_dirt = 0;                   							// 否则复位已修改和已更新标志。
		bh->b_uptodate = 0;
		if (bh->b_count)                							// 若此时b_count为1,则调用brelse()释放之。
    f97c:	84 d2                	test   %dl,%dl
		bh->b_uptodate = 0;
    f97e:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
		if (bh->b_count)                							// 若此时b_count为1,则调用brelse()释放之。
    f984:	74 0c                	je     f992 <free_block+0x9d>
			brelse(bh);
    f986:	83 ec 0c             	sub    $0xc,%esp
    f989:	50                   	push   %eax
    f98a:	e8 cf c9 ff ff       	call   c35e <brelse>
    f98f:	83 c4 10             	add    $0x10,%esp
	}
	// 接着我们复位block在逻辑块位图中的位（置0）。先计算block在数据区开始算起的数据逻辑块号（从1开始计数）。然后对逻辑
	// 块（区块）位图进行操作，复位对应的位。如果对应位原来就是0,则出错停机。由于1个缓冲块有1024字节，即8192位，因此
	// block/8192即可计算出指定块block在逻辑位图中的哪个块上。而block&8191可以得到block在逻辑块位图当前块中的位偏移
	// 位置。
	block -= sb->s_firstdatazone - 1 ;
    f992:	0f b7 4f 08          	movzwl 0x8(%edi),%ecx
	if (clear_bit(block & 8191, sb->s_zmap[block / 8192]->b_data)) {
    f996:	bd 00 20 00 00       	mov    $0x2000,%ebp
	block -= sb->s_firstdatazone - 1 ;
    f99b:	8d 41 ff             	lea    -0x1(%ecx),%eax
    f99e:	29 c6                	sub    %eax,%esi
	if (clear_bit(block & 8191, sb->s_zmap[block / 8192]->b_data)) {
    f9a0:	89 f0                	mov    %esi,%eax
    f9a2:	99                   	cltd   
    f9a3:	f7 fd                	idiv   %ebp
    f9a5:	89 f5                	mov    %esi,%ebp
    f9a7:	81 e5 ff 1f 00 00    	and    $0x1fff,%ebp
    f9ad:	8d 3c 87             	lea    (%edi,%eax,4),%edi
    f9b0:	8b 47 34             	mov    0x34(%edi),%eax
    f9b3:	8b 10                	mov    (%eax),%edx
    f9b5:	31 c0                	xor    %eax,%eax
    f9b7:	0f b3 2a             	btr    %ebp,(%edx)
    f9ba:	0f 93 c0             	setae  %al
    f9bd:	85 c0                	test   %eax,%eax
    f9bf:	74 27                	je     f9e8 <free_block+0xf3>
		printk("block (%04x:%d) ", dev, block + sb->s_firstdatazone - 1);
    f9c1:	50                   	push   %eax
    f9c2:	8d 44 0e ff          	lea    -0x1(%esi,%ecx,1),%eax
    f9c6:	50                   	push   %eax
    f9c7:	8d 83 f0 75 ff ff    	lea    -0x8a10(%ebx),%eax
    f9cd:	ff 74 24 28          	pushl  0x28(%esp)
    f9d1:	50                   	push   %eax
    f9d2:	e8 4a 87 ff ff       	call   8121 <printk>
		printk("free_block: bit already cleared\n");
    f9d7:	8d 83 01 76 ff ff    	lea    -0x89ff(%ebx),%eax
    f9dd:	89 04 24             	mov    %eax,(%esp)
    f9e0:	e8 3c 87 ff ff       	call   8121 <printk>
    f9e5:	83 c4 10             	add    $0x10,%esp
	}
	// 最后置相应逻辑块位图所在缓冲区已修改标志。
	sb->s_zmap[block / 8192]->b_dirt = 1;
    f9e8:	8b 47 34             	mov    0x34(%edi),%eax
    f9eb:	c6 40 0b 01          	movb   $0x1,0xb(%eax)
	return 1;
    f9ef:	b8 01 00 00 00       	mov    $0x1,%eax
}
    f9f4:	83 c4 0c             	add    $0xc,%esp
    f9f7:	5b                   	pop    %ebx
    f9f8:	5e                   	pop    %esi
    f9f9:	5f                   	pop    %edi
    f9fa:	5d                   	pop    %ebp
    f9fb:	c3                   	ret    

0000f9fc <new_block>:
// 向设备申请一个逻辑块(盘块,区块).
// 函数首先取得设备的超级块,并在超级块中的逻辑块位图中寻找第一个0值位(代表一个空闲逻辑块).然后置位对应逻辑块在逻辑位图
// 中的位.接着为该逻辑块在缓冲区中取得一块对应缓冲块.最后将该缓冲块清零,并设置其已更新标志和已修改标志.并返回逻辑块号.
// 函数执行成功则返回逻辑块号(盘块号),否则返回0.
int new_block(int dev)
{
    f9fc:	55                   	push   %ebp
    f9fd:	57                   	push   %edi
    f9fe:	56                   	push   %esi
    f9ff:	53                   	push   %ebx
    fa00:	e8 27 70 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    fa05:	81 c3 fb 15 01 00    	add    $0x115fb,%ebx
    fa0b:	83 ec 28             	sub    $0x28,%esp
	int i,j;

	// 首先获取设备dev的超级块.如果指定设备的超级块不存在,则出错停机.然后扫描文件系统的8块逻辑块位图,寻找首个0值位,以寻找
	// 空闲逻辑块,获取设置该逻辑块的块号.如果全部扫描完8块逻辑块位图的所有位(i >=8 或 j >= 8192)还没有找到0值位或者位图
	// 所在的缓冲块指针无效(bn = NULL)则返回0退出(没有空闲逻辑块).
	if (!(sb = get_super(dev)))
    fa0e:	ff 74 24 3c          	pushl  0x3c(%esp)
    fa12:	e8 50 cc ff ff       	call   c667 <get_super>
    fa17:	83 c4 10             	add    $0x10,%esp
    fa1a:	85 c0                	test   %eax,%eax
    fa1c:	89 c7                	mov    %eax,%edi
    fa1e:	75 12                	jne    fa32 <new_block+0x36>
		panic("trying to get new block from nonexistant device");
    fa20:	8d 83 22 76 ff ff    	lea    -0x89de(%ebx),%eax
    fa26:	83 ec 0c             	sub    $0xc,%esp
    fa29:	50                   	push   %eax
    fa2a:	e8 a3 86 ff ff       	call   80d2 <panic>
    fa2f:	83 c4 10             	add    $0x10,%esp
	j = 8192;
    fa32:	be 00 20 00 00       	mov    $0x2000,%esi
	for (i = 0 ; i < 8 ; i++)
    fa37:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    fa3e:	00 
		if (bh = sb->s_zmap[i])
    fa3f:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fa43:	8b 6c 87 34          	mov    0x34(%edi,%eax,4),%ebp
    fa47:	85 ed                	test   %ebp,%ebp
    fa49:	74 27                	je     fa72 <new_block+0x76>
			if ((j = find_first_zero(bh->b_data)) < 8192)
    fa4b:	8b 75 00             	mov    0x0(%ebp),%esi
    fa4e:	31 c9                	xor    %ecx,%ecx
    fa50:	fc                   	cld    
    fa51:	ad                   	lods   %ds:(%esi),%eax
    fa52:	f7 d0                	not    %eax
    fa54:	0f bc d0             	bsf    %eax,%edx
    fa57:	74 04                	je     fa5d <new_block+0x61>
    fa59:	01 d1                	add    %edx,%ecx
    fa5b:	eb 0b                	jmp    fa68 <new_block+0x6c>
    fa5d:	83 c1 20             	add    $0x20,%ecx
    fa60:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
    fa66:	7c e9                	jl     fa51 <new_block+0x55>
    fa68:	81 f9 ff 1f 00 00    	cmp    $0x1fff,%ecx
    fa6e:	89 ce                	mov    %ecx,%esi
    fa70:	7e 0b                	jle    fa7d <new_block+0x81>
	for (i = 0 ; i < 8 ; i++)
    fa72:	ff 44 24 0c          	incl   0xc(%esp)
    fa76:	83 7c 24 0c 08       	cmpl   $0x8,0xc(%esp)
    fa7b:	75 c2                	jne    fa3f <new_block+0x43>
				break;
	if (i >= 8 || !bh || j >= 8192)
    fa7d:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
    fa82:	0f 9f c2             	setg   %dl
    fa85:	85 ed                	test   %ebp,%ebp
    fa87:	0f 94 c0             	sete   %al
    fa8a:	08 c2                	or     %al,%dl
    fa8c:	75 08                	jne    fa96 <new_block+0x9a>
    fa8e:	81 fe ff 1f 00 00    	cmp    $0x1fff,%esi
    fa94:	7e 07                	jle    fa9d <new_block+0xa1>
		return 0;
    fa96:	31 f6                	xor    %esi,%esi
    fa98:	e9 9c 00 00 00       	jmp    fb39 <new_block+0x13d>
	// 接着设置找到的新逻辑块j对应逻辑块位图中的位.若对应位已经置位,则出错停机.否则置存在位图的对应缓冲区块已修改标志.因为
	// 逻辑块位图仅表示盘上数据区中逻辑块的占用情况,即逻辑块位图中位偏移值表示从数据区开始处算起的块号,因此这里需要加上数据
	// 区第1个逻辑块的块号,把j转换成逻辑块号.此时如果新逻辑块大于该设备上的总逻辑块数,则说明指定逻辑块在对应设备上不存在.
	// 申请失败,返回0退出.
	if (set_bit(j, bh->b_data))
    fa9d:	8b 55 00             	mov    0x0(%ebp),%edx
    faa0:	31 c0                	xor    %eax,%eax
    faa2:	0f ab 32             	bts    %esi,(%edx)
    faa5:	0f 92 c0             	setb   %al
    faa8:	85 c0                	test   %eax,%eax
    faaa:	74 12                	je     fabe <new_block+0xc2>
		panic("new_block: bit already set");
    faac:	8d 83 52 76 ff ff    	lea    -0x89ae(%ebx),%eax
    fab2:	83 ec 0c             	sub    $0xc,%esp
    fab5:	50                   	push   %eax
    fab6:	e8 17 86 ff ff       	call   80d2 <panic>
    fabb:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
    fabe:	c6 45 0b 01          	movb   $0x1,0xb(%ebp)
	j += i * 8192 + sb->s_firstdatazone - 1;
    fac2:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fac6:	0f b7 57 08          	movzwl 0x8(%edi),%edx
    faca:	c1 e0 0d             	shl    $0xd,%eax
    facd:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
	if (j >= sb->s_nzones)
    fad1:	0f b7 47 02          	movzwl 0x2(%edi),%eax
	j += i * 8192 + sb->s_firstdatazone - 1;
    fad5:	01 ce                	add    %ecx,%esi
	if (j >= sb->s_nzones)
    fad7:	39 f0                	cmp    %esi,%eax
    fad9:	7e bb                	jle    fa96 <new_block+0x9a>
		return 0;
	// 然后在高速缓冲区中为该设备上指定的逻辑块号取得一个缓冲块,并返回缓冲块头指针.
	// 因为刚取得的逻辑块其引用次数一定为1(getblk()中会设置),因此若不为1则停机.最后将新逻辑块清零,并设置其已更新标志和已
	// 修改标志.然后释放对应缓冲块,返回逻辑块号.
	if (!(bh = getblk(dev, j)))
    fadb:	50                   	push   %eax
    fadc:	50                   	push   %eax
    fadd:	56                   	push   %esi
    fade:	ff 74 24 3c          	pushl  0x3c(%esp)
    fae2:	e8 d0 c6 ff ff       	call   c1b7 <getblk>
    fae7:	83 c4 10             	add    $0x10,%esp
    faea:	85 c0                	test   %eax,%eax
    faec:	89 c5                	mov    %eax,%ebp
    faee:	75 12                	jne    fb02 <new_block+0x106>
		panic("new_block: cannot get block");
    faf0:	8d 83 6d 76 ff ff    	lea    -0x8993(%ebx),%eax
    faf6:	83 ec 0c             	sub    $0xc,%esp
    faf9:	50                   	push   %eax
    fafa:	e8 d3 85 ff ff       	call   80d2 <panic>
    faff:	83 c4 10             	add    $0x10,%esp
	if (bh->b_count != 1)
    fb02:	80 7d 0c 01          	cmpb   $0x1,0xc(%ebp)
    fb06:	74 12                	je     fb1a <new_block+0x11e>
		panic("new block: count is != 1");
    fb08:	8d 83 89 76 ff ff    	lea    -0x8977(%ebx),%eax
    fb0e:	83 ec 0c             	sub    $0xc,%esp
    fb11:	50                   	push   %eax
    fb12:	e8 bb 85 ff ff       	call   80d2 <panic>
    fb17:	83 c4 10             	add    $0x10,%esp
	clear_block(bh->b_data);
    fb1a:	8b 7d 00             	mov    0x0(%ebp),%edi
    fb1d:	31 c0                	xor    %eax,%eax
    fb1f:	b9 00 01 00 00       	mov    $0x100,%ecx
    fb24:	fc                   	cld    
    fb25:	f3 ab                	rep stos %eax,%es:(%edi)
	bh->b_uptodate = 1;
	bh->b_dirt = 1;
	brelse(bh);
    fb27:	83 ec 0c             	sub    $0xc,%esp
	bh->b_uptodate = 1;
    fb2a:	66 c7 45 0a 01 01    	movw   $0x101,0xa(%ebp)
	brelse(bh);
    fb30:	55                   	push   %ebp
    fb31:	e8 28 c8 ff ff       	call   c35e <brelse>
    fb36:	83 c4 10             	add    $0x10,%esp
	return j;
}
    fb39:	83 c4 1c             	add    $0x1c,%esp
    fb3c:	89 f0                	mov    %esi,%eax
    fb3e:	5b                   	pop    %ebx
    fb3f:	5e                   	pop    %esi
    fb40:	5f                   	pop    %edi
    fb41:	5d                   	pop    %ebp
    fb42:	c3                   	ret    

0000fb43 <free_inode>:

// 释放指定的i节点。
// 该函数首先判断参数给出的i节点号的有效性和可释放性。若i节点仍然在使用中则不能被释放。然后利用超级块信息对i节点位图进行
// 操作，复位i节点号对应的i节点位图中位，并清空i节点结构。
void free_inode(struct m_inode * inode)
{
    fb43:	57                   	push   %edi
    fb44:	56                   	push   %esi
    fb45:	53                   	push   %ebx
    fb46:	8b 7c 24 10          	mov    0x10(%esp),%edi
    fb4a:	e8 dd 6e ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    fb4f:	81 c3 b1 14 01 00    	add    $0x114b1,%ebx
	struct buffer_head * bh;

	// 首先判断参数给出的需要释放的i节点有效性或合法性。如果i节点指针=NULL，则退出。
	// 如果i节点上的设备号字段为0,说明该节点没有使用。于是用0清空对应i节点所占内存区并返回memset()定义在include/string.h
	// 处。这里表示用0填写inode指针指定处、长度是sizeof(*inode)的内存块。
	if (!inode)
    fb55:	85 ff                	test   %edi,%edi
    fb57:	0f 84 f4 00 00 00    	je     fc51 <free_inode+0x10e>
		return;
	if (!inode->i_dev) {
    fb5d:	66 83 7f 30 00       	cmpw   $0x0,0x30(%edi)
    fb62:	0f 84 dd 00 00 00    	je     fc45 <free_inode+0x102>
		memset(inode, 0, sizeof(*inode));
		return;
	}
	// 如果此i节点还有其他程序引用，则不释放，说明内核有问题，停机。如果文件连接数不为0,则表示还有其他文件目录项在使用该节点，
	// 因此也不应释放，而应该放回等。
	if (inode->i_count > 1) {
    fb68:	0f b7 47 34          	movzwl 0x34(%edi),%eax
    fb6c:	66 83 f8 01          	cmp    $0x1,%ax
    fb70:	76 20                	jbe    fb92 <free_inode+0x4f>
		printk("trying to free inode with count=%d\n", inode->i_count);
    fb72:	52                   	push   %edx
    fb73:	52                   	push   %edx
    fb74:	50                   	push   %eax
    fb75:	8d 83 a2 76 ff ff    	lea    -0x895e(%ebx),%eax
    fb7b:	50                   	push   %eax
    fb7c:	e8 a0 85 ff ff       	call   8121 <printk>
		panic("free_inode");
    fb81:	8d 83 c6 76 ff ff    	lea    -0x893a(%ebx),%eax
    fb87:	89 04 24             	mov    %eax,(%esp)
    fb8a:	e8 43 85 ff ff       	call   80d2 <panic>
    fb8f:	83 c4 10             	add    $0x10,%esp
	}
	if (inode->i_nlinks)
    fb92:	80 7f 0d 00          	cmpb   $0x0,0xd(%edi)
    fb96:	74 12                	je     fbaa <free_inode+0x67>
		panic("trying to free inode with links");
    fb98:	8d 83 d1 76 ff ff    	lea    -0x892f(%ebx),%eax
    fb9e:	83 ec 0c             	sub    $0xc,%esp
    fba1:	50                   	push   %eax
    fba2:	e8 2b 85 ff ff       	call   80d2 <panic>
    fba7:	83 c4 10             	add    $0x10,%esp
	// 在判断完i节点的合理性之后，我们开始利用其超级块信息对其i节点位图进行操作。首先取i节点所在设备的超级块，测试设备是否存在。
	// 然后判断i节点号的范围是否正确，如果i节点号等于0或大于该设备上i节点总数，则出错（0号i节点保留没有使用）。如果该i节点对应
	// 的节点位图不存在，则出错。因为一个缓冲块的i节点位图有8192比特位。因此i_num>>13（即i_num/8192）可以得到当前i节点号所
	// 在的s_imap[]项，即所在盘块。
	if (!(sb = get_super(inode->i_dev)))
    fbaa:	0f b7 47 30          	movzwl 0x30(%edi),%eax
    fbae:	83 ec 0c             	sub    $0xc,%esp
    fbb1:	50                   	push   %eax
    fbb2:	e8 b0 ca ff ff       	call   c667 <get_super>
    fbb7:	83 c4 10             	add    $0x10,%esp
    fbba:	85 c0                	test   %eax,%eax
    fbbc:	89 c6                	mov    %eax,%esi
    fbbe:	75 12                	jne    fbd2 <free_inode+0x8f>
		panic("trying to free inode on nonexistent device");
    fbc0:	8d 83 f1 76 ff ff    	lea    -0x890f(%ebx),%eax
    fbc6:	83 ec 0c             	sub    $0xc,%esp
    fbc9:	50                   	push   %eax
    fbca:	e8 03 85 ff ff       	call   80d2 <panic>
    fbcf:	83 c4 10             	add    $0x10,%esp
	if (inode->i_num < 1 || inode->i_num > sb->s_ninodes)
    fbd2:	66 8b 47 32          	mov    0x32(%edi),%ax
    fbd6:	66 85 c0             	test   %ax,%ax
    fbd9:	74 05                	je     fbe0 <free_inode+0x9d>
    fbdb:	66 3b 06             	cmp    (%esi),%ax
    fbde:	76 12                	jbe    fbf2 <free_inode+0xaf>
		panic("trying to free inode 0 or nonexistant inode");
    fbe0:	8d 83 1c 77 ff ff    	lea    -0x88e4(%ebx),%eax
    fbe6:	83 ec 0c             	sub    $0xc,%esp
    fbe9:	50                   	push   %eax
    fbea:	e8 e3 84 ff ff       	call   80d2 <panic>
    fbef:	83 c4 10             	add    $0x10,%esp
	if (!(bh = sb->s_imap[inode->i_num >> 13]))
    fbf2:	66 8b 57 32          	mov    0x32(%edi),%dx
    fbf6:	66 c1 ea 0d          	shr    $0xd,%dx
    fbfa:	0f b7 d2             	movzwl %dx,%edx
    fbfd:	8b 74 96 14          	mov    0x14(%esi,%edx,4),%esi
    fc01:	85 f6                	test   %esi,%esi
    fc03:	75 12                	jne    fc17 <free_inode+0xd4>
		panic("nonexistent imap in superblock");
    fc05:	8d 83 48 77 ff ff    	lea    -0x88b8(%ebx),%eax
    fc0b:	83 ec 0c             	sub    $0xc,%esp
    fc0e:	50                   	push   %eax
    fc0f:	e8 be 84 ff ff       	call   80d2 <panic>
    fc14:	83 c4 10             	add    $0x10,%esp
	// 现在我们复位i节点对应的节点位图中的位。如果该位已经等于0,则显示出错警告信息。最后置i节点位图所在缓冲区已修改标志，并清空
	// 该i节点结构所占内存区。
	if (clear_bit(inode->i_num & 8191, bh->b_data))
    fc17:	66 8b 57 32          	mov    0x32(%edi),%dx
    fc1b:	8b 0e                	mov    (%esi),%ecx
    fc1d:	31 c0                	xor    %eax,%eax
    fc1f:	81 e2 ff 1f 00 00    	and    $0x1fff,%edx
    fc25:	0f b3 11             	btr    %edx,(%ecx)
    fc28:	0f 93 c0             	setae  %al
    fc2b:	85 c0                	test   %eax,%eax
    fc2d:	74 12                	je     fc41 <free_inode+0xfe>
		printk("free_inode: bit already cleared.\n\r");
    fc2f:	8d 83 67 77 ff ff    	lea    -0x8899(%ebx),%eax
    fc35:	83 ec 0c             	sub    $0xc,%esp
    fc38:	50                   	push   %eax
    fc39:	e8 e3 84 ff ff       	call   8121 <printk>
    fc3e:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
    fc41:	c6 46 0b 01          	movb   $0x1,0xb(%esi)
__asm__(
    fc45:	31 c0                	xor    %eax,%eax
    fc47:	b9 3c 00 00 00       	mov    $0x3c,%ecx
    fc4c:	fc                   	cld    
    fc4d:	57                   	push   %edi
    fc4e:	f3 aa                	rep stos %al,%es:(%edi)
    fc50:	5f                   	pop    %edi
	memset(inode, 0, sizeof(*inode));
}
    fc51:	5b                   	pop    %ebx
    fc52:	5e                   	pop    %esi
    fc53:	5f                   	pop    %edi
    fc54:	c3                   	ret    

0000fc55 <new_inode>:

// 为设备dev建立一个新i节点。初始化并返回该新i节点的指针。
// 在内存i节点表中获取一个空闲i节点表项，并从i节点位图中找一个空闲i节点。
struct m_inode * new_inode(int dev)
{
    fc55:	55                   	push   %ebp
    fc56:	57                   	push   %edi
    fc57:	56                   	push   %esi
    fc58:	53                   	push   %ebx
    fc59:	e8 ce 6d ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    fc5e:	81 c3 a2 13 01 00    	add    $0x113a2,%ebx
    fc64:	83 ec 1c             	sub    $0x1c,%esp
	int i, j;

	// 首先从内在i节点表（inode_table）中获取一个空闲i节点项，并读取指定设备的超级块结构。然后扫描超级块中8块i节点位图，
	// 寻找第1个0位，寻找空闲节点，获取放置该i节点的节点号。如果全部扫描完还没找到，或者位图所在的缓冲块无效（bh = NULL）
	// 则放回先前申请的i节点表中的i节点，并返回空指针退出（没有空闲i节点）。
	if (!(inode = get_empty_inode()))
    fc67:	e8 a9 bf ff ff       	call   bc15 <get_empty_inode>
    fc6c:	85 c0                	test   %eax,%eax
    fc6e:	89 c7                	mov    %eax,%edi
    fc70:	0f 84 3a 01 00 00    	je     fdb0 <new_inode+0x15b>
		return NULL;
	if (!(sb = get_super(dev)))
    fc76:	83 ec 0c             	sub    $0xc,%esp
    fc79:	ff 74 24 3c          	pushl  0x3c(%esp)
    fc7d:	e8 e5 c9 ff ff       	call   c667 <get_super>
    fc82:	83 c4 10             	add    $0x10,%esp
    fc85:	85 c0                	test   %eax,%eax
    fc87:	89 44 24 0c          	mov    %eax,0xc(%esp)
    fc8b:	75 12                	jne    fc9f <new_inode+0x4a>
		panic("new_inode with unknown device");
    fc8d:	8d 83 8a 77 ff ff    	lea    -0x8876(%ebx),%eax
    fc93:	83 ec 0c             	sub    $0xc,%esp
    fc96:	50                   	push   %eax
    fc97:	e8 36 84 ff ff       	call   80d2 <panic>
    fc9c:	83 c4 10             	add    $0x10,%esp
	j = 8192;
    fc9f:	be 00 20 00 00       	mov    $0x2000,%esi
	for (i = 0 ; i < 8 ; i++)
    fca4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    fcab:	00 
		if (bh = sb->s_imap[i])
    fcac:	8b 44 24 0c          	mov    0xc(%esp),%eax
    fcb0:	8b 4c 24 08          	mov    0x8(%esp),%ecx
    fcb4:	8b 6c 88 14          	mov    0x14(%eax,%ecx,4),%ebp
    fcb8:	85 ed                	test   %ebp,%ebp
    fcba:	74 27                	je     fce3 <new_inode+0x8e>
			if ((j = find_first_zero(bh->b_data)) < 8192)
    fcbc:	8b 75 00             	mov    0x0(%ebp),%esi
    fcbf:	31 c9                	xor    %ecx,%ecx
    fcc1:	fc                   	cld    
    fcc2:	ad                   	lods   %ds:(%esi),%eax
    fcc3:	f7 d0                	not    %eax
    fcc5:	0f bc d0             	bsf    %eax,%edx
    fcc8:	74 04                	je     fcce <new_inode+0x79>
    fcca:	01 d1                	add    %edx,%ecx
    fccc:	eb 0b                	jmp    fcd9 <new_inode+0x84>
    fcce:	83 c1 20             	add    $0x20,%ecx
    fcd1:	81 f9 00 20 00 00    	cmp    $0x2000,%ecx
    fcd7:	7c e9                	jl     fcc2 <new_inode+0x6d>
    fcd9:	81 f9 ff 1f 00 00    	cmp    $0x1fff,%ecx
    fcdf:	89 ce                	mov    %ecx,%esi
    fce1:	7e 0b                	jle    fcee <new_inode+0x99>
	for (i = 0 ; i < 8 ; i++)
    fce3:	ff 44 24 08          	incl   0x8(%esp)
    fce7:	83 7c 24 08 08       	cmpl   $0x8,0x8(%esp)
    fcec:	75 be                	jne    fcac <new_inode+0x57>
				break;
	if (!bh || j >= 8192 || j + i * 8192 > sb->s_ninodes) {
    fcee:	85 ed                	test   %ebp,%ebp
    fcf0:	74 1c                	je     fd0e <new_inode+0xb9>
    fcf2:	81 fe ff 1f 00 00    	cmp    $0x1fff,%esi
    fcf8:	7f 14                	jg     fd0e <new_inode+0xb9>
    fcfa:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
    fcfe:	8b 44 24 08          	mov    0x8(%esp),%eax
    fd02:	0f b7 11             	movzwl (%ecx),%edx
    fd05:	c1 e0 0d             	shl    $0xd,%eax
    fd08:	01 f0                	add    %esi,%eax
    fd0a:	39 d0                	cmp    %edx,%eax
    fd0c:	7e 13                	jle    fd21 <new_inode+0xcc>
		iput(inode);
    fd0e:	83 ec 0c             	sub    $0xc,%esp
    fd11:	57                   	push   %edi
		return NULL;
    fd12:	31 ff                	xor    %edi,%edi
		iput(inode);
    fd14:	e8 0f be ff ff       	call   bb28 <iput>
    fd19:	83 c4 10             	add    $0x10,%esp
		return NULL;
    fd1c:	e9 8f 00 00 00       	jmp    fdb0 <new_inode+0x15b>
	}
	// 现在我们已经找到了还未使用的i节点号j。于是置位i节点j对应的i节点位图相应比特位（如果已经置位，则出错）。然后置i节点
	// 位图所在缓冲块已修改标志。最后初始化该i节点结构（i_ctime是i节点内容改变时间）。
	if (set_bit(j, bh->b_data))
    fd21:	8b 55 00             	mov    0x0(%ebp),%edx
    fd24:	31 c0                	xor    %eax,%eax
    fd26:	0f ab 32             	bts    %esi,(%edx)
    fd29:	0f 92 c0             	setb   %al
    fd2c:	85 c0                	test   %eax,%eax
    fd2e:	74 12                	je     fd42 <new_inode+0xed>
		panic("new_inode: bit already set");
    fd30:	8d 83 a8 77 ff ff    	lea    -0x8858(%ebx),%eax
    fd36:	83 ec 0c             	sub    $0xc,%esp
    fd39:	50                   	push   %eax
    fd3a:	e8 93 83 ff ff       	call   80d2 <panic>
    fd3f:	83 c4 10             	add    $0x10,%esp
	bh->b_dirt = 1;
	inode->i_count = 1;               										// 引用计数。
	inode->i_nlinks = 1;              										// 文件目录项链接数。
	inode->i_dev = dev;               										// i节点所在的设备号。
    fd42:	8b 44 24 30          	mov    0x30(%esp),%eax
	bh->b_dirt = 1;
    fd46:	c6 45 0b 01          	movb   $0x1,0xb(%ebp)
	inode->i_nlinks = 1;              										// 文件目录项链接数。
    fd4a:	c6 47 0d 01          	movb   $0x1,0xd(%edi)
	inode->i_count = 1;               										// 引用计数。
    fd4e:	66 c7 47 34 01 00    	movw   $0x1,0x34(%edi)
	inode->i_dev = dev;               										// i节点所在的设备号。
    fd54:	66 89 47 30          	mov    %ax,0x30(%edi)
	inode->i_uid = current->euid;     										// i节点所属用户id。
    fd58:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
    fd5e:	8b 00                	mov    (%eax),%eax
    fd60:	66 8b 90 ce 02 00 00 	mov    0x2ce(%eax),%dx
	inode->i_gid = current->egid;     										// 组id。
    fd67:	8b 80 d4 02 00 00    	mov    0x2d4(%eax),%eax
	inode->i_dirt = 1;                										// 已修改标志置位。
    fd6d:	c6 47 37 01          	movb   $0x1,0x37(%edi)
	inode->i_gid = current->egid;     										// 组id。
    fd71:	88 47 0c             	mov    %al,0xc(%edi)
	inode->i_num = j + i * 8192;      										// 对应设备中的i节点号。
    fd74:	8b 44 24 08          	mov    0x8(%esp),%eax
	inode->i_uid = current->euid;     										// i节点所属用户id。
    fd78:	66 89 57 02          	mov    %dx,0x2(%edi)
	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;        // 设置时间。
    fd7c:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
	inode->i_num = j + i * 8192;      										// 对应设备中的i节点号。
    fd82:	c1 e0 0d             	shl    $0xd,%eax
    fd85:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;        // 设置时间。
    fd88:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
	inode->i_num = j + i * 8192;      										// 对应设备中的i节点号。
    fd8e:	66 89 4f 32          	mov    %cx,0x32(%edi)
	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;        // 设置时间。
    fd92:	b9 64 00 00 00       	mov    $0x64,%ecx
    fd97:	8b 00                	mov    (%eax),%eax
    fd99:	03 02                	add    (%edx),%eax
    fd9b:	31 d2                	xor    %edx,%edx
    fd9d:	f7 f1                	div    %ecx
    fd9f:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
    fda5:	03 02                	add    (%edx),%eax
    fda7:	89 47 2c             	mov    %eax,0x2c(%edi)
    fdaa:	89 47 28             	mov    %eax,0x28(%edi)
    fdad:	89 47 08             	mov    %eax,0x8(%edi)
	return inode;                   										// 返回该i节点指针。
}
    fdb0:	83 c4 1c             	add    $0x1c,%esp
    fdb3:	89 f8                	mov    %edi,%eax
    fdb5:	5b                   	pop    %ebx
    fdb6:	5e                   	pop    %esi
    fdb7:	5f                   	pop    %edi
    fdb8:	5d                   	pop    %ebp
    fdb9:	c3                   	ret    

0000fdba <dupfd>:

// 复制文件句柄(文件描述符).
// 参数fd是欲复制的文件句柄,arg指定新文件句柄的最小数值.
// 返回新文件句柄或出错码.
static int dupfd(unsigned int fd, unsigned int arg)
{
    fdba:	e8 bf a0 ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
    fdbf:	81 c1 41 12 01 00    	add    $0x11241,%ecx
	// 首先检查函数参数的有效性.如果文件句柄值大于一个程序最多打开文件数NR_OPEN,或者该句柄的文件结构不存在,则返回出错码并退出.如果指定的新
	// 句柄值arg大于最多打开文件数,也返回出错码并退出.注意,实际上文件句柄就是进程文件结构指针数组项索引号.
	if (fd >= NR_OPEN || !current->filp[fd])
    fdc5:	83 f8 13             	cmp    $0x13,%eax
    fdc8:	77 3b                	ja     fe05 <dupfd+0x4b>
    fdca:	c7 c1 60 23 02 00    	mov    $0x22360,%ecx
{
    fdd0:	56                   	push   %esi
    fdd1:	53                   	push   %ebx
	if (fd >= NR_OPEN || !current->filp[fd])
    fdd2:	8b 19                	mov    (%ecx),%ebx
    fdd4:	8b b4 83 48 03 00 00 	mov    0x348(%ebx,%eax,4),%esi
		return -EBADF;
    fddb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
	if (fd >= NR_OPEN || !current->filp[fd])
    fde0:	85 f6                	test   %esi,%esi
    fde2:	74 43                	je     fe27 <dupfd+0x6d>
	if (arg >= NR_OPEN)
    fde4:	83 fa 13             	cmp    $0x13,%edx
		return -EINVAL;
    fde7:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	if (arg >= NR_OPEN)
    fdec:	77 39                	ja     fe27 <dupfd+0x6d>
	// 然后在当前进程的文件结构指针数组中寻找索引号等于或大于arg,但还没有使用的项.若找到的新句柄值arg大于最多打开文件数(即没有空闲项),则返回
	// 出错码并退出.
	while (arg < NR_OPEN)
		if (current->filp[arg])
    fdee:	83 bc 93 48 03 00 00 	cmpl   $0x0,0x348(%ebx,%edx,4)
    fdf5:	00 
    fdf6:	74 13                	je     fe0b <dupfd+0x51>
			arg++;
    fdf8:	42                   	inc    %edx
	while (arg < NR_OPEN)
    fdf9:	83 fa 14             	cmp    $0x14,%edx
    fdfc:	75 f0                	jne    fdee <dupfd+0x34>
		else
			break;
	if (arg >= NR_OPEN)
		return -EMFILE;
    fdfe:	b8 e8 ff ff ff       	mov    $0xffffffe8,%eax
    fe03:	eb 22                	jmp    fe27 <dupfd+0x6d>
		return -EBADF;
    fe05:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
	// 否则针对找到的空闲项(句柄),在执行时关闭标志位图close_on_exec中复位该句柄位.即在运行exec()类函数时,不会关闭用dup()创建的的句柄.并令该
	// 文件结构指针等于原句柄fd的指针,并且将文件引用数增1.最后返回新的文件句柄arg.
	current->close_on_exec &= ~(1 << arg);
	(current->filp[arg] = current->filp[fd])->f_count++;
	return arg;
}
    fe0a:	c3                   	ret    
	current->close_on_exec &= ~(1 << arg);
    fe0b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
    fe10:	88 d1                	mov    %dl,%cl
    fe12:	d3 c0                	rol    %cl,%eax
    fe14:	21 83 44 03 00 00    	and    %eax,0x344(%ebx)
	(current->filp[arg] = current->filp[fd])->f_count++;
    fe1a:	89 b4 93 48 03 00 00 	mov    %esi,0x348(%ebx,%edx,4)
    fe21:	66 ff 46 04          	incw   0x4(%esi)
	return arg;
    fe25:	89 d0                	mov    %edx,%eax
}
    fe27:	5b                   	pop    %ebx
    fe28:	5e                   	pop    %esi
    fe29:	c3                   	ret    

0000fe2a <sys_dup2>:
// 复制文件句柄系统调用。
// 复制指定文件句柄oldfd，新文件句柄值等于newfd。如果newfd已打开，则首先关闭之。
// 参数：oldfd -- 原文件句柄；newfd - 新文件句柄。
// 返回新文件句柄值。
int sys_dup2(unsigned int oldfd, unsigned int newfd)
{
    fe2a:	57                   	push   %edi
    fe2b:	56                   	push   %esi
    fe2c:	53                   	push   %ebx
    fe2d:	8b 74 24 14          	mov    0x14(%esp),%esi
    fe31:	8b 7c 24 10          	mov    0x10(%esp),%edi
	sys_close(newfd);               						// 若句柄newfd已经打开，则首先关闭之。
    fe35:	83 ec 0c             	sub    $0xc,%esp
    fe38:	56                   	push   %esi
    fe39:	e8 ee 6b ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    fe3e:	81 c3 c2 11 01 00    	add    $0x111c2,%ebx
    fe44:	e8 a6 b4 ff ff       	call   b2ef <sys_close>
    fe49:	83 c4 10             	add    $0x10,%esp
	return dupfd(oldfd, newfd);      						// 复制并返回新句柄。
    fe4c:	89 f2                	mov    %esi,%edx
    fe4e:	89 f8                	mov    %edi,%eax
}
    fe50:	5b                   	pop    %ebx
    fe51:	5e                   	pop    %esi
    fe52:	5f                   	pop    %edi
	return dupfd(oldfd, newfd);      						// 复制并返回新句柄。
    fe53:	e9 62 ff ff ff       	jmp    fdba <dupfd>

0000fe58 <sys_dup>:
// 复制指定文件句柄oldfd,新句柄的值是当前最小的未用句柄值.
// 参数:fildes -- 被复制的文件句柄.
// 返回新文件句柄值.
int sys_dup(unsigned int fildes)
{
	return dupfd(fildes, 0);
    fe58:	8b 44 24 04          	mov    0x4(%esp),%eax
    fe5c:	31 d2                	xor    %edx,%edx
    fe5e:	e9 57 ff ff ff       	jmp    fdba <dupfd>

0000fe63 <sys_fcntl>:
// arg是新文件句可取的最小值；对于设置文件操作和访问标志命令F_SETFL，arg是新的文件操作和访问模式。对于文件上锁命令
// F_GETLK、F_SETLK和F_SETLKW，arg是指向flock结构的指针。但本内核中没有实现文件上锁功能。
// 返回：若出错，则所有操作都返回-1.若成功，那么F_DUPFD返回新文件句柄；F_GETFD返回文件句柄的当前执行时关闭标志
// close_on_exec；F_GETFL返回文件操作和访问标志。
int sys_fcntl(unsigned int fd, unsigned int cmd, unsigned long arg)
{
    fe63:	57                   	push   %edi
    fe64:	56                   	push   %esi
    fe65:	53                   	push   %ebx
    fe66:	8b 4c 24 10          	mov    0x10(%esp),%ecx
    fe6a:	e8 0b a0 ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
    fe6f:	05 91 11 01 00       	add    $0x11191,%eax
    fe74:	8b 7c 24 14          	mov    0x14(%esp),%edi
    fe78:	8b 54 24 18          	mov    0x18(%esp),%edx
	struct file * filp;

	// 首先检查给出的文件句柄有效性。然后根据不同命令cmd进行分别处理。如果文件句柄值大于一个进程最多打开文件数NR_OPEN，或者
	// 该句柄的文件结构指针为空，则返回出错码并退出。
	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
    fe7c:	83 f9 13             	cmp    $0x13,%ecx
    fe7f:	77 7a                	ja     fefb <.L24+0x14>
    fe81:	c7 c3 60 23 02 00    	mov    $0x22360,%ebx
    fe87:	8b 33                	mov    (%ebx),%esi
    fe89:	8b 9c 8e 48 03 00 00 	mov    0x348(%esi,%ecx,4),%ebx
    fe90:	85 db                	test   %ebx,%ebx
    fe92:	74 67                	je     fefb <.L24+0x14>
		return -EBADF;
	switch (cmd) {
    fe94:	83 ff 04             	cmp    $0x4,%edi
    fe97:	77 69                	ja     ff02 <.L24+0x1b>
    fe99:	03 84 b8 00 72 ff ff 	add    -0x8e00(%eax,%edi,4),%eax
    fea0:	ff e0                	jmp    *%eax

0000fea2 <.L19>:
		case F_GETLK:	case F_SETLK:	case F_SETLKW:  		// 未实现。
			return -1;
		default:
			return -1;
	}
}
    fea2:	5b                   	pop    %ebx
    fea3:	5e                   	pop    %esi
    fea4:	5f                   	pop    %edi
			return dupfd(fd,arg);
    fea5:	89 c8                	mov    %ecx,%eax
    fea7:	e9 0e ff ff ff       	jmp    fdba <dupfd>

0000feac <.L21>:
			return (current->close_on_exec >> fd) & 1;
    feac:	8b 96 44 03 00 00    	mov    0x344(%esi),%edx
    feb2:	89 d0                	mov    %edx,%eax
    feb4:	d3 e8                	shr    %cl,%eax
    feb6:	83 e0 01             	and    $0x1,%eax
    feb9:	eb 4a                	jmp    ff05 <.L24+0x1e>

0000febb <.L22>:
    febb:	bb 01 00 00 00       	mov    $0x1,%ebx
    fec0:	8b be 44 03 00 00    	mov    0x344(%esi),%edi
    fec6:	89 d8                	mov    %ebx,%eax
    fec8:	d3 e0                	shl    %cl,%eax
			if (arg & 1)
    feca:	80 e2 01             	and    $0x1,%dl
    fecd:	74 04                	je     fed3 <.L22+0x18>
				current->close_on_exec |= (1 << fd);
    fecf:	09 f8                	or     %edi,%eax
    fed1:	eb 04                	jmp    fed7 <.L22+0x1c>
				current->close_on_exec &= ~(1 << fd);
    fed3:	f7 d0                	not    %eax
    fed5:	21 f8                	and    %edi,%eax
    fed7:	89 86 44 03 00 00    	mov    %eax,0x344(%esi)
			return 0;
    fedd:	31 c0                	xor    %eax,%eax
    fedf:	eb 24                	jmp    ff05 <.L24+0x1e>

0000fee1 <.L23>:
			return filp->f_flags;
    fee1:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
    fee5:	eb 1e                	jmp    ff05 <.L24+0x1e>

0000fee7 <.L24>:
			filp->f_flags &= ~(O_APPEND | O_NONBLOCK);
    fee7:	66 8b 43 02          	mov    0x2(%ebx),%ax
			filp->f_flags |= arg & (O_APPEND | O_NONBLOCK);
    feeb:	66 81 e2 00 0c       	and    $0xc00,%dx
			filp->f_flags &= ~(O_APPEND | O_NONBLOCK);
    fef0:	80 e4 f3             	and    $0xf3,%ah
			filp->f_flags |= arg & (O_APPEND | O_NONBLOCK);
    fef3:	09 c2                	or     %eax,%edx
    fef5:	66 89 53 02          	mov    %dx,0x2(%ebx)
    fef9:	eb e2                	jmp    fedd <.L22+0x22>
		return -EBADF;
    fefb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    ff00:	eb 03                	jmp    ff05 <.L24+0x1e>
			return -1;
    ff02:	83 c8 ff             	or     $0xffffffff,%eax
}
    ff05:	5b                   	pop    %ebx
    ff06:	5e                   	pop    %esi
    ff07:	5f                   	pop    %edi
    ff08:	c3                   	ret    

0000ff09 <sys_ioctl>:
// 该函数首先判断参数给出的文件描述符是否有效。然后根据对应i节点中文件属性判断文件类型，并根据具体文件类型调用相关
// 的处理函数。
// 参数：fd - 文件描述符； cmd - 命令码； arg - 参数。
// 返回：成功则返回0,否则返回出错码。
int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
{
    ff09:	57                   	push   %edi
    ff0a:	56                   	push   %esi
    ff0b:	53                   	push   %ebx
    ff0c:	8b 44 24 10          	mov    0x10(%esp),%eax
    ff10:	e8 17 6b ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ff15:	81 c3 eb 10 01 00    	add    $0x110eb,%ebx
    ff1b:	8b 74 24 14          	mov    0x14(%esp),%esi
    ff1f:	8b 7c 24 18          	mov    0x18(%esp),%edi
	struct file * filp;
	int dev, mode;

	// 首先判断给出的文件描述符的有效性。如果文件描述符超出可打开的文件数，或者对应描述符的文件结构指针为空，则返回出错
	// 码退出。
	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
    ff23:	83 f8 13             	cmp    $0x13,%eax
    ff26:	77 62                	ja     ff8a <sys_ioctl+0x81>
    ff28:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
    ff2e:	8b 12                	mov    (%edx),%edx
    ff30:	8b 8c 82 48 03 00 00 	mov    0x348(%edx,%eax,4),%ecx
    ff37:	85 c9                	test   %ecx,%ecx
    ff39:	74 4f                	je     ff8a <sys_ioctl+0x81>
		return -EBADF;
	// 如果文件结构对应的是管道i节点，则根据进程是否有权操作该管道确定是否执行管道IO控制操作。若有权执行则调用pipe_ioctl()，
	// 否则返回无效文件错误码。
	if (filp->f_inode->i_pipe)
    ff3b:	8b 51 08             	mov    0x8(%ecx),%edx
    ff3e:	80 7a 38 00          	cmpb   $0x0,0x38(%edx)
    ff42:	74 18                	je     ff5c <sys_ioctl+0x53>
		return (filp->f_mode & 1) ? pipe_ioctl(filp->f_inode, cmd, arg) : -EBADF;
    ff44:	f6 01 01             	testb  $0x1,(%ecx)
		return -EBADF;
    ff47:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
		return (filp->f_mode & 1) ? pipe_ioctl(filp->f_inode, cmd, arg) : -EBADF;
    ff4c:	74 56                	je     ffa4 <sys_ioctl+0x9b>
    ff4e:	50                   	push   %eax
    ff4f:	57                   	push   %edi
    ff50:	56                   	push   %esi
    ff51:	52                   	push   %edx
    ff52:	e8 86 e2 ff ff       	call   e1dd <pipe_ioctl>
    ff57:	83 c4 10             	add    $0x10,%esp
    ff5a:	eb 48                	jmp    ffa4 <sys_ioctl+0x9b>
	// 对于其他类型文件，取对应文件的属性，并据此判断文件的类型。如果该文件即不是字符设备文件，也不是块设备文件，则返回
	// 出错码退出。若是字符或块设备文件，则从文件的i节点中取设备号。如果设备号大于系统现有的设备数，则返回出错号。
	mode = filp->f_inode->i_mode;
	if (!S_ISCHR(mode) && !S_ISBLK(mode))
    ff5c:	8b 02                	mov    (%edx),%eax
    ff5e:	66 25 00 b0          	and    $0xb000,%ax
    ff62:	66 3d 00 20          	cmp    $0x2000,%ax
    ff66:	75 29                	jne    ff91 <sys_ioctl+0x88>
		return -EINVAL;
	dev = filp->f_inode->i_zone[0];
    ff68:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
	if (MAJOR(dev) >= NRDEVS)
    ff6c:	89 d0                	mov    %edx,%eax
    ff6e:	c1 e8 08             	shr    $0x8,%eax
    ff71:	83 f8 07             	cmp    $0x7,%eax
    ff74:	77 22                	ja     ff98 <sys_ioctl+0x8f>
		return -ENODEV;
	// 然后根据IO控制表ioctl_table查得对应设备的ioctl函数指针，并调用该函数。如果该设备在ioctl函数指针表中没有对应函数，
	// 则返回出错码。
	if (!ioctl_table[MAJOR(dev)])
    ff76:	8b 84 83 c0 ff ff ff 	mov    -0x40(%ebx,%eax,4),%eax
    ff7d:	85 c0                	test   %eax,%eax
    ff7f:	74 1e                	je     ff9f <sys_ioctl+0x96>
		return -ENOTTY;
	return ioctl_table[MAJOR(dev)](dev, cmd, arg);
    ff81:	89 54 24 10          	mov    %edx,0x10(%esp)
}
    ff85:	5b                   	pop    %ebx
    ff86:	5e                   	pop    %esi
    ff87:	5f                   	pop    %edi
	return ioctl_table[MAJOR(dev)](dev, cmd, arg);
    ff88:	ff e0                	jmp    *%eax
		return -EBADF;
    ff8a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    ff8f:	eb 13                	jmp    ffa4 <sys_ioctl+0x9b>
		return -EINVAL;
    ff91:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    ff96:	eb 0c                	jmp    ffa4 <sys_ioctl+0x9b>
		return -ENODEV;
    ff98:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    ff9d:	eb 05                	jmp    ffa4 <sys_ioctl+0x9b>
		return -ENOTTY;
    ff9f:	b8 e7 ff ff ff       	mov    $0xffffffe7,%eax
}
    ffa4:	5b                   	pop    %ebx
    ffa5:	5e                   	pop    %esi
    ffa6:	5f                   	pop    %edi
    ffa7:	c3                   	ret    

0000ffa8 <free_ind.part.0>:

#include <sys/stat.h>           								// 文件状态头文件。含有文件或文件系统状态结构stat{}和常量。

// 释放所有一次间接块。（内部函数）
// 参数dev是文件系统所有设备的设备号；block是逻辑块号。成功则返回1，否则返回0。
static int free_ind(int dev, int block)
    ffa8:	55                   	push   %ebp
    ffa9:	57                   	push   %edi
    ffaa:	89 d5                	mov    %edx,%ebp
    ffac:	56                   	push   %esi
    ffad:	53                   	push   %ebx
    ffae:	89 c7                	mov    %eax,%edi
    ffb0:	e8 77 6a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
    ffb5:	81 c3 4b 10 01 00    	add    $0x1104b,%ebx
    ffbb:	83 ec 24             	sub    $0x24,%esp
	// 首先判断参数的有效性。如果逻辑块号为0,则返回。然后读取一次间接块，并释放其上表明使用的所有逻辑块，然后
	// 释放该一次间接块的缓冲块。函数free_block()用于释放设备上指定逻辑块号的磁盘块（fs/bitmap.c）。
	if (!block)
		return 1;
	block_busy = 0;
	if (bh = bread(dev, block)) {
    ffbe:	52                   	push   %edx
    ffbf:	50                   	push   %eax
    ffc0:	e8 eb c3 ff ff       	call   c3b0 <bread>
    ffc5:	83 c4 10             	add    $0x10,%esp
    ffc8:	85 c0                	test   %eax,%eax
    ffca:	75 0e                	jne    ffda <free_ind.part.0+0x32>
	}
	// 最后释放设备上的一次间接块。但如果其中有逻辑块没有被释放，则返回0（失败）。
	if (block_busy)
		return 0;
	else
		return free_block(dev, block);                   		// 成功则返回1,否则返回0.
    ffcc:	51                   	push   %ecx
    ffcd:	51                   	push   %ecx
    ffce:	55                   	push   %ebp
    ffcf:	57                   	push   %edi
    ffd0:	e8 20 f9 ff ff       	call   f8f5 <free_block>
    ffd5:	83 c4 10             	add    $0x10,%esp
    ffd8:	eb 69                	jmp    10043 <free_ind.part.0+0x9b>
		p = (unsigned short *) bh->b_data;              		// 指向缓冲块数据区。
    ffda:	8b 08                	mov    (%eax),%ecx
    ffdc:	89 c2                	mov    %eax,%edx
	block_busy = 0;
    ffde:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    ffe5:	00 
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可有512个块号。
    ffe6:	31 f6                	xor    %esi,%esi
			if (*p)
    ffe8:	0f b7 04 71          	movzwl (%ecx,%esi,2),%eax
    ffec:	66 85 c0             	test   %ax,%ax
    ffef:	74 34                	je     10025 <free_ind.part.0+0x7d>
    fff1:	89 54 24 08          	mov    %edx,0x8(%esp)
    fff5:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
				if (free_block(dev, *p)) {       				// 释放指定的设备逻辑块。
    fff9:	52                   	push   %edx
    fffa:	52                   	push   %edx
    fffb:	50                   	push   %eax
    fffc:	57                   	push   %edi
    fffd:	e8 f3 f8 ff ff       	call   f8f5 <free_block>
   10002:	83 c4 10             	add    $0x10,%esp
   10005:	85 c0                	test   %eax,%eax
   10007:	8b 54 24 08          	mov    0x8(%esp),%edx
   1000b:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1000f:	74 0c                	je     1001d <free_ind.part.0+0x75>
					*p = 0;                 					// 清零。
   10011:	66 c7 04 71 00 00    	movw   $0x0,(%ecx,%esi,2)
					bh->b_dirt = 1;         					// 设置已修改标志。
   10017:	c6 42 0b 01          	movb   $0x1,0xb(%edx)
   1001b:	eb 08                	jmp    10025 <free_ind.part.0+0x7d>
					block_busy = 1;         					// 设置逻辑块没有释放标志。
   1001d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
   10024:	00 
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可有512个块号。
   10025:	46                   	inc    %esi
   10026:	81 fe 00 02 00 00    	cmp    $0x200,%esi
   1002c:	75 ba                	jne    ffe8 <free_ind.part.0+0x40>
		brelse(bh);                                     		// 然后释放间接块占用的缓冲块。
   1002e:	83 ec 0c             	sub    $0xc,%esp
   10031:	52                   	push   %edx
   10032:	e8 27 c3 ff ff       	call   c35e <brelse>
   10037:	83 c4 10             	add    $0x10,%esp
	if (block_busy)
   1003a:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   1003f:	74 8b                	je     ffcc <free_ind.part.0+0x24>
		return 0;
   10041:	31 c0                	xor    %eax,%eax
}
   10043:	83 c4 1c             	add    $0x1c,%esp
   10046:	5b                   	pop    %ebx
   10047:	5e                   	pop    %esi
   10048:	5f                   	pop    %edi
   10049:	5d                   	pop    %ebp
   1004a:	c3                   	ret    

0001004b <truncate>:
}

// 截断文件数据函数。
// 将节点对应的文件长度减0,并释放战胜的设备空间。
void truncate(struct m_inode * inode)
{
   1004b:	55                   	push   %ebp
   1004c:	57                   	push   %edi
   1004d:	56                   	push   %esi
   1004e:	53                   	push   %ebx
   1004f:	e8 d8 69 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10054:	81 c3 ac 0f 01 00    	add    $0x10fac,%ebx
   1005a:	83 ec 2c             	sub    $0x2c,%esp
   1005d:	8b 74 24 40          	mov    0x40(%esp),%esi
	int i;
	int block_busy;                 							// 有逻辑块没有被释放的标志。

	// 首先判断指定i节点有效性。如果不是常规文件、目录文件或链接项，则返回。
	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
   10061:	8b 06                	mov    (%esi),%eax
   10063:	89 c2                	mov    %eax,%edx
   10065:	66 81 e2 00 f0       	and    $0xf000,%dx
   1006a:	66 81 fa 00 40       	cmp    $0x4000,%dx
   1006f:	74 0e                	je     1007f <truncate+0x34>
   10071:	66 25 00 d0          	and    $0xd000,%ax
   10075:	66 3d 00 80          	cmp    $0x8000,%ax
   10079:	0f 85 6e 01 00 00    	jne    101ed <truncate+0x1a2>
		block_busy = 1;                         				// 若没有释放掉则置标志。
	// 此后设置i节点已修改标志，并且如果还有逻辑块由于 “忙”而没有被释放，则把当前进程运行时间片置0,以让当前进程先被
	// 切换去运行其他进程，稍等一会再重新执行释放操作。
	inode->i_dirt = 1;
	if (block_busy) {
		current->counter = 0;           						// 当前进程时间片置0。
   1007f:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   10085:	89 44 24 18          	mov    %eax,0x18(%esp)
	block_busy = 0;
   10089:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   10090:	00 
	for (i = 0; i < 7; i++)
   10091:	31 ff                	xor    %edi,%edi
		if (inode->i_zone[i]) {                 				// 如果块号不为0，则释放之。
   10093:	0f b7 44 7e 0e       	movzwl 0xe(%esi,%edi,2),%eax
   10098:	66 85 c0             	test   %ax,%ax
   1009b:	74 25                	je     100c2 <truncate+0x77>
			if (free_block(inode->i_dev, inode->i_zone[i]))
   1009d:	51                   	push   %ecx
   1009e:	51                   	push   %ecx
   1009f:	50                   	push   %eax
   100a0:	0f b7 46 30          	movzwl 0x30(%esi),%eax
   100a4:	50                   	push   %eax
   100a5:	e8 4b f8 ff ff       	call   f8f5 <free_block>
   100aa:	83 c4 10             	add    $0x10,%esp
   100ad:	85 c0                	test   %eax,%eax
   100af:	74 09                	je     100ba <truncate+0x6f>
				inode->i_zone[i] = 0;     						// 块指针置0。
   100b1:	66 c7 44 7e 0e 00 00 	movw   $0x0,0xe(%esi,%edi,2)
   100b8:	eb 08                	jmp    100c2 <truncate+0x77>
				block_busy = 1;         						// 若没有释放掉则置标志。
   100ba:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
   100c1:	00 
	for (i = 0; i < 7; i++)
   100c2:	47                   	inc    %edi
   100c3:	83 ff 07             	cmp    $0x7,%edi
   100c6:	75 cb                	jne    10093 <truncate+0x48>
	if (free_ind(inode->i_dev, inode->i_zone[7]))    			// 释放所有一次间接块。
   100c8:	0f b7 56 1c          	movzwl 0x1c(%esi),%edx
	if (!block)
   100cc:	85 d2                	test   %edx,%edx
   100ce:	75 08                	jne    100d8 <truncate+0x8d>
		inode->i_zone[7] = 0;                   				// 块指针置0。
   100d0:	66 c7 46 1c 00 00    	movw   $0x0,0x1c(%esi)
   100d6:	eb 15                	jmp    100ed <truncate+0xa2>
	if (free_ind(inode->i_dev, inode->i_zone[7]))    			// 释放所有一次间接块。
   100d8:	0f b7 46 30          	movzwl 0x30(%esi),%eax
   100dc:	e8 c7 fe ff ff       	call   ffa8 <free_ind.part.0>
   100e1:	85 c0                	test   %eax,%eax
   100e3:	75 eb                	jne    100d0 <truncate+0x85>
		block_busy = 1;                         				// 若没有释放掉则置标志。
   100e5:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
   100ec:	00 
	if (free_dind(inode->i_dev, inode->i_zone[8]))   			// 释放所有二次间接块。
   100ed:	0f b7 7e 1e          	movzwl 0x1e(%esi),%edi
	if (!block)
   100f1:	85 ff                	test   %edi,%edi
   100f3:	0f 84 9e 00 00 00    	je     10197 <truncate+0x14c>
	if (free_dind(inode->i_dev, inode->i_zone[8]))   			// 释放所有二次间接块。
   100f9:	0f b7 46 30          	movzwl 0x30(%esi),%eax
   100fd:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (bh = bread(dev, block)) {
   10101:	52                   	push   %edx
   10102:	52                   	push   %edx
   10103:	57                   	push   %edi
   10104:	ff 74 24 14          	pushl  0x14(%esp)
   10108:	e8 a3 c2 ff ff       	call   c3b0 <bread>
   1010d:	83 c4 10             	add    $0x10,%esp
   10110:	85 c0                	test   %eax,%eax
   10112:	89 c1                	mov    %eax,%ecx
   10114:	75 15                	jne    1012b <truncate+0xe0>
		return free_block(dev, block);							// 最后释放存放第一间接块的逻辑块
   10116:	50                   	push   %eax
   10117:	50                   	push   %eax
   10118:	57                   	push   %edi
   10119:	ff 74 24 14          	pushl  0x14(%esp)
   1011d:	e8 d3 f7 ff ff       	call   f8f5 <free_block>
   10122:	83 c4 10             	add    $0x10,%esp
	if (free_dind(inode->i_dev, inode->i_zone[8]))   			// 释放所有二次间接块。
   10125:	85 c0                	test   %eax,%eax
   10127:	74 68                	je     10191 <truncate+0x146>
   10129:	eb 6c                	jmp    10197 <truncate+0x14c>
		p = (unsigned short *) bh->b_data;              		// 指向缓冲块数据区。
   1012b:	8b 00                	mov    (%eax),%eax
	block_busy = 0;
   1012d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
   10134:	00 
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可连接512个二级块。
   10135:	31 ed                	xor    %ebp,%ebp
		p = (unsigned short *) bh->b_data;              		// 指向缓冲块数据区。
   10137:	89 44 24 10          	mov    %eax,0x10(%esp)
			if (*p)
   1013b:	8b 44 24 10          	mov    0x10(%esp),%eax
   1013f:	0f b7 14 68          	movzwl (%eax,%ebp,2),%edx
   10143:	66 85 d2             	test   %dx,%dx
   10146:	74 2d                	je     10175 <truncate+0x12a>
   10148:	8b 44 24 08          	mov    0x8(%esp),%eax
   1014c:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
   10150:	e8 53 fe ff ff       	call   ffa8 <free_ind.part.0>
				if (free_ind(dev, *p)) {         				// 释放所有一次间接块。
   10155:	85 c0                	test   %eax,%eax
   10157:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   1015b:	74 10                	je     1016d <truncate+0x122>
					*p = 0;                 					// 清零。
   1015d:	8b 44 24 10          	mov    0x10(%esp),%eax
   10161:	66 c7 04 68 00 00    	movw   $0x0,(%eax,%ebp,2)
					bh->b_dirt = 1;         					// 设置已修改标志。
   10167:	c6 41 0b 01          	movb   $0x1,0xb(%ecx)
   1016b:	eb 08                	jmp    10175 <truncate+0x12a>
					block_busy = 1;         					// 设置逻辑块没有释放标志。
   1016d:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
   10174:	00 
		for (i = 0; i < 512; i++, p++)                         	// 每个逻辑块上可连接512个二级块。
   10175:	45                   	inc    %ebp
   10176:	81 fd 00 02 00 00    	cmp    $0x200,%ebp
   1017c:	75 bd                	jne    1013b <truncate+0xf0>
		brelse(bh);                                     		// 释放二次间接块占用的缓冲块。
   1017e:	83 ec 0c             	sub    $0xc,%esp
   10181:	51                   	push   %ecx
   10182:	e8 d7 c1 ff ff       	call   c35e <brelse>
   10187:	83 c4 10             	add    $0x10,%esp
	if (block_busy)
   1018a:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1018f:	74 85                	je     10116 <truncate+0xcb>
	inode->i_dirt = 1;
   10191:	c6 46 37 01          	movb   $0x1,0x37(%esi)
   10195:	eb 11                	jmp    101a8 <truncate+0x15d>
	if (block_busy) {
   10197:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
		inode->i_zone[8] = 0;                   				// 块指针置0。
   1019c:	66 c7 46 1e 00 00    	movw   $0x0,0x1e(%esi)
	inode->i_dirt = 1;
   101a2:	c6 46 37 01          	movb   $0x1,0x37(%esi)
	if (block_busy) {
   101a6:	74 17                	je     101bf <truncate+0x174>
		current->counter = 0;           						// 当前进程时间片置0。
   101a8:	8b 44 24 18          	mov    0x18(%esp),%eax
   101ac:	8b 00                	mov    (%eax),%eax
   101ae:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		schedule();
   101b5:	e8 f2 6a ff ff       	call   6cac <schedule>
		goto repeat;
   101ba:	e9 ca fe ff ff       	jmp    10089 <truncate+0x3e>
	}
	inode->i_size = 0;                      					// 文件大小置零。
	// 最后重新置文件修改时间和i节点改变时间为当前时间。宏CURRENT_TIME定义在头文件include/linux/sched.h中，定义
	// 为（startup_time+jiffies/HZ）。用于取得从1970:0:0:0开始到现在为止经过的秒数。
	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
   101bf:	c7 c2 64 2a 02 00    	mov    $0x22a64,%edx
   101c5:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
   101cb:	b9 64 00 00 00       	mov    $0x64,%ecx
	inode->i_size = 0;                      					// 文件大小置零。
   101d0:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
   101d7:	8b 00                	mov    (%eax),%eax
   101d9:	03 02                	add    (%edx),%eax
   101db:	31 d2                	xor    %edx,%edx
   101dd:	f7 f1                	div    %ecx
   101df:	c7 c2 68 2a 02 00    	mov    $0x22a68,%edx
   101e5:	03 02                	add    (%edx),%eax
   101e7:	89 46 2c             	mov    %eax,0x2c(%esi)
   101ea:	89 46 08             	mov    %eax,0x8(%esi)
}
   101ed:	83 c4 2c             	add    $0x2c,%esp
   101f0:	5b                   	pop    %ebx
   101f1:	5e                   	pop    %esi
   101f2:	5f                   	pop    %edi
   101f3:	5d                   	pop    %ebp
   101f4:	c3                   	ret    

000101f5 <free_wait>:
}

// 清空等待表。参数是等待表结构指针。本函数在do_select()函数中睡眠后被唤醒返回时被调用，用于唤醒等待表中处于各个等待队列上的其他
// 任务，它与kernel/sched.c中sleep_on()函数的后半部分代码几乎完全相同，请参考对sleep_on()函数的说明。
static void free_wait(select_table * p)
{
   101f5:	55                   	push   %ebp
   101f6:	57                   	push   %edi
   101f7:	89 c5                	mov    %eax,%ebp
   101f9:	56                   	push   %esi
   101fa:	53                   	push   %ebx
	struct task_struct ** tpp;

	// 如果等待表中各项（共nr个有效项）记录的等待队列头指针表明还有其他后来添加进的等待任务（例如其他进程调用sleep_on()函数而睡眠在该
	// 等待队列上），则此时等待队列头指针指向的不是当前进程，那么我们就需要先唤醒这些任务。操作方法是将等待队列头所指任务先置为就绪状态
	// （state = 0），并把自己设置为不可中断等待状态，即自己要等待这些后续进队列的任务被唤醒而执行时来唤醒本任务。然后重新执行调度程序。
	for (i = 0; i < p->nr ; i++) {
   101fb:	31 f6                	xor    %esi,%esi
   101fd:	e8 2a 68 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10202:	81 c3 fe 0d 01 00    	add    $0x10dfe,%ebx
{
   10208:	83 ec 1c             	sub    $0x1c,%esp
		tpp = p->entry[i].wait_address;
		while (*tpp && *tpp != current) {
   1020b:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   10211:	89 44 24 0c          	mov    %eax,0xc(%esp)
	for (i = 0; i < p->nr ; i++) {
   10215:	39 75 00             	cmp    %esi,0x0(%ebp)
   10218:	7e 4c                	jle    10266 <free_wait+0x71>
		tpp = p->entry[i].wait_address;
   1021a:	8b 7c f5 08          	mov    0x8(%ebp,%esi,8),%edi
		while (*tpp && *tpp != current) {
   1021e:	8b 07                	mov    (%edi),%eax
   10220:	85 c0                	test   %eax,%eax
   10222:	74 1d                	je     10241 <free_wait+0x4c>
   10224:	8b 54 24 0c          	mov    0xc(%esp),%edx
   10228:	8b 0a                	mov    (%edx),%ecx
   1022a:	39 c8                	cmp    %ecx,%eax
   1022c:	74 25                	je     10253 <free_wait+0x5e>
			(*tpp)->state = 0;
   1022e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			current->state = TASK_UNINTERRUPTIBLE;
   10234:	c7 01 02 00 00 00    	movl   $0x2,(%ecx)
			schedule();
   1023a:	e8 6d 6a ff ff       	call   6cac <schedule>
   1023f:	eb dd                	jmp    1021e <free_wait+0x29>
		}
		// 执行到这里，说明等待表当前处理项中的等待队列头指针字段wait_address指向当前任务，若它为空，则表明调度有问题，于是显示警告信息。
		// 然后我们让等待队列头指针指向在我们前面进入队列的任务（第76行）。若此时该头指针确实指向一个任务而不是NULL，则说明队列中还有任务（
		// *tpp不为空），于是将该任务设置成就绪状态，唤醒之。最后把等待表的有效表项计数字段nr清零。
		if (!*tpp)
			printk("free_wait: NULL");
   10241:	8d 83 c3 77 ff ff    	lea    -0x883d(%ebx),%eax
   10247:	83 ec 0c             	sub    $0xc,%esp
   1024a:	50                   	push   %eax
   1024b:	e8 d1 7e ff ff       	call   8121 <printk>
   10250:	83 c4 10             	add    $0x10,%esp
		if (*tpp = p->entry[i].old_task)
   10253:	8b 44 f5 04          	mov    0x4(%ebp,%esi,8),%eax
   10257:	85 c0                	test   %eax,%eax
   10259:	89 07                	mov    %eax,(%edi)
   1025b:	74 06                	je     10263 <free_wait+0x6e>
			(**tpp).state = 0;
   1025d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	for (i = 0; i < p->nr ; i++) {
   10263:	46                   	inc    %esi
   10264:	eb af                	jmp    10215 <free_wait+0x20>
	}
	p->nr = 0;
   10266:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
}
   1026d:	83 c4 1c             	add    $0x1c,%esp
   10270:	5b                   	pop    %ebx
   10271:	5e                   	pop    %esi
   10272:	5f                   	pop    %edi
   10273:	5d                   	pop    %ebp
   10274:	c3                   	ret    

00010275 <add_wait>:
	for (i = 0 ; i < p->nr ; i++)
   10275:	8b 0a                	mov    (%edx),%ecx
{
   10277:	57                   	push   %edi
   10278:	56                   	push   %esi
   10279:	53                   	push   %ebx
	for (i = 0 ; i < p->nr ; i++)
   1027a:	31 db                	xor    %ebx,%ebx
   1027c:	e8 01 9c ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   10281:	81 c6 7f 0d 01 00    	add    $0x10d7f,%esi
   10287:	39 cb                	cmp    %ecx,%ebx
   10289:	7d 09                	jge    10294 <add_wait+0x1f>
		if (p->entry[i].wait_address == wait_address)
   1028b:	3b 44 da 08          	cmp    0x8(%edx,%ebx,8),%eax
   1028f:	74 1b                	je     102ac <add_wait+0x37>
	for (i = 0 ; i < p->nr ; i++)
   10291:	43                   	inc    %ebx
   10292:	eb f3                	jmp    10287 <add_wait+0x12>
   10294:	8d 1c ca             	lea    (%edx,%ecx,8),%ebx
	p->nr++;
   10297:	41                   	inc    %ecx
	p->entry[p->nr].wait_address = wait_address;
   10298:	89 43 08             	mov    %eax,0x8(%ebx)
	p->entry[p->nr].old_task = * wait_address;
   1029b:	8b 38                	mov    (%eax),%edi
   1029d:	89 7b 04             	mov    %edi,0x4(%ebx)
	*wait_address = current;
   102a0:	c7 c3 60 23 02 00    	mov    $0x22360,%ebx
   102a6:	8b 1b                	mov    (%ebx),%ebx
   102a8:	89 18                	mov    %ebx,(%eax)
	p->nr++;
   102aa:	89 0a                	mov    %ecx,(%edx)
}
   102ac:	5b                   	pop    %ebx
   102ad:	5e                   	pop    %esi
   102ae:	5f                   	pop    %edi
   102af:	c3                   	ret    

000102b0 <get_tty>:
static struct tty_struct * get_tty(struct m_inode * inode)
{
	int major, minor;

	// 如果不是字符设备文件则返回NULL。如果主设备号不是5（控制终端）或4，则返回NULL。
	if (!S_ISCHR(inode->i_mode))
   102b0:	8b 10                	mov    (%eax),%edx
   102b2:	e8 c7 9b ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
   102b7:	81 c1 49 0d 01 00    	add    $0x10d49,%ecx
   102bd:	66 81 e2 00 f0       	and    $0xf000,%dx
   102c2:	66 81 fa 00 20       	cmp    $0x2000,%dx
   102c7:	75 55                	jne    1031e <get_tty+0x6e>
{
   102c9:	56                   	push   %esi
   102ca:	53                   	push   %ebx
		return NULL;
	if ((major = MAJOR(inode->i_zone[0])) != 5 && major != 4)
   102cb:	66 8b 50 0e          	mov    0xe(%eax),%dx
		return NULL;
   102cf:	31 c0                	xor    %eax,%eax
	if ((major = MAJOR(inode->i_zone[0])) != 5 && major != 4)
   102d1:	89 d3                	mov    %edx,%ebx
   102d3:	66 c1 eb 08          	shr    $0x8,%bx
   102d7:	8d 73 fc             	lea    -0x4(%ebx),%esi
   102da:	66 83 fe 01          	cmp    $0x1,%si
   102de:	77 41                	ja     10321 <get_tty+0x71>
		return NULL;
	// 如果主设备号是5，那么其终端设备号等于进程的tty字段值，否则就等于字符设备文件次设备号。如果终端设备号小于0,表示进程没有
	// 控制终端或没有使用终端，于是返回NULL。否则返回对应的tty结构指针。
	if (major == 5)
   102e0:	66 83 fb 05          	cmp    $0x5,%bx
		minor = current->tty;
	else
		minor = MINOR(inode->i_zone[0]);
   102e4:	0f b6 d2             	movzbl %dl,%edx
	if (major == 5)
   102e7:	75 14                	jne    102fd <get_tty+0x4d>
		minor = current->tty;
   102e9:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   102ef:	8b 00                	mov    (%eax),%eax
   102f1:	8b 90 2c 03 00 00    	mov    0x32c(%eax),%edx
		return NULL;
   102f7:	31 c0                	xor    %eax,%eax
	if (minor < 0)
   102f9:	85 d2                	test   %edx,%edx
   102fb:	78 24                	js     10321 <get_tty+0x71>
		return NULL;
	return TTY_TABLE(minor);
   102fd:	85 d2                	test   %edx,%edx
   102ff:	c7 c0 00 57 03 00    	mov    $0x35700,%eax
   10305:	74 08                	je     1030f <get_tty+0x5f>
   10307:	83 fa 3f             	cmp    $0x3f,%edx
   1030a:	7f 0b                	jg     10317 <get_tty+0x67>
   1030c:	4a                   	dec    %edx
   1030d:	eb 08                	jmp    10317 <get_tty+0x67>
   1030f:	c7 c2 a0 51 02 00    	mov    $0x251a0,%edx
   10315:	8b 12                	mov    (%edx),%edx
   10317:	c1 e2 06             	shl    $0x6,%edx
   1031a:	01 d0                	add    %edx,%eax
   1031c:	eb 03                	jmp    10321 <get_tty+0x71>
		return NULL;
   1031e:	31 c0                	xor    %eax,%eax
}
   10320:	c3                   	ret    
   10321:	5b                   	pop    %ebx
   10322:	5e                   	pop    %esi
   10323:	c3                   	ret    

00010324 <do_select.part.2>:

// do_select()是内核执行select()系统调用的实际处理函数。该函数首先检查描述符集中各个描述符的有效性，然后分别调用相关描述符
// 集描述符检查函数check_XX()对每个描述符进行检查，同时统计描述符集中当前已经准备好的描述符个数。若有任何一个描述符已经准备好，
// 本函数就会立刻返回，否则进程就会在本函数中进入睡眠状态，并在过了超时时间或者由于某个描述符所在等待队列上的进程被唤醒而使本
// 进程继续运行。
int do_select(fd_set in, fd_set out, fd_set ex,
   10324:	55                   	push   %ebp
   10325:	57                   	push   %edi
   10326:	56                   	push   %esi
   10327:	53                   	push   %ebx
   10328:	e8 ff 66 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1032d:	81 c3 d3 0c 01 00    	add    $0x10cd3,%ebx
   10333:	81 ec 1c 02 00 00    	sub    $0x21c,%esp
   10339:	89 44 24 0c          	mov    %eax,0xc(%esp)
	mask = 1;
	for (i = 0 ; i < NR_OPEN ; i++, mask += mask) {
		// 如果此时判断的描述符在读操作描述符集中，并且该描述符已经准备好可以进行读操作，则把该描述符在描述符集in中对应位置为1,同时把已准备
		// 好描述符个数计数值count增1。
		if (mask & in)
			if (check_in(&wait_table, current->filp[i]->f_inode)) {
   1033d:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
int do_select(fd_set in, fd_set out, fd_set ex,
   10343:	89 54 24 10          	mov    %edx,0x10(%esp)
   10347:	89 4c 24 14          	mov    %ecx,0x14(%esp)
			if (check_in(&wait_table, current->filp[i]->f_inode)) {
   1034b:	89 44 24 08          	mov    %eax,0x8(%esp)
				count++;        								// 已准备好描述符个数计数。
			}
		// 如果此时判断的描述符在写操作描述符集中，并且该描述符已经准备好可以进行写操作，则把该描述符在描述符集out中对应位置为1,同时把已准备
		// 好描述符个数计数值count增1。
		if (mask & out)
			if (check_out(&wait_table, current->filp[i]->f_inode)) {
   1034f:	89 44 24 18          	mov    %eax,0x18(%esp)
	*inp = *outp = *exp = 0;
   10353:	8b 84 24 38 02 00 00 	mov    0x238(%esp),%eax
	wait_table.nr = 0;
   1035a:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
   10361:	00 
	count = 0;
   10362:	31 ff                	xor    %edi,%edi
	for (i = 0 ; i < NR_OPEN ; i++, mask += mask) {
   10364:	31 ed                	xor    %ebp,%ebp
	mask = 1;
   10366:	be 01 00 00 00       	mov    $0x1,%esi
	*inp = *outp = *exp = 0;
   1036b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   10371:	8b 84 24 34 02 00 00 	mov    0x234(%esp),%eax
   10378:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1037e:	8b 84 24 30 02 00 00 	mov    0x230(%esp),%eax
   10385:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (mask & in)
   1038b:	85 74 24 0c          	test   %esi,0xc(%esp)
   1038f:	74 5e                	je     103ef <do_select.part.2+0xcb>
			if (check_in(&wait_table, current->filp[i]->f_inode)) {
   10391:	8b 44 24 08          	mov    0x8(%esp),%eax
   10395:	8b 00                	mov    (%eax),%eax
   10397:	8b 84 a8 48 03 00 00 	mov    0x348(%eax,%ebp,4),%eax
   1039e:	8b 48 08             	mov    0x8(%eax),%ecx
	if (tty = get_tty(inode))
   103a1:	89 c8                	mov    %ecx,%eax
   103a3:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
   103a7:	e8 04 ff ff ff       	call   102b0 <get_tty>
   103ac:	85 c0                	test   %eax,%eax
   103ae:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   103b2:	74 14                	je     103c8 <do_select.part.2+0xa4>
		if (!EMPTY(tty->secondary))
   103b4:	8b 40 3c             	mov    0x3c(%eax),%eax
   103b7:	8b 48 08             	mov    0x8(%eax),%ecx
   103ba:	39 48 04             	cmp    %ecx,0x4(%eax)
   103bd:	75 26                	jne    103e5 <do_select.part.2+0xc1>
			add_wait(&tty->secondary->proc_list, wait);
   103bf:	8d 54 24 2c          	lea    0x2c(%esp),%edx
   103c3:	83 c0 0c             	add    $0xc,%eax
   103c6:	eb 16                	jmp    103de <do_select.part.2+0xba>
	else if (inode->i_pipe)
   103c8:	80 79 38 00          	cmpb   $0x0,0x38(%ecx)
   103cc:	74 21                	je     103ef <do_select.part.2+0xcb>
		if (!PIPE_EMPTY(*inode))
   103ce:	8b 41 10             	mov    0x10(%ecx),%eax
   103d1:	66 39 41 0e          	cmp    %ax,0xe(%ecx)
   103d5:	75 0e                	jne    103e5 <do_select.part.2+0xc1>
			add_wait(&inode->i_wait, wait);
   103d7:	8d 54 24 2c          	lea    0x2c(%esp),%edx
   103db:	8d 41 20             	lea    0x20(%ecx),%eax
   103de:	e8 92 fe ff ff       	call   10275 <add_wait>
   103e3:	eb 0a                	jmp    103ef <do_select.part.2+0xcb>
				*inp |= mask;   								// 描述符集中设置对应位。
   103e5:	8b 84 24 30 02 00 00 	mov    0x230(%esp),%eax
				count++;        								// 已准备好描述符个数计数。
   103ec:	47                   	inc    %edi
				*inp |= mask;   								// 描述符集中设置对应位。
   103ed:	09 30                	or     %esi,(%eax)
		if (mask & out)
   103ef:	85 74 24 10          	test   %esi,0x10(%esp)
   103f3:	74 6d                	je     10462 <do_select.part.2+0x13e>
			if (check_out(&wait_table, current->filp[i]->f_inode)) {
   103f5:	8b 44 24 18          	mov    0x18(%esp),%eax
   103f9:	8b 00                	mov    (%eax),%eax
   103fb:	8b 84 a8 48 03 00 00 	mov    0x348(%eax,%ebp,4),%eax
   10402:	8b 48 08             	mov    0x8(%eax),%ecx
	if (tty = get_tty(inode))
   10405:	89 c8                	mov    %ecx,%eax
   10407:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
   1040b:	e8 a0 fe ff ff       	call   102b0 <get_tty>
   10410:	85 c0                	test   %eax,%eax
   10412:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   10416:	74 1b                	je     10433 <do_select.part.2+0x10f>
		if (!FULL(tty->write_q))
   10418:	8b 40 38             	mov    0x38(%eax),%eax
   1041b:	8b 50 08             	mov    0x8(%eax),%edx
   1041e:	4a                   	dec    %edx
   1041f:	2b 50 04             	sub    0x4(%eax),%edx
   10422:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   10428:	75 2e                	jne    10458 <do_select.part.2+0x134>
			add_wait(&tty->write_q->proc_list, wait);
   1042a:	8d 54 24 2c          	lea    0x2c(%esp),%edx
   1042e:	83 c0 0c             	add    $0xc,%eax
   10431:	eb 1e                	jmp    10451 <do_select.part.2+0x12d>
	else if (inode->i_pipe)
   10433:	80 79 38 00          	cmpb   $0x0,0x38(%ecx)
   10437:	74 29                	je     10462 <do_select.part.2+0x13e>
		if (!PIPE_FULL(*inode))
   10439:	66 8b 41 0e          	mov    0xe(%ecx),%ax
   1043d:	2b 41 10             	sub    0x10(%ecx),%eax
   10440:	66 25 ff 0f          	and    $0xfff,%ax
   10444:	66 3d ff 0f          	cmp    $0xfff,%ax
   10448:	75 0e                	jne    10458 <do_select.part.2+0x134>
			add_wait(&inode->i_wait, wait);
   1044a:	8d 54 24 2c          	lea    0x2c(%esp),%edx
   1044e:	8d 41 20             	lea    0x20(%ecx),%eax
   10451:	e8 1f fe ff ff       	call   10275 <add_wait>
   10456:	eb 0a                	jmp    10462 <do_select.part.2+0x13e>
				*outp |= mask;
   10458:	8b 84 24 34 02 00 00 	mov    0x234(%esp),%eax
				count++;
   1045f:	47                   	inc    %edi
				*outp |= mask;
   10460:	09 30                	or     %esi,(%eax)
			}
		// 如果此时判断的描述符在异常描述符集中，并且该描述符已经有异常出现，则把该描述符在描述符集ex中对应位置为1,同时把已准备好描述符个数计
		// 数值count增1。
		if (mask & ex)
   10462:	85 74 24 14          	test   %esi,0x14(%esp)
   10466:	74 4a                	je     104b2 <do_select.part.2+0x18e>
			if (check_ex(&wait_table, current->filp[i]->f_inode)) {
   10468:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   1046e:	8b 00                	mov    (%eax),%eax
   10470:	8b 84 a8 48 03 00 00 	mov    0x348(%eax,%ebp,4),%eax
   10477:	8b 48 08             	mov    0x8(%eax),%ecx
	if (tty = get_tty(inode))
   1047a:	89 c8                	mov    %ecx,%eax
   1047c:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
   10480:	e8 2b fe ff ff       	call   102b0 <get_tty>
   10485:	85 c0                	test   %eax,%eax
   10487:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
   1048b:	75 25                	jne    104b2 <do_select.part.2+0x18e>
	else if (inode->i_pipe)
   1048d:	80 79 38 00          	cmpb   $0x0,0x38(%ecx)
   10491:	74 1f                	je     104b2 <do_select.part.2+0x18e>
		if (inode->i_count < 2)
   10493:	66 83 79 34 01       	cmpw   $0x1,0x34(%ecx)
   10498:	76 0e                	jbe    104a8 <do_select.part.2+0x184>
			add_wait(&inode->i_wait, wait);
   1049a:	8d 54 24 2c          	lea    0x2c(%esp),%edx
   1049e:	8d 41 20             	lea    0x20(%ecx),%eax
   104a1:	e8 cf fd ff ff       	call   10275 <add_wait>
   104a6:	eb 0a                	jmp    104b2 <do_select.part.2+0x18e>
				*exp |= mask;
   104a8:	8b 84 24 38 02 00 00 	mov    0x238(%esp),%eax
				count++;
   104af:	47                   	inc    %edi
				*exp |= mask;
   104b0:	09 30                	or     %esi,(%eax)
	for (i = 0 ; i < NR_OPEN ; i++, mask += mask) {
   104b2:	45                   	inc    %ebp
   104b3:	01 f6                	add    %esi,%esi
   104b5:	83 fd 14             	cmp    $0x14,%ebp
   104b8:	0f 85 cd fe ff ff    	jne    1038b <do_select.part.2+0x67>
	}
	// 在对进程所有描述符判断处理后，若没有发现有已准备好的描述符（count==0），并且此时进程没有收到任何非阻塞信号，并且此时有等待着描述符
	// 或者等待时间还没有超时，那么我们就把当前进程状态设置成可中断睡眠状态，然后执行调度函数去执行其他任务。当内核又一次调度执行本任务时就
	// 调用free_wait()唤醒相关等待队列上本任务前后的任务,然后跳转到repeat标号处再次重新检测是否有我们关心的（描述符集中的）描述符已准备
	// 好。
	if (!(current->signal & ~current->blocked) &&
   104be:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   104c4:	8b 00                	mov    (%eax),%eax
   104c6:	8b 90 10 02 00 00    	mov    0x210(%eax),%edx
   104cc:	f7 d2                	not    %edx
   104ce:	85 50 0c             	test   %edx,0xc(%eax)
   104d1:	75 2d                	jne    10500 <do_select.part.2+0x1dc>
   104d3:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
   104d8:	75 09                	jne    104e3 <do_select.part.2+0x1bf>
	    (wait_table.nr || current->timeout) && !count) {
   104da:	83 b8 d8 02 00 00 00 	cmpl   $0x0,0x2d8(%eax)
   104e1:	74 1d                	je     10500 <do_select.part.2+0x1dc>
   104e3:	85 ff                	test   %edi,%edi
   104e5:	75 19                	jne    10500 <do_select.part.2+0x1dc>
		current->state = TASK_INTERRUPTIBLE;
   104e7:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		schedule();
   104ed:	e8 ba 67 ff ff       	call   6cac <schedule>
		free_wait(&wait_table);         						// 本任务被唤醒返回后从这里开始执行。
   104f2:	8d 44 24 2c          	lea    0x2c(%esp),%eax
   104f6:	e8 fa fc ff ff       	call   101f5 <free_wait>
   104fb:	e9 53 fe ff ff       	jmp    10353 <do_select.part.2+0x2f>
		goto repeat;
	}
	// 如果此时count不等于0，或者接收到了信号，或者等待时间到并且没有需要等待的描述符，那么我们就调用free_wait()唤醒等待队列上
	// 的任务，然后返回已准备好的描述符个数。
	free_wait(&wait_table);
   10500:	8d 44 24 2c          	lea    0x2c(%esp),%eax
   10504:	e8 ec fc ff ff       	call   101f5 <free_wait>
	return count;
}
   10509:	81 c4 1c 02 00 00    	add    $0x21c,%esp
   1050f:	89 f8                	mov    %edi,%eax
   10511:	5b                   	pop    %ebx
   10512:	5e                   	pop    %esi
   10513:	5f                   	pop    %edi
   10514:	5d                   	pop    %ebp
   10515:	c3                   	ret    

00010516 <do_select>:
{
   10516:	55                   	push   %ebp
   10517:	57                   	push   %edi
   10518:	56                   	push   %esi
   10519:	53                   	push   %ebx
   1051a:	e8 0d 65 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1051f:	81 c3 e1 0a 01 00    	add    $0x10ae1,%ebx
   10525:	83 ec 1c             	sub    $0x1c,%esp
   10528:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
   1052c:	8b 54 24 34          	mov    0x34(%esp),%edx
   10530:	8b 4c 24 38          	mov    0x38(%esp),%ecx
		if (!current->filp[i])                                  // 若文件未打开，则返回描述符值。
   10534:	c7 c3 60 23 02 00    	mov    $0x22360,%ebx
{
   1053a:	8b 44 24 30          	mov    0x30(%esp),%eax
   1053e:	89 7c 24 08          	mov    %edi,0x8(%esp)
   10542:	8b 7c 24 40          	mov    0x40(%esp),%edi
	mask = in | out | ex;
   10546:	89 d6                	mov    %edx,%esi
   10548:	09 ce                	or     %ecx,%esi
		if (!current->filp[i])                                  // 若文件未打开，则返回描述符值。
   1054a:	8b 2b                	mov    (%ebx),%ebp
	mask = in | out | ex;
   1054c:	09 c6                	or     %eax,%esi
{
   1054e:	89 7c 24 0c          	mov    %edi,0xc(%esp)
   10552:	8b 7c 24 44          	mov    0x44(%esp),%edi
	mask = in | out | ex;
   10556:	89 74 24 04          	mov    %esi,0x4(%esp)
	for (i = 0 ; i < NR_OPEN ; i++, mask >>= 1) {
   1055a:	31 f6                	xor    %esi,%esi
		if (!(mask & 1))                                        // 若不在描述符集中则继续判断下一个。
   1055c:	f6 44 24 04 01       	testb  $0x1,0x4(%esp)
   10561:	74 2b                	je     1058e <do_select+0x78>
		if (!current->filp[i])                                  // 若文件未打开，则返回描述符值。
   10563:	8b 9c b5 48 03 00 00 	mov    0x348(%ebp,%esi,4),%ebx
   1056a:	85 db                	test   %ebx,%ebx
   1056c:	74 4a                	je     105b8 <do_select+0xa2>
		if (!current->filp[i]->f_inode)                         // 若文件i节点指针为空，则返回错误号。
   1056e:	8b 5b 08             	mov    0x8(%ebx),%ebx
   10571:	85 db                	test   %ebx,%ebx
   10573:	74 43                	je     105b8 <do_select+0xa2>
		if (current->filp[i]->f_inode->i_pipe)                  // 若是管道文件描述符，则有效。
   10575:	80 7b 38 00          	cmpb   $0x0,0x38(%ebx)
   10579:	75 13                	jne    1058e <do_select+0x78>
		if (S_ISFIFO(current->filp[i]->f_inode->i_mode))        // FIFO也有效。
   1057b:	8b 1b                	mov    (%ebx),%ebx
   1057d:	66 81 e3 00 f0       	and    $0xf000,%bx
   10582:	66 81 eb 00 10       	sub    $0x1000,%bx
   10587:	66 f7 c3 00 e0       	test   $0xe000,%bx
   1058c:	75 2a                	jne    105b8 <do_select+0xa2>
	for (i = 0 ; i < NR_OPEN ; i++, mask >>= 1) {
   1058e:	46                   	inc    %esi
   1058f:	d1 6c 24 04          	shrl   0x4(%esp)
   10593:	83 fe 14             	cmp    $0x14,%esi
   10596:	75 c4                	jne    1055c <do_select+0x46>
   10598:	89 7c 24 38          	mov    %edi,0x38(%esp)
   1059c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   105a0:	89 7c 24 34          	mov    %edi,0x34(%esp)
   105a4:	8b 7c 24 08          	mov    0x8(%esp),%edi
   105a8:	89 7c 24 30          	mov    %edi,0x30(%esp)
}
   105ac:	83 c4 1c             	add    $0x1c,%esp
   105af:	5b                   	pop    %ebx
   105b0:	5e                   	pop    %esi
   105b1:	5f                   	pop    %edi
   105b2:	5d                   	pop    %ebp
   105b3:	e9 6c fd ff ff       	jmp    10324 <do_select.part.2>
   105b8:	83 c4 1c             	add    $0x1c,%esp
   105bb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   105c0:	5b                   	pop    %ebx
   105c1:	5e                   	pop    %esi
   105c2:	5f                   	pop    %edi
   105c3:	5d                   	pop    %ebp
   105c4:	c3                   	ret    

000105c5 <sys_select>:
// 函数来完成。sys_select()会首先根据参数传递来的缓冲区指针从用户数据空间把select()函数调用的参数分解复制到内核空间，然后
// 设置需要等待的超时时间值timeout，接着调用do_select()执行select功能，返回后就把处理结果再复制回用户空间中。
// 参数buffer指向用户数据区中select()函数的第1个参数处。如果返回值小于0表示执行时出现错误；如果返回值等于0,则表示在规定等
// 待时间内没有描述符准备好操作；如果返回值大于0,则表示已准备好的描述符数量。
int sys_select( unsigned long *buffer )
{
   105c5:	55                   	push   %ebp
   105c6:	57                   	push   %edi
	unsigned long timeout;

	// 然后从用户数据区把参数分别隔离复制到局部指针变量中，并根据描述符集指针是否有效分别取得3个描述符集in（读）、out（写）和ex
	// （异常）。其中mask也是一个描述符集变量，根据3个描述符集中最大描述符值+1（即第1个参数nd的值），它被设置成用户程序关心的所有
	// 描述符的屏蔽码。例如，若nd = 4,则mask = 0b00001111（共32位）。
	mask = ~((~0) << get_fs_long(buffer++));
   105c7:	83 c8 ff             	or     $0xffffffff,%eax
{
   105ca:	56                   	push   %esi
   105cb:	53                   	push   %ebx
   105cc:	31 f6                	xor    %esi,%esi
   105ce:	e8 59 64 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   105d3:	81 c3 2d 0a 01 00    	add    $0x10a2d,%ebx
   105d9:	83 ec 3c             	sub    $0x3c,%esp
   105dc:	8b 54 24 50          	mov    0x50(%esp),%edx
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   105e0:	64 8b 0a             	mov    %fs:(%edx),%ecx
	mask = ~((~0) << get_fs_long(buffer++));
   105e3:	d3 e0                	shl    %cl,%eax
   105e5:	64 8b 4a 04          	mov    %fs:0x4(%edx),%ecx
   105e9:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
   105ed:	f7 d0                	not    %eax
   105ef:	64 8b 4a 08          	mov    %fs:0x8(%edx),%ecx
   105f3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
   105f7:	64 8b 4a 0c          	mov    %fs:0xc(%edx),%ecx
   105fb:	89 4c 24 14          	mov    %ecx,0x14(%esp)
   105ff:	64 8b 4a 10          	mov    %fs:0x10(%edx),%ecx
	inp = (fd_set *) get_fs_long(buffer++);
	outp = (fd_set *) get_fs_long(buffer++);
	exp = (fd_set *) get_fs_long(buffer++);
	tvp = (struct timeval *) get_fs_long(buffer);

	if (inp)                                						// 若指针有效，则取读操作描述符集。
   10603:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   10608:	89 cd                	mov    %ecx,%ebp
   1060a:	74 0b                	je     10617 <sys_select+0x52>
   1060c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   10610:	64 8b 17             	mov    %fs:(%edi),%edx
		in = mask & get_fs_long(inp);
   10613:	89 d6                	mov    %edx,%esi
   10615:	21 c6                	and    %eax,%esi
	if (outp)                               						// 若指针有效，则取写操作描述符集。
   10617:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
	fd_set res_out, out = 0, *outp;         						// 写操作描述符集。
   1061c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   10623:	00 
	if (outp)                               						// 若指针有效，则取写操作描述符集。
   10624:	74 0d                	je     10633 <sys_select+0x6e>
   10626:	8b 7c 24 10          	mov    0x10(%esp),%edi
   1062a:	64 8b 17             	mov    %fs:(%edi),%edx
		out = mask & get_fs_long(outp);
   1062d:	21 c2                	and    %eax,%edx
   1062f:	89 54 24 18          	mov    %edx,0x18(%esp)
	fd_set res_ex, ex = 0, *exp;            						// 异常条件描述符集。
   10633:	31 c9                	xor    %ecx,%ecx
	if (exp)                                						// 若指针有效，则取异常描述符集。
   10635:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   1063a:	74 09                	je     10645 <sys_select+0x80>
   1063c:	8b 7c 24 14          	mov    0x14(%esp),%edi
   10640:	64 8b 0f             	mov    %fs:(%edi),%ecx
		ex = mask & get_fs_long(exp);
   10643:	21 c1                	and    %eax,%ecx
	// 接下来我们尝试从时间结构中取出等待（睡眠）时间值timeout。首先把timeout初始化成最大（无限）值，然后从用户数据空间取得该时间
	// 结构中设置的时间值，经转换和加上系统当前嘀嗒值jiffies，最后得到需要等待的时间嘀嗒数值timeout。我们用此值来设置当前进程应该
	// 等待的延时。另外，第241行上tv_usec字段是微秒值，把它除以1000000后可得到对应秒数，再乘以系统每秒嘀嗒数HZ，即把tv_usec转换
	// 成嘀嗒值。
	timeout = 0xffffffff;
   10645:	83 c8 ff             	or     $0xffffffff,%eax
	if (tvp) {
   10648:	85 ed                	test   %ebp,%ebp
   1064a:	74 20                	je     1066c <sys_select+0xa7>
		timeout = get_fs_long((unsigned long *) & tvp->tv_usec) / (1000000 / HZ);
   1064c:	bf 10 27 00 00       	mov    $0x2710,%edi
   10651:	31 d2                	xor    %edx,%edx
   10653:	64 8b 45 04          	mov    %fs:0x4(%ebp),%eax
   10657:	f7 f7                	div    %edi
   10659:	64 8b 55 00          	mov    %fs:0x0(%ebp),%edx
		timeout += get_fs_long((unsigned long *) & tvp->tv_sec) * HZ;
   1065d:	6b d2 64             	imul   $0x64,%edx,%edx
   10660:	01 d0                	add    %edx,%eax
		timeout += jiffies;
   10662:	c7 c2 6c 2a 02 00    	mov    $0x22a6c,%edx
   10668:	8b 12                	mov    (%edx),%edx
   1066a:	01 d0                	add    %edx,%eax
	}
	current->timeout = timeout;             						// 设置当前进程应该延时的嘀嗒值。
   1066c:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
   10672:	8b 17                	mov    (%edi),%edx
   10674:	89 82 d8 02 00 00    	mov    %eax,0x2d8(%edx)
	// select()函数的主要工作在do_select()中完成。在调用该函数之后的代码用于把处理结果复制到用户数据区中，返回给用户。为了避免出现
	// 竞争条件，在调用do_select()前需要禁止中断，并在该函数返回后再开启中断。
	// 如果在do_select()返回之后进程的等待延时字段timeout还大于当前系统计时嘀嗒值jiffies，说明在超时之前已经有描述准备好，于是这里
	// 我们先记下到超时还剩余的时间值，随后我们会把这个值返回给用户。如果进程的等待延时字段timeout已经小于或等于当前系统jiffies，表示
	// do_select()可能是由于超时而返回，因此把剩余时间值设置为0。
	cli();                  										// 禁止响应中断。
   1067a:	fa                   	cli    
	i = do_select(in, out, ex, &res_in, &res_out, &res_ex);
   1067b:	50                   	push   %eax
   1067c:	50                   	push   %eax
   1067d:	8d 44 24 34          	lea    0x34(%esp),%eax
   10681:	50                   	push   %eax
   10682:	8d 44 24 34          	lea    0x34(%esp),%eax
   10686:	50                   	push   %eax
   10687:	8d 44 24 34          	lea    0x34(%esp),%eax
   1068b:	50                   	push   %eax
   1068c:	51                   	push   %ecx
   1068d:	ff 74 24 30          	pushl  0x30(%esp)
   10691:	56                   	push   %esi
   10692:	e8 7f fe ff ff       	call   10516 <do_select>
	if (current->timeout > jiffies)
   10697:	c7 c1 6c 2a 02 00    	mov    $0x22a6c,%ecx
	i = do_select(in, out, ex, &res_in, &res_out, &res_ex);
   1069d:	89 c6                	mov    %eax,%esi
	if (current->timeout > jiffies)
   1069f:	8b 07                	mov    (%edi),%eax
	i = do_select(in, out, ex, &res_in, &res_out, &res_ex);
   106a1:	83 c4 20             	add    $0x20,%esp
		timeout = current->timeout - jiffies;
	else
		timeout = 0;
   106a4:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   106ab:	00 
	if (current->timeout > jiffies)
   106ac:	8b 90 d8 02 00 00    	mov    0x2d8(%eax),%edx
   106b2:	89 44 24 18          	mov    %eax,0x18(%esp)
   106b6:	8b 01                	mov    (%ecx),%eax
   106b8:	39 c2                	cmp    %eax,%edx
   106ba:	76 08                	jbe    106c4 <sys_select+0xff>
		timeout = current->timeout - jiffies;
   106bc:	8b 09                	mov    (%ecx),%ecx
   106be:	29 ca                	sub    %ecx,%edx
   106c0:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	sti();                  										// 开启中断响应。
   106c4:	fb                   	sti    
	// 接下来我们把进程的超时字段清零。如果do_select()返回的已准备好描述符个数小于0，表示执行出错，于是返回这个错误号。然后我们把处理过
	// 的描述符集内容和延迟时间结构内容写回到用户数据缓冲空间。在时间结构内容时还需要先将嘀嗒时间单位表示的剩余延迟时间转换成秒和微秒值。
	current->timeout = 0;
   106c5:	8b 44 24 18          	mov    0x18(%esp),%eax
	if (i < 0)
   106c9:	85 f6                	test   %esi,%esi
	current->timeout = 0;
   106cb:	c7 80 d8 02 00 00 00 	movl   $0x0,0x2d8(%eax)
   106d2:	00 00 00 
	if (i < 0)
   106d5:	0f 88 ab 00 00 00    	js     10786 <sys_select+0x1c1>
		return i;
	if (inp) {
   106db:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   106e0:	74 1b                	je     106fd <sys_select+0x138>
		verify_area(inp, 4);
   106e2:	50                   	push   %eax
   106e3:	50                   	push   %eax
   106e4:	6a 04                	push   $0x4
   106e6:	ff 74 24 18          	pushl  0x18(%esp)
   106ea:	e8 fc 74 ff ff       	call   7beb <verify_area>
   106ef:	83 c4 10             	add    $0x10,%esp
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   106f2:	8b 44 24 24          	mov    0x24(%esp),%eax
   106f6:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   106fa:	64 89 01             	mov    %eax,%fs:(%ecx)
		put_fs_long(res_in, inp);        							// 可读描述符值。
	}
	if (outp) {
   106fd:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   10702:	74 1b                	je     1071f <sys_select+0x15a>
		verify_area(outp, 4);
   10704:	51                   	push   %ecx
   10705:	51                   	push   %ecx
   10706:	6a 04                	push   $0x4
   10708:	ff 74 24 1c          	pushl  0x1c(%esp)
   1070c:	e8 da 74 ff ff       	call   7beb <verify_area>
   10711:	83 c4 10             	add    $0x10,%esp
   10714:	8b 44 24 28          	mov    0x28(%esp),%eax
   10718:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1071c:	64 89 01             	mov    %eax,%fs:(%ecx)
		put_fs_long(res_out, outp);      							// 可写描述符值。
	}
	if (exp) {
   1071f:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
   10724:	74 1b                	je     10741 <sys_select+0x17c>
		verify_area(exp, 4);
   10726:	52                   	push   %edx
   10727:	52                   	push   %edx
   10728:	6a 04                	push   $0x4
   1072a:	ff 74 24 20          	pushl  0x20(%esp)
   1072e:	e8 b8 74 ff ff       	call   7beb <verify_area>
   10733:	83 c4 10             	add    $0x10,%esp
   10736:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   1073a:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   1073e:	64 89 01             	mov    %eax,%fs:(%ecx)
		put_fs_long(res_ex, exp);        							// 出现异常条件描述符集。
	}
	if (tvp) {
   10741:	85 ed                	test   %ebp,%ebp
   10743:	74 28                	je     1076d <sys_select+0x1a8>
		verify_area(tvp, sizeof(*tvp));
   10745:	50                   	push   %eax
   10746:	50                   	push   %eax
   10747:	6a 08                	push   $0x8
   10749:	55                   	push   %ebp
   1074a:	e8 9c 74 ff ff       	call   7beb <verify_area>
   1074f:	83 c4 10             	add    $0x10,%esp
		put_fs_long(timeout / HZ, (unsigned long *) &tvp->tv_sec);  // 秒。
   10752:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   10756:	b9 64 00 00 00       	mov    $0x64,%ecx
   1075b:	31 d2                	xor    %edx,%edx
   1075d:	f7 f1                	div    %ecx
   1075f:	64 89 45 00          	mov    %eax,%fs:0x0(%ebp)
		timeout %= HZ;
		timeout *= (1000000 / HZ);
   10763:	69 d2 10 27 00 00    	imul   $0x2710,%edx,%edx
   10769:	64 89 55 04          	mov    %edx,%fs:0x4(%ebp)
		put_fs_long(timeout, (unsigned long *) &tvp->tv_usec);      // 微秒。
	}
	// 如果此时并没有已准备好的描述符，并且收到了某个非阻塞信号，则返回被中断错误号。否则返回已准备好的描述符个数值。
	if (!i && (current->signal & ~current->blocked))
   1076d:	85 f6                	test   %esi,%esi
   1076f:	75 15                	jne    10786 <sys_select+0x1c1>
   10771:	8b 17                	mov    (%edi),%edx
   10773:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
   10779:	f7 d0                	not    %eax
		return -EINTR;
   1077b:	85 42 0c             	test   %eax,0xc(%edx)
   1077e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10783:	0f 45 f0             	cmovne %eax,%esi
	return i;
}
   10786:	83 c4 3c             	add    $0x3c,%esp
   10789:	89 f0                	mov    %esi,%eax
   1078b:	5b                   	pop    %ebx
   1078c:	5e                   	pop    %esi
   1078d:	5f                   	pop    %edi
   1078e:	5d                   	pop    %ebp
   1078f:	c3                   	ret    

00010790 <__x86.get_pc_thunk.di>:
   10790:	8b 3c 24             	mov    (%esp),%edi
   10793:	c3                   	ret    

00010794 <add_request>:
// 参数dev是指定块设备结构指针,该结构中有处理请求项函数指针和当前正在请求项指针;
// req是已设置好内容的请求项结构指针.
// 本函数把已经设置好的请求项req添加到指定设备的请求项链表中.如果该设备在当前请求项指针为空,则可以设置req为当前请求项并立刻调用设备请求
// 项处理函数.否则就把req请求项插入到该请求项链表中.
static void add_request(struct blk_dev_struct * dev, struct request * req)
{
   10794:	55                   	push   %ebp
	// 首先对参数提供的请求项的指针和标志作初始设置.置空请求项中的下一请求项指针,关中断并清除请求项相关缓冲区脏标志.
	struct request * tmp;

	req->next = NULL;
   10795:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
{
   1079c:	57                   	push   %edi
   1079d:	56                   	push   %esi
   1079e:	53                   	push   %ebx
	cli();								// 关中断
   1079f:	fa                   	cli    
	if (req->bh)
   107a0:	8b 5a 1c             	mov    0x1c(%edx),%ebx
   107a3:	85 db                	test   %ebx,%ebx
   107a5:	74 04                	je     107ab <add_request+0x17>
		req->bh->b_dirt = 0;			// 清缓冲区"脏"标志.
   107a7:	c6 43 0b 00          	movb   $0x0,0xb(%ebx)
	// 然后查看指定设备是否有当前请求项,即查看设备是否正忙.如果指定设备dev当前请求项(current_equest)字段为空,则表示目前该设备没有请求项,本次是
	// 第1个请求项,也是唯一的一个.因此可将块设备当前请求指针直接指向该请求项,并立刻执行相应设备的请求函数.
	if (!(tmp = dev->current_request)) {
   107ab:	8b 48 04             	mov    0x4(%eax),%ecx
   107ae:	85 c9                	test   %ecx,%ecx
   107b0:	75 18                	jne    107ca <add_request+0x36>
		dev->current_request = req;
   107b2:	89 50 04             	mov    %edx,0x4(%eax)
		sti();							// 开中断.
   107b5:	fb                   	sti    
			break;
	}
	req->next = tmp->next;
	tmp->next = req;
	sti();
}
   107b6:	5b                   	pop    %ebx
   107b7:	5e                   	pop    %esi
   107b8:	5f                   	pop    %edi
   107b9:	5d                   	pop    %ebp
		(dev->request_fn)();			// 执行请求函数,对于硬盘是do_hd_request().
   107ba:	8b 00                	mov    (%eax),%eax
   107bc:	ff e0                	jmp    *%eax
		if (!req->bh)
   107be:	85 db                	test   %ebx,%ebx
   107c0:	75 11                	jne    107d3 <add_request+0x3f>
			if (tmp->next->bh)
   107c2:	83 78 1c 00          	cmpl   $0x0,0x1c(%eax)
   107c6:	75 55                	jne    1081d <add_request+0x89>
{
   107c8:	89 c1                	mov    %eax,%ecx
	for ( ; tmp->next ; tmp = tmp->next) {
   107ca:	8b 41 20             	mov    0x20(%ecx),%eax
   107cd:	85 c0                	test   %eax,%eax
   107cf:	75 ed                	jne    107be <add_request+0x2a>
   107d1:	eb 4a                	jmp    1081d <add_request+0x89>
		if ((IN_ORDER(tmp, req) ||
   107d3:	8b 79 04             	mov    0x4(%ecx),%edi
   107d6:	8b 72 04             	mov    0x4(%edx),%esi
   107d9:	39 f7                	cmp    %esi,%edi
   107db:	7c 29                	jl     10806 <add_request+0x72>
   107dd:	75 10                	jne    107ef <add_request+0x5b>
   107df:	8b 2a                	mov    (%edx),%ebp
   107e1:	39 29                	cmp    %ebp,(%ecx)
   107e3:	7c 21                	jl     10806 <add_request+0x72>
   107e5:	75 08                	jne    107ef <add_request+0x5b>
   107e7:	8b 6a 0c             	mov    0xc(%edx),%ebp
   107ea:	39 69 0c             	cmp    %ebp,0xc(%ecx)
   107ed:	72 17                	jb     10806 <add_request+0x72>
   107ef:	3b 78 04             	cmp    0x4(%eax),%edi
   107f2:	7c d4                	jl     107c8 <add_request+0x34>
		    !IN_ORDER(tmp, tmp->next)) &&
   107f4:	75 10                	jne    10806 <add_request+0x72>
   107f6:	8b 38                	mov    (%eax),%edi
   107f8:	39 39                	cmp    %edi,(%ecx)
   107fa:	7c cc                	jl     107c8 <add_request+0x34>
   107fc:	75 08                	jne    10806 <add_request+0x72>
   107fe:	8b 78 0c             	mov    0xc(%eax),%edi
   10801:	39 79 0c             	cmp    %edi,0xc(%ecx)
   10804:	72 c2                	jb     107c8 <add_request+0x34>
   10806:	3b 70 04             	cmp    0x4(%eax),%esi
   10809:	7c 12                	jl     1081d <add_request+0x89>
		    IN_ORDER(req, tmp->next))
   1080b:	75 bb                	jne    107c8 <add_request+0x34>
   1080d:	8b 30                	mov    (%eax),%esi
   1080f:	39 32                	cmp    %esi,(%edx)
   10811:	7c 0a                	jl     1081d <add_request+0x89>
   10813:	75 b3                	jne    107c8 <add_request+0x34>
   10815:	8b 70 0c             	mov    0xc(%eax),%esi
   10818:	39 72 0c             	cmp    %esi,0xc(%edx)
   1081b:	73 ab                	jae    107c8 <add_request+0x34>
	req->next = tmp->next;
   1081d:	89 42 20             	mov    %eax,0x20(%edx)
	tmp->next = req;
   10820:	89 51 20             	mov    %edx,0x20(%ecx)
	sti();
   10823:	fb                   	sti    
}
   10824:	5b                   	pop    %ebx
   10825:	5e                   	pop    %esi
   10826:	5f                   	pop    %edi
   10827:	5d                   	pop    %ebp
   10828:	c3                   	ret    

00010829 <ll_rw_page>:
}

// 低级页面读写函数(Low Level Read Write Pagk).
// 以页面(4K)为单位访问设备数据,即每次读/写8个扇区.参见下面ll_rw_blk()函数.
void ll_rw_page(int rw, int dev, int page, char * buffer)
{
   10829:	55                   	push   %ebp
   1082a:	57                   	push   %edi
   1082b:	56                   	push   %esi
   1082c:	53                   	push   %ebx
   1082d:	e8 fa 61 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10832:	81 c3 ce 07 01 00    	add    $0x107ce,%ebx
   10838:	83 ec 0c             	sub    $0xc,%esp
	struct request * req;
	unsigned int major = MAJOR(dev);
   1083b:	8b 74 24 24          	mov    0x24(%esp),%esi
   1083f:	c1 ee 08             	shr    $0x8,%esi

	// 首先对函数参数的合法性进行检测.如果设备主设备号不存在或者该设备的请求操作函数不存在,则显示出错信息,并返回.如果参数给出的命令既不是
	// READ也不是WRITE,则表示内核程序有错,显示出错信息并停机.
	if (major >= NR_BLK_DEV || !(blk_dev[major].request_fn)) {
   10842:	83 fe 06             	cmp    $0x6,%esi
   10845:	77 0c                	ja     10853 <ll_rw_page+0x2a>
   10847:	8d bb 40 40 00 00    	lea    0x4040(%ebx),%edi
   1084d:	83 3c f7 00          	cmpl   $0x0,(%edi,%esi,8)
   10851:	75 17                	jne    1086a <ll_rw_page+0x41>
		printk("Trying to read nonexistent block-device\n\r");
   10853:	8d 83 d3 77 ff ff    	lea    -0x882d(%ebx),%eax
   10859:	83 ec 0c             	sub    $0xc,%esp
   1085c:	50                   	push   %eax
   1085d:	e8 bf 78 ff ff       	call   8121 <printk>
		return;
   10862:	83 c4 10             	add    $0x10,%esp
   10865:	e9 9f 00 00 00       	jmp    10909 <ll_rw_page+0xe0>
	}
	if (rw != READ && rw != WRITE)
   1086a:	83 7c 24 20 01       	cmpl   $0x1,0x20(%esp)
   1086f:	76 12                	jbe    10883 <ll_rw_page+0x5a>
		panic("Bad block dev command, must be R/W");
   10871:	8d 83 fd 77 ff ff    	lea    -0x8803(%ebx),%eax
   10877:	83 ec 0c             	sub    $0xc,%esp
   1087a:	50                   	push   %eax
   1087b:	e8 52 78 ff ff       	call   80d2 <panic>
   10880:	83 c4 10             	add    $0x10,%esp
	// 在参数检测操作完成后,我们现在需要为本次操作建立请求项.首先我们需要在请求数组中寻找到一个空闲项(糟)来存放新请求项.搜索过程从请求数组末端
	// 开始.于是我们开始从后向前搜索,当请求结构request的设备字段值<0时,表示该项未被占用(空闲).如果没有一项是空闲的(此时请求项数组指针已经搜索越过
	// 头部),则让本次请求操作先睡眠(以等待请求队列腾出空项),过一会再来搜索请求队列.
repeat:
	req = request + NR_REQUEST;							// 将指针指向队列尾部.
   10883:	c7 c5 60 52 03 00    	mov    $0x35260,%ebp
   10889:	8d 95 80 04 00 00    	lea    0x480(%ebp),%edx
	while (--req >= request)
   1088f:	83 ea 24             	sub    $0x24,%edx
   10892:	39 ea                	cmp    %ebp,%edx
   10894:	72 5f                	jb     108f5 <ll_rw_page+0xcc>
		if (req->dev < 0)
   10896:	83 3a 00             	cmpl   $0x0,(%edx)
   10899:	79 f4                	jns    1088f <ll_rw_page+0x66>
	/* 向空闲请求项中填写请求信息,并将其加入队列中 */
	// OK,程序执行到这里表示已找到一个空闲请求项.于是我们设置好新请求项,把当前进程置为不可中断睡眠中断后,就去调用add_request()把它添加到请求队列中,
	// 然后直接调用调度函数让当前进程睡眠等待页面从交换设备中读入.这里不像make_request()函数那样直接退出函数而调用了schedule(),是因为make_request()
	// 函数仅读2个扇区数据.而这里需要对交换设备读/写8个扇区,需要花较长的时间.因此当前进程肯定需要等待而睡眠.因此这里直接就让进程去睡眠了,省得在程序其他地方
	// 还要进行这些判断操作.
	req->dev = dev;										// 设备号
   1089b:	8b 44 24 24          	mov    0x24(%esp),%eax
	req->cmd = rw;										// 命令(READ/WRITE)start_code
	req->errors = 0;									// 读写操作错误计数
   1089f:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	req->sector = page << 3;							// 起始读写扇区
	req->nr_sectors = 8;								// 读写扇区数
   108a6:	c7 42 10 08 00 00 00 	movl   $0x8,0x10(%edx)
	req->buffer = buffer;								// 数据缓冲区
	req->waiting = current;								// 当前进程进入该请求等待队列
	req->bh = NULL;										// 无缓冲块头指针(不用高速缓冲)
   108ad:	c7 42 1c 00 00 00 00 	movl   $0x0,0x1c(%edx)
	req->next = NULL;									// 下一个请求项指针
   108b4:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
	req->dev = dev;										// 设备号
   108bb:	89 02                	mov    %eax,(%edx)
	req->cmd = rw;										// 命令(READ/WRITE)start_code
   108bd:	8b 44 24 20          	mov    0x20(%esp),%eax
   108c1:	89 42 04             	mov    %eax,0x4(%edx)
	req->sector = page << 3;							// 起始读写扇区
   108c4:	8b 44 24 28          	mov    0x28(%esp),%eax
   108c8:	c1 e0 03             	shl    $0x3,%eax
   108cb:	89 42 0c             	mov    %eax,0xc(%edx)
	req->buffer = buffer;								// 数据缓冲区
   108ce:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   108d2:	89 42 14             	mov    %eax,0x14(%edx)
	req->waiting = current;								// 当前进程进入该请求等待队列
   108d5:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   108db:	8b 00                	mov    (%eax),%eax
   108dd:	89 42 18             	mov    %eax,0x18(%edx)
	current->state = TASK_UNINTERRUPTIBLE;				// 置为不可中断状态
   108e0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	add_request(major + blk_dev, req);					// 将请求项加入队列中.
   108e6:	8d 04 f7             	lea    (%edi,%esi,8),%eax
   108e9:	e8 a6 fe ff ff       	call   10794 <add_request>
	// 当前进程需要读取8个扇区的数据因此需要睡眠，因此调用调度程序选择进程运行
	schedule();
   108ee:	e8 b9 63 ff ff       	call   6cac <schedule>
   108f3:	eb 14                	jmp    10909 <ll_rw_page+0xe0>
		sleep_on(&wait_for_request);					// 睡眠,过会再查看请求队列.
   108f5:	8d 93 78 40 00 00    	lea    0x4078(%ebx),%edx
   108fb:	83 ec 0c             	sub    $0xc,%esp
   108fe:	52                   	push   %edx
   108ff:	e8 81 65 ff ff       	call   6e85 <sleep_on>
		goto repeat;
   10904:	83 c4 10             	add    $0x10,%esp
   10907:	eb 80                	jmp    10889 <ll_rw_page+0x60>
}
   10909:	83 c4 0c             	add    $0xc,%esp
   1090c:	5b                   	pop    %ebx
   1090d:	5e                   	pop    %esi
   1090e:	5f                   	pop    %edi
   1090f:	5d                   	pop    %ebp
   10910:	c3                   	ret    

00010911 <ll_rw_block>:
// 该函数是块设备驱动程序与系统其他部分的接口函数.通常在fs/buffer.c程序中被调用.
// 主要功能是创建块设备读写请求项并插入到指定块设备请求队列.实际的读写操作则是由设备的request_fn()函数完成.对于硬盘操作,该函数是do_hd_request();对于软盘操作
// 该函数是do_fd_request();对于虚拟盘则是do_rd_request().另外,在调用该函数之前,调用者需要首先把读/写块设备的信息保存在缓冲块头结构中,如设备号,块号.
// 参数:rw - READ,READA,WRITE或WRITEA是命令;bh - 数据缓冲块头指针.
void ll_rw_block(int rw, struct buffer_head * bh)
{
   10911:	55                   	push   %ebp
   10912:	57                   	push   %edi
   10913:	56                   	push   %esi
   10914:	53                   	push   %ebx
   10915:	e8 12 61 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1091a:	81 c3 e6 06 01 00    	add    $0x106e6,%ebx
   10920:	83 ec 1c             	sub    $0x1c,%esp
   10923:	8b 74 24 34          	mov    0x34(%esp),%esi
   10927:	8b 6c 24 30          	mov    0x30(%esp),%ebp
	unsigned int major;									// 主设备号(对于硬盘是3)

	// 如果设备主设备号不存在或者该设备的请求操作函数不存在,则显示出错信息,并返回.否则创建请求项并插入请求队列.
	if ((major = MAJOR(bh->b_dev)) >= NR_BLK_DEV ||
   1092b:	0f b6 7e 09          	movzbl 0x9(%esi),%edi
   1092f:	66 83 ff 06          	cmp    $0x6,%di
   10933:	77 0a                	ja     1093f <ll_rw_block+0x2e>
   10935:	83 bc fb 40 40 00 00 	cmpl   $0x0,0x4040(%ebx,%edi,8)
   1093c:	00 
   1093d:	75 14                	jne    10953 <ll_rw_block+0x42>
	!(blk_dev[major].request_fn)) {
		printk("Trying to read nonexistent block-device\n\r");
   1093f:	8d 83 d3 77 ff ff    	lea    -0x882d(%ebx),%eax
   10945:	83 ec 0c             	sub    $0xc,%esp
   10948:	50                   	push   %eax
   10949:	e8 d3 77 ff ff       	call   8121 <printk>
   1094e:	e9 96 00 00 00       	jmp    109e9 <ll_rw_block+0xd8>
	if (rw_ahead = (rw == READA || rw == WRITEA)) {
   10953:	8d 45 fe             	lea    -0x2(%ebp),%eax
   10956:	83 f8 01             	cmp    $0x1,%eax
   10959:	89 44 24 04          	mov    %eax,0x4(%esp)
   1095d:	77 14                	ja     10973 <ll_rw_block+0x62>
		if (bh->b_lock)
   1095f:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   10963:	0f 85 24 01 00 00    	jne    10a8d <ll_rw_block+0x17c>
		if (rw == READA)
   10969:	31 c0                	xor    %eax,%eax
   1096b:	83 fd 02             	cmp    $0x2,%ebp
   1096e:	0f 95 c0             	setne  %al
   10971:	89 c5                	mov    %eax,%ebp
	if (rw != READ && rw != WRITE)
   10973:	83 fd 01             	cmp    $0x1,%ebp
   10976:	76 12                	jbe    1098a <ll_rw_block+0x79>
		panic("Bad block dev command, must be R/W/RA/WA");
   10978:	8d 83 20 78 ff ff    	lea    -0x87e0(%ebx),%eax
   1097e:	83 ec 0c             	sub    $0xc,%esp
   10981:	50                   	push   %eax
   10982:	e8 4b 77 ff ff       	call   80d2 <panic>
   10987:	83 c4 10             	add    $0x10,%esp
	cli();							// 清中断许可.
   1098a:	fa                   	cli    
	while (bh->b_lock)				// 如果缓冲区已被锁定则睡眠,直到缓冲区解锁.
   1098b:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   1098f:	74 11                	je     109a2 <ll_rw_block+0x91>
		sleep_on(&bh->b_wait);
   10991:	8d 46 10             	lea    0x10(%esi),%eax
   10994:	83 ec 0c             	sub    $0xc,%esp
   10997:	50                   	push   %eax
   10998:	e8 e8 64 ff ff       	call   6e85 <sleep_on>
   1099d:	83 c4 10             	add    $0x10,%esp
   109a0:	eb e9                	jmp    1098b <ll_rw_block+0x7a>
	bh->b_lock = 1;					// 立刻锁定缓冲区.
   109a2:	c6 46 0d 01          	movb   $0x1,0xd(%esi)
	sti();							// 开中断.
   109a6:	fb                   	sti    
	if ((rw == WRITE && !bh->b_dirt) || (rw == READ && bh->b_uptodate)) {
   109a7:	83 fd 01             	cmp    $0x1,%ebp
   109aa:	75 23                	jne    109cf <ll_rw_block+0xbe>
   109ac:	80 7e 0b 00          	cmpb   $0x0,0xb(%esi)
   109b0:	74 27                	je     109d9 <ll_rw_block+0xc8>
   109b2:	c7 c0 60 52 03 00    	mov    $0x35260,%eax
   109b8:	85 ed                	test   %ebp,%ebp
   109ba:	8d 88 80 04 00 00    	lea    0x480(%eax),%ecx
   109c0:	8d 90 f4 02 00 00    	lea    0x2f4(%eax),%edx
   109c6:	0f 44 d1             	cmove  %ecx,%edx
   109c9:	89 54 24 08          	mov    %edx,0x8(%esp)
   109cd:	eb 4a                	jmp    10a19 <ll_rw_block+0x108>
   109cf:	85 ed                	test   %ebp,%ebp
   109d1:	75 df                	jne    109b2 <ll_rw_block+0xa1>
   109d3:	80 7e 0a 00          	cmpb   $0x0,0xa(%esi)
   109d7:	74 d9                	je     109b2 <ll_rw_block+0xa1>
	bh->b_lock = 0;					// 清锁定标志.
   109d9:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
	wake_up(&bh->b_wait);			// 唤醒等待该缓冲区的任务.
   109dd:	83 ec 0c             	sub    $0xc,%esp
   109e0:	83 c6 10             	add    $0x10,%esi
   109e3:	56                   	push   %esi
   109e4:	e8 aa 64 ff ff       	call   6e93 <wake_up>
   109e9:	83 c4 10             	add    $0x10,%esp
   109ec:	e9 9c 00 00 00       	jmp    10a8d <ll_rw_block+0x17c>
	while (--req >= request)
   109f1:	83 ea 24             	sub    $0x24,%edx
   109f4:	39 c2                	cmp    %eax,%edx
   109f6:	73 27                	jae    10a1f <ll_rw_block+0x10e>
		if (rw_ahead) {									// 则若是提前读/写请求,则退出.
   109f8:	83 7c 24 04 01       	cmpl   $0x1,0x4(%esp)
   109fd:	76 6d                	jbe    10a6c <ll_rw_block+0x15b>
		sleep_on(&wait_for_request);					// 否则就睡眠,过会再查看请求队列.
   109ff:	8d 93 78 40 00 00    	lea    0x4078(%ebx),%edx
   10a05:	89 44 24 0c          	mov    %eax,0xc(%esp)
   10a09:	83 ec 0c             	sub    $0xc,%esp
   10a0c:	52                   	push   %edx
   10a0d:	e8 73 64 ff ff       	call   6e85 <sleep_on>
   10a12:	83 c4 10             	add    $0x10,%esp
   10a15:	8b 44 24 0c          	mov    0xc(%esp),%eax
{
   10a19:	8b 54 24 08          	mov    0x8(%esp),%edx
   10a1d:	eb d2                	jmp    109f1 <ll_rw_block+0xe0>
		if (req->dev < 0)
   10a1f:	83 3a 00             	cmpl   $0x0,(%edx)
   10a22:	79 cd                	jns    109f1 <ll_rw_block+0xe0>
	req->dev = bh->b_dev;								// 设备号.
   10a24:	0f b7 46 08          	movzwl 0x8(%esi),%eax
	req->cmd = rw;										// 命令(READ/WRITE).
   10a28:	89 6a 04             	mov    %ebp,0x4(%edx)
	req->errors = 0;									// 操作时产生的错误次数.
   10a2b:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	req->dev = bh->b_dev;								// 设备号.
   10a32:	89 02                	mov    %eax,(%edx)
	req->sector = bh->b_blocknr << 1;					// 起始扇区.块号转换成扇区号(1块=2扇区).
   10a34:	8b 46 04             	mov    0x4(%esi),%eax
	req->nr_sectors = 2;								// 本请求项需要读写的扇区数.
   10a37:	c7 42 10 02 00 00 00 	movl   $0x2,0x10(%edx)
	req->sector = bh->b_blocknr << 1;					// 起始扇区.块号转换成扇区号(1块=2扇区).
   10a3e:	01 c0                	add    %eax,%eax
   10a40:	89 42 0c             	mov    %eax,0xc(%edx)
	req->buffer = bh->b_data;							// 请求项缓冲区指针指向需读写的数据缓冲区.
   10a43:	8b 06                	mov    (%esi),%eax
	req->waiting = NULL;								// 任务等待操作执行完成的地方.
   10a45:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%edx)
	req->bh = bh;										// 缓冲块头指针.
   10a4c:	89 72 1c             	mov    %esi,0x1c(%edx)
	req->next = NULL;									// 指向下一请求项.
   10a4f:	c7 42 20 00 00 00 00 	movl   $0x0,0x20(%edx)
	req->buffer = bh->b_data;							// 请求项缓冲区指针指向需读写的数据缓冲区.
   10a56:	89 42 14             	mov    %eax,0x14(%edx)
		return;
	}
	make_request(major, rw, bh);
}
   10a59:	83 c4 1c             	add    $0x1c,%esp
	add_request(major + blk_dev, req);					// 将请求项加入队列中(blk_dev[major],reg).
   10a5c:	8d 84 fb 40 40 00 00 	lea    0x4040(%ebx,%edi,8),%eax
}
   10a63:	5b                   	pop    %ebx
   10a64:	5e                   	pop    %esi
   10a65:	5f                   	pop    %edi
   10a66:	5d                   	pop    %ebp
	add_request(major + blk_dev, req);					// 将请求项加入队列中(blk_dev[major],reg).
   10a67:	e9 28 fd ff ff       	jmp    10794 <add_request>
	if (!bh->b_lock)				// 如果该缓冲区没有被锁定,则打印出错信息.
   10a6c:	80 7e 0d 00          	cmpb   $0x0,0xd(%esi)
   10a70:	0f 85 63 ff ff ff    	jne    109d9 <ll_rw_block+0xc8>
		printk("ll_rw_block.c: buffer not locked\n\r");
   10a76:	8d 83 49 78 ff ff    	lea    -0x87b7(%ebx),%eax
   10a7c:	83 ec 0c             	sub    $0xc,%esp
   10a7f:	50                   	push   %eax
   10a80:	e8 9c 76 ff ff       	call   8121 <printk>
   10a85:	83 c4 10             	add    $0x10,%esp
   10a88:	e9 4c ff ff ff       	jmp    109d9 <ll_rw_block+0xc8>
}
   10a8d:	83 c4 1c             	add    $0x1c,%esp
   10a90:	5b                   	pop    %ebx
   10a91:	5e                   	pop    %esi
   10a92:	5f                   	pop    %edi
   10a93:	5d                   	pop    %ebp
   10a94:	c3                   	ret    

00010a95 <blk_dev_init>:

// 块设备初始化函数,由初始化程序main.c调用.
// 初始化请求数组,将所有请求项置为空闲项(dev = -1).有32项(NR_REQUEST = 32).
void blk_dev_init(void)
{
   10a95:	e8 8e 5f ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
   10a9a:	81 c2 66 05 01 00    	add    $0x10566,%edx
   10aa0:	31 c0                	xor    %eax,%eax
	int i;

	for (i = 0; i < NR_REQUEST; i++) {
		request[i].dev = -1;
   10aa2:	c7 c2 60 52 03 00    	mov    $0x35260,%edx
   10aa8:	c7 04 10 ff ff ff ff 	movl   $0xffffffff,(%eax,%edx,1)
		request[i].next = NULL;
   10aaf:	c7 44 10 20 00 00 00 	movl   $0x0,0x20(%eax,%edx,1)
   10ab6:	00 
   10ab7:	83 c0 24             	add    $0x24,%eax
	for (i = 0; i < NR_REQUEST; i++) {
   10aba:	3d 80 04 00 00       	cmp    $0x480,%eax
   10abf:	75 e7                	jne    10aa8 <blk_dev_init+0x13>
	}
}
   10ac1:	c3                   	ret    

00010ac2 <end_request>:
// 参数uptodate是更新标志.
// 首先关闭指定块设备,然后检查此次读写缓冲区是否有效.如果有效则根据参数值设置缓冲区数据更新标志,并解锁该缓冲区.如果更新标志参数值是0,
// 表示此次请求项的操作失败,因此显示相关块设备IO错误信息.最后,唤醒等待该请求项的进程以及等待空闲请求项出现的进程,释放并从请求链表
// 中删除本请求项,并把当前请求项指针指向下一请求项.
static inline void end_request(int uptodate)
{
   10ac2:	55                   	push   %ebp
   10ac3:	57                   	push   %edi
   10ac4:	89 c7                	mov    %eax,%edi
   10ac6:	56                   	push   %esi
   10ac7:	53                   	push   %ebx
   10ac8:	e8 5f 5f ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10acd:	81 c3 33 05 01 00    	add    $0x10533,%ebx
   10ad3:	83 ec 18             	sub    $0x18,%esp
	DEVICE_OFF(CURRENT->dev);							// 关闭设备
   10ad6:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   10adc:	8b 46 14             	mov    0x14(%esi),%eax
   10adf:	8b 00                	mov    (%eax),%eax
   10ae1:	83 e0 03             	and    $0x3,%eax
   10ae4:	50                   	push   %eax
   10ae5:	e8 d2 64 ff ff       	call   6fbc <floppy_off>
	if (CURRENT->bh) {									// CURRENT为当前请求结构项指针
   10aea:	8b 46 14             	mov    0x14(%esi),%eax
   10aed:	83 c4 10             	add    $0x10,%esp
   10af0:	8b 68 1c             	mov    0x1c(%eax),%ebp
   10af3:	85 ed                	test   %ebp,%ebp
   10af5:	74 30                	je     10b27 <end_request+0x65>
	if (!bh->b_lock)
   10af7:	80 7d 0d 00          	cmpb   $0x0,0xd(%ebp)
		CURRENT->bh->b_uptodate = uptodate;				// 置更新标志.
   10afb:	89 f8                	mov    %edi,%eax
   10afd:	88 45 0a             	mov    %al,0xa(%ebp)
	if (!bh->b_lock)
   10b00:	75 12                	jne    10b14 <end_request+0x52>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   10b02:	8d 83 6c 78 ff ff    	lea    -0x8794(%ebx),%eax
   10b08:	83 ec 0c             	sub    $0xc,%esp
   10b0b:	50                   	push   %eax
   10b0c:	e8 10 76 ff ff       	call   8121 <printk>
   10b11:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   10b14:	c6 45 0d 00          	movb   $0x0,0xd(%ebp)
	wake_up(&bh->b_wait);
   10b18:	83 ec 0c             	sub    $0xc,%esp
   10b1b:	83 c5 10             	add    $0x10,%ebp
   10b1e:	55                   	push   %ebp
   10b1f:	e8 6f 63 ff ff       	call   6e93 <wake_up>
   10b24:	83 c4 10             	add    $0x10,%esp
		unlock_buffer(CURRENT->bh);						// 解锁缓冲区.
	}
	if (!uptodate) {									// 若更新标志为0则显示出错信息.
   10b27:	85 ff                	test   %edi,%edi
   10b29:	75 2c                	jne    10b57 <end_request+0x95>
		printk(DEVICE_NAME " I/O error\n\r");
   10b2b:	8d 83 90 78 ff ff    	lea    -0x8770(%ebx),%eax
   10b31:	83 ec 0c             	sub    $0xc,%esp
   10b34:	50                   	push   %eax
   10b35:	e8 e7 75 ff ff       	call   8121 <printk>
		printk("dev %04x, block %d\n\r",CURRENT->dev,
			CURRENT->bh->b_blocknr);
   10b3a:	8b 46 14             	mov    0x14(%esi),%eax
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   10b3d:	83 c4 0c             	add    $0xc,%esp
   10b40:	8b 50 1c             	mov    0x1c(%eax),%edx
   10b43:	ff 72 04             	pushl  0x4(%edx)
   10b46:	ff 30                	pushl  (%eax)
   10b48:	8d 83 a3 78 ff ff    	lea    -0x875d(%ebx),%eax
   10b4e:	50                   	push   %eax
   10b4f:	e8 cd 75 ff ff       	call   8121 <printk>
   10b54:	83 c4 10             	add    $0x10,%esp
	}
	wake_up(&CURRENT->waiting);							// 唤醒等待该请求项的进程.
   10b57:	8b 46 14             	mov    0x14(%esi),%eax
   10b5a:	83 ec 0c             	sub    $0xc,%esp
   10b5d:	83 c0 18             	add    $0x18,%eax
   10b60:	50                   	push   %eax
   10b61:	e8 2d 63 ff ff       	call   6e93 <wake_up>
	wake_up(&wait_for_request);							// 唤醒等待空闲请求项的进程.
   10b66:	58                   	pop    %eax
   10b67:	ff b3 e0 ff ff ff    	pushl  -0x20(%ebx)
   10b6d:	e8 21 63 ff ff       	call   6e93 <wake_up>
	CURRENT->dev = -1;									// 释放该请求项.
   10b72:	8b 46 14             	mov    0x14(%esi),%eax
   10b75:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;							// 指向下一请求项.
   10b7b:	8b 40 20             	mov    0x20(%eax),%eax
   10b7e:	89 46 14             	mov    %eax,0x14(%esi)
}
   10b81:	83 c4 1c             	add    $0x1c,%esp
   10b84:	5b                   	pop    %ebx
   10b85:	5e                   	pop    %esi
   10b86:	5f                   	pop    %edi
   10b87:	5d                   	pop    %ebp
   10b88:	c3                   	ret    

00010b89 <result>:
}

// 读取FDC执行的结果信息.
// 结果信息最多7个字节,存放在数组reply_buffer[]中.返回读入的结果字节数,若返回值=-1,则表示出错.程序处理方式与上面函数类似.
static int result(void)
{
   10b89:	55                   	push   %ebp
   10b8a:	57                   	push   %edi
   10b8b:	56                   	push   %esi
   10b8c:	53                   	push   %ebx
   10b8d:	e8 9a 5e ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10b92:	81 c3 6e 04 01 00    	add    $0x1046e,%ebx
   10b98:	83 ec 0c             	sub    $0xc,%esp
	int i = 0, counter, status;

	// 若复位标志已置位,则立刻退出.去执行后续程序中的复位操作.否则循环读取主状态控制器FD_STATUS(0x3f4)的状态.如果读取的控制器状态
	// 是READY,表示已经没有数据可取,则返回已读取的字节数i.如果控制器状态是方向标志置位(CPU <-FDC),已准备好,忙,表示有数据可读取.
	// 于是把控制器中的结果数据读入到应答结果数组中.最多读取MAX_REPLIES(7)个字节.
	if (reset)
   10b9b:	8b 8b 9c 40 00 00    	mov    0x409c(%ebx),%ecx
   10ba1:	85 c9                	test   %ecx,%ecx
   10ba3:	75 54                	jne    10bf9 <result+0x70>
   10ba5:	be 10 27 00 00       	mov    $0x2710,%esi
		return -1;
	for (counter = 0 ; counter < 10000 ; counter++) {
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   10baa:	bf f4 03 00 00       	mov    $0x3f4,%edi
		if (status == STATUS_READY)
			return i;
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
			if (i >= MAX_REPLIES)
				break;
			reply_buffer[i++] = inb_p(FD_DATA);
   10baf:	bd f5 03 00 00       	mov    $0x3f5,%ebp
		status = inb_p(FD_STATUS)&(STATUS_DIR|STATUS_READY|STATUS_BUSY);
   10bb4:	89 fa                	mov    %edi,%edx
   10bb6:	ec                   	in     (%dx),%al
   10bb7:	eb 00                	jmp    10bb9 <result+0x30>
   10bb9:	eb 00                	jmp    10bbb <result+0x32>
   10bbb:	83 e0 d0             	and    $0xffffffd0,%eax
		if (status == STATUS_READY)
   10bbe:	3c 80                	cmp    $0x80,%al
   10bc0:	74 3a                	je     10bfc <result+0x73>
		if (status == (STATUS_DIR|STATUS_READY|STATUS_BUSY)) {
   10bc2:	3c d0                	cmp    $0xd0,%al
   10bc4:	75 14                	jne    10bda <result+0x51>
			if (i >= MAX_REPLIES)
   10bc6:	83 f9 06             	cmp    $0x6,%ecx
   10bc9:	7f 12                	jg     10bdd <result+0x54>
			reply_buffer[i++] = inb_p(FD_DATA);
   10bcb:	89 ea                	mov    %ebp,%edx
   10bcd:	ec                   	in     (%dx),%al
   10bce:	eb 00                	jmp    10bd0 <result+0x47>
   10bd0:	eb 00                	jmp    10bd2 <result+0x49>
   10bd2:	88 84 0b 90 40 00 00 	mov    %al,0x4090(%ebx,%ecx,1)
   10bd9:	41                   	inc    %ecx
	for (counter = 0 ; counter < 10000 ; counter++) {
   10bda:	4e                   	dec    %esi
   10bdb:	75 d7                	jne    10bb4 <result+0x2b>
		}
	}
	// 如果到循环1万次结束还不能发送,则置复位标志,并打印出错信息.
	reset = 1;
	printk("Getstatus times out\n\r");
   10bdd:	8d 83 b8 78 ff ff    	lea    -0x8748(%ebx),%eax
   10be3:	83 ec 0c             	sub    $0xc,%esp
	reset = 1;
   10be6:	c7 83 9c 40 00 00 01 	movl   $0x1,0x409c(%ebx)
   10bed:	00 00 00 
	printk("Getstatus times out\n\r");
   10bf0:	50                   	push   %eax
   10bf1:	e8 2b 75 ff ff       	call   8121 <printk>
   10bf6:	83 c4 10             	add    $0x10,%esp
		return -1;
   10bf9:	83 c9 ff             	or     $0xffffffff,%ecx
	return -1;
}
   10bfc:	83 c4 0c             	add    $0xc,%esp
   10bff:	89 c8                	mov    %ecx,%eax
   10c01:	5b                   	pop    %ebx
   10c02:	5e                   	pop    %esi
   10c03:	5f                   	pop    %edi
   10c04:	5d                   	pop    %ebp
   10c05:	c3                   	ret    

00010c06 <output_byte>:
{
   10c06:	56                   	push   %esi
   10c07:	53                   	push   %ebx
   10c08:	e8 1f 5e ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10c0d:	81 c3 f3 03 01 00    	add    $0x103f3,%ebx
   10c13:	52                   	push   %edx
	if (reset)
   10c14:	83 bb 9c 40 00 00 00 	cmpl   $0x0,0x409c(%ebx)
   10c1b:	75 41                	jne    10c5e <output_byte+0x58>
   10c1d:	89 c6                	mov    %eax,%esi
   10c1f:	b9 10 27 00 00       	mov    $0x2710,%ecx
		status = inb_p(FD_STATUS) & (STATUS_READY | STATUS_DIR);
   10c24:	ba f4 03 00 00       	mov    $0x3f4,%edx
   10c29:	ec                   	in     (%dx),%al
   10c2a:	eb 00                	jmp    10c2c <output_byte+0x26>
   10c2c:	eb 00                	jmp    10c2e <output_byte+0x28>
   10c2e:	83 e0 c0             	and    $0xffffffc0,%eax
		if (status == STATUS_READY) {
   10c31:	3c 80                	cmp    $0x80,%al
   10c33:	75 0a                	jne    10c3f <output_byte+0x39>
			outb(byte,FD_DATA);
   10c35:	ba f5 03 00 00       	mov    $0x3f5,%edx
   10c3a:	89 f0                	mov    %esi,%eax
   10c3c:	ee                   	out    %al,(%dx)
			return;
   10c3d:	eb 1f                	jmp    10c5e <output_byte+0x58>
	for(counter = 0 ; counter < 10000 ; counter++) {
   10c3f:	49                   	dec    %ecx
   10c40:	75 e7                	jne    10c29 <output_byte+0x23>
	printk("Unable to send byte to FDC\n\r");
   10c42:	8d 83 ce 78 ff ff    	lea    -0x8732(%ebx),%eax
   10c48:	83 ec 0c             	sub    $0xc,%esp
	reset = 1;
   10c4b:	c7 83 9c 40 00 00 01 	movl   $0x1,0x409c(%ebx)
   10c52:	00 00 00 
	printk("Unable to send byte to FDC\n\r");
   10c55:	50                   	push   %eax
   10c56:	e8 c6 74 ff ff       	call   8121 <printk>
   10c5b:	83 c4 10             	add    $0x10,%esp
}
   10c5e:	58                   	pop    %eax
   10c5f:	5b                   	pop    %ebx
   10c60:	5e                   	pop    %esi
   10c61:	c3                   	ret    

00010c62 <do_fd_request>:

// 软盘读写请求项处理函数
// 该函数是软盘驱动程序中最主要的函数.主要作用是:1处理有复位标志或重新校正标志置位情况;2利用请求项中的设备号计算取得请求项指定软驱的
// 参数块;3利用内核定时器启动软盘读/写操作.
void do_fd_request(void)
{
   10c62:	55                   	push   %ebp
   10c63:	57                   	push   %edi
   10c64:	56                   	push   %esi
   10c65:	53                   	push   %ebx
   10c66:	e8 c1 5d ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10c6b:	81 c3 95 03 01 00    	add    $0x10395,%ebx
   10c71:	83 ec 0c             	sub    $0xc,%esp
	unsigned int block;

	// 首先检查是否有复位标志或重校正标志置位,若有则本函数仅执行相关标志的处理功能后就返回.如果复位标志已置位,则执行软盘复位操作并返回.
	// 如果重新校正标志已置位,则执行软盘重新校正操作并返回.
	seek = 0;										// 清寻道标志.
	if (reset) {									// 复位标志已置位.
   10c74:	83 bb 9c 40 00 00 00 	cmpl   $0x0,0x409c(%ebx)
	seek = 0;										// 清寻道标志.
   10c7b:	c7 83 98 40 00 00 00 	movl   $0x0,0x4098(%ebx)
   10c82:	00 00 00 
	if (reset) {									// 复位标志已置位.
   10c85:	74 74                	je     10cfb <do_fd_request+0x99>
	printk("Reset-floppy called\n\r");				// 显示执行软盘复位操作信息.
   10c87:	8d 83 eb 78 ff ff    	lea    -0x8715(%ebx),%eax
   10c8d:	83 ec 0c             	sub    $0xc,%esp
	reset = 0;										// 复位标志置0.
   10c90:	c7 83 9c 40 00 00 00 	movl   $0x0,0x409c(%ebx)
   10c97:	00 00 00 
	cur_spec1 = -1;									// 使无效.
   10c9a:	c7 83 08 14 00 00 ff 	movl   $0xffffffff,0x1408(%ebx)
   10ca1:	ff ff ff 
	cur_rate = -1;
   10ca4:	c7 83 04 14 00 00 ff 	movl   $0xffffffff,0x1404(%ebx)
   10cab:	ff ff ff 
	printk("Reset-floppy called\n\r");				// 显示执行软盘复位操作信息.
   10cae:	50                   	push   %eax
	recalibrate = 1;								// 重新校正标志置位.
   10caf:	c7 83 a0 40 00 00 01 	movl   $0x1,0x40a0(%ebx)
   10cb6:	00 00 00 
	printk("Reset-floppy called\n\r");				// 显示执行软盘复位操作信息.
   10cb9:	e8 63 74 ff ff       	call   8121 <printk>
	cli();											// 关中断.
   10cbe:	fa                   	cli    
	outb_p(current_DOR & ~0x04,FD_DOR);				// 对软盘控制器FDC执行复位操作.
   10cbf:	c7 c1 60 10 02 00    	mov    $0x21060,%ecx
	do_floppy = reset_interrupt;					// 设置在中断处理程序中调用的函数.
   10cc5:	8d 83 a5 fe fe ff    	lea    -0x1015b(%ebx),%eax
	outb_p(current_DOR & ~0x04,FD_DOR);				// 对软盘控制器FDC执行复位操作.
   10ccb:	ba f2 03 00 00       	mov    $0x3f2,%edx
	do_floppy = reset_interrupt;					// 设置在中断处理程序中调用的函数.
   10cd0:	89 83 84 40 00 00    	mov    %eax,0x4084(%ebx)
	outb_p(current_DOR & ~0x04,FD_DOR);				// 对软盘控制器FDC执行复位操作.
   10cd6:	0f b6 01             	movzbl (%ecx),%eax
   10cd9:	83 e0 fb             	and    $0xfffffffb,%eax
   10cdc:	ee                   	out    %al,(%dx)
   10cdd:	eb 00                	jmp    10cdf <do_fd_request+0x7d>
   10cdf:	eb 00                	jmp    10ce1 <do_fd_request+0x7f>
   10ce1:	b8 64 00 00 00       	mov    $0x64,%eax
   10ce6:	83 c4 10             	add    $0x10,%esp
		__asm__("nop");
   10ce9:	90                   	nop
	for (i = 0 ; i < 100 ; i++)						// 空操作,延迟.
   10cea:	48                   	dec    %eax
   10ceb:	75 fc                	jne    10ce9 <do_fd_request+0x87>
	outb(current_DOR,FD_DOR);						// 再启动软盘控制器.
   10ced:	8a 01                	mov    (%ecx),%al
   10cef:	ba f2 03 00 00       	mov    $0x3f2,%edx
   10cf4:	ee                   	out    %al,(%dx)
	sti();											// 开中断.
   10cf5:	fb                   	sti    
   10cf6:	e9 a2 01 00 00       	jmp    10e9d <do_fd_request+0x23b>
		reset_floppy();
		return;
	}
	if (recalibrate) {								// 重新校正标志已置位.
   10cfb:	83 bb a0 40 00 00 00 	cmpl   $0x0,0x40a0(%ebx)
   10d02:	0f 85 49 01 00 00    	jne    10e51 <do_fd_request+0x1ef>
		return;
	}
	// 本函数的真正功能从这里开始.首先利用blk.h文件中的INIT_REQUEST宏来检测请求项的合法性,如果已没有请求项则退出.然后利用请求项中的设备
	// 号取得请求项指定软驱的参数块.这个参数块将在下面用于设置软盘操作使用的全局变量参数块.请求项设备号中的软盘类型(MINOR(CURRENT->dev)>>2)
	// 被用作磁盘类型数组floppy_type[]的索引值来取得指定软驱的参数块.
	INIT_REQUEST;
   10d08:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   10d0e:	8b 46 14             	mov    0x14(%esi),%eax
   10d11:	85 c0                	test   %eax,%eax
   10d13:	75 0f                	jne    10d24 <do_fd_request+0xc2>
   10d15:	c7 83 84 40 00 00 00 	movl   $0x0,0x4084(%ebx)
   10d1c:	00 00 00 
   10d1f:	e9 79 01 00 00       	jmp    10e9d <do_fd_request+0x23b>
   10d24:	8b 00                	mov    (%eax),%eax
   10d26:	c1 e8 08             	shr    $0x8,%eax
   10d29:	83 f8 02             	cmp    $0x2,%eax
   10d2c:	74 12                	je     10d40 <do_fd_request+0xde>
   10d2e:	8d 83 01 79 ff ff    	lea    -0x86ff(%ebx),%eax
   10d34:	83 ec 0c             	sub    $0xc,%esp
   10d37:	50                   	push   %eax
   10d38:	e8 95 73 ff ff       	call   80d2 <panic>
   10d3d:	83 c4 10             	add    $0x10,%esp
   10d40:	8b 46 14             	mov    0x14(%esi),%eax
   10d43:	8b 40 1c             	mov    0x1c(%eax),%eax
   10d46:	85 c0                	test   %eax,%eax
   10d48:	74 18                	je     10d62 <do_fd_request+0x100>
   10d4a:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   10d4e:	75 12                	jne    10d62 <do_fd_request+0x100>
   10d50:	8d 83 20 79 ff ff    	lea    -0x86e0(%ebx),%eax
   10d56:	83 ec 0c             	sub    $0xc,%esp
   10d59:	50                   	push   %eax
   10d5a:	e8 73 73 ff ff       	call   80d2 <panic>
   10d5f:	83 c4 10             	add    $0x10,%esp
	floppy = (MINOR(CURRENT->dev) >> 2) + floppy_type;
   10d62:	8b 7e 14             	mov    0x14(%esi),%edi
	// 下面开始设置全局变量值.如果当前驱动器号current_drive不是请求项中指定的驱动器号,则置标志seek,表示在执行读/写操作之前需要先让驱动
	// 器执行寻道处理.然后把当前驱动器号设置为请求项中指定的驱动器号.
	if (current_drive != CURRENT_DEV)				// CURRENT_DEV是请求项中指定的软驱号.
   10d65:	0f b6 ab 8d 40 00 00 	movzbl 0x408d(%ebx),%ebp
	floppy = (MINOR(CURRENT->dev) >> 2) + floppy_type;
   10d6c:	8b 07                	mov    (%edi),%eax
   10d6e:	89 c2                	mov    %eax,%edx
   10d70:	c1 fa 02             	sar    $0x2,%edx
   10d73:	83 e2 3f             	and    $0x3f,%edx
   10d76:	6b d2 18             	imul   $0x18,%edx,%edx
   10d79:	8d 8c 13 20 14 00 00 	lea    0x1420(%ebx,%edx,1),%ecx
	if (current_drive != CURRENT_DEV)				// CURRENT_DEV是请求项中指定的软驱号.
   10d80:	89 c2                	mov    %eax,%edx
   10d82:	83 e2 03             	and    $0x3,%edx
   10d85:	39 d5                	cmp    %edx,%ebp
	floppy = (MINOR(CURRENT->dev) >> 2) + floppy_type;
   10d87:	89 8b e0 14 00 00    	mov    %ecx,0x14e0(%ebx)
	if (current_drive != CURRENT_DEV)				// CURRENT_DEV是请求项中指定的软驱号.
   10d8d:	74 0a                	je     10d99 <do_fd_request+0x137>
		seek = 1;
   10d8f:	c7 83 98 40 00 00 01 	movl   $0x1,0x4098(%ebx)
   10d96:	00 00 00 
	current_drive = CURRENT_DEV;
   10d99:	83 e0 03             	and    $0x3,%eax
   10d9c:	88 83 8d 40 00 00    	mov    %al,0x408d(%ebx)
	// 设置读写起始扇区block.因为每次读写是以块为单位(1块为2个扇区),所以起始扇区需要起码比磁盘总扇区数小2个扇区.否则说明这个请求 参数无效,
	// 结束该次软盘请求项去执行下一个请求项.
	block = CURRENT->sector;						// 取当前软盘请求项中起始扇区号.
   10da2:	8b 47 0c             	mov    0xc(%edi),%eax
	if (block + 2 > floppy->size) {					// 如果block + 2大于磁盘扇区总数,则结束本人软盘请求项.
   10da5:	8d 50 02             	lea    0x2(%eax),%edx
   10da8:	3b 11                	cmp    (%ecx),%edx
   10daa:	76 0c                	jbe    10db8 <do_fd_request+0x156>
		end_request(0);
   10dac:	31 c0                	xor    %eax,%eax
   10dae:	e8 0f fd ff ff       	call   10ac2 <end_request>
   10db3:	e9 56 ff ff ff       	jmp    10d0e <do_fd_request+0xac>
   10db8:	31 d2                	xor    %edx,%edx
   10dba:	f7 71 04             	divl   0x4(%ecx)
   10dbd:	89 d6                	mov    %edx,%esi
		goto repeat;
	}
	// 再求对应在磁道上的扇区号,磁头号,磁道号,搜寻磁道号(对于软驱读不同格式的盘).
	sector = block % floppy->sect;					// 起始扇区对每磁道扇区数取模,得磁道上扇区号.
   10dbf:	88 93 8c 40 00 00    	mov    %dl,0x408c(%ebx)
   10dc5:	31 d2                	xor    %edx,%edx
   10dc7:	f7 71 08             	divl   0x8(%ecx)
	block /= floppy->sect;							// 起始扇区对每磁道扇区数取整,得起始磁道数.
	head = block % floppy->head;					// 起始磁道数对磁头数取模,得操作的磁头号.
	track = block / floppy->head;					// 起始磁道数对磁头数取整,得操作的磁道号.
	seek_track = track << floppy->stretch;			// 相应于软驱中盘类型进行调整,得寻道号.
   10dca:	8b 49 10             	mov    0x10(%ecx),%ecx
	track = block / floppy->head;					// 起始磁道数对磁头数取整,得操作的磁道号.
   10dcd:	88 83 8a 40 00 00    	mov    %al,0x408a(%ebx)
	seek_track = track << floppy->stretch;			// 相应于软驱中盘类型进行调整,得寻道号.
   10dd3:	0f b6 c0             	movzbl %al,%eax
	head = block % floppy->head;					// 起始磁道数对磁头数取模,得操作的磁头号.
   10dd6:	88 93 8b 40 00 00    	mov    %dl,0x408b(%ebx)
	seek_track = track << floppy->stretch;			// 相应于软驱中盘类型进行调整,得寻道号.
   10ddc:	d3 e0                	shl    %cl,%eax
	// 再看看是否还需要首先执行寻道操作.如果寻道号与当前磁头所在磁道号不同,则需要进行寻道操作,于是置需要寻道标志seek.最后我们设置执行的软盘
	// 命令command.
	if (seek_track != current_track)
   10dde:	3a 83 00 14 00 00    	cmp    0x1400(%ebx),%al
	seek_track = track << floppy->stretch;			// 相应于软驱中盘类型进行调整,得寻道号.
   10de4:	88 83 89 40 00 00    	mov    %al,0x4089(%ebx)
	if (seek_track != current_track)
   10dea:	74 0a                	je     10df6 <do_fd_request+0x194>
		seek = 1;
   10dec:	c7 83 98 40 00 00 01 	movl   $0x1,0x4098(%ebx)
   10df3:	00 00 00 
	sector++;										// 磁盘上实际扇区计数是从1算起.
   10df6:	8d 46 01             	lea    0x1(%esi),%eax
   10df9:	88 83 8c 40 00 00    	mov    %al,0x408c(%ebx)
	if (CURRENT->cmd == READ)						// 如果请求项是读操作,则置读命令码.
   10dff:	8b 47 04             	mov    0x4(%edi),%eax
   10e02:	85 c0                	test   %eax,%eax
   10e04:	75 09                	jne    10e0f <do_fd_request+0x1ad>
		command = FD_READ;
   10e06:	c6 83 88 40 00 00 e6 	movb   $0xe6,0x4088(%ebx)
   10e0d:	eb 1e                	jmp    10e2d <do_fd_request+0x1cb>
	else if (CURRENT->cmd == WRITE)					// 如果请求项是写操作,则置写命令码.
   10e0f:	48                   	dec    %eax
   10e10:	75 09                	jne    10e1b <do_fd_request+0x1b9>
		command = FD_WRITE;
   10e12:	c6 83 88 40 00 00 c5 	movb   $0xc5,0x4088(%ebx)
   10e19:	eb 12                	jmp    10e2d <do_fd_request+0x1cb>
	else
		panic("do_fd_request: unknown command");
   10e1b:	8d 83 39 79 ff ff    	lea    -0x86c7(%ebx),%eax
   10e21:	83 ec 0c             	sub    $0xc,%esp
   10e24:	50                   	push   %eax
   10e25:	e8 a8 72 ff ff       	call   80d2 <panic>
   10e2a:	83 c4 10             	add    $0x10,%esp
	// 在上面设置好所有全局变量值之后,我们可以开始执行请求项操作了.该操作利用定时器来启动.因为为了能对软驱进行读写操作,需要首先启动驱动器马达
	// 并达到正常运转速度.而这需要一定的时间.因此这里利用ticks_to_floppy_on()来计算启动延时时间,然后使用该延时设定一个定时器.当时间到时就调用
	// 函数floppy_on_interrupt().
	add_timer(ticks_to_floppy_on(current_drive), &floppy_on_interrupt);
   10e2d:	0f b6 83 8d 40 00 00 	movzbl 0x408d(%ebx),%eax
   10e34:	83 ec 0c             	sub    $0xc,%esp
   10e37:	50                   	push   %eax
   10e38:	e8 ae 60 ff ff       	call   6eeb <ticks_to_floppy_on>
   10e3d:	5a                   	pop    %edx
   10e3e:	8d 93 42 03 ff ff    	lea    -0xfcbe(%ebx),%edx
   10e44:	59                   	pop    %ecx
   10e45:	52                   	push   %edx
   10e46:	50                   	push   %eax
   10e47:	e8 0c 62 ff ff       	call   7058 <add_timer>
   10e4c:	83 c4 10             	add    $0x10,%esp
   10e4f:	eb 4c                	jmp    10e9d <do_fd_request+0x23b>
	do_floppy = recal_interrupt;					// 指向重新校正中断调用的C函数.
   10e51:	8d 83 ec fe fe ff    	lea    -0x10114(%ebx),%eax
	recalibrate = 0;								// 复位重新校正标志.
   10e57:	c7 83 a0 40 00 00 00 	movl   $0x0,0x40a0(%ebx)
   10e5e:	00 00 00 
	current_track = 0;								// 当前磁道号归零.
   10e61:	c6 83 00 14 00 00 00 	movb   $0x0,0x1400(%ebx)
	do_floppy = recal_interrupt;					// 指向重新校正中断调用的C函数.
   10e68:	89 83 84 40 00 00    	mov    %eax,0x4084(%ebx)
	output_byte(FD_RECALIBRATE);					// 命令:重新校正.
   10e6e:	b8 07 00 00 00       	mov    $0x7,%eax
   10e73:	e8 8e fd ff ff       	call   10c06 <output_byte>
	output_byte(head<<2 | current_drive);			// 参数:磁头号 + 当前驱动器号.
   10e78:	0f b6 83 8b 40 00 00 	movzbl 0x408b(%ebx),%eax
   10e7f:	c1 e0 02             	shl    $0x2,%eax
   10e82:	0a 83 8d 40 00 00    	or     0x408d(%ebx),%al
   10e88:	0f be c0             	movsbl %al,%eax
   10e8b:	e8 76 fd ff ff       	call   10c06 <output_byte>
	if (reset)
   10e90:	83 bb 9c 40 00 00 00 	cmpl   $0x0,0x409c(%ebx)
   10e97:	0f 85 d7 fd ff ff    	jne    10c74 <do_fd_request+0x12>
}
   10e9d:	83 c4 0c             	add    $0xc,%esp
   10ea0:	5b                   	pop    %ebx
   10ea1:	5e                   	pop    %esi
   10ea2:	5f                   	pop    %edi
   10ea3:	5d                   	pop    %ebp
   10ea4:	c3                   	ret    

00010ea5 <reset_interrupt>:
{
   10ea5:	53                   	push   %ebx
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   10ea6:	b8 08 00 00 00       	mov    $0x8,%eax
   10eab:	e8 7c 5b ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10eb0:	81 c3 50 01 01 00    	add    $0x10150,%ebx
{
   10eb6:	83 ec 08             	sub    $0x8,%esp
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   10eb9:	e8 48 fd ff ff       	call   10c06 <output_byte>
	(void) result();								// 读取命令执行结果字节.
   10ebe:	e8 c6 fc ff ff       	call   10b89 <result>
	output_byte(FD_SPECIFY);						// 发送设定软驱参数命令.
   10ec3:	b8 03 00 00 00       	mov    $0x3,%eax
   10ec8:	e8 39 fd ff ff       	call   10c06 <output_byte>
	output_byte(cur_spec1);							/* hut etc */	// 发送参数
   10ecd:	0f be 83 08 14 00 00 	movsbl 0x1408(%ebx),%eax
   10ed4:	e8 2d fd ff ff       	call   10c06 <output_byte>
	output_byte(6);									/* Head load time =6ms, DMA */
   10ed9:	b8 06 00 00 00       	mov    $0x6,%eax
   10ede:	e8 23 fd ff ff       	call   10c06 <output_byte>
}
   10ee3:	83 c4 08             	add    $0x8,%esp
   10ee6:	5b                   	pop    %ebx
	do_fd_request();                				// 调用执行软盘请求.
   10ee7:	e9 76 fd ff ff       	jmp    10c62 <do_fd_request>

00010eec <recal_interrupt>:
{
   10eec:	53                   	push   %ebx
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   10eed:	b8 08 00 00 00       	mov    $0x8,%eax
   10ef2:	e8 35 5b ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10ef7:	81 c3 09 01 01 00    	add    $0x10109,%ebx
{
   10efd:	83 ec 08             	sub    $0x8,%esp
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   10f00:	e8 01 fd ff ff       	call   10c06 <output_byte>
	if (result() != 2 || (ST0 & 0xE0) == 0x60)		// 如果返回结果字节数不等于2或命令异常结束,则置复位标志.
   10f05:	e8 7f fc ff ff       	call   10b89 <result>
   10f0a:	83 f8 02             	cmp    $0x2,%eax
   10f0d:	75 0d                	jne    10f1c <recal_interrupt+0x30>
   10f0f:	8a 83 90 40 00 00    	mov    0x4090(%ebx),%al
   10f15:	83 e0 e0             	and    $0xffffffe0,%eax
   10f18:	3c 60                	cmp    $0x60,%al
   10f1a:	75 0c                	jne    10f28 <recal_interrupt+0x3c>
		reset = 1;
   10f1c:	c7 83 9c 40 00 00 01 	movl   $0x1,0x409c(%ebx)
   10f23:	00 00 00 
   10f26:	eb 0a                	jmp    10f32 <recal_interrupt+0x46>
		recalibrate = 0;							// 否则复位重新校正标志
   10f28:	c7 83 a0 40 00 00 00 	movl   $0x0,0x40a0(%ebx)
   10f2f:	00 00 00 
}
   10f32:	83 c4 08             	add    $0x8,%esp
   10f35:	5b                   	pop    %ebx
	do_fd_request();								// 作相应处理.
   10f36:	e9 27 fd ff ff       	jmp    10c62 <do_fd_request>

00010f3b <floppy_deselect>:
{
   10f3b:	53                   	push   %ebx
   10f3c:	e8 eb 5a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10f41:	81 c3 bf 00 01 00    	add    $0x100bf,%ebx
   10f47:	83 ec 08             	sub    $0x8,%esp
	if (nr != (current_DOR & 3))
   10f4a:	c7 c0 60 10 02 00    	mov    $0x21060,%eax
   10f50:	8a 00                	mov    (%eax),%al
   10f52:	83 e0 03             	and    $0x3,%eax
   10f55:	3b 44 24 10          	cmp    0x10(%esp),%eax
   10f59:	74 12                	je     10f6d <floppy_deselect+0x32>
		printk("floppy_deselect: drive not selected\n\r");
   10f5b:	8d 83 58 79 ff ff    	lea    -0x86a8(%ebx),%eax
   10f61:	83 ec 0c             	sub    $0xc,%esp
   10f64:	50                   	push   %eax
   10f65:	e8 b7 71 ff ff       	call   8121 <printk>
   10f6a:	83 c4 10             	add    $0x10,%esp
	wake_up(&wait_on_floppy_select);						// 唤醒等待的任务.
   10f6d:	8d 83 7c 40 00 00    	lea    0x407c(%ebx),%eax
   10f73:	83 ec 0c             	sub    $0xc,%esp
	selected = 0;											// 复位软驱已选定标志.
   10f76:	c6 83 80 40 00 00 00 	movb   $0x0,0x4080(%ebx)
	wake_up(&wait_on_floppy_select);						// 唤醒等待的任务.
   10f7d:	50                   	push   %eax
   10f7e:	e8 10 5f ff ff       	call   6e93 <wake_up>
}
   10f83:	83 c4 18             	add    $0x18,%esp
   10f86:	5b                   	pop    %ebx
   10f87:	c3                   	ret    

00010f88 <bad_flp_intr>:
{
   10f88:	56                   	push   %esi
   10f89:	53                   	push   %ebx
   10f8a:	e8 9d 5a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10f8f:	81 c3 71 00 01 00    	add    $0x10071,%ebx
   10f95:	52                   	push   %edx
	CURRENT->errors++;
   10f96:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   10f9c:	8b 56 14             	mov    0x14(%esi),%edx
   10f9f:	8b 42 08             	mov    0x8(%edx),%eax
   10fa2:	40                   	inc    %eax
	if (CURRENT->errors > MAX_ERRORS) {
   10fa3:	83 f8 08             	cmp    $0x8,%eax
	CURRENT->errors++;
   10fa6:	89 42 08             	mov    %eax,0x8(%edx)
	if (CURRENT->errors > MAX_ERRORS) {
   10fa9:	7e 1a                	jle    10fc5 <bad_flp_intr+0x3d>
		floppy_deselect(current_drive);
   10fab:	0f b6 83 8d 40 00 00 	movzbl 0x408d(%ebx),%eax
   10fb2:	83 ec 0c             	sub    $0xc,%esp
   10fb5:	50                   	push   %eax
   10fb6:	e8 80 ff ff ff       	call   10f3b <floppy_deselect>
		end_request(0);
   10fbb:	31 c0                	xor    %eax,%eax
   10fbd:	e8 00 fb ff ff       	call   10ac2 <end_request>
   10fc2:	83 c4 10             	add    $0x10,%esp
	if (CURRENT->errors > MAX_ERRORS / 2)
   10fc5:	8b 46 14             	mov    0x14(%esi),%eax
   10fc8:	83 78 08 04          	cmpl   $0x4,0x8(%eax)
   10fcc:	7e 0c                	jle    10fda <bad_flp_intr+0x52>
		reset = 1;
   10fce:	c7 83 9c 40 00 00 01 	movl   $0x1,0x409c(%ebx)
   10fd5:	00 00 00 
   10fd8:	eb 0a                	jmp    10fe4 <bad_flp_intr+0x5c>
		recalibrate = 1;
   10fda:	c7 83 a0 40 00 00 01 	movl   $0x1,0x40a0(%ebx)
   10fe1:	00 00 00 
}
   10fe4:	58                   	pop    %eax
   10fe5:	5b                   	pop    %ebx
   10fe6:	5e                   	pop    %esi
   10fe7:	c3                   	ret    

00010fe8 <rw_interrupt>:
{
   10fe8:	57                   	push   %edi
   10fe9:	56                   	push   %esi
   10fea:	53                   	push   %ebx
   10feb:	e8 3c 5a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   10ff0:	81 c3 10 00 01 00    	add    $0x10010,%ebx
	if (result() != 7 || (ST0 & 0xd8) || (ST1 & 0xbf) || (ST2 & 0x73)) {    // 把0xf8修改0xd8
   10ff6:	e8 8e fb ff ff       	call   10b89 <result>
   10ffb:	83 f8 07             	cmp    $0x7,%eax
   10ffe:	8a 83 91 40 00 00    	mov    0x4091(%ebx),%al
   11004:	75 16                	jne    1101c <rw_interrupt+0x34>
   11006:	f6 83 90 40 00 00 d8 	testb  $0xd8,0x4090(%ebx)
   1100d:	75 0d                	jne    1101c <rw_interrupt+0x34>
   1100f:	a8 bf                	test   $0xbf,%al
   11011:	75 09                	jne    1101c <rw_interrupt+0x34>
   11013:	f6 83 92 40 00 00 73 	testb  $0x73,0x4092(%ebx)
   1101a:	74 34                	je     11050 <rw_interrupt+0x68>
		if (ST1 & 0x02) {
   1101c:	a8 02                	test   $0x2,%al
   1101e:	74 29                	je     11049 <rw_interrupt+0x61>
			printk("Drive %d is write protected\n\r",current_drive);
   11020:	50                   	push   %eax
   11021:	50                   	push   %eax
   11022:	0f b6 83 8d 40 00 00 	movzbl 0x408d(%ebx),%eax
   11029:	50                   	push   %eax
   1102a:	8d 83 7e 79 ff ff    	lea    -0x8682(%ebx),%eax
   11030:	50                   	push   %eax
   11031:	e8 eb 70 ff ff       	call   8121 <printk>
			floppy_deselect(current_drive);
   11036:	0f b6 83 8d 40 00 00 	movzbl 0x408d(%ebx),%eax
   1103d:	89 04 24             	mov    %eax,(%esp)
   11040:	e8 f6 fe ff ff       	call   10f3b <floppy_deselect>
			end_request(0);
   11045:	31 c0                	xor    %eax,%eax
   11047:	eb 47                	jmp    11090 <rw_interrupt+0xa8>
			bad_flp_intr();
   11049:	e8 3a ff ff ff       	call   10f88 <bad_flp_intr>
   1104e:	eb 48                	jmp    11098 <rw_interrupt+0xb0>
	if (command == FD_READ && (unsigned long)(CURRENT->buffer) >= 0x100000)
   11050:	80 bb 88 40 00 00 e6 	cmpb   $0xe6,0x4088(%ebx)
   11057:	75 22                	jne    1107b <rw_interrupt+0x93>
   11059:	c7 c0 40 50 02 00    	mov    $0x25040,%eax
   1105f:	8b 40 14             	mov    0x14(%eax),%eax
   11062:	8b 78 14             	mov    0x14(%eax),%edi
   11065:	81 ff ff ff 0f 00    	cmp    $0xfffff,%edi
   1106b:	76 0e                	jbe    1107b <rw_interrupt+0x93>
		copy_buffer(tmp_floppy_area,CURRENT->buffer);
   1106d:	b9 00 01 00 00       	mov    $0x100,%ecx
   11072:	c7 c6 d0 52 00 00    	mov    $0x52d0,%esi
   11078:	fc                   	cld    
   11079:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	floppy_deselect(current_drive);
   1107b:	0f b6 83 8d 40 00 00 	movzbl 0x408d(%ebx),%eax
   11082:	83 ec 0c             	sub    $0xc,%esp
   11085:	50                   	push   %eax
   11086:	e8 b0 fe ff ff       	call   10f3b <floppy_deselect>
	end_request(1);
   1108b:	b8 01 00 00 00       	mov    $0x1,%eax
   11090:	e8 2d fa ff ff       	call   10ac2 <end_request>
	do_fd_request();
   11095:	83 c4 10             	add    $0x10,%esp
}
   11098:	5b                   	pop    %ebx
   11099:	5e                   	pop    %esi
   1109a:	5f                   	pop    %edi
	do_fd_request();
   1109b:	e9 c2 fb ff ff       	jmp    10c62 <do_fd_request>

000110a0 <floppy_change>:
{
   110a0:	57                   	push   %edi
   110a1:	56                   	push   %esi
   110a2:	53                   	push   %ebx
   110a3:	8b 74 24 10          	mov    0x10(%esp),%esi
   110a7:	e8 80 59 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   110ac:	81 c3 54 ff 00 00    	add    $0xff54,%ebx
	while ((current_DOR & 3) != nr && selected)
   110b2:	c7 c7 60 10 02 00    	mov    $0x21060,%edi
	floppy_on(nr);										// 启动并等待指定软驱nr(kernel/sched.c)
   110b8:	83 ec 0c             	sub    $0xc,%esp
   110bb:	56                   	push   %esi
   110bc:	e8 bf 5e ff ff       	call   6f80 <floppy_on>
	while ((current_DOR & 3) != nr && selected)
   110c1:	8a 07                	mov    (%edi),%al
		sleep_on(&wait_on_floppy_select);
   110c3:	83 c4 10             	add    $0x10,%esp
	while ((current_DOR & 3) != nr && selected)
   110c6:	83 e0 03             	and    $0x3,%eax
   110c9:	39 f0                	cmp    %esi,%eax
   110cb:	74 1a                	je     110e7 <floppy_change+0x47>
   110cd:	80 bb 80 40 00 00 00 	cmpb   $0x0,0x4080(%ebx)
   110d4:	74 e2                	je     110b8 <floppy_change+0x18>
		sleep_on(&wait_on_floppy_select);
   110d6:	8d 83 7c 40 00 00    	lea    0x407c(%ebx),%eax
   110dc:	83 ec 0c             	sub    $0xc,%esp
   110df:	50                   	push   %eax
   110e0:	e8 a0 5d ff ff       	call   6e85 <sleep_on>
   110e5:	eb da                	jmp    110c1 <floppy_change+0x21>
	if (inb(FD_DIR) & 0x80) {
   110e7:	ba f7 03 00 00       	mov    $0x3f7,%edx
   110ec:	ec                   	in     (%dx),%al
   110ed:	84 c0                	test   %al,%al
   110ef:	79 13                	jns    11104 <floppy_change+0x64>
		floppy_off(nr);
   110f1:	83 ec 0c             	sub    $0xc,%esp
   110f4:	56                   	push   %esi
   110f5:	e8 c2 5e ff ff       	call   6fbc <floppy_off>
		return 1;
   110fa:	83 c4 10             	add    $0x10,%esp
   110fd:	b8 01 00 00 00       	mov    $0x1,%eax
   11102:	eb 0e                	jmp    11112 <floppy_change+0x72>
	floppy_off(nr);
   11104:	83 ec 0c             	sub    $0xc,%esp
   11107:	56                   	push   %esi
   11108:	e8 af 5e ff ff       	call   6fbc <floppy_off>
	return 0;
   1110d:	83 c4 10             	add    $0x10,%esp
   11110:	31 c0                	xor    %eax,%eax
}
   11112:	5b                   	pop    %ebx
   11113:	5e                   	pop    %esi
   11114:	5f                   	pop    %edi
   11115:	c3                   	ret    

00011116 <setup_rw_floppy>:
{
   11116:	57                   	push   %edi
   11117:	56                   	push   %esi
   11118:	53                   	push   %ebx
   11119:	e8 0e 59 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1111e:	81 c3 e2 fe 00 00    	add    $0xfee2,%ebx
	long addr = (long) CURRENT->buffer;				// 当前请求项缓冲区所处内存地址.
   11124:	c7 c0 40 50 02 00    	mov    $0x25040,%eax
   1112a:	8b 40 14             	mov    0x14(%eax),%eax
   1112d:	8b 70 14             	mov    0x14(%eax),%esi
	cli();
   11130:	fa                   	cli    
	if (addr >= 0x100000) {
   11131:	81 fe ff ff 0f 00    	cmp    $0xfffff,%esi
   11137:	8a 93 88 40 00 00    	mov    0x4088(%ebx),%dl
   1113d:	89 f7                	mov    %esi,%edi
   1113f:	7e 13                	jle    11154 <setup_rw_floppy+0x3e>
		if (command == FD_WRITE)
   11141:	80 fa c5             	cmp    $0xc5,%dl
		addr = (long) tmp_floppy_area;
   11144:	c7 c7 d0 52 00 00    	mov    $0x52d0,%edi
		if (command == FD_WRITE)
   1114a:	75 08                	jne    11154 <setup_rw_floppy+0x3e>
			copy_buffer(CURRENT->buffer,tmp_floppy_area);
   1114c:	b9 00 01 00 00       	mov    $0x100,%ecx
   11151:	fc                   	cld    
   11152:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	immoutb_p(4 | 2,10);
   11154:	b0 06                	mov    $0x6,%al
   11156:	e6 0a                	out    %al,$0xa
   11158:	eb 00                	jmp    1115a <setup_rw_floppy+0x44>
   1115a:	eb 00                	jmp    1115c <setup_rw_floppy+0x46>
	"a" ((char) ((command == FD_READ)?DMA_READ:DMA_WRITE)));
   1115c:	80 fa e6             	cmp    $0xe6,%dl
   1115f:	0f 95 c0             	setne  %al
   11162:	8d 04 85 46 00 00 00 	lea    0x46(,%eax,4),%eax
 	__asm__("outb %%al,$12\n\tjmp 1f\n1:\tjmp 1f\n1:\t"
   11169:	e6 0c                	out    %al,$0xc
   1116b:	eb 00                	jmp    1116d <setup_rw_floppy+0x57>
   1116d:	eb 00                	jmp    1116f <setup_rw_floppy+0x59>
   1116f:	e6 0b                	out    %al,$0xb
   11171:	eb 00                	jmp    11173 <setup_rw_floppy+0x5d>
   11173:	eb 00                	jmp    11175 <setup_rw_floppy+0x5f>
	immoutb_p(addr, 4);
   11175:	89 f8                	mov    %edi,%eax
   11177:	e6 04                	out    %al,$0x4
   11179:	eb 00                	jmp    1117b <setup_rw_floppy+0x65>
   1117b:	eb 00                	jmp    1117d <setup_rw_floppy+0x67>
	addr >>= 8;
   1117d:	89 f8                	mov    %edi,%eax
   1117f:	c1 f8 08             	sar    $0x8,%eax
	immoutb_p(addr, 4);
   11182:	e6 04                	out    %al,$0x4
   11184:	eb 00                	jmp    11186 <setup_rw_floppy+0x70>
   11186:	eb 00                	jmp    11188 <setup_rw_floppy+0x72>
	addr >>= 8;
   11188:	89 f8                	mov    %edi,%eax
   1118a:	c1 f8 10             	sar    $0x10,%eax
	immoutb_p(addr, 0x81);
   1118d:	e6 81                	out    %al,$0x81
   1118f:	eb 00                	jmp    11191 <setup_rw_floppy+0x7b>
   11191:	eb 00                	jmp    11193 <setup_rw_floppy+0x7d>
	immoutb_p(0xff, 5);
   11193:	b0 ff                	mov    $0xff,%al
   11195:	e6 05                	out    %al,$0x5
   11197:	eb 00                	jmp    11199 <setup_rw_floppy+0x83>
   11199:	eb 00                	jmp    1119b <setup_rw_floppy+0x85>
	immoutb_p(3, 5);
   1119b:	b0 03                	mov    $0x3,%al
   1119d:	e6 05                	out    %al,$0x5
   1119f:	eb 00                	jmp    111a1 <setup_rw_floppy+0x8b>
   111a1:	eb 00                	jmp    111a3 <setup_rw_floppy+0x8d>
	immoutb_p(0 | 2, 10);
   111a3:	b0 02                	mov    $0x2,%al
   111a5:	e6 0a                	out    %al,$0xa
   111a7:	eb 00                	jmp    111a9 <setup_rw_floppy+0x93>
   111a9:	eb 00                	jmp    111ab <setup_rw_floppy+0x95>
	sti();
   111ab:	fb                   	sti    
	do_floppy = rw_interrupt;							// 置软盘中断调用函数指针.
   111ac:	8d 83 e8 ff fe ff    	lea    -0x10018(%ebx),%eax
   111b2:	89 83 84 40 00 00    	mov    %eax,0x4084(%ebx)
	output_byte(command);								// 发送命令字节.
   111b8:	0f be c2             	movsbl %dl,%eax
   111bb:	e8 46 fa ff ff       	call   10c06 <output_byte>
	output_byte(head<<2 | current_drive);				// 参数:磁头号 + 驱动器号.
   111c0:	0f b6 83 8b 40 00 00 	movzbl 0x408b(%ebx),%eax
   111c7:	c1 e0 02             	shl    $0x2,%eax
   111ca:	0a 83 8d 40 00 00    	or     0x408d(%ebx),%al
   111d0:	0f be c0             	movsbl %al,%eax
   111d3:	e8 2e fa ff ff       	call   10c06 <output_byte>
	output_byte(track);									// 参数:磁道号.
   111d8:	0f be 83 8a 40 00 00 	movsbl 0x408a(%ebx),%eax
   111df:	e8 22 fa ff ff       	call   10c06 <output_byte>
	output_byte(head);									// 参数:磁头号.
   111e4:	0f be 83 8b 40 00 00 	movsbl 0x408b(%ebx),%eax
   111eb:	e8 16 fa ff ff       	call   10c06 <output_byte>
	output_byte(sector);								// 参数:起始扇区号.
   111f0:	0f be 83 8c 40 00 00 	movsbl 0x408c(%ebx),%eax
   111f7:	e8 0a fa ff ff       	call   10c06 <output_byte>
	output_byte(2);										/* sector size = 512 */	// 参数:(N=2)512字节.
   111fc:	b8 02 00 00 00       	mov    $0x2,%eax
   11201:	e8 00 fa ff ff       	call   10c06 <output_byte>
	output_byte(floppy->sect);							// 参数:每磁道扇区数.
   11206:	8b 83 e0 14 00 00    	mov    0x14e0(%ebx),%eax
   1120c:	0f be 40 04          	movsbl 0x4(%eax),%eax
   11210:	e8 f1 f9 ff ff       	call   10c06 <output_byte>
	output_byte(floppy->gap);							// 参数:扇区间隔长度.
   11215:	8b 83 e0 14 00 00    	mov    0x14e0(%ebx),%eax
   1121b:	0f be 40 14          	movsbl 0x14(%eax),%eax
   1121f:	e8 e2 f9 ff ff       	call   10c06 <output_byte>
	output_byte(0xFF);									/* sector size (0xff when n!=0 ?) */ // 参数:当N=0时,扇区定义的字节长度,这里无用.
   11224:	83 c8 ff             	or     $0xffffffff,%eax
   11227:	e8 da f9 ff ff       	call   10c06 <output_byte>
	if (reset)
   1122c:	83 bb 9c 40 00 00 00 	cmpl   $0x0,0x409c(%ebx)
   11233:	74 08                	je     1123d <setup_rw_floppy+0x127>
}
   11235:	5b                   	pop    %ebx
   11236:	5e                   	pop    %esi
   11237:	5f                   	pop    %edi
		do_fd_request();
   11238:	e9 25 fa ff ff       	jmp    10c62 <do_fd_request>
}
   1123d:	5b                   	pop    %ebx
   1123e:	5e                   	pop    %esi
   1123f:	5f                   	pop    %edi
   11240:	c3                   	ret    

00011241 <transfer>:
{
   11241:	53                   	push   %ebx
   11242:	e8 e5 57 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11247:	81 c3 b9 fd 00 00    	add    $0xfdb9,%ebx
   1124d:	83 ec 08             	sub    $0x8,%esp
	if (cur_spec1 != floppy->spec1) {				// 检测当前参数.
   11250:	8b 83 e0 14 00 00    	mov    0x14e0(%ebx),%eax
   11256:	0f b6 40 16          	movzbl 0x16(%eax),%eax
   1125a:	3b 83 08 14 00 00    	cmp    0x1408(%ebx),%eax
   11260:	74 26                	je     11288 <transfer+0x47>
		cur_spec1 = floppy->spec1;
   11262:	89 83 08 14 00 00    	mov    %eax,0x1408(%ebx)
		output_byte(FD_SPECIFY);					// 发送设置磁盘参数命令.
   11268:	b8 03 00 00 00       	mov    $0x3,%eax
   1126d:	e8 94 f9 ff ff       	call   10c06 <output_byte>
		output_byte(cur_spec1);						/* hut etc */	// 发送参数.
   11272:	0f be 83 08 14 00 00 	movsbl 0x1408(%ebx),%eax
   11279:	e8 88 f9 ff ff       	call   10c06 <output_byte>
		output_byte(6);								/* Head load time =6ms, DMA */
   1127e:	b8 06 00 00 00       	mov    $0x6,%eax
   11283:	e8 7e f9 ff ff       	call   10c06 <output_byte>
	if (cur_rate != floppy->rate)					// 检测当前速率.
   11288:	8b 83 e0 14 00 00    	mov    0x14e0(%ebx),%eax
   1128e:	0f b6 40 15          	movzbl 0x15(%eax),%eax
   11292:	3b 83 04 14 00 00    	cmp    0x1404(%ebx),%eax
   11298:	74 10                	je     112aa <transfer+0x69>
		outb_p(cur_rate = floppy->rate,FD_DCR);
   1129a:	89 83 04 14 00 00    	mov    %eax,0x1404(%ebx)
   112a0:	ba f7 03 00 00       	mov    $0x3f7,%edx
   112a5:	ee                   	out    %al,(%dx)
   112a6:	eb 00                	jmp    112a8 <transfer+0x67>
   112a8:	eb 00                	jmp    112aa <transfer+0x69>
	if (reset) {
   112aa:	83 bb 9c 40 00 00 00 	cmpl   $0x0,0x409c(%ebx)
   112b1:	74 09                	je     112bc <transfer+0x7b>
}
   112b3:	83 c4 08             	add    $0x8,%esp
   112b6:	5b                   	pop    %ebx
		do_fd_request();
   112b7:	e9 a6 f9 ff ff       	jmp    10c62 <do_fd_request>
	if (!seek) {
   112bc:	83 bb 98 40 00 00 00 	cmpl   $0x0,0x4098(%ebx)
   112c3:	75 09                	jne    112ce <transfer+0x8d>
}
   112c5:	83 c4 08             	add    $0x8,%esp
   112c8:	5b                   	pop    %ebx
		setup_rw_floppy();							// 发送命令参数块.
   112c9:	e9 48 fe ff ff       	jmp    11116 <setup_rw_floppy>
	if (seek_track) {								// 起始磁道号.
   112ce:	80 bb 89 40 00 00 00 	cmpb   $0x0,0x4089(%ebx)
	do_floppy = seek_interrupt;						// 寻道中断调用的C函数.
   112d5:	8d 83 99 03 ff ff    	lea    -0xfc67(%ebx),%eax
   112db:	89 83 84 40 00 00    	mov    %eax,0x4084(%ebx)
	if (seek_track) {								// 起始磁道号.
   112e1:	74 2b                	je     1130e <transfer+0xcd>
		output_byte(FD_SEEK);						// 发送磁头寻道命令.
   112e3:	b8 0f 00 00 00       	mov    $0xf,%eax
   112e8:	e8 19 f9 ff ff       	call   10c06 <output_byte>
		output_byte(head<<2 | current_drive);		// 发送参数:磁头号+当前软驱号.
   112ed:	0f b6 83 8b 40 00 00 	movzbl 0x408b(%ebx),%eax
   112f4:	c1 e0 02             	shl    $0x2,%eax
   112f7:	0a 83 8d 40 00 00    	or     0x408d(%ebx),%al
   112fd:	0f be c0             	movsbl %al,%eax
   11300:	e8 01 f9 ff ff       	call   10c06 <output_byte>
		output_byte(seek_track);					// 发送参数:磁道号.
   11305:	0f be 83 89 40 00 00 	movsbl 0x4089(%ebx),%eax
   1130c:	eb 1d                	jmp    1132b <transfer+0xea>
		output_byte(FD_RECALIBRATE);				// 发送重新校正命令(磁头归零).
   1130e:	b8 07 00 00 00       	mov    $0x7,%eax
   11313:	e8 ee f8 ff ff       	call   10c06 <output_byte>
		output_byte(head<<2 | current_drive);		// 发送参数:磁头号+当前软驱号.
   11318:	0f b6 83 8b 40 00 00 	movzbl 0x408b(%ebx),%eax
   1131f:	c1 e0 02             	shl    $0x2,%eax
   11322:	0a 83 8d 40 00 00    	or     0x408d(%ebx),%al
   11328:	0f be c0             	movsbl %al,%eax
   1132b:	e8 d6 f8 ff ff       	call   10c06 <output_byte>
	if (reset)
   11330:	83 bb 9c 40 00 00 00 	cmpl   $0x0,0x409c(%ebx)
   11337:	0f 85 76 ff ff ff    	jne    112b3 <transfer+0x72>
}
   1133d:	83 c4 08             	add    $0x8,%esp
   11340:	5b                   	pop    %ebx
   11341:	c3                   	ret    

00011342 <floppy_on_interrupt>:
{
   11342:	56                   	push   %esi
   11343:	53                   	push   %ebx
   11344:	e8 e3 56 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11349:	81 c3 b7 fc 00 00    	add    $0xfcb7,%ebx
   1134f:	51                   	push   %ecx
	if (current_drive != (current_DOR & 3)) {
   11350:	c7 c6 60 10 02 00    	mov    $0x21060,%esi
   11356:	8a 8b 8d 40 00 00    	mov    0x408d(%ebx),%cl
	selected = 1;									// 置已选定当前驱动器标志.
   1135c:	c6 83 80 40 00 00 01 	movb   $0x1,0x4080(%ebx)
	if (current_drive != (current_DOR & 3)) {
   11363:	8a 06                	mov    (%esi),%al
   11365:	88 c2                	mov    %al,%dl
   11367:	83 e2 03             	and    $0x3,%edx
   1136a:	38 d1                	cmp    %dl,%cl
   1136c:	74 23                	je     11391 <floppy_on_interrupt+0x4f>
		current_DOR &= 0xFC;
   1136e:	83 e0 fc             	and    $0xfffffffc,%eax
		outb(current_DOR,FD_DOR);					// 向数字输出寄存器输出当前DOR.
   11371:	ba f2 03 00 00       	mov    $0x3f2,%edx
		current_DOR |= current_drive;
   11376:	09 c8                	or     %ecx,%eax
   11378:	88 06                	mov    %al,(%esi)
		outb(current_DOR,FD_DOR);					// 向数字输出寄存器输出当前DOR.
   1137a:	ee                   	out    %al,(%dx)
		add_timer(2,&transfer);						// 添加定时器并执行传输函数.
   1137b:	8d 83 41 02 ff ff    	lea    -0xfdbf(%ebx),%eax
   11381:	52                   	push   %edx
   11382:	52                   	push   %edx
   11383:	50                   	push   %eax
   11384:	6a 02                	push   $0x2
   11386:	e8 cd 5c ff ff       	call   7058 <add_timer>
}
   1138b:	83 c4 14             	add    $0x14,%esp
   1138e:	5b                   	pop    %ebx
   1138f:	5e                   	pop    %esi
   11390:	c3                   	ret    
   11391:	58                   	pop    %eax
   11392:	5b                   	pop    %ebx
   11393:	5e                   	pop    %esi
		transfer();									// 执行软盘读写传输函数.
   11394:	e9 a8 fe ff ff       	jmp    11241 <transfer>

00011399 <seek_interrupt>:
{
   11399:	53                   	push   %ebx
	output_byte(FD_SENSEI);
   1139a:	b8 08 00 00 00       	mov    $0x8,%eax
   1139f:	e8 88 56 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   113a4:	81 c3 5c fc 00 00    	add    $0xfc5c,%ebx
{
   113aa:	83 ec 08             	sub    $0x8,%esp
	output_byte(FD_SENSEI);
   113ad:	e8 54 f8 ff ff       	call   10c06 <output_byte>
	if (result() != 2 || (ST0 & 0xF8) != 0x20 || ST1 != seek_track) {
   113b2:	e8 d2 f7 ff ff       	call   10b89 <result>
   113b7:	83 f8 02             	cmp    $0x2,%eax
   113ba:	75 1b                	jne    113d7 <seek_interrupt+0x3e>
   113bc:	8a 83 90 40 00 00    	mov    0x4090(%ebx),%al
   113c2:	83 e0 f8             	and    $0xfffffff8,%eax
   113c5:	3c 20                	cmp    $0x20,%al
   113c7:	75 0e                	jne    113d7 <seek_interrupt+0x3e>
   113c9:	8a 83 91 40 00 00    	mov    0x4091(%ebx),%al
   113cf:	3a 83 89 40 00 00    	cmp    0x4089(%ebx),%al
   113d5:	74 0e                	je     113e5 <seek_interrupt+0x4c>
		bad_flp_intr();
   113d7:	e8 ac fb ff ff       	call   10f88 <bad_flp_intr>
}
   113dc:	83 c4 08             	add    $0x8,%esp
   113df:	5b                   	pop    %ebx
		do_fd_request();
   113e0:	e9 7d f8 ff ff       	jmp    10c62 <do_fd_request>
	current_track = ST1;							// 设置当前磁道.
   113e5:	88 83 00 14 00 00    	mov    %al,0x1400(%ebx)
}
   113eb:	83 c4 08             	add    $0x8,%esp
   113ee:	5b                   	pop    %ebx
	setup_rw_floppy();								// 设置DMA并输出软盘操作命令和参数.
   113ef:	e9 22 fd ff ff       	jmp    11116 <setup_rw_floppy>

000113f4 <unexpected_floppy_interrupt>:
{
   113f4:	53                   	push   %ebx
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   113f5:	b8 08 00 00 00       	mov    $0x8,%eax
   113fa:	e8 2d 56 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   113ff:	81 c3 01 fc 00 00    	add    $0xfc01,%ebx
{
   11405:	83 ec 08             	sub    $0x8,%esp
	output_byte(FD_SENSEI);							// 发送检测中断状态命令.
   11408:	e8 f9 f7 ff ff       	call   10c06 <output_byte>
	if (result()!=2 || (ST0 & 0xE0) == 0x60)		// 如果返回结果字节数不等于2或命令异常结束,则置复位标志.
   1140d:	e8 77 f7 ff ff       	call   10b89 <result>
   11412:	83 f8 02             	cmp    $0x2,%eax
   11415:	75 0d                	jne    11424 <unexpected_floppy_interrupt+0x30>
   11417:	8a 83 90 40 00 00    	mov    0x4090(%ebx),%al
   1141d:	83 e0 e0             	and    $0xffffffe0,%eax
   11420:	3c 60                	cmp    $0x60,%al
   11422:	75 0c                	jne    11430 <unexpected_floppy_interrupt+0x3c>
		reset = 1;
   11424:	c7 83 9c 40 00 00 01 	movl   $0x1,0x409c(%ebx)
   1142b:	00 00 00 
   1142e:	eb 0a                	jmp    1143a <unexpected_floppy_interrupt+0x46>
		recalibrate = 1;							// 否则置重新校正标志.
   11430:	c7 83 a0 40 00 00 01 	movl   $0x1,0x40a0(%ebx)
   11437:	00 00 00 
}
   1143a:	83 c4 08             	add    $0x8,%esp
   1143d:	5b                   	pop    %ebx
   1143e:	c3                   	ret    

0001143f <floppy_init>:

// 软盘系统初始化.
// 设置软盘块设备请求项的处理函数do_fd_request(),并设置软盘中断门(int 0x26,对应硬件中断请求信号IRQ6).然后取消对该中断信号的屏蔽,以
// 允许软盘控制器FDC发送中断请求信号.中断描述符表IDT中陷阱门描述符设置宏set_trap_gate()定义在头文件include/asm/system.h中.
void floppy_init(void)
{
   1143f:	e8 36 8a ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   11444:	05 bc fb 00 00       	add    $0xfbbc,%eax
	// 设置软盘中断门描述符。floppy_interrup(kernel/sys_call.s)是其中断处理过程。
	blk_size[MAJOR_NR] = floppy_sizes;
   11449:	c7 c2 20 50 02 00    	mov    $0x25020,%edx
   1144f:	8d 88 80 13 00 00    	lea    0x1380(%eax),%ecx
   11455:	89 4a 08             	mov    %ecx,0x8(%edx)
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;  						// = do_fd_request()。
   11458:	c7 c2 40 50 02 00    	mov    $0x25040,%edx
   1145e:	8d 88 62 fc fe ff    	lea    -0x1039e(%eax),%ecx
   11464:	89 4a 10             	mov    %ecx,0x10(%edx)
	set_trap_gate(0x26, &floppy_interrupt);          						// 设置陷阱门描述符。
   11467:	c7 c1 88 57 00 00    	mov    $0x5788,%ecx
   1146d:	c7 c2 f2 74 00 00    	mov    $0x74f2,%edx
   11473:	b8 00 00 08 00       	mov    $0x80000,%eax
   11478:	66 89 d0             	mov    %dx,%ax
   1147b:	66 ba 00 8f          	mov    $0x8f00,%dx
   1147f:	89 81 30 01 00 00    	mov    %eax,0x130(%ecx)
   11485:	89 91 34 01 00 00    	mov    %edx,0x134(%ecx)
	outb(inb_p(0x21) & ~0x40, 0x21);                   						// 复位软盘中断请求屏蔽位。
   1148b:	ba 21 00 00 00       	mov    $0x21,%edx
   11490:	ec                   	in     (%dx),%al
   11491:	eb 00                	jmp    11493 <floppy_init+0x54>
   11493:	eb 00                	jmp    11495 <floppy_init+0x56>
   11495:	25 bf 00 00 00       	and    $0xbf,%eax
   1149a:	ee                   	out    %al,(%dx)
}
   1149b:	c3                   	ret    

0001149c <win_result>:

// 检测硬盘执行命令后的状态.(win表示温切斯特硬盘的缩写)
// 读取状态寄存器中的命令执行结果状态.返回0表示正常;1表示出错.如果执行命令错,则需要再读错误寄存器HD_ERROR(0x1f1).
static int win_result(void)
{
	int i = inb_p(HD_STATUS);							// 取状态信息.
   1149c:	ba f7 01 00 00       	mov    $0x1f7,%edx
   114a1:	ec                   	in     (%dx),%al
   114a2:	eb 00                	jmp    114a4 <win_result+0x8>
   114a4:	eb 00                	jmp    114a6 <win_result+0xa>

	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
   114a6:	88 c2                	mov    %al,%dl
		== (READY_STAT | SEEK_STAT))
		return(0); 										/* ok */
   114a8:	31 c9                	xor    %ecx,%ecx
	if ((i & (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))
   114aa:	83 e2 f1             	and    $0xfffffff1,%edx
   114ad:	80 fa 50             	cmp    $0x50,%dl
   114b0:	74 0f                	je     114c1 <win_result+0x25>
	if (i & 1) i = inb(HD_ERROR);						// 若ERR_STAT置位,则读取错误寄存器.
   114b2:	a8 01                	test   $0x1,%al
	return (1);
   114b4:	b9 01 00 00 00       	mov    $0x1,%ecx
	if (i & 1) i = inb(HD_ERROR);						// 若ERR_STAT置位,则读取错误寄存器.
   114b9:	74 06                	je     114c1 <win_result+0x25>
   114bb:	ba f1 01 00 00       	mov    $0x1f1,%edx
   114c0:	ec                   	in     (%dx),%al
}
   114c1:	89 c8                	mov    %ecx,%eax
   114c3:	c3                   	ret    

000114c4 <hd_out>:
// 第191行定义1个寄存器变量__res.该变量将被保存在1个寄存器中,以便于快速访问.
// 如果想指定寄存器(如eax),则我们可以把该句写成"register char __res asm("ax");"
static void hd_out(unsigned int drive, unsigned int nsect, unsigned int sect,
		unsigned int head, unsigned int cyl, unsigned int cmd,
		void (*intr_addr)(void))
{
   114c4:	55                   	push   %ebp
   114c5:	57                   	push   %edi
   114c6:	89 cd                	mov    %ecx,%ebp
   114c8:	56                   	push   %esi
   114c9:	53                   	push   %ebx
   114ca:	89 c6                	mov    %eax,%esi
   114cc:	e8 5b 55 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   114d1:	81 c3 2f fb 00 00    	add    $0xfb2f,%ebx
   114d7:	83 ec 0c             	sub    $0xc,%esp
	register int port;

	// 首先对参数进行有效性检查.如果驱动器号大于1(只能是0,1)或者磁头号大于15,则程序不支持,停机.否则就判断并循环等待驱动器就绪.如果等待一段时间
	// 后仍未就绪则表示硬盘控制器出错,也停机.
	if (drive > 1 || head > 15)
   114da:	83 f8 01             	cmp    $0x1,%eax
{
   114dd:	89 d7                	mov    %edx,%edi
	if (drive > 1 || head > 15)
   114df:	77 07                	ja     114e8 <hd_out+0x24>
   114e1:	83 7c 24 20 0f       	cmpl   $0xf,0x20(%esp)
   114e6:	76 12                	jbe    114fa <hd_out+0x36>
		panic("Trying to write bad sector");
   114e8:	8d 83 9c 79 ff ff    	lea    -0x8664(%ebx),%eax
   114ee:	83 ec 0c             	sub    $0xc,%esp
   114f1:	50                   	push   %eax
   114f2:	e8 db 6b ff ff       	call   80d2 <panic>
   114f7:	83 c4 10             	add    $0x10,%esp
{
   114fa:	b9 a0 86 01 00       	mov    $0x186a0,%ecx
	while(--retries && (inb_p(HD_STATUS) & 0X80)) ;
   114ff:	ba f7 01 00 00       	mov    $0x1f7,%edx
   11504:	49                   	dec    %ecx
   11505:	0f 84 9e 00 00 00    	je     115a9 <hd_out+0xe5>
   1150b:	ec                   	in     (%dx),%al
   1150c:	eb 00                	jmp    1150e <hd_out+0x4a>
   1150e:	eb 00                	jmp    11510 <hd_out+0x4c>
   11510:	84 c0                	test   %al,%al
   11512:	78 f0                	js     11504 <hd_out+0x40>
	if (!controller_ready())
		panic("HD controller not ready");
	// 接着我们设置硬盘中断发生时将调用的C函数指针do_hd(该函数指针定义在blk.h文件).然后在向硬盘控制器发送参数和命令之前,规定要先向控制器命令端口
	// (0x3f6)发送一指定硬盘的控制字节,以建立相应的硬盘控制方式.该控制字节即是硬盘信息结构数组中的ctl字节.然后向控制器端口0x1f1-0x1f7发送7字节
	// 的参数命令块.
	SET_INTR(intr_addr);								// do_hd = intr_addr在中断中被调用.
   11514:	8b 44 24 2c          	mov    0x2c(%esp),%eax
   11518:	c7 83 f0 40 00 00 c8 	movl   $0xc8,0x40f0(%ebx)
   1151f:	00 00 00 
	outb_p(hd_info[drive].ctl, HD_CMD);					// 向控制寄存器输出控制字节
   11522:	ba f6 03 00 00       	mov    $0x3f6,%edx
	SET_INTR(intr_addr);								// do_hd = intr_addr在中断中被调用.
   11527:	89 83 f4 40 00 00    	mov    %eax,0x40f4(%ebx)
	outb_p(hd_info[drive].ctl, HD_CMD);					// 向控制寄存器输出控制字节
   1152d:	6b c6 18             	imul   $0x18,%esi,%eax
   11530:	8d 8c 03 c0 40 00 00 	lea    0x40c0(%ebx,%eax,1),%ecx
   11537:	8b 41 14             	mov    0x14(%ecx),%eax
   1153a:	ee                   	out    %al,(%dx)
   1153b:	eb 00                	jmp    1153d <hd_out+0x79>
   1153d:	eb 00                	jmp    1153f <hd_out+0x7b>
	port = HD_DATA;										// 置dx为数据寄存器端口(0x1f0)
	outb_p(hd_info[drive].wpcom >> 2, ++port);			// 参数:写预补偿柱面号(需除4)
   1153f:	8b 41 0c             	mov    0xc(%ecx),%eax
   11542:	ba f1 01 00 00       	mov    $0x1f1,%edx
   11547:	c1 f8 02             	sar    $0x2,%eax
   1154a:	ee                   	out    %al,(%dx)
   1154b:	eb 00                	jmp    1154d <hd_out+0x89>
   1154d:	eb 00                	jmp    1154f <hd_out+0x8b>
	outb_p(nsect, ++port);								// 参数:读/写扇区总数.
   1154f:	ba f2 01 00 00       	mov    $0x1f2,%edx
   11554:	89 f8                	mov    %edi,%eax
   11556:	ee                   	out    %al,(%dx)
   11557:	eb 00                	jmp    11559 <hd_out+0x95>
   11559:	eb 00                	jmp    1155b <hd_out+0x97>
	outb_p(sect, ++port);								// 参数:起始扇区.
   1155b:	ba f3 01 00 00       	mov    $0x1f3,%edx
   11560:	89 e8                	mov    %ebp,%eax
   11562:	ee                   	out    %al,(%dx)
   11563:	eb 00                	jmp    11565 <hd_out+0xa1>
   11565:	eb 00                	jmp    11567 <hd_out+0xa3>
	outb_p(cyl, ++port);								// 参数:柱面号低8位.
   11567:	ba f4 01 00 00       	mov    $0x1f4,%edx
   1156c:	8b 44 24 24          	mov    0x24(%esp),%eax
   11570:	ee                   	out    %al,(%dx)
   11571:	eb 00                	jmp    11573 <hd_out+0xaf>
   11573:	eb 00                	jmp    11575 <hd_out+0xb1>
	outb_p(cyl >> 8, ++port);							// 参数:柱面号高8位.
   11575:	ba f5 01 00 00       	mov    $0x1f5,%edx
   1157a:	c1 e8 08             	shr    $0x8,%eax
   1157d:	ee                   	out    %al,(%dx)
   1157e:	eb 00                	jmp    11580 <hd_out+0xbc>
   11580:	eb 00                	jmp    11582 <hd_out+0xbe>
	outb_p(0xA0 | (drive << 4) | head, ++port);			// 参数:驱动器号+磁头号.
   11582:	8b 44 24 20          	mov    0x20(%esp),%eax
   11586:	c1 e6 04             	shl    $0x4,%esi
   11589:	ba f6 01 00 00       	mov    $0x1f6,%edx
   1158e:	0c a0                	or     $0xa0,%al
   11590:	09 f0                	or     %esi,%eax
   11592:	ee                   	out    %al,(%dx)
   11593:	eb 00                	jmp    11595 <hd_out+0xd1>
   11595:	eb 00                	jmp    11597 <hd_out+0xd3>
	outb(cmd, ++port);									// 命令:硬盘控制命令.
   11597:	ba f7 01 00 00       	mov    $0x1f7,%edx
   1159c:	8b 44 24 28          	mov    0x28(%esp),%eax
   115a0:	ee                   	out    %al,(%dx)
}
   115a1:	83 c4 0c             	add    $0xc,%esp
   115a4:	5b                   	pop    %ebx
   115a5:	5e                   	pop    %esi
   115a6:	5f                   	pop    %edi
   115a7:	5d                   	pop    %ebp
   115a8:	c3                   	ret    
		panic("HD controller not ready");
   115a9:	8d 83 b7 79 ff ff    	lea    -0x8649(%ebx),%eax
   115af:	83 ec 0c             	sub    $0xc,%esp
   115b2:	50                   	push   %eax
   115b3:	e8 1a 6b ff ff       	call   80d2 <panic>
   115b8:	83 c4 10             	add    $0x10,%esp
   115bb:	e9 54 ff ff ff       	jmp    11514 <hd_out+0x50>

000115c0 <end_request>:
{
   115c0:	55                   	push   %ebp
   115c1:	57                   	push   %edi
   115c2:	89 c7                	mov    %eax,%edi
   115c4:	56                   	push   %esi
   115c5:	53                   	push   %ebx
   115c6:	e8 61 54 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   115cb:	81 c3 35 fa 00 00    	add    $0xfa35,%ebx
   115d1:	83 ec 0c             	sub    $0xc,%esp
	if (CURRENT->bh) {									// CURRENT为当前请求结构项指针
   115d4:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   115da:	8b 46 1c             	mov    0x1c(%esi),%eax
   115dd:	8b 68 1c             	mov    0x1c(%eax),%ebp
   115e0:	85 ed                	test   %ebp,%ebp
   115e2:	74 30                	je     11614 <end_request+0x54>
	if (!bh->b_lock)
   115e4:	80 7d 0d 00          	cmpb   $0x0,0xd(%ebp)
		CURRENT->bh->b_uptodate = uptodate;				// 置更新标志.
   115e8:	89 f8                	mov    %edi,%eax
   115ea:	88 45 0a             	mov    %al,0xa(%ebp)
	if (!bh->b_lock)
   115ed:	75 12                	jne    11601 <end_request+0x41>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   115ef:	8d 83 cf 79 ff ff    	lea    -0x8631(%ebx),%eax
   115f5:	83 ec 0c             	sub    $0xc,%esp
   115f8:	50                   	push   %eax
   115f9:	e8 23 6b ff ff       	call   8121 <printk>
   115fe:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   11601:	c6 45 0d 00          	movb   $0x0,0xd(%ebp)
	wake_up(&bh->b_wait);
   11605:	83 ec 0c             	sub    $0xc,%esp
   11608:	83 c5 10             	add    $0x10,%ebp
   1160b:	55                   	push   %ebp
   1160c:	e8 82 58 ff ff       	call   6e93 <wake_up>
   11611:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {									// 若更新标志为0则显示出错信息.
   11614:	85 ff                	test   %edi,%edi
   11616:	75 2c                	jne    11644 <end_request+0x84>
		printk(DEVICE_NAME " I/O error\n\r");
   11618:	8d 83 f5 79 ff ff    	lea    -0x860b(%ebx),%eax
   1161e:	83 ec 0c             	sub    $0xc,%esp
   11621:	50                   	push   %eax
   11622:	e8 fa 6a ff ff       	call   8121 <printk>
			CURRENT->bh->b_blocknr);
   11627:	8b 46 1c             	mov    0x1c(%esi),%eax
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   1162a:	83 c4 0c             	add    $0xc,%esp
   1162d:	8b 50 1c             	mov    0x1c(%eax),%edx
   11630:	ff 72 04             	pushl  0x4(%edx)
   11633:	ff 30                	pushl  (%eax)
   11635:	8d 83 a3 78 ff ff    	lea    -0x875d(%ebx),%eax
   1163b:	50                   	push   %eax
   1163c:	e8 e0 6a ff ff       	call   8121 <printk>
   11641:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);							// 唤醒等待该请求项的进程.
   11644:	8b 46 1c             	mov    0x1c(%esi),%eax
   11647:	83 ec 0c             	sub    $0xc,%esp
   1164a:	83 c0 18             	add    $0x18,%eax
   1164d:	50                   	push   %eax
   1164e:	e8 40 58 ff ff       	call   6e93 <wake_up>
	wake_up(&wait_for_request);							// 唤醒等待空闲请求项的进程.
   11653:	58                   	pop    %eax
   11654:	ff b3 e0 ff ff ff    	pushl  -0x20(%ebx)
   1165a:	e8 34 58 ff ff       	call   6e93 <wake_up>
	CURRENT->dev = -1;									// 释放该请求项.
   1165f:	8b 46 1c             	mov    0x1c(%esi),%eax
   11662:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;							// 指向下一请求项.
   11668:	8b 40 20             	mov    0x20(%eax),%eax
   1166b:	89 46 1c             	mov    %eax,0x1c(%esi)
}
   1166e:	83 c4 1c             	add    $0x1c,%esp
   11671:	5b                   	pop    %ebx
   11672:	5e                   	pop    %esi
   11673:	5f                   	pop    %edi
   11674:	5d                   	pop    %ebp
   11675:	c3                   	ret    

00011676 <bad_rw_intr>:

// 读写硬盘失败处理调用函数
// 如果读扇区时的出错次数大于或等于7次时,则结束当前请求项并唤醒等待该请求的进程,而且对应缓冲区更新标志复位,表示数据没有更新.如果读写一扇区时的出错次数已经大于
// 3次,则要求执行复位硬盘控制器操作(设置复位标志).
static void bad_rw_intr(void)
{
   11676:	56                   	push   %esi
   11677:	53                   	push   %ebx
   11678:	e8 af 53 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1167d:	81 c3 83 f9 00 00    	add    $0xf983,%ebx
   11683:	52                   	push   %edx
	if (++CURRENT->errors >= MAX_ERRORS)
   11684:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   1168a:	8b 56 1c             	mov    0x1c(%esi),%edx
   1168d:	8b 42 08             	mov    0x8(%edx),%eax
   11690:	40                   	inc    %eax
   11691:	83 f8 06             	cmp    $0x6,%eax
   11694:	89 42 08             	mov    %eax,0x8(%edx)
   11697:	7e 07                	jle    116a0 <bad_rw_intr+0x2a>
		end_request(0);
   11699:	31 c0                	xor    %eax,%eax
   1169b:	e8 20 ff ff ff       	call   115c0 <end_request>
	if (CURRENT->errors > MAX_ERRORS / 2)
   116a0:	8b 46 1c             	mov    0x1c(%esi),%eax
   116a3:	83 78 08 03          	cmpl   $0x3,0x8(%eax)
   116a7:	7e 0a                	jle    116b3 <bad_rw_intr+0x3d>
		reset = 1;
   116a9:	c7 83 94 41 00 00 01 	movl   $0x1,0x4194(%ebx)
   116b0:	00 00 00 
}
   116b3:	58                   	pop    %eax
   116b4:	5b                   	pop    %ebx
   116b5:	5e                   	pop    %esi
   116b6:	c3                   	ret    

000116b7 <do_hd_request>:
// 该函数根据设备当前请求项中的设备号和起始扇区号信息首先计算到对应硬盘上的柱面号,当前磁道中扇区号,磁头号数据,然后再根据请求项中的命令(READ/WRITE)对硬盘发送相应读/写命令
// 若控制器复位标志或硬盘重新校正已被置位,那么首先会执行复位或重新校正操作.
// 若请求项此时是块设备的第1个(原来设备空闲),则块设备当前请求项指针会直接指向该请求项(参见ll_rw_blk.c),并会立刻调用本函数执行读写操作.否则在一个读写操作完成而引发的硬盘
// 中断过程,若还有请求项需要处理,则也会在硬盘中断过程中调用本函数
void do_hd_request(void)
{
   116b7:	55                   	push   %ebp
   116b8:	57                   	push   %edi
   116b9:	56                   	push   %esi
   116ba:	53                   	push   %ebx
   116bb:	e8 6c 53 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   116c0:	81 c3 40 f9 00 00    	add    $0xf940,%ebx
   116c6:	83 ec 1c             	sub    $0x1c,%esp

	// 函数首先检测请求项的合法性.若请求队列中已没有请求项则退出(参见blk.h)
	// 然后取设备号中的子设备号以及设备当前请求项中的起始扇区号.子设备号即对应硬盘上各分区.如果子设备号不存在或者起始扇区大于该分区扇区数-2,则结束该请求项,并跳转到标号repeat处(定义
	// 在INIT_REQUEST开始处).因为次要求读写一块数据(2个扇区,即1024字节),所以请求的扇区号不能大于分区中最后倒数第二个扇区号.然后通过加上子设备号对应分区的起始扇区号,就把需要读写的
	// 块对应到整个硬盘的绝对扇区号block上.而子设备号被5整除即可得到对应的硬盘号.
	INIT_REQUEST;
   116c9:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   116cf:	8b 46 1c             	mov    0x1c(%esi),%eax
   116d2:	85 c0                	test   %eax,%eax
   116d4:	75 19                	jne    116ef <do_hd_request+0x38>
   116d6:	c7 83 f4 40 00 00 00 	movl   $0x0,0x40f4(%ebx)
   116dd:	00 00 00 
   116e0:	c7 83 f0 40 00 00 00 	movl   $0x0,0x40f0(%ebx)
   116e7:	00 00 00 
   116ea:	e9 a4 01 00 00       	jmp    11893 <do_hd_request+0x1dc>
   116ef:	8b 00                	mov    (%eax),%eax
   116f1:	c1 e8 08             	shr    $0x8,%eax
   116f4:	83 f8 03             	cmp    $0x3,%eax
   116f7:	74 12                	je     1170b <do_hd_request+0x54>
   116f9:	8d 83 0a 7a ff ff    	lea    -0x85f6(%ebx),%eax
   116ff:	83 ec 0c             	sub    $0xc,%esp
   11702:	50                   	push   %eax
   11703:	e8 ca 69 ff ff       	call   80d2 <panic>
   11708:	83 c4 10             	add    $0x10,%esp
   1170b:	8b 46 1c             	mov    0x1c(%esi),%eax
   1170e:	8b 40 1c             	mov    0x1c(%eax),%eax
   11711:	85 c0                	test   %eax,%eax
   11713:	74 18                	je     1172d <do_hd_request+0x76>
   11715:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   11719:	75 12                	jne    1172d <do_hd_request+0x76>
   1171b:	8d 83 2b 7a ff ff    	lea    -0x85d5(%ebx),%eax
   11721:	83 ec 0c             	sub    $0xc,%esp
   11724:	50                   	push   %eax
   11725:	e8 a8 69 ff ff       	call   80d2 <panic>
   1172a:	83 c4 10             	add    $0x10,%esp
 	dev = MINOR(CURRENT->dev);
   1172d:	8b 46 1c             	mov    0x1c(%esi),%eax
   11730:	89 44 24 04          	mov    %eax,0x4(%esp)
   11734:	0f b6 00             	movzbl (%eax),%eax
   11737:	89 04 24             	mov    %eax,(%esp)
	block = CURRENT->sector;						// 请求的起始扇区.
	if (dev >= 5 * NR_HD || block + 2 > hd[dev].nr_sects) {
   1173a:	6b 83 90 41 00 00 05 	imul   $0x5,0x4190(%ebx),%eax
   11741:	3b 04 24             	cmp    (%esp),%eax
   11744:	76 16                	jbe    1175c <do_hd_request+0xa5>
	block = CURRENT->sector;						// 请求的起始扇区.
   11746:	8b 44 24 04          	mov    0x4(%esp),%eax
	if (dev >= 5 * NR_HD || block + 2 > hd[dev].nr_sects) {
   1174a:	8b 3c 24             	mov    (%esp),%edi
	block = CURRENT->sector;						// 请求的起始扇区.
   1174d:	8b 48 0c             	mov    0xc(%eax),%ecx
	if (dev >= 5 * NR_HD || block + 2 > hd[dev].nr_sects) {
   11750:	8d 41 02             	lea    0x2(%ecx),%eax
   11753:	3b 84 fb 44 41 00 00 	cmp    0x4144(%ebx,%edi,8),%eax
   1175a:	76 0c                	jbe    11768 <do_hd_request+0xb1>
		end_request(0);
   1175c:	31 c0                	xor    %eax,%eax
   1175e:	e8 5d fe ff ff       	call   115c0 <end_request>
		goto repeat;								// 该标号在blk.h最后面.
   11763:	e9 67 ff ff ff       	jmp    116cf <do_hd_request+0x18>
	}
	block += hd[dev].start_sect;
   11768:	8b 04 24             	mov    (%esp),%eax
	dev /= 5;										// 此时dev代表硬盘号(硬盘0还是硬盘1)
   1176b:	bf 05 00 00 00       	mov    $0x5,%edi
   11770:	31 d2                	xor    %edx,%edx
	// 然后根据求得的绝对扇区号block和硬盘号dev,我们就可以计算出对应硬盘中的磁道中扇区号(sec),所在柱面号(cyl)和磁头号(head).下面嵌入的汇编代码即用来根据硬盘信息结构中的每磁道扇区
	// 数和硬盘磁头数来计算这些数据.计算方法为:初始时eax是扇区号block,edx中置0.divl指令把edx:eax组成的扇区号除以每磁道扇区数(hd_info[dev].sect),所得整数商值在eax中,余数在edx
	// 中.其中eax中是到指定位置的对应总磁道数(所有磁头面),edx中是当前磁道上的扇区号.348-349行代码初始时eax是计算出的对应总磁道数,edx中置0.divl指令把edx:eax的对应总磁道数除以硬盘
	// 总磁头数(hd_info[dev].head),在eax中得到的整除值是柱面号(cyl),edx得到的余数就是对应得当前磁头号(head).
	// 对应总磁道数 * 每磁道扇区数 + 当前磁道上的扇区号 = 绝对扇区号
	__asm__("divl %4":"=a" (block), "=d" (sec):"0" (block), "1" (0),
   11772:	31 ed                	xor    %ebp,%ebp
	block += hd[dev].start_sect;
   11774:	03 8c c3 40 41 00 00 	add    0x4140(%ebx,%eax,8),%ecx
	dev /= 5;										// 此时dev代表硬盘号(硬盘0还是硬盘1)
   1177b:	f7 f7                	div    %edi
	__asm__("divl %4":"=a" (block), "=d" (sec):"0" (block), "1" (0),
   1177d:	89 ea                	mov    %ebp,%edx
		"r" (hd_info[dev].sect));
   1177f:	6b f8 18             	imul   $0x18,%eax,%edi
	dev /= 5;										// 此时dev代表硬盘号(硬盘0还是硬盘1)
   11782:	89 44 24 08          	mov    %eax,0x8(%esp)
	__asm__("divl %4":"=a" (block), "=d" (sec):"0" (block), "1" (0),
   11786:	8b 84 3b c4 40 00 00 	mov    0x40c4(%ebx,%edi,1),%eax
	// 总磁头数 * 柱面号 + 磁头号 = 对应总磁道数
	__asm__("divl %4":"=a" (cyl), "=d" (head):"0" (block), "1" (0),
   1178d:	8b bc 3b c0 40 00 00 	mov    0x40c0(%ebx,%edi,1),%edi
	__asm__("divl %4":"=a" (block), "=d" (sec):"0" (block), "1" (0),
   11794:	89 44 24 0c          	mov    %eax,0xc(%esp)
   11798:	89 c8                	mov    %ecx,%eax
   1179a:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1179e:	f7 f1                	div    %ecx
   117a0:	89 d1                	mov    %edx,%ecx
	__asm__("divl %4":"=a" (cyl), "=d" (head):"0" (block), "1" (0),
   117a2:	89 ea                	mov    %ebp,%edx
		"r" (hd_info[dev].head));
	sec++;											// 对计算所得当前磁道扇区号进行调整.
   117a4:	41                   	inc    %ecx
	__asm__("divl %4":"=a" (cyl), "=d" (head):"0" (block), "1" (0),
   117a5:	f7 f7                	div    %edi
	// 此时我们得到了欲读写的硬盘起始扇区block所对应的硬盘上柱面号(cyl),在当前磁道上的扇区号(sec),磁头号(head)以及欲读写的总扇区数(nsect).接着我们可以根据这些信息向硬盘控制器发送I/O
	// 操作信息了.但在发送之前我们还需要先看看是否有复位控制器状态和重新校正硬盘的标志.通常在复位操作之后都需要重新校正硬盘磁头位置.若这些标志已被置位,则说明前面的硬盘操作可能出现了一些问题
	// 或者现在是系统第一次硬盘读写操作等情况.于是我们就需要重新复位硬盘或控制器并重新校正硬盘.
	// 如果此时复位标志reset是置位的,则需要执行复位操作.复位硬盘和控制器,并置硬盘需要重新校正标志,返回.reset_hd()将首先向硬盘控制器发送复位(重新校正)命令,然后发送硬盘控制命令"
	// 建立驱动器参数".
	if (reset) {
   117a7:	83 bb 94 41 00 00 00 	cmpl   $0x0,0x4194(%ebx)
	nsect = CURRENT->nr_sectors;					// 预读/写的扇区数.
   117ae:	8b 7c 24 04          	mov    0x4(%esp),%edi
	__asm__("divl %4":"=a" (cyl), "=d" (head):"0" (block), "1" (0),
   117b2:	89 d5                	mov    %edx,%ebp
	nsect = CURRENT->nr_sectors;					// 预读/写的扇区数.
   117b4:	8b 57 10             	mov    0x10(%edi),%edx
	if (reset) {
   117b7:	74 16                	je     117cf <do_hd_request+0x118>
		recalibrate = 1;							// 置需重新校正标志.
   117b9:	c7 83 98 41 00 00 01 	movl   $0x1,0x4198(%ebx)
   117c0:	00 00 00 
	// 如果当前请求是读硬盘数据,则向硬盘控制器发送读扇区命令.若命令无效则停机.
	} else if (CURRENT->cmd == READ) {
		hd_out(dev, nsect, sec, head, cyl, WIN_READ, &read_intr);
	} else
		panic("unknown hd-command");
}
   117c3:	83 c4 1c             	add    $0x1c,%esp
   117c6:	5b                   	pop    %ebx
   117c7:	5e                   	pop    %esi
   117c8:	5f                   	pop    %edi
   117c9:	5d                   	pop    %ebp
		reset_hd();
   117ca:	e9 cc 00 00 00       	jmp    1189b <reset_hd>
	if (recalibrate) {
   117cf:	83 bb 98 41 00 00 00 	cmpl   $0x0,0x4198(%ebx)
   117d6:	74 30                	je     11808 <do_hd_request+0x151>
		hd_out(dev, hd_info[CURRENT_DEV].sect, 0, 0, 0,
   117d8:	8b 04 24             	mov    (%esp),%eax
   117db:	be 05 00 00 00       	mov    $0x5,%esi
		recalibrate = 0;
   117e0:	c7 83 98 41 00 00 00 	movl   $0x0,0x4198(%ebx)
   117e7:	00 00 00 
		hd_out(dev, hd_info[CURRENT_DEV].sect, 0, 0, 0,
   117ea:	31 c9                	xor    %ecx,%ecx
   117ec:	99                   	cltd   
   117ed:	f7 fe                	idiv   %esi
   117ef:	8d 93 b3 09 ff ff    	lea    -0xf64d(%ebx),%edx
   117f5:	52                   	push   %edx
   117f6:	6a 10                	push   $0x10
   117f8:	6a 00                	push   $0x0
   117fa:	6a 00                	push   $0x0
   117fc:	6b c0 18             	imul   $0x18,%eax,%eax
   117ff:	8b 94 03 c4 40 00 00 	mov    0x40c4(%ebx,%eax,1),%edx
   11806:	eb 52                	jmp    1185a <do_hd_request+0x1a3>
	if (CURRENT->cmd == WRITE) {
   11808:	8b 7c 24 04          	mov    0x4(%esp),%edi
   1180c:	8b 7f 04             	mov    0x4(%edi),%edi
   1180f:	83 ff 01             	cmp    $0x1,%edi
   11812:	75 37                	jne    1184b <do_hd_request+0x194>
		hd_out(dev, nsect, sec, head, cyl, WIN_WRITE, &write_intr);
   11814:	8d bb 48 0a ff ff    	lea    -0xf5b8(%ebx),%edi
   1181a:	57                   	push   %edi
   1181b:	6a 30                	push   $0x30
   1181d:	50                   	push   %eax
   1181e:	55                   	push   %ebp
   1181f:	8b 44 24 18          	mov    0x18(%esp),%eax
   11823:	e8 9c fc ff ff       	call   114c4 <hd_out>
   11828:	83 c4 10             	add    $0x10,%esp
   1182b:	b9 10 27 00 00       	mov    $0x2710,%ecx
		for(i = 0 ; i < 10000 && !(r = inb_p(HD_STATUS) & DRQ_STAT) ; i++)
   11830:	ba f7 01 00 00       	mov    $0x1f7,%edx
   11835:	ec                   	in     (%dx),%al
   11836:	eb 00                	jmp    11838 <do_hd_request+0x181>
   11838:	eb 00                	jmp    1183a <do_hd_request+0x183>
   1183a:	a8 08                	test   $0x8,%al
   1183c:	75 3b                	jne    11879 <do_hd_request+0x1c2>
   1183e:	49                   	dec    %ecx
   1183f:	75 f4                	jne    11835 <do_hd_request+0x17e>
			bad_rw_intr();
   11841:	e8 30 fe ff ff       	call   11676 <bad_rw_intr>
			goto repeat;							// 该标号在blk.h文件最后面.
   11846:	e9 84 fe ff ff       	jmp    116cf <do_hd_request+0x18>
	} else if (CURRENT->cmd == READ) {
   1184b:	85 ff                	test   %edi,%edi
   1184d:	75 16                	jne    11865 <do_hd_request+0x1ae>
		hd_out(dev, nsect, sec, head, cyl, WIN_READ, &read_intr);
   1184f:	8d 9b cc 09 ff ff    	lea    -0xf634(%ebx),%ebx
   11855:	53                   	push   %ebx
   11856:	6a 20                	push   $0x20
   11858:	50                   	push   %eax
   11859:	55                   	push   %ebp
   1185a:	8b 44 24 18          	mov    0x18(%esp),%eax
   1185e:	e8 61 fc ff ff       	call   114c4 <hd_out>
   11863:	eb 0f                	jmp    11874 <do_hd_request+0x1bd>
		panic("unknown hd-command");
   11865:	8d 83 46 7a ff ff    	lea    -0x85ba(%ebx),%eax
   1186b:	83 ec 0c             	sub    $0xc,%esp
   1186e:	50                   	push   %eax
   1186f:	e8 5e 68 ff ff       	call   80d2 <panic>
   11874:	83 c4 10             	add    $0x10,%esp
   11877:	eb 1a                	jmp    11893 <do_hd_request+0x1dc>
		port_write(HD_DATA, CURRENT->buffer, 256);
   11879:	c7 c0 40 50 02 00    	mov    $0x25040,%eax
   1187f:	ba f0 01 00 00       	mov    $0x1f0,%edx
   11884:	b9 00 01 00 00       	mov    $0x100,%ecx
   11889:	8b 40 1c             	mov    0x1c(%eax),%eax
   1188c:	8b 70 14             	mov    0x14(%eax),%esi
   1188f:	fc                   	cld    
   11890:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
}
   11893:	83 c4 1c             	add    $0x1c,%esp
   11896:	5b                   	pop    %ebx
   11897:	5e                   	pop    %esi
   11898:	5f                   	pop    %edi
   11899:	5d                   	pop    %ebp
   1189a:	c3                   	ret    

0001189b <reset_hd>:
{
   1189b:	57                   	push   %edi
   1189c:	56                   	push   %esi
   1189d:	53                   	push   %ebx
   1189e:	e8 89 51 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   118a3:	81 c3 5d f7 00 00    	add    $0xf75d,%ebx
	if (reset) {
   118a9:	83 bb 94 41 00 00 00 	cmpl   $0x0,0x4194(%ebx)
   118b0:	0f 84 92 00 00 00    	je     11948 <reset_hd+0xad>
		reset = 0;
   118b6:	c7 83 94 41 00 00 00 	movl   $0x0,0x4194(%ebx)
   118bd:	00 00 00 
		i = -1;											// 初始化当前硬盘号(静态变量).
   118c0:	c7 83 f8 40 00 00 ff 	movl   $0xffffffff,0x40f8(%ebx)
   118c7:	ff ff ff 
	outb(4, HD_CMD);									// 向控制寄存器端口发送复位控制字节.
   118ca:	b8 04 00 00 00       	mov    $0x4,%eax
   118cf:	ba f6 03 00 00       	mov    $0x3f6,%edx
   118d4:	ee                   	out    %al,(%dx)
   118d5:	b8 e8 03 00 00       	mov    $0x3e8,%eax
	for(i = 0; i < 1000; i++) nop();					// 等待一段时间.
   118da:	90                   	nop
   118db:	48                   	dec    %eax
   118dc:	75 fc                	jne    118da <reset_hd+0x3f>
	outb(hd_info[0].ctl & 0x0f, HD_CMD);				// 发送正常控制字节(不禁止重试,重读).
   118de:	8b 83 d4 40 00 00    	mov    0x40d4(%ebx),%eax
   118e4:	ba f6 03 00 00       	mov    $0x3f6,%edx
   118e9:	83 e0 0f             	and    $0xf,%eax
   118ec:	ee                   	out    %al,(%dx)
   118ed:	b9 50 c3 00 00       	mov    $0xc350,%ecx
		c = inb_p(HD_STATUS);							// 取主控制器状态字节.
   118f2:	ba f7 01 00 00       	mov    $0x1f7,%edx
   118f7:	ec                   	in     (%dx),%al
   118f8:	eb 00                	jmp    118fa <reset_hd+0x5f>
   118fa:	eb 00                	jmp    118fc <reset_hd+0x61>
		c &= (BUSY_STAT | READY_STAT | SEEK_STAT);
   118fc:	83 e0 d0             	and    $0xffffffd0,%eax
		if (c == (READY_STAT | SEEK_STAT))
   118ff:	3c 50                	cmp    $0x50,%al
   11901:	74 23                	je     11926 <reset_hd+0x8b>
	for (i = 0; i < 50000; i++) {
   11903:	49                   	dec    %ecx
   11904:	75 f1                	jne    118f7 <reset_hd+0x5c>
	printk("HD controller times out\n\r");				// 等待超时,显示信息.并返回1.
   11906:	8d 83 59 7a ff ff    	lea    -0x85a7(%ebx),%eax
   1190c:	83 ec 0c             	sub    $0xc,%esp
   1190f:	50                   	push   %eax
   11910:	e8 0c 68 ff ff       	call   8121 <printk>
		printk("HD-controller still busy\n\r");
   11915:	8d 83 73 7a ff ff    	lea    -0x858d(%ebx),%eax
   1191b:	89 04 24             	mov    %eax,(%esp)
   1191e:	e8 fe 67 ff ff       	call   8121 <printk>
   11923:	83 c4 10             	add    $0x10,%esp
	if ((i = inb(HD_ERROR)) != 1)
   11926:	ba f1 01 00 00       	mov    $0x1f1,%edx
   1192b:	ec                   	in     (%dx),%al
   1192c:	0f b6 c0             	movzbl %al,%eax
   1192f:	83 f8 01             	cmp    $0x1,%eax
   11932:	74 2f                	je     11963 <reset_hd+0xc8>
		printk("HD-controller reset failed: %02x\n\r",i);
   11934:	52                   	push   %edx
   11935:	52                   	push   %edx
   11936:	50                   	push   %eax
   11937:	8d 83 8e 7a ff ff    	lea    -0x8572(%ebx),%eax
   1193d:	50                   	push   %eax
   1193e:	e8 de 67 ff ff       	call   8121 <printk>
   11943:	83 c4 10             	add    $0x10,%esp
   11946:	eb 1b                	jmp    11963 <reset_hd+0xc8>
	} else if (win_result()) {
   11948:	e8 4f fb ff ff       	call   1149c <win_result>
   1194d:	85 c0                	test   %eax,%eax
   1194f:	74 12                	je     11963 <reset_hd+0xc8>
		bad_rw_intr();
   11951:	e8 20 fd ff ff       	call   11676 <bad_rw_intr>
		if (reset)
   11956:	83 bb 94 41 00 00 00 	cmpl   $0x0,0x4194(%ebx)
   1195d:	0f 85 46 ff ff ff    	jne    118a9 <reset_hd+0xe>
	i++;												// 处理下一个硬盘(第1个是0).
   11963:	8b 83 f8 40 00 00    	mov    0x40f8(%ebx),%eax
   11969:	40                   	inc    %eax
	if (i < NR_HD) {
   1196a:	3b 83 90 41 00 00    	cmp    0x4190(%ebx),%eax
	i++;												// 处理下一个硬盘(第1个是0).
   11970:	89 83 f8 40 00 00    	mov    %eax,0x40f8(%ebx)
	if (i < NR_HD) {
   11976:	7d 33                	jge    119ab <reset_hd+0x110>
		hd_out(i, hd_info[i].sect, hd_info[i].sect,hd_info[i].head - 1,
   11978:	6b c8 18             	imul   $0x18,%eax,%ecx
   1197b:	8d bb 9b 08 ff ff    	lea    -0xf765(%ebx),%edi
   11981:	57                   	push   %edi
   11982:	68 91 00 00 00       	push   $0x91
   11987:	8d b4 0b c0 40 00 00 	lea    0x40c0(%ebx,%ecx,1),%esi
   1198e:	8b 8c 0b c0 40 00 00 	mov    0x40c0(%ebx,%ecx,1),%ecx
   11995:	8b 56 04             	mov    0x4(%esi),%edx
   11998:	ff 76 08             	pushl  0x8(%esi)
   1199b:	49                   	dec    %ecx
   1199c:	51                   	push   %ecx
   1199d:	89 d1                	mov    %edx,%ecx
   1199f:	e8 20 fb ff ff       	call   114c4 <hd_out>
   119a4:	83 c4 10             	add    $0x10,%esp
}
   119a7:	5b                   	pop    %ebx
   119a8:	5e                   	pop    %esi
   119a9:	5f                   	pop    %edi
   119aa:	c3                   	ret    
   119ab:	5b                   	pop    %ebx
   119ac:	5e                   	pop    %esi
   119ad:	5f                   	pop    %edi
		do_hd_request();								// 执行请求项处理.
   119ae:	e9 04 fd ff ff       	jmp    116b7 <do_hd_request>

000119b3 <recal_intr>:
{
   119b3:	83 ec 0c             	sub    $0xc,%esp
	if (win_result())									// 若返回出错,则调用bad_rw_intr().
   119b6:	e8 e1 fa ff ff       	call   1149c <win_result>
   119bb:	85 c0                	test   %eax,%eax
   119bd:	74 05                	je     119c4 <recal_intr+0x11>
		bad_rw_intr();
   119bf:	e8 b2 fc ff ff       	call   11676 <bad_rw_intr>
}
   119c4:	83 c4 0c             	add    $0xc,%esp
	do_hd_request();
   119c7:	e9 eb fc ff ff       	jmp    116b7 <do_hd_request>

000119cc <read_intr>:
{
   119cc:	57                   	push   %edi
   119cd:	53                   	push   %ebx
   119ce:	51                   	push   %ecx
   119cf:	e8 58 50 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   119d4:	81 c3 2c f6 00 00    	add    $0xf62c,%ebx
	if (win_result()) {									// 若控制器忙,读写错或命令执行错,则进行读写硬盘失败处理.
   119da:	e8 bd fa ff ff       	call   1149c <win_result>
   119df:	85 c0                	test   %eax,%eax
   119e1:	74 07                	je     119ea <read_intr+0x1e>
		bad_rw_intr();
   119e3:	e8 8e fc ff ff       	call   11676 <bad_rw_intr>
   119e8:	eb 56                	jmp    11a40 <read_intr+0x74>
	port_read(HD_DATA, CURRENT->buffer, 256);			// 读数据到请求结构缓冲区.
   119ea:	c7 c0 40 50 02 00    	mov    $0x25040,%eax
   119f0:	ba f0 01 00 00       	mov    $0x1f0,%edx
   119f5:	b9 00 01 00 00       	mov    $0x100,%ecx
   119fa:	8b 40 1c             	mov    0x1c(%eax),%eax
   119fd:	8b 78 14             	mov    0x14(%eax),%edi
   11a00:	fc                   	cld    
   11a01:	f3 66 6d             	rep insw (%dx),%es:(%edi)
	CURRENT->buffer += 512;								// 高速缓冲区指针,指向新的空区.
   11a04:	81 c7 00 02 00 00    	add    $0x200,%edi
	CURRENT->sector++;									// 起始扇区号加1.
   11a0a:	ff 40 0c             	incl   0xc(%eax)
	if (--CURRENT->nr_sectors) {						// 如果所需读出的扇区数还没读完,则再置硬盘调用C函数指针为read_intr().
   11a0d:	ff 48 10             	decl   0x10(%eax)
	CURRENT->errors = 0;								// 清出错次数
   11a10:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	CURRENT->buffer += 512;								// 高速缓冲区指针,指向新的空区.
   11a17:	89 78 14             	mov    %edi,0x14(%eax)
	if (--CURRENT->nr_sectors) {						// 如果所需读出的扇区数还没读完,则再置硬盘调用C函数指针为read_intr().
   11a1a:	74 1a                	je     11a36 <read_intr+0x6a>
		SET_INTR(&read_intr);
   11a1c:	8d 83 cc 09 ff ff    	lea    -0xf634(%ebx),%eax
   11a22:	c7 83 f0 40 00 00 c8 	movl   $0xc8,0x40f0(%ebx)
   11a29:	00 00 00 
   11a2c:	89 83 f4 40 00 00    	mov    %eax,0x40f4(%ebx)
}
   11a32:	5a                   	pop    %edx
   11a33:	5b                   	pop    %ebx
   11a34:	5f                   	pop    %edi
   11a35:	c3                   	ret    
	end_request(1);										// 数据已更新标志置位(1).
   11a36:	b8 01 00 00 00       	mov    $0x1,%eax
   11a3b:	e8 80 fb ff ff       	call   115c0 <end_request>
}
   11a40:	58                   	pop    %eax
   11a41:	5b                   	pop    %ebx
   11a42:	5f                   	pop    %edi
	do_hd_request();
   11a43:	e9 6f fc ff ff       	jmp    116b7 <do_hd_request>

00011a48 <write_intr>:
{
   11a48:	56                   	push   %esi
   11a49:	53                   	push   %ebx
   11a4a:	51                   	push   %ecx
   11a4b:	e8 dc 4f ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11a50:	81 c3 b0 f5 00 00    	add    $0xf5b0,%ebx
	if (win_result()) {									// 如果硬盘控制器返回错误信息,则首先进行硬盘读写失败处理,再次请求硬盘作相应(复位)处理.
   11a56:	e8 41 fa ff ff       	call   1149c <win_result>
   11a5b:	85 c0                	test   %eax,%eax
   11a5d:	74 07                	je     11a66 <write_intr+0x1e>
		bad_rw_intr();
   11a5f:	e8 12 fc ff ff       	call   11676 <bad_rw_intr>
   11a64:	eb 4f                	jmp    11ab5 <write_intr+0x6d>
	if (--CURRENT->nr_sectors) {						// 若还有扇区要写,则
   11a66:	c7 c0 40 50 02 00    	mov    $0x25040,%eax
   11a6c:	8b 40 1c             	mov    0x1c(%eax),%eax
   11a6f:	ff 48 10             	decl   0x10(%eax)
   11a72:	74 37                	je     11aab <write_intr+0x63>
		CURRENT->buffer += 512;							// 调整请求缓冲区指针,
   11a74:	8b 70 14             	mov    0x14(%eax),%esi
		CURRENT->sector++;								// 当前请求起始扇区号+1,
   11a77:	ff 40 0c             	incl   0xc(%eax)
		port_write(HD_DATA, CURRENT->buffer, 256);		// 向数据端口写256字.
   11a7a:	ba f0 01 00 00       	mov    $0x1f0,%edx
		SET_INTR(&write_intr);							// do_hd置函数指针为write_intr().
   11a7f:	c7 83 f0 40 00 00 c8 	movl   $0xc8,0x40f0(%ebx)
   11a86:	00 00 00 
		port_write(HD_DATA, CURRENT->buffer, 256);		// 向数据端口写256字.
   11a89:	b9 00 01 00 00       	mov    $0x100,%ecx
		CURRENT->buffer += 512;							// 调整请求缓冲区指针,
   11a8e:	81 c6 00 02 00 00    	add    $0x200,%esi
   11a94:	89 70 14             	mov    %esi,0x14(%eax)
		SET_INTR(&write_intr);							// do_hd置函数指针为write_intr().
   11a97:	8d 83 48 0a ff ff    	lea    -0xf5b8(%ebx),%eax
   11a9d:	89 83 f4 40 00 00    	mov    %eax,0x40f4(%ebx)
		port_write(HD_DATA, CURRENT->buffer, 256);		// 向数据端口写256字.
   11aa3:	fc                   	cld    
   11aa4:	f3 66 6f             	rep outsw %ds:(%esi),(%dx)
}
   11aa7:	5a                   	pop    %edx
   11aa8:	5b                   	pop    %ebx
   11aa9:	5e                   	pop    %esi
   11aaa:	c3                   	ret    
	end_request(1);										// 数据已更新标志置位(1).
   11aab:	b8 01 00 00 00       	mov    $0x1,%eax
   11ab0:	e8 0b fb ff ff       	call   115c0 <end_request>
}
   11ab5:	58                   	pop    %eax
   11ab6:	5b                   	pop    %ebx
   11ab7:	5e                   	pop    %esi
	do_hd_request();
   11ab8:	e9 fa fb ff ff       	jmp    116b7 <do_hd_request>

00011abd <sys_setup>:
{
   11abd:	55                   	push   %ebp
   11abe:	57                   	push   %edi
   11abf:	83 c8 ff             	or     $0xffffffff,%eax
   11ac2:	56                   	push   %esi
   11ac3:	53                   	push   %ebx
   11ac4:	e8 63 4f ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11ac9:	81 c3 37 f5 00 00    	add    $0xf537,%ebx
   11acf:	83 ec 1c             	sub    $0x1c,%esp
	if (!callable)
   11ad2:	83 bb e4 14 00 00 00 	cmpl   $0x0,0x14e4(%ebx)
{
   11ad9:	8b 54 24 30          	mov    0x30(%esp),%edx
	if (!callable)
   11add:	0f 84 c3 02 00 00    	je     11da6 <sys_setup+0x2e9>
		hd_info[drive].cyl = *(unsigned short *) BIOS;							// 柱面数
   11ae3:	0f b7 02             	movzwl (%edx),%eax
   11ae6:	8d b3 c0 40 00 00    	lea    0x40c0(%ebx),%esi
	callable = 0;
   11aec:	c7 83 e4 14 00 00 00 	movl   $0x0,0x14e4(%ebx)
   11af3:	00 00 00 
		hd_info[drive].cyl = *(unsigned short *) BIOS;							// 柱面数
   11af6:	89 83 c8 40 00 00    	mov    %eax,0x40c8(%ebx)
		hd_info[drive].head = *(unsigned char *) (2 + BIOS);					// 磁头数
   11afc:	0f b6 42 02          	movzbl 0x2(%edx),%eax
   11b00:	89 83 c0 40 00 00    	mov    %eax,0x40c0(%ebx)
		hd_info[drive].wpcom = *(unsigned short *) (5 + BIOS);					// 写前预补偿柱面号
   11b06:	0f b7 42 05          	movzwl 0x5(%edx),%eax
   11b0a:	89 83 cc 40 00 00    	mov    %eax,0x40cc(%ebx)
		hd_info[drive].ctl = *(unsigned char *) (8 + BIOS);						// 控制字节
   11b10:	0f b6 42 08          	movzbl 0x8(%edx),%eax
   11b14:	89 83 d4 40 00 00    	mov    %eax,0x40d4(%ebx)
		hd_info[drive].lzone = *(unsigned short *) (12 + BIOS);					// 磁头着陆区柱面号
   11b1a:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
   11b1e:	89 83 d0 40 00 00    	mov    %eax,0x40d0(%ebx)
		hd_info[drive].sect = *(unsigned char *) (14 + BIOS);					// 每磁道扇区数
   11b24:	0f b6 42 0e          	movzbl 0xe(%edx),%eax
   11b28:	89 83 c4 40 00 00    	mov    %eax,0x40c4(%ebx)
		hd_info[drive].cyl = *(unsigned short *) BIOS;							// 柱面数
   11b2e:	0f b7 42 10          	movzwl 0x10(%edx),%eax
   11b32:	89 83 e0 40 00 00    	mov    %eax,0x40e0(%ebx)
		hd_info[drive].head = *(unsigned char *) (2 + BIOS);					// 磁头数
   11b38:	0f b6 4a 12          	movzbl 0x12(%edx),%ecx
		NR_HD = 2;																// 硬盘数置为2.
   11b3c:	83 f8 01             	cmp    $0x1,%eax
   11b3f:	19 c0                	sbb    %eax,%eax
	for (i = 0 ; i < NR_HD ; i++) {
   11b41:	31 ed                	xor    %ebp,%ebp
		NR_HD = 2;																// 硬盘数置为2.
   11b43:	83 c0 02             	add    $0x2,%eax
   11b46:	89 83 90 41 00 00    	mov    %eax,0x4190(%ebx)
		hd_info[drive].head = *(unsigned char *) (2 + BIOS);					// 磁头数
   11b4c:	89 8b d8 40 00 00    	mov    %ecx,0x40d8(%ebx)
		hd_info[drive].wpcom = *(unsigned short *) (5 + BIOS);					// 写前预补偿柱面号
   11b52:	0f b7 4a 15          	movzwl 0x15(%edx),%ecx
   11b56:	89 8b e4 40 00 00    	mov    %ecx,0x40e4(%ebx)
		hd_info[drive].ctl = *(unsigned char *) (8 + BIOS);						// 控制字节
   11b5c:	0f b6 4a 18          	movzbl 0x18(%edx),%ecx
   11b60:	89 8b ec 40 00 00    	mov    %ecx,0x40ec(%ebx)
		hd_info[drive].lzone = *(unsigned short *) (12 + BIOS);					// 磁头着陆区柱面号
   11b66:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
   11b6a:	89 8b e8 40 00 00    	mov    %ecx,0x40e8(%ebx)
		hd_info[drive].sect = *(unsigned char *) (14 + BIOS);					// 每磁道扇区数
   11b70:	0f b6 52 1e          	movzbl 0x1e(%edx),%edx
	for (i = 0 ; i < NR_HD ; i++) {
   11b74:	89 f1                	mov    %esi,%ecx
		hd_info[drive].sect = *(unsigned char *) (14 + BIOS);					// 每磁道扇区数
   11b76:	89 93 dc 40 00 00    	mov    %edx,0x40dc(%ebx)
   11b7c:	8d 93 40 41 00 00    	lea    0x4140(%ebx),%edx
   11b82:	89 54 24 0c          	mov    %edx,0xc(%esp)
	for (i = 0 ; i < NR_HD ; i++) {
   11b86:	39 e8                	cmp    %ebp,%eax
   11b88:	7e 1c                	jle    11ba6 <sys_setup+0xe9>
		hd[i * 5].nr_sects = hd_info[i].head * hd_info[i].sect * hd_info[i].cyl;// 硬盘总扇区数
   11b8a:	8b 39                	mov    (%ecx),%edi
		hd[i * 5].start_sect = 0;												// 硬盘起始扇区号
   11b8c:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	for (i = 0 ; i < NR_HD ; i++) {
   11b92:	45                   	inc    %ebp
		hd[i * 5].nr_sects = hd_info[i].head * hd_info[i].sect * hd_info[i].cyl;// 硬盘总扇区数
   11b93:	0f af 79 04          	imul   0x4(%ecx),%edi
   11b97:	83 c2 28             	add    $0x28,%edx
   11b9a:	83 c1 18             	add    $0x18,%ecx
   11b9d:	0f af 79 f0          	imul   -0x10(%ecx),%edi
   11ba1:	89 7a dc             	mov    %edi,-0x24(%edx)
   11ba4:	eb e0                	jmp    11b86 <sys_setup+0xc9>
	if ((cmos_disks = CMOS_READ(0x12)) & 0xf0)
   11ba6:	b8 92 00 00 00       	mov    $0x92,%eax
   11bab:	ba 70 00 00 00       	mov    $0x70,%edx
   11bb0:	ee                   	out    %al,(%dx)
   11bb1:	eb 00                	jmp    11bb3 <sys_setup+0xf6>
   11bb3:	eb 00                	jmp    11bb5 <sys_setup+0xf8>
   11bb5:	ba 71 00 00 00       	mov    $0x71,%edx
   11bba:	ec                   	in     (%dx),%al
   11bbb:	eb 00                	jmp    11bbd <sys_setup+0x100>
   11bbd:	eb 00                	jmp    11bbf <sys_setup+0x102>
   11bbf:	a8 f0                	test   $0xf0,%al
   11bc1:	74 12                	je     11bd5 <sys_setup+0x118>
		if (cmos_disks & 0x0f)
   11bc3:	83 e0 0f             	and    $0xf,%eax
			NR_HD = 2;
   11bc6:	3c 01                	cmp    $0x1,%al
   11bc8:	19 c0                	sbb    %eax,%eax
   11bca:	83 c0 02             	add    $0x2,%eax
   11bcd:	89 83 90 41 00 00    	mov    %eax,0x4190(%ebx)
   11bd3:	eb 0a                	jmp    11bdf <sys_setup+0x122>
		NR_HD = 0;
   11bd5:	c7 83 90 41 00 00 00 	movl   $0x0,0x4190(%ebx)
   11bdc:	00 00 00 
	for (i = NR_HD ; i < 2 ; i++) {
   11bdf:	8b 93 90 41 00 00    	mov    0x4190(%ebx),%edx
   11be5:	6b c2 28             	imul   $0x28,%edx,%eax
   11be8:	03 44 24 0c          	add    0xc(%esp),%eax
   11bec:	83 fa 01             	cmp    $0x1,%edx
   11bef:	7f 13                	jg     11c04 <sys_setup+0x147>
		hd[i * 5].start_sect = 0;
   11bf1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		hd[i * 5].nr_sects = 0;
   11bf7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	for (i = NR_HD ; i < 2 ; i++) {
   11bfe:	42                   	inc    %edx
   11bff:	83 c0 28             	add    $0x28,%eax
   11c02:	eb e8                	jmp    11bec <sys_setup+0x12f>
   11c04:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
   11c0b:	00 
	for (drive = 0 ; drive < NR_HD ; drive++) {
   11c0c:	31 ff                	xor    %edi,%edi
   11c0e:	39 bb 90 41 00 00    	cmp    %edi,0x4190(%ebx)
   11c14:	0f 8e c9 00 00 00    	jle    11ce3 <sys_setup+0x226>
		if (!(bh = bread(0x300 + drive * 5, 0))) {								// 0x300,0x305是设备号.
   11c1a:	50                   	push   %eax
   11c1b:	50                   	push   %eax
   11c1c:	8d 04 bf             	lea    (%edi,%edi,4),%eax
   11c1f:	6a 00                	push   $0x0
   11c21:	05 00 03 00 00       	add    $0x300,%eax
   11c26:	50                   	push   %eax
   11c27:	e8 84 a7 ff ff       	call   c3b0 <bread>
   11c2c:	89 44 24 10          	mov    %eax,0x10(%esp)
   11c30:	83 c4 10             	add    $0x10,%esp
   11c33:	85 c0                	test   %eax,%eax
   11c35:	75 20                	jne    11c57 <sys_setup+0x19a>
			printk("Unable to read partition table of drive %d\n\r",
   11c37:	8d 83 b1 7a ff ff    	lea    -0x854f(%ebx),%eax
   11c3d:	55                   	push   %ebp
   11c3e:	55                   	push   %ebp
   11c3f:	57                   	push   %edi
   11c40:	50                   	push   %eax
   11c41:	e8 db 64 ff ff       	call   8121 <printk>
			panic("");
   11c46:	8d 83 0c 73 ff ff    	lea    -0x8cf4(%ebx),%eax
   11c4c:	89 04 24             	mov    %eax,(%esp)
   11c4f:	e8 7e 64 ff ff       	call   80d2 <panic>
   11c54:	83 c4 10             	add    $0x10,%esp
		if (bh->b_data[510] != 0x55 || (unsigned char)
   11c57:	8b 04 24             	mov    (%esp),%eax
   11c5a:	8b 00                	mov    (%eax),%eax
   11c5c:	80 b8 fe 01 00 00 55 	cmpb   $0x55,0x1fe(%eax)
   11c63:	75 09                	jne    11c6e <sys_setup+0x1b1>
   11c65:	80 b8 ff 01 00 00 aa 	cmpb   $0xaa,0x1ff(%eax)
   11c6c:	74 20                	je     11c8e <sys_setup+0x1d1>
			printk("Bad partition table on drive %d\n\r",drive);
   11c6e:	8d 83 de 7a ff ff    	lea    -0x8522(%ebx),%eax
   11c74:	51                   	push   %ecx
   11c75:	51                   	push   %ecx
   11c76:	57                   	push   %edi
   11c77:	50                   	push   %eax
   11c78:	e8 a4 64 ff ff       	call   8121 <printk>
			panic("");
   11c7d:	8d 83 0c 73 ff ff    	lea    -0x8cf4(%ebx),%eax
   11c83:	89 04 24             	mov    %eax,(%esp)
   11c86:	e8 47 64 ff ff       	call   80d2 <panic>
   11c8b:	83 c4 10             	add    $0x10,%esp
		p = 0x1BE + (void *)bh->b_data;	 										// 分区表位于第1扇区0x1BE处.
   11c8e:	8b 04 24             	mov    (%esp),%eax
   11c91:	8b 00                	mov    (%eax),%eax
   11c93:	89 44 24 08          	mov    %eax,0x8(%esp)
   11c97:	31 c0                	xor    %eax,%eax
			hd[i + 5 * drive].start_sect = p->start_sect;
   11c99:	8b 6c 24 08          	mov    0x8(%esp),%ebp
   11c9d:	8b 54 24 0c          	mov    0xc(%esp),%edx
   11ca1:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   11ca5:	8b ac 45 c6 01 00 00 	mov    0x1c6(%ebp,%eax,2),%ebp
   11cac:	01 c2                	add    %eax,%edx
   11cae:	89 6c 0a 08          	mov    %ebp,0x8(%edx,%ecx,1)
			hd[i + 5 * drive].nr_sects = p->nr_sects;
   11cb2:	8b 6c 24 08          	mov    0x8(%esp),%ebp
   11cb6:	8b ac 45 ca 01 00 00 	mov    0x1ca(%ebp,%eax,2),%ebp
   11cbd:	83 c0 08             	add    $0x8,%eax
		for (i = 1; i < 5; i++, p++) {
   11cc0:	83 f8 20             	cmp    $0x20,%eax
			hd[i + 5 * drive].nr_sects = p->nr_sects;
   11cc3:	89 6c 0a 0c          	mov    %ebp,0xc(%edx,%ecx,1)
		for (i = 1; i < 5; i++, p++) {
   11cc7:	75 d0                	jne    11c99 <sys_setup+0x1dc>
		brelse(bh);																// 释放为存放硬盘数据块而申请的缓冲区.
   11cc9:	83 ec 0c             	sub    $0xc,%esp
	for (drive = 0 ; drive < NR_HD ; drive++) {
   11ccc:	47                   	inc    %edi
		brelse(bh);																// 释放为存放硬盘数据块而申请的缓冲区.
   11ccd:	ff 74 24 0c          	pushl  0xc(%esp)
   11cd1:	e8 88 a6 ff ff       	call   c35e <brelse>
   11cd6:	83 44 24 14 28       	addl   $0x28,0x14(%esp)
   11cdb:	83 c4 10             	add    $0x10,%esp
   11cde:	e9 2b ff ff ff       	jmp    11c0e <sys_setup+0x151>
	for (i = 0 ; i < 5 * MAX_HD ; i++) {
   11ce3:	31 ff                	xor    %edi,%edi
   11ce5:	8d 2c fd 00 00 00 00 	lea    0x0(,%edi,8),%ebp
		if (hd[i].nr_sects != 0)
   11cec:	8b 84 1d 44 41 00 00 	mov    0x4144(%ebp,%ebx,1),%eax
   11cf3:	85 c0                	test   %eax,%eax
   11cf5:	74 1d                	je     11d14 <sys_setup+0x257>
			Log(LOG_INFO_TYPE, "<<<<< HD Partition%d Info : start_sect = %d, nr_sects = %d >>>>>\n", i, hd[i].start_sect, hd[i].nr_sects);
   11cf7:	83 ec 0c             	sub    $0xc,%esp
   11cfa:	50                   	push   %eax
   11cfb:	8d 83 00 7b ff ff    	lea    -0x8500(%ebx),%eax
   11d01:	ff b4 1d 40 41 00 00 	pushl  0x4140(%ebp,%ebx,1)
   11d08:	57                   	push   %edi
   11d09:	50                   	push   %eax
   11d0a:	6a 00                	push   $0x0
   11d0c:	e8 7e 57 00 00       	call   1748f <Log>
   11d11:	83 c4 20             	add    $0x20,%esp
		hd_sizes[i] = hd[i].nr_sects >> 1 ;
   11d14:	8b 84 1d 44 41 00 00 	mov    0x4144(%ebp,%ebx,1),%eax
   11d1b:	d1 f8                	sar    %eax
   11d1d:	89 84 bb 00 41 00 00 	mov    %eax,0x4100(%ebx,%edi,4)
	for (i = 0 ; i < 5 * MAX_HD ; i++) {
   11d24:	47                   	inc    %edi
   11d25:	83 ff 0a             	cmp    $0xa,%edi
   11d28:	75 bb                	jne    11ce5 <sys_setup+0x228>
	blk_size[MAJOR_NR] = hd_sizes;
   11d2a:	c7 c0 20 50 02 00    	mov    $0x25020,%eax
   11d30:	8d 93 00 41 00 00    	lea    0x4100(%ebx),%edx
   11d36:	89 50 0c             	mov    %edx,0xc(%eax)
	if (NR_HD)
   11d39:	8b 93 90 41 00 00    	mov    0x4190(%ebx),%edx
   11d3f:	85 d2                	test   %edx,%edx
   11d41:	75 13                	jne    11d56 <sys_setup+0x299>
	rd_load();																	// blk_drv/ramdisk.c
   11d43:	e8 38 03 00 00       	call   12080 <rd_load>
	init_swapping();															// mm/swap.c
   11d48:	e8 e4 8e ff ff       	call   ac31 <init_swapping>
	mount_root();																// fs/super.c
   11d4d:	e8 20 ae ff ff       	call   cb72 <mount_root>
	return (0);
   11d52:	31 c0                	xor    %eax,%eax
   11d54:	eb 50                	jmp    11da6 <sys_setup+0x2e9>
		Log(LOG_INFO_TYPE, "<<<<< Partition table%s ok. >>>>>\n\r",(NR_HD > 1) ? "s":"");
   11d56:	4a                   	dec    %edx
   11d57:	8d 83 b8 68 ff ff    	lea    -0x9748(%ebx),%eax
   11d5d:	7f 06                	jg     11d65 <sys_setup+0x2a8>
   11d5f:	8d 83 0c 73 ff ff    	lea    -0x8cf4(%ebx),%eax
   11d65:	52                   	push   %edx
   11d66:	50                   	push   %eax
   11d67:	8d 83 42 7b ff ff    	lea    -0x84be(%ebx),%eax
   11d6d:	31 ff                	xor    %edi,%edi
   11d6f:	50                   	push   %eax
   11d70:	6a 00                	push   $0x0
   11d72:	e8 18 57 00 00       	call   1748f <Log>
   11d77:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NR_HD; i++)
   11d7a:	39 bb 90 41 00 00    	cmp    %edi,0x4190(%ebx)
   11d80:	7e c1                	jle    11d43 <sys_setup+0x286>
		Log(LOG_INFO_TYPE, "<<<<< HD%d Info: cyl = %d, head = %d, sect = %d, ctl = %x >>>>>\n", hd_info[i].cyl, hd_info[i].head, hd_info[i].sect, hd_info[i].ctl);
   11d82:	50                   	push   %eax
   11d83:	50                   	push   %eax
   11d84:	8d 83 66 7b ff ff    	lea    -0x849a(%ebx),%eax
   11d8a:	ff 76 14             	pushl  0x14(%esi)
   11d8d:	ff 76 04             	pushl  0x4(%esi)
	for (i = 0; i < NR_HD; i++)
   11d90:	47                   	inc    %edi
		Log(LOG_INFO_TYPE, "<<<<< HD%d Info: cyl = %d, head = %d, sect = %d, ctl = %x >>>>>\n", hd_info[i].cyl, hd_info[i].head, hd_info[i].sect, hd_info[i].ctl);
   11d91:	ff 36                	pushl  (%esi)
   11d93:	ff 76 08             	pushl  0x8(%esi)
   11d96:	83 c6 18             	add    $0x18,%esi
   11d99:	50                   	push   %eax
   11d9a:	6a 00                	push   $0x0
   11d9c:	e8 ee 56 00 00       	call   1748f <Log>
   11da1:	83 c4 20             	add    $0x20,%esp
   11da4:	eb d4                	jmp    11d7a <sys_setup+0x2bd>
}
   11da6:	83 c4 1c             	add    $0x1c,%esp
   11da9:	5b                   	pop    %ebx
   11daa:	5e                   	pop    %esi
   11dab:	5f                   	pop    %edi
   11dac:	5d                   	pop    %ebp
   11dad:	c3                   	ret    

00011dae <unexpected_hd_interrupt>:
{
   11dae:	53                   	push   %ebx
   11daf:	e8 78 4c ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11db4:	81 c3 4c f2 00 00    	add    $0xf24c,%ebx
   11dba:	83 ec 14             	sub    $0x14,%esp
	printk("Unexpected HD interrupt\n\r");
   11dbd:	8d 83 a7 7b ff ff    	lea    -0x8459(%ebx),%eax
   11dc3:	50                   	push   %eax
   11dc4:	e8 58 63 ff ff       	call   8121 <printk>
	reset = 1;
   11dc9:	c7 83 94 41 00 00 01 	movl   $0x1,0x4194(%ebx)
   11dd0:	00 00 00 
}
   11dd3:	83 c4 18             	add    $0x18,%esp
   11dd6:	5b                   	pop    %ebx
	do_hd_request();
   11dd7:	e9 db f8 ff ff       	jmp    116b7 <do_hd_request>

00011ddc <hd_times_out>:
{
   11ddc:	56                   	push   %esi
   11ddd:	53                   	push   %ebx
   11dde:	e8 49 4c ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11de3:	81 c3 1d f2 00 00    	add    $0xf21d,%ebx
   11de9:	51                   	push   %ecx
	if (!CURRENT)
   11dea:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   11df0:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
   11df4:	74 4e                	je     11e44 <hd_times_out+0x68>
	printk("HD timeout");
   11df6:	8d 83 c1 7b ff ff    	lea    -0x843f(%ebx),%eax
   11dfc:	83 ec 0c             	sub    $0xc,%esp
   11dff:	50                   	push   %eax
   11e00:	e8 1c 63 ff ff       	call   8121 <printk>
	if (++CURRENT->errors >= MAX_ERRORS)
   11e05:	8b 56 1c             	mov    0x1c(%esi),%edx
   11e08:	83 c4 10             	add    $0x10,%esp
   11e0b:	8b 42 08             	mov    0x8(%edx),%eax
   11e0e:	40                   	inc    %eax
   11e0f:	83 f8 06             	cmp    $0x6,%eax
   11e12:	89 42 08             	mov    %eax,0x8(%edx)
   11e15:	7e 07                	jle    11e1e <hd_times_out+0x42>
		end_request(0);
   11e17:	31 c0                	xor    %eax,%eax
   11e19:	e8 a2 f7 ff ff       	call   115c0 <end_request>
	SET_INTR(NULL);										// 令do_hd = NULL,time_out=200
   11e1e:	c7 83 f4 40 00 00 00 	movl   $0x0,0x40f4(%ebx)
   11e25:	00 00 00 
   11e28:	c7 83 f0 40 00 00 c8 	movl   $0xc8,0x40f0(%ebx)
   11e2f:	00 00 00 
	reset = 1;											// 设置复位标志.
   11e32:	c7 83 94 41 00 00 01 	movl   $0x1,0x4194(%ebx)
   11e39:	00 00 00 
}
   11e3c:	5a                   	pop    %edx
   11e3d:	5b                   	pop    %ebx
   11e3e:	5e                   	pop    %esi
	do_hd_request();
   11e3f:	e9 73 f8 ff ff       	jmp    116b7 <do_hd_request>
}
   11e44:	58                   	pop    %eax
   11e45:	5b                   	pop    %ebx
   11e46:	5e                   	pop    %esi
   11e47:	c3                   	ret    

00011e48 <hd_init>:
// 设置硬盘中断描述符,并允许硬盘控制器发送中断请求信号.
// 该函数设置硬盘设备的请求项处理函数指针为do_hd_request(),然后设置硬盘中断门描述符.hd_interrup(kernel/sys_call.s)是其中断处理过程地址.硬盘中断号为int 0x2E(46),对应8259A
// 芯片的中断请求信号IRQ13.接着复位接联的主8259A int 2屏蔽位,允许从片发出中断请求信号.再复位硬盘的中断请求屏蔽位(在从片上),允许硬盘控制器发送中断请求信号.中断描述符表IDT内中断门
// 描述符设置宏set_intr_gate()在include/asm/system.h中实现.
void hd_init(void)
{
   11e48:	e8 2d 80 ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   11e4d:	05 b3 f1 00 00       	add    $0xf1b3,%eax
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;				// do_hd_request().
   11e52:	c7 c2 40 50 02 00    	mov    $0x25040,%edx
   11e58:	8d 88 b7 06 ff ff    	lea    -0xf949(%eax),%ecx
   11e5e:	89 4a 18             	mov    %ecx,0x18(%edx)
	set_intr_gate(0x2E, &hd_interrupt);							// 设置中断门中处理函数指针
   11e61:	c7 c1 88 57 00 00    	mov    $0x5788,%ecx
   11e67:	c7 c2 b0 74 00 00    	mov    $0x74b0,%edx
   11e6d:	b8 00 00 08 00       	mov    $0x80000,%eax
   11e72:	66 89 d0             	mov    %dx,%ax
   11e75:	66 ba 00 8e          	mov    $0x8e00,%dx
   11e79:	89 81 70 01 00 00    	mov    %eax,0x170(%ecx)
   11e7f:	89 91 74 01 00 00    	mov    %edx,0x174(%ecx)
	outb_p(inb_p(0x21) & 0xfb, 0x21);							// 复位接联的主8259A int 2的屏蔽位
   11e85:	ba 21 00 00 00       	mov    $0x21,%edx
   11e8a:	ec                   	in     (%dx),%al
   11e8b:	eb 00                	jmp    11e8d <hd_init+0x45>
   11e8d:	eb 00                	jmp    11e8f <hd_init+0x47>
   11e8f:	25 fb 00 00 00       	and    $0xfb,%eax
   11e94:	ee                   	out    %al,(%dx)
   11e95:	eb 00                	jmp    11e97 <hd_init+0x4f>
   11e97:	eb 00                	jmp    11e99 <hd_init+0x51>
	outb(inb_p(0xA1) & 0xbf, 0xA1);								// 复位硬盘中断请求屏蔽位(在从片上).
   11e99:	ba a1 00 00 00       	mov    $0xa1,%edx
   11e9e:	ec                   	in     (%dx),%al
   11e9f:	eb 00                	jmp    11ea1 <hd_init+0x59>
   11ea1:	eb 00                	jmp    11ea3 <hd_init+0x5b>
   11ea3:	25 bf 00 00 00       	and    $0xbf,%eax
   11ea8:	ee                   	out    %al,(%dx)
}
   11ea9:	c3                   	ret    

00011eaa <end_request>:
{
   11eaa:	55                   	push   %ebp
   11eab:	57                   	push   %edi
   11eac:	89 c7                	mov    %eax,%edi
   11eae:	56                   	push   %esi
   11eaf:	53                   	push   %ebx
   11eb0:	e8 77 4b ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11eb5:	81 c3 4b f1 00 00    	add    $0xf14b,%ebx
   11ebb:	83 ec 0c             	sub    $0xc,%esp
	if (CURRENT->bh) {									// CURRENT为当前请求结构项指针
   11ebe:	c7 c6 40 50 02 00    	mov    $0x25040,%esi
   11ec4:	8b 46 0c             	mov    0xc(%esi),%eax
   11ec7:	8b 68 1c             	mov    0x1c(%eax),%ebp
   11eca:	85 ed                	test   %ebp,%ebp
   11ecc:	74 30                	je     11efe <end_request+0x54>
	if (!bh->b_lock)
   11ece:	80 7d 0d 00          	cmpb   $0x0,0xd(%ebp)
		CURRENT->bh->b_uptodate = uptodate;				// 置更新标志.
   11ed2:	89 f8                	mov    %edi,%eax
   11ed4:	88 45 0a             	mov    %al,0xa(%ebp)
	if (!bh->b_lock)
   11ed7:	75 12                	jne    11eeb <end_request+0x41>
		printk(DEVICE_NAME ": free buffer being unlocked\n");
   11ed9:	8d 83 cc 7b ff ff    	lea    -0x8434(%ebx),%eax
   11edf:	83 ec 0c             	sub    $0xc,%esp
   11ee2:	50                   	push   %eax
   11ee3:	e8 39 62 ff ff       	call   8121 <printk>
   11ee8:	83 c4 10             	add    $0x10,%esp
	bh->b_lock = 0;
   11eeb:	c6 45 0d 00          	movb   $0x0,0xd(%ebp)
	wake_up(&bh->b_wait);
   11eef:	83 ec 0c             	sub    $0xc,%esp
   11ef2:	83 c5 10             	add    $0x10,%ebp
   11ef5:	55                   	push   %ebp
   11ef6:	e8 98 4f ff ff       	call   6e93 <wake_up>
   11efb:	83 c4 10             	add    $0x10,%esp
	if (!uptodate) {									// 若更新标志为0则显示出错信息.
   11efe:	85 ff                	test   %edi,%edi
   11f00:	75 2c                	jne    11f2e <end_request+0x84>
		printk(DEVICE_NAME " I/O error\n\r");
   11f02:	8d 83 f1 7b ff ff    	lea    -0x840f(%ebx),%eax
   11f08:	83 ec 0c             	sub    $0xc,%esp
   11f0b:	50                   	push   %eax
   11f0c:	e8 10 62 ff ff       	call   8121 <printk>
			CURRENT->bh->b_blocknr);
   11f11:	8b 46 0c             	mov    0xc(%esi),%eax
		printk("dev %04x, block %d\n\r",CURRENT->dev,
   11f14:	83 c4 0c             	add    $0xc,%esp
   11f17:	8b 50 1c             	mov    0x1c(%eax),%edx
   11f1a:	ff 72 04             	pushl  0x4(%edx)
   11f1d:	ff 30                	pushl  (%eax)
   11f1f:	8d 83 a3 78 ff ff    	lea    -0x875d(%ebx),%eax
   11f25:	50                   	push   %eax
   11f26:	e8 f6 61 ff ff       	call   8121 <printk>
   11f2b:	83 c4 10             	add    $0x10,%esp
	wake_up(&CURRENT->waiting);							// 唤醒等待该请求项的进程.
   11f2e:	8b 46 0c             	mov    0xc(%esi),%eax
   11f31:	83 ec 0c             	sub    $0xc,%esp
   11f34:	83 c0 18             	add    $0x18,%eax
   11f37:	50                   	push   %eax
   11f38:	e8 56 4f ff ff       	call   6e93 <wake_up>
	wake_up(&wait_for_request);							// 唤醒等待空闲请求项的进程.
   11f3d:	58                   	pop    %eax
   11f3e:	ff b3 e0 ff ff ff    	pushl  -0x20(%ebx)
   11f44:	e8 4a 4f ff ff       	call   6e93 <wake_up>
	CURRENT->dev = -1;									// 释放该请求项.
   11f49:	8b 46 0c             	mov    0xc(%esi),%eax
   11f4c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	CURRENT = CURRENT->next;							// 指向下一请求项.
   11f52:	8b 40 20             	mov    0x20(%eax),%eax
   11f55:	89 46 0c             	mov    %eax,0xc(%esi)
}
   11f58:	83 c4 1c             	add    $0x1c,%esp
   11f5b:	5b                   	pop    %ebx
   11f5c:	5e                   	pop    %esi
   11f5d:	5f                   	pop    %edi
   11f5e:	5d                   	pop    %ebp
   11f5f:	c3                   	ret    

00011f60 <do_rd_request>:
// 添加到rd的链表中之后,就会调用该函数对rd当前请求项进行处理.该函数首先计算当前请求项中指定起始扇区对应虚拟盘所处内存
// 的起始位置addr和要求的扇区数对应的字节长度值len,然后根据请求项中的命令进行操作.若是写命令WRITE,就把请求项所指缓
// 冲区中的数据直接复制到内存位置addr处。若是读操作作反之。数据复制完成后即可直接调用end_request()对本次请求项作结束
// 处理。然后跳转到函数开始处再去处理下一个请求项。若已没有请求项则退出。
void do_rd_request(void)
{
   11f60:	55                   	push   %ebp
   11f61:	57                   	push   %edi
   11f62:	56                   	push   %esi
   11f63:	53                   	push   %ebx
   11f64:	e8 c3 4a ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   11f69:	81 c3 97 f0 00 00    	add    $0xf097,%ebx
   11f6f:	83 ec 1c             	sub    $0x1c,%esp

	// 首先检测请求项的合法性,若已没有请求项则退出(参见blk.h).然后计算请求项处理的虚拟盘中起始扇区在物理内存中对应的地址
	// addr和占用的内存字节长度值len.下句用于取得请求项中的起始扇区对应的内存起始位置和内存长度.其中sector<<9表示
	// sector * 512,换算成字节值.CURRENT被定义为(blk_dev[MAJOR_NR].current_request).
	INIT_REQUEST;
	addr = rd_start + (CURRENT->sector << 9);
   11f72:	c7 c0 e0 56 03 00    	mov    $0x356e0,%eax
	INIT_REQUEST;
   11f78:	c7 c5 40 50 02 00    	mov    $0x25040,%ebp
	addr = rd_start + (CURRENT->sector << 9);
   11f7e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	INIT_REQUEST;
   11f82:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f85:	85 c0                	test   %eax,%eax
   11f87:	0f 84 a7 00 00 00    	je     12034 <do_rd_request+0xd4>
   11f8d:	8b 00                	mov    (%eax),%eax
   11f8f:	c1 e8 08             	shr    $0x8,%eax
   11f92:	48                   	dec    %eax
   11f93:	74 12                	je     11fa7 <do_rd_request+0x47>
   11f95:	8d 83 05 7c ff ff    	lea    -0x83fb(%ebx),%eax
   11f9b:	83 ec 0c             	sub    $0xc,%esp
   11f9e:	50                   	push   %eax
   11f9f:	e8 2e 61 ff ff       	call   80d2 <panic>
   11fa4:	83 c4 10             	add    $0x10,%esp
   11fa7:	8b 45 0c             	mov    0xc(%ebp),%eax
   11faa:	8b 40 1c             	mov    0x1c(%eax),%eax
   11fad:	85 c0                	test   %eax,%eax
   11faf:	74 18                	je     11fc9 <do_rd_request+0x69>
   11fb1:	80 78 0d 00          	cmpb   $0x0,0xd(%eax)
   11fb5:	75 12                	jne    11fc9 <do_rd_request+0x69>
   11fb7:	8d 83 25 7c ff ff    	lea    -0x83db(%ebx),%eax
   11fbd:	83 ec 0c             	sub    $0xc,%esp
   11fc0:	50                   	push   %eax
   11fc1:	e8 0c 61 ff ff       	call   80d2 <panic>
   11fc6:	83 c4 10             	add    $0x10,%esp
	addr = rd_start + (CURRENT->sector << 9);
   11fc9:	8b 55 0c             	mov    0xc(%ebp),%edx
	len = CURRENT->nr_sectors << 9;
	// 如果当前请求项中子设备号不为1或者对应内存起始位置大于虚拟盘末尾，则结束该请求项，并跳转到repeat处去处理下一个虚拟
	// 盘请求项。标号repeat定义在宏INIT_REQUEST内，位于宏的开始处，参见blk.h文件。
	if ((MINOR(CURRENT->dev) != 1) || (addr + len > rd_start + rd_length)) {
   11fcc:	80 3a 01             	cmpb   $0x1,(%edx)
   11fcf:	75 21                	jne    11ff2 <do_rd_request+0x92>
	addr = rd_start + (CURRENT->sector << 9);
   11fd1:	8b 44 24 0c          	mov    0xc(%esp),%eax
	len = CURRENT->nr_sectors << 9;
   11fd5:	8b 4a 10             	mov    0x10(%edx),%ecx
	addr = rd_start + (CURRENT->sector << 9);
   11fd8:	8b 30                	mov    (%eax),%esi
   11fda:	8b 42 0c             	mov    0xc(%edx),%eax
	len = CURRENT->nr_sectors << 9;
   11fdd:	c1 e1 09             	shl    $0x9,%ecx
	addr = rd_start + (CURRENT->sector << 9);
   11fe0:	c1 e0 09             	shl    $0x9,%eax
   11fe3:	01 f0                	add    %esi,%eax
	if ((MINOR(CURRENT->dev) != 1) || (addr + len > rd_start + rd_length)) {
   11fe5:	03 b3 9c 41 00 00    	add    0x419c(%ebx),%esi
   11feb:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
   11fee:	39 f7                	cmp    %esi,%edi
   11ff0:	76 04                	jbe    11ff6 <do_rd_request+0x96>
		end_request(0);
   11ff2:	31 c0                	xor    %eax,%eax
   11ff4:	eb 34                	jmp    1202a <do_rd_request+0xca>
		goto repeat;
	}
	// 然后进行实际的读写操作。如果是写命令(WRITE)，则将请求项中缓冲区的内容复制到地址addr处，长度为len字节。如果是读命
	// 令(READ)，则将addr开始的内存内容复制到请求项缓冲区中，长度为len字节。否则显示命令不存在，死机。
	if (CURRENT-> cmd == WRITE) {
   11ff6:	8b 72 04             	mov    0x4(%edx),%esi
   11ff9:	83 fe 01             	cmp    $0x1,%esi
   11ffc:	75 07                	jne    12005 <do_rd_request+0xa5>

// 内存块复制.从源地址src处开始复制n个字节到目的地址dest处.
// 参数:dest - 复制的目的地址,src - 复制的源地址,n - 复制字节数.
static inline void * memcpy(void * dest, const void * src, int n)
{
__asm__(
   11ffe:	8b 72 14             	mov    0x14(%edx),%esi
   12001:	89 c7                	mov    %eax,%edi
   12003:	eb 09                	jmp    1200e <do_rd_request+0xae>
		(void ) memcpy(addr,
			      CURRENT->buffer,
			      len);
	} else if (CURRENT->cmd == READ) {
   12005:	85 f6                	test   %esi,%esi
   12007:	75 0a                	jne    12013 <do_rd_request+0xb3>
   12009:	8b 7a 14             	mov    0x14(%edx),%edi
   1200c:	89 c6                	mov    %eax,%esi
   1200e:	fc                   	cld    
   1200f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   12011:	eb 12                	jmp    12025 <do_rd_request+0xc5>
		(void) memcpy(CURRENT->buffer,
			      addr,
			      len);
	} else
		panic("unknown ramdisk-command");
   12013:	8d 83 3f 7c ff ff    	lea    -0x83c1(%ebx),%eax
   12019:	83 ec 0c             	sub    $0xc,%esp
   1201c:	50                   	push   %eax
   1201d:	e8 b0 60 ff ff       	call   80d2 <panic>
   12022:	83 c4 10             	add    $0x10,%esp
	// 然后在请求项成功后处理，置更新标志。并继续处理本设备的下一请求项。
	end_request(1);
   12025:	b8 01 00 00 00       	mov    $0x1,%eax
   1202a:	e8 7b fe ff ff       	call   11eaa <end_request>
	goto repeat;
   1202f:	e9 4e ff ff ff       	jmp    11f82 <do_rd_request+0x22>
}
   12034:	83 c4 1c             	add    $0x1c,%esp
   12037:	5b                   	pop    %ebx
   12038:	5e                   	pop    %esi
   12039:	5f                   	pop    %edi
   1203a:	5d                   	pop    %ebp
   1203b:	c3                   	ret    

0001203c <rd_init>:
// 该函数首先设置虚拟盘设备的请求项处理函数指针指向do_rd_request(),然后确定虚拟盘在物理内存中的起始地址,占用字节长度
// 值.并对整个虚拟盘区清零.最后返回盘区长度.当linux/Makefile文件中设置过RAMDISK值不为零时,表示系统中会创建RAM虚拟盘
// 设备.在这种情况下的内核初始化过程中,本函数就会被调用(init/main.c).该函数在第2个参数length会被赋值成RAMDISK*1024
// 单位为字节.
long rd_init(long mem_start, int length)
{
   1203c:	e8 e7 49 ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
   12041:	81 c2 bf ef 00 00    	add    $0xefbf,%edx
   12047:	56                   	push   %esi
   12048:	53                   	push   %ebx
	int	i;
	char	*cp;

	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   12049:	c7 c3 40 50 02 00    	mov    $0x25040,%ebx
   1204f:	8d b2 60 0f ff ff    	lea    -0xf0a0(%edx),%esi
{
   12055:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   12059:	8b 44 24 10          	mov    0x10(%esp),%eax
	blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;
   1205d:	89 73 08             	mov    %esi,0x8(%ebx)
	rd_start = (char *) mem_start;
   12060:	c7 c3 e0 56 03 00    	mov    $0x356e0,%ebx
	rd_length = length;
   12066:	89 82 9c 41 00 00    	mov    %eax,0x419c(%edx)
	cp = rd_start;
	// 将内存空间清零
	for (i = 0; i < length; i++)
   1206c:	31 d2                	xor    %edx,%edx
	rd_start = (char *) mem_start;
   1206e:	89 0b                	mov    %ecx,(%ebx)
	for (i = 0; i < length; i++)
   12070:	39 c2                	cmp    %eax,%edx
   12072:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
   12075:	7d 06                	jge    1207d <rd_init+0x41>
		*cp++ = '\0';
   12077:	c6 03 00             	movb   $0x0,(%ebx)
	for (i = 0; i < length; i++)
   1207a:	42                   	inc    %edx
   1207b:	eb f3                	jmp    12070 <rd_init+0x34>
	return(length);
}
   1207d:	5b                   	pop    %ebx
   1207e:	5e                   	pop    %esi
   1207f:	c3                   	ret    

00012080 <rd_load>:
 */
// 尝试根文件系统加载到虚拟盘中.
// 该函数将在内核设置函数setup()(hd.c)中被调用.另外,1磁盘块 = 1024字节.变量block=256表示根文件系统映像被存储于boot盘第
// 256磁盘块开始处.
void rd_load(void)
{
   12080:	55                   	push   %ebp
   12081:	57                   	push   %edi
   12082:	56                   	push   %esi
   12083:	53                   	push   %ebx
   12084:	e8 a3 49 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   12089:	81 c3 77 ef 00 00    	add    $0xef77,%ebx
   1208f:	83 ec 1c             	sub    $0x1c,%esp
	int		nblocks;									// 文件系统盘块总数.
	char		*cp;									/* Move pointer */

	// 首先检查虚拟盘的有效性和完整性.如果ramdisk的长度为零,则退出.否则显示ramdisk的大小以及内存起始位置.如果此时根文件设备不是软盘
	// 设备,则也退出.
	if (!rd_length)
   12092:	8b 83 9c 41 00 00    	mov    0x419c(%ebx),%eax
   12098:	85 c0                	test   %eax,%eax
   1209a:	0f 84 5d 01 00 00    	je     121fd <rd_load+0x17d>
		return;
	printk("Ram disk: %d bytes, starting at 0x%x, dev = 0x%x \n", rd_length, (int) rd_start, ROOT_DEV);
   120a0:	c7 c6 0c 50 02 00    	mov    $0x2500c,%esi
   120a6:	89 74 24 08          	mov    %esi,0x8(%esp)
   120aa:	ff 36                	pushl  (%esi)
   120ac:	c7 c6 e0 56 03 00    	mov    $0x356e0,%esi
   120b2:	ff 36                	pushl  (%esi)
   120b4:	50                   	push   %eax
   120b5:	8d 83 57 7c ff ff    	lea    -0x83a9(%ebx),%eax
   120bb:	50                   	push   %eax
   120bc:	e8 60 60 ff ff       	call   8121 <printk>
	if (MAJOR(ROOT_DEV) != 2)
   120c1:	8b 44 24 18          	mov    0x18(%esp),%eax
   120c5:	83 c4 10             	add    $0x10,%esp
   120c8:	8b 00                	mov    (%eax),%eax
   120ca:	89 c2                	mov    %eax,%edx
   120cc:	c1 ea 08             	shr    $0x8,%edx
   120cf:	83 fa 02             	cmp    $0x2,%edx
   120d2:	0f 85 25 01 00 00    	jne    121fd <rd_load+0x17d>
		return;
	// 然后读根文件系统的基本参数.即读软盘块256+1,256和256+2.这里block+1是指磁盘上的超级块.breada()用于读取指定的数据块,并标出还需要读的块,
	// 然后返回含有数据块的缓冲区指针.如果返回NULL,则表示数据块不可读(fs/buffer.c).然后把缓冲区中的磁盘超级块(d_super_block是磁盘超级
	// 块结构)复制到s变量中,并释放缓冲区.接着我们开始对超级块的有效性进行判断.超级块中文件系统魔数不对,则说明加载的数据块不是MINIX文件
	// 系统,于是退出.
	bh = breada(ROOT_DEV, block + 1, block, block + 2, -1);
   120d8:	83 ec 0c             	sub    $0xc,%esp
   120db:	6a ff                	push   $0xffffffff
   120dd:	68 02 01 00 00       	push   $0x102
   120e2:	68 00 01 00 00       	push   $0x100
   120e7:	68 01 01 00 00       	push   $0x101
   120ec:	50                   	push   %eax
   120ed:	e8 d8 a3 ff ff       	call   c4ca <breada>
	if (!bh) {
   120f2:	83 c4 20             	add    $0x20,%esp
   120f5:	85 c0                	test   %eax,%eax
   120f7:	75 0e                	jne    12107 <rd_load+0x87>
		printk("Disk error while looking for ramdisk!\n");
   120f9:	83 ec 0c             	sub    $0xc,%esp
   120fc:	8d 83 8a 7c ff ff    	lea    -0x8376(%ebx),%eax
   12102:	e9 cd 00 00 00       	jmp    121d4 <rd_load+0x154>
		return;
	}
	*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);
   12107:	8b 10                	mov    (%eax),%edx
	brelse(bh);
   12109:	83 ec 0c             	sub    $0xc,%esp
	*((struct d_super_block *) &s) = *((struct d_super_block *) bh->b_data);
   1210c:	66 8b 4a 0a          	mov    0xa(%edx),%cx
   12110:	8b 6a 10             	mov    0x10(%edx),%ebp
   12113:	66 8b 7a 02          	mov    0x2(%edx),%di
   12117:	89 4c 24 18          	mov    %ecx,0x18(%esp)
	brelse(bh);
   1211b:	50                   	push   %eax
   1211c:	e8 3d a2 ff ff       	call   c35e <brelse>
	if (s.s_magic != SUPER_MAGIC)
   12121:	83 c4 10             	add    $0x10,%esp
   12124:	66 81 fd 7f 13       	cmp    $0x137f,%bp
   12129:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   1212d:	0f 85 ca 00 00 00    	jne    121fd <rd_load+0x17d>
	// 然后我们试图把整个根文件系统读入在内存虚拟盘区中.对于一个文件系统来说,其超级块结构的s_nzones字段中保存着总逻辑块数(或称为区段数).一个
	// 逻辑块中含有的数据块数则由字段s_log_zone_size指定.因此文件系统中的数据块总数nblocks就等于(逻辑块数 *2^(每区段块数的次方)),即
	// nblocks=(s_nzones * 2^s_log_zone_size).如果遇到文件系统中数据块总数大于内存虚拟盘所能容纳的块数的情况,则不能执行加载操作,而只能显示
	// 出错信息并返回.
	nblocks = s.s_nzones << s.s_log_zone_size;
	if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
   12133:	8b 83 9c 41 00 00    	mov    0x419c(%ebx),%eax
	nblocks = s.s_nzones << s.s_log_zone_size;
   12139:	0f b7 ef             	movzwl %di,%ebp
   1213c:	d3 e5                	shl    %cl,%ebp
	if (nblocks > (rd_length >> BLOCK_SIZE_BITS)) {
   1213e:	c1 f8 0a             	sar    $0xa,%eax
   12141:	39 e8                	cmp    %ebp,%eax
   12143:	7d 0e                	jge    12153 <rd_load+0xd3>
		printk("Ram disk image too big!  (%d blocks, %d avail)\n",
   12145:	52                   	push   %edx
   12146:	50                   	push   %eax
   12147:	8d 83 b1 7c ff ff    	lea    -0x834f(%ebx),%eax
   1214d:	55                   	push   %ebp
   1214e:	e9 81 00 00 00       	jmp    121d4 <rd_load+0x154>
	}
	// 若虚拟盘能容纳得下文件系统总数据块数,则我们显示加载数据信息,并让cp指向内存虚拟盘起始处,然后开始执行循环操作将磁盘上根文件系统映像加载到
	// 虚拟盘上.在操作过程中,如果一次需要加载的盘块数大于2块,我们就是用超前预读函数breada(),否则就使用bread()函数进行单块读取.若在读盘过程
	// 中出现I/O操作错误,就只能放弃加载过程返回.所读取的磁盘块会使用memcpy()函数从高速缓冲区中复制到内存虚拟盘相应位置处,同时显示已加载的块数.
	// 显示字符串中的八进制数'\010'表示显示一个制表符.
	printk("Loading %d bytes into ram disk... (0k)",
   12153:	89 e8                	mov    %ebp,%eax
   12155:	57                   	push   %edi
   12156:	57                   	push   %edi
   12157:	c1 e0 0a             	shl    $0xa,%eax
   1215a:	50                   	push   %eax
   1215b:	8d 83 e1 7c ff ff    	lea    -0x831f(%ebx),%eax
   12161:	50                   	push   %eax
   12162:	e8 ba 5f ff ff       	call   8121 <printk>
		nblocks << BLOCK_SIZE_BITS);
	cp = rd_start;
   12167:	8b 3e                	mov    (%esi),%edi
	while (nblocks) {
   12169:	83 c4 10             	add    $0x10,%esp
	int		block = 256;								/* Start at block 256 */	/* 开始于256盘块 */
   1216c:	ba 00 01 00 00       	mov    $0x100,%edx
	while (nblocks) {
   12171:	eb 26                	jmp    12199 <rd_load+0x119>
   12173:	89 54 24 0c          	mov    %edx,0xc(%esp)
   12177:	8b 30                	mov    (%eax),%esi
   12179:	b9 00 04 00 00       	mov    $0x400,%ecx
   1217e:	fc                   	cld    
   1217f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
			printk("I/O error on block %d, aborting load\n",
				block);
			return;
		}
		(void) memcpy(cp, bh->b_data, BLOCK_SIZE);		// 复制到cp处.
		brelse(bh);
   12181:	83 ec 0c             	sub    $0xc,%esp
		cp += BLOCK_SIZE;								// 虚拟盘指针前移.
   12184:	81 c7 00 04 00 00    	add    $0x400,%edi
		block++;
		nblocks--;
   1218a:	4d                   	dec    %ebp
		brelse(bh);
   1218b:	50                   	push   %eax
   1218c:	e8 cd a1 ff ff       	call   c35e <brelse>
		block++;
   12191:	8b 54 24 1c          	mov    0x1c(%esp),%edx
		nblocks--;
   12195:	83 c4 10             	add    $0x10,%esp
		block++;
   12198:	42                   	inc    %edx
	while (nblocks) {
   12199:	85 ed                	test   %ebp,%ebp
   1219b:	74 54                	je     121f1 <rd_load+0x171>
   1219d:	8b 44 24 08          	mov    0x8(%esp),%eax
		if (nblocks > 2)  								// 若读取块数多于2块则采用超前预读.
   121a1:	83 fd 02             	cmp    $0x2,%ebp
   121a4:	8b 00                	mov    (%eax),%eax
   121a6:	7e 37                	jle    121df <rd_load+0x15f>
			bh = breada(ROOT_DEV, block, block + 1, block + 2, -1);
   121a8:	8d 4a 02             	lea    0x2(%edx),%ecx
   121ab:	83 ec 0c             	sub    $0xc,%esp
   121ae:	6a ff                	push   $0xffffffff
   121b0:	51                   	push   %ecx
   121b1:	8d 4a 01             	lea    0x1(%edx),%ecx
   121b4:	51                   	push   %ecx
   121b5:	52                   	push   %edx
   121b6:	89 54 24 28          	mov    %edx,0x28(%esp)
   121ba:	50                   	push   %eax
   121bb:	e8 0a a3 ff ff       	call   c4ca <breada>
   121c0:	83 c4 20             	add    $0x20,%esp
		if (!bh) {
   121c3:	85 c0                	test   %eax,%eax
			bh = bread(ROOT_DEV, block);
   121c5:	8b 54 24 0c          	mov    0xc(%esp),%edx
		if (!bh) {
   121c9:	75 a8                	jne    12173 <rd_load+0xf3>
			printk("I/O error on block %d, aborting load\n",
   121cb:	50                   	push   %eax
   121cc:	50                   	push   %eax
   121cd:	8d 83 08 7d ff ff    	lea    -0x82f8(%ebx),%eax
   121d3:	52                   	push   %edx
   121d4:	50                   	push   %eax
   121d5:	e8 47 5f ff ff       	call   8121 <printk>
			return;
   121da:	83 c4 10             	add    $0x10,%esp
   121dd:	eb 1e                	jmp    121fd <rd_load+0x17d>
			bh = bread(ROOT_DEV, block);
   121df:	51                   	push   %ecx
   121e0:	51                   	push   %ecx
   121e1:	52                   	push   %edx
   121e2:	89 54 24 18          	mov    %edx,0x18(%esp)
   121e6:	50                   	push   %eax
   121e7:	e8 c4 a1 ff ff       	call   c3b0 <bread>
   121ec:	83 c4 10             	add    $0x10,%esp
   121ef:	eb d2                	jmp    121c3 <rd_load+0x143>
		i++;
	}
	// 当boot盘中从256盘块开始的整个文件系统加载完毕后,我们显示"done",并把目前根文件设备号修改成虚拟盘的设备号0x0101, 返回.
	ROOT_DEV = 0x0101;
   121f1:	c7 c0 0c 50 02 00    	mov    $0x2500c,%eax
   121f7:	c7 00 01 01 00 00    	movl   $0x101,(%eax)
}
   121fd:	83 c4 1c             	add    $0x1c,%esp
   12200:	5b                   	pop    %ebx
   12201:	5e                   	pop    %esi
   12202:	5f                   	pop    %edi
   12203:	5d                   	pop    %ebp
   12204:	c3                   	ret    

00012205 <change_console>:

// 改变前台控制台.
// 将前台控制台设定为指定的虚拟控制台
// 参数:new_console - 指定的新控制台号
void change_console(unsigned int new_console)
{
   12205:	53                   	push   %ebx
   12206:	e8 21 48 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1220b:	81 c3 f5 ed 00 00    	add    $0xedf5,%ebx
   12211:	83 ec 08             	sub    $0x8,%esp
   12214:	8b 44 24 10          	mov    0x10(%esp),%eax
	// 如果参数指定的控制台已经在前台或者参数无效,则退出.否则设置当前前台控制台号,同时更新table_list[]中的前台控制台读/写队列结构地址.
	// 最后更新当前前台控制台屏幕.
	if (new_console == fg_console || new_console >= NR_CONSOLES)
   12218:	39 83 a0 41 00 00    	cmp    %eax,0x41a0(%ebx)
   1221e:	74 37                	je     12257 <change_console+0x52>
   12220:	c7 c2 2c 2d 03 00    	mov    $0x32d2c,%edx
   12226:	39 02                	cmp    %eax,(%edx)
   12228:	76 2d                	jbe    12257 <change_console+0x52>
		return;
	fg_console = new_console;
   1222a:	89 83 a0 41 00 00    	mov    %eax,0x41a0(%ebx)
	table_list[0] = con_queues + 0 + fg_console * 3;
   12230:	8d 93 c0 41 00 00    	lea    0x41c0(%ebx),%edx
   12236:	69 c0 30 0c 00 00    	imul   $0xc30,%eax,%eax
   1223c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
	table_list[1] = con_queues + 1 + fg_console * 3;
   1223f:	8d 84 02 10 04 00 00 	lea    0x410(%edx,%eax,1),%eax
	table_list[0] = con_queues + 0 + fg_console * 3;
   12246:	89 8b e8 14 00 00    	mov    %ecx,0x14e8(%ebx)
	table_list[1] = con_queues + 1 + fg_console * 3;
   1224c:	89 83 ec 14 00 00    	mov    %eax,0x14ec(%ebx)
	update_screen();
   12252:	e8 ea 1d 00 00       	call   14041 <update_screen>
}
   12257:	83 c4 08             	add    $0x8,%esp
   1225a:	5b                   	pop    %ebx
   1225b:	c3                   	ret    

0001225c <wait_for_keypress>:
}

// 等待按键.
// 如果前台控制台读队列缓冲区空,则让进程进入可中断睡眠状态.
void wait_for_keypress(void)
{
   1225c:	57                   	push   %edi
   1225d:	56                   	push   %esi
   1225e:	53                   	push   %ebx
   1225f:	e8 c8 47 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   12264:	81 c3 9c ed 00 00    	add    $0xed9c,%ebx
	sleep_if_empty(tty_table[fg_console].secondary);
   1226a:	8b 83 a0 41 00 00    	mov    0x41a0(%ebx),%eax
   12270:	c1 e0 06             	shl    $0x6,%eax
   12273:	81 c0 00 57 03 00    	add    $0x35700,%eax
   12279:	8b 70 3c             	mov    0x3c(%eax),%esi
	cli();
   1227c:	fa                   	cli    
	while (!(current->signal & ~current->blocked) && EMPTY(queue))
   1227d:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
   12283:	8b 17                	mov    (%edi),%edx
   12285:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
   1228b:	f7 d0                	not    %eax
   1228d:	85 42 0c             	test   %eax,0xc(%edx)
   12290:	75 19                	jne    122ab <wait_for_keypress+0x4f>
   12292:	8b 46 08             	mov    0x8(%esi),%eax
   12295:	39 46 04             	cmp    %eax,0x4(%esi)
   12298:	75 11                	jne    122ab <wait_for_keypress+0x4f>
		interruptible_sleep_on(&queue->proc_list);
   1229a:	8d 46 0c             	lea    0xc(%esi),%eax
   1229d:	83 ec 0c             	sub    $0xc,%esp
   122a0:	50                   	push   %eax
   122a1:	e8 d1 4b ff ff       	call   6e77 <interruptible_sleep_on>
   122a6:	83 c4 10             	add    $0x10,%esp
   122a9:	eb d8                	jmp    12283 <wait_for_keypress+0x27>
	sti();
   122ab:	fb                   	sti    
}
   122ac:	5b                   	pop    %ebx
   122ad:	5e                   	pop    %esi
   122ae:	5f                   	pop    %edi
   122af:	c3                   	ret    

000122b0 <copy_to_cooked>:

// 复制成规范模式字符序列
// 根据终端termios结构中设置的各种标志,将指定tty同读队列缓冲区中的字符复制转换成规范模式(熟模式)字符并存放在辅助队列(规范模式队列)中.
// 参数:tty - 指定终端的tty结构指针.
void copy_to_cooked(struct tty_struct * tty)
{
   122b0:	55                   	push   %ebp
   122b1:	57                   	push   %edi
   122b2:	56                   	push   %esi
   122b3:	53                   	push   %ebx
   122b4:	e8 73 47 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   122b9:	81 c3 47 ed 00 00    	add    $0xed47,%ebx
   122bf:	83 ec 2c             	sub    $0x2c,%esp
   122c2:	8b 74 24 40          	mov    0x40(%esp),%esi
	signed char c;

	// 首先检查当前终端tty结构中缓冲队列指针是否有效.如果三个队列指针都是NULL,则说明内核tty初始化函数有问题.
	if (!(tty->read_q || tty->write_q || tty->secondary)) {
   122c6:	83 7e 34 00          	cmpl   $0x0,0x34(%esi)
   122ca:	75 0a                	jne    122d6 <copy_to_cooked+0x26>
   122cc:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
   122d0:	0f 84 5f 03 00 00    	je     12635 <copy_to_cooked+0x385>
		// 如果字符是换行符NL(10),换行转回车标志NLCR置位,则将其转换为回车符CR(13).
		} else if (c == 10 && I_NLCR(tty))
			c = 13;
		// 如果大写转小写输入标志UCLC置位,则将该字符转换为小写字符.
		if (I_UCLC(tty))
			c = tolower(c);
   122d6:	c7 c0 00 97 03 00    	mov    $0x39700,%eax
   122dc:	89 44 24 18          	mov    %eax,0x18(%esp)
   122e0:	c7 c0 00 25 02 00    	mov    $0x22500,%eax
   122e6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if (EMPTY(tty->read_q))
   122ea:	8b 7e 34             	mov    0x34(%esi),%edi
   122ed:	8b 4e 3c             	mov    0x3c(%esi),%ecx
   122f0:	8b 57 08             	mov    0x8(%edi),%edx
   122f3:	39 57 04             	cmp    %edx,0x4(%edi)
   122f6:	0f 84 2b 03 00 00    	je     12627 <copy_to_cooked+0x377>
		if (FULL(tty->secondary))
   122fc:	8b 41 04             	mov    0x4(%ecx),%eax
   122ff:	89 44 24 14          	mov    %eax,0x14(%esp)
   12303:	f7 d0                	not    %eax
   12305:	03 41 08             	add    0x8(%ecx),%eax
   12308:	a9 ff 03 00 00       	test   $0x3ff,%eax
   1230d:	0f 84 14 03 00 00    	je     12627 <copy_to_cooked+0x377>
		GETCH(tty->read_q, c);								// 取一字符到c,并前移尾指针
   12313:	8a 44 17 10          	mov    0x10(%edi,%edx,1),%al
   12317:	42                   	inc    %edx
   12318:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1231e:	89 57 08             	mov    %edx,0x8(%edi)
   12321:	8b 3e                	mov    (%esi),%edi
		if (c == 13) {
   12323:	3c 0d                	cmp    $0xd,%al
		GETCH(tty->read_q, c);								// 取一字符到c,并前移尾指针
   12325:	88 44 24 0f          	mov    %al,0xf(%esp)
		if (c == 13) {
   12329:	75 10                	jne    1233b <copy_to_cooked+0x8b>
			if (I_CRNL(tty))
   1232b:	0f ba e7 08          	bt     $0x8,%edi
   1232f:	72 26                	jb     12357 <copy_to_cooked+0xa7>
			else if (I_NOCR(tty))
   12331:	f7 c7 80 00 00 00    	test   $0x80,%edi
   12337:	74 23                	je     1235c <copy_to_cooked+0xac>
   12339:	eb af                	jmp    122ea <copy_to_cooked+0x3a>
		} else if (c == 10 && I_NLCR(tty))
   1233b:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   12340:	75 1a                	jne    1235c <copy_to_cooked+0xac>
			c = 13;
   12342:	8a 44 24 0f          	mov    0xf(%esp),%al
   12346:	f7 c7 40 00 00 00    	test   $0x40,%edi
   1234c:	b2 0d                	mov    $0xd,%dl
   1234e:	0f 45 c2             	cmovne %edx,%eax
   12351:	88 44 24 0f          	mov    %al,0xf(%esp)
   12355:	eb 05                	jmp    1235c <copy_to_cooked+0xac>
				c = 10;
   12357:	c6 44 24 0f 0a       	movb   $0xa,0xf(%esp)
		if (I_UCLC(tty))
   1235c:	0f ba e7 09          	bt     $0x9,%edi
   12360:	73 1b                	jae    1237d <copy_to_cooked+0xcd>
			c = tolower(c);
   12362:	0f be 54 24 0f       	movsbl 0xf(%esp),%edx
   12367:	8b 44 24 18          	mov    0x18(%esp),%eax
   1236b:	88 10                	mov    %dl,(%eax)
   1236d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   12371:	f6 44 02 01 01       	testb  $0x1,0x1(%edx,%eax,1)
   12376:	74 05                	je     1237d <copy_to_cooked+0xcd>
   12378:	80 44 24 0f 20       	addb   $0x20,0xf(%esp)
		// 字符(^D),则循环执行下列代码:
		// 如果本了回显标志ECHO置位,那么:若字符是控制字符(值 < 32),则往tty写队列放入擦除控制字符ERASE(^H).然后再放入一个擦除字符ERASE,并且调用
		// 该tty写函数,把写队列中的所有字符输出到终端屏幕上.另外,因为控制字符在放入写队列时需要用2个字节表示(例如^V),因此要求特别对控制字符多放入
		// 一个ERASE.最后将tty辅助队列头指针后退1字节.另外,如果了_POSIZ_VDISABLE(\0),那么在对字符修理过程中,若字符代码值等于_POSIX_VDISABLE
		// 的值时,表示禁止使用相应特殊控制字符的功能.
		if (L_CANON(tty)) {
   1237d:	8b 46 0c             	mov    0xc(%esi),%eax
   12380:	a8 02                	test   $0x2,%al
   12382:	89 44 24 10          	mov    %eax,0x10(%esp)
   12386:	0f 84 39 01 00 00    	je     124c5 <copy_to_cooked+0x215>
			if ((KILL_CHAR(tty) != _POSIX_VDISABLE) &&
   1238c:	0f b6 56 14          	movzbl 0x14(%esi),%edx
   12390:	84 d2                	test   %dl,%dl
   12392:	0f 84 90 00 00 00    	je     12428 <copy_to_cooked+0x178>
			    (c == KILL_CHAR(tty))) {
   12398:	0f be 6c 24 0f       	movsbl 0xf(%esp),%ebp
			if ((KILL_CHAR(tty) != _POSIX_VDISABLE) &&
   1239d:	39 d5                	cmp    %edx,%ebp
   1239f:	0f 85 83 00 00 00    	jne    12428 <copy_to_cooked+0x178>
				/* deal with killing the input line */
				while(!(EMPTY(tty->secondary) ||
   123a5:	8b 56 3c             	mov    0x3c(%esi),%edx
   123a8:	8b 42 04             	mov    0x4(%edx),%eax
   123ab:	3b 42 08             	cmp    0x8(%edx),%eax
   123ae:	0f 84 36 ff ff ff    	je     122ea <copy_to_cooked+0x3a>
				        (c = LAST(tty->secondary)) == 10 ||
   123b4:	48                   	dec    %eax
   123b5:	25 ff 03 00 00       	and    $0x3ff,%eax
   123ba:	8a 54 02 10          	mov    0x10(%edx,%eax,1),%dl
				while(!(EMPTY(tty->secondary) ||
   123be:	80 fa 0a             	cmp    $0xa,%dl
   123c1:	0f 84 23 ff ff ff    	je     122ea <copy_to_cooked+0x3a>
				        ((EOF_CHAR(tty) != _POSIX_VDISABLE) && (c == EOF_CHAR(tty))))) {
   123c7:	0f b6 46 15          	movzbl 0x15(%esi),%eax
				while(!(EMPTY(tty->secondary) ||
   123cb:	84 c0                	test   %al,%al
   123cd:	75 4d                	jne    1241c <copy_to_cooked+0x16c>
					if (L_ECHO(tty)) {						// 若本地回显标志置位
   123cf:	f6 46 0c 08          	testb  $0x8,0xc(%esi)
   123d3:	74 36                	je     1240b <copy_to_cooked+0x15b>
						if (c < 32)							// 控制字符要删2字节
   123d5:	80 fa 1f             	cmp    $0x1f,%dl
   123d8:	8b 46 38             	mov    0x38(%esi),%eax
   123db:	7f 12                	jg     123ef <copy_to_cooked+0x13f>
   123dd:	8b 50 04             	mov    0x4(%eax),%edx
							PUTCH(127, tty->write_q);
   123e0:	c6 44 10 10 7f       	movb   $0x7f,0x10(%eax,%edx,1)
   123e5:	42                   	inc    %edx
   123e6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   123ec:	89 50 04             	mov    %edx,0x4(%eax)
						PUTCH(127, tty->write_q);
   123ef:	8b 50 04             	mov    0x4(%eax),%edx
						tty->write(tty);
   123f2:	83 ec 0c             	sub    $0xc,%esp
						PUTCH(127, tty->write_q);
   123f5:	c6 44 10 10 7f       	movb   $0x7f,0x10(%eax,%edx,1)
   123fa:	42                   	inc    %edx
   123fb:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   12401:	89 50 04             	mov    %edx,0x4(%eax)
						tty->write(tty);
   12404:	56                   	push   %esi
   12405:	ff 56 30             	call   *0x30(%esi)
   12408:	83 c4 10             	add    $0x10,%esp
					}
					DEC(tty->secondary->head);
   1240b:	8b 56 3c             	mov    0x3c(%esi),%edx
   1240e:	8b 42 04             	mov    0x4(%edx),%eax
   12411:	48                   	dec    %eax
   12412:	25 ff 03 00 00       	and    $0x3ff,%eax
   12417:	89 42 04             	mov    %eax,0x4(%edx)
   1241a:	eb 89                	jmp    123a5 <copy_to_cooked+0xf5>
				        ((EOF_CHAR(tty) != _POSIX_VDISABLE) && (c == EOF_CHAR(tty))))) {
   1241c:	0f be ca             	movsbl %dl,%ecx
   1241f:	39 c1                	cmp    %eax,%ecx
   12421:	75 ac                	jne    123cf <copy_to_cooked+0x11f>
   12423:	e9 c2 fe ff ff       	jmp    122ea <copy_to_cooked+0x3a>
			}
			// 如果该字符是删除控制字符ERASE(^H),那么:如果tty的辅助队列为空,或者其最后一个字符是换行符NL(10),或者是文件结束符,则继续处理其他字符.如果本地回显
			// 标志ECHO置位,那么:若字符是控制字符(值 < 32),则往tty的写队列中放入擦除字符ERASE.再放入一个擦除字符ERASE,并且调用该tty的写函数.最后将tty辅助
			// 队列头指针后退1字节,继续处理其他字符.同样地,如果定义了_POSIX_VDISABLE(\0),那么在对字符处理过程中,若字符代码值等于_POSIX_VDISABLE的值时,
			// 表示禁止使用相应特殊控制字符的功能.
			if ((ERASE_CHAR(tty) != _POSIX_VDISABLE) && (c == ERASE_CHAR(tty))) {
   12428:	0f b6 56 13          	movzbl 0x13(%esi),%edx
   1242c:	84 d2                	test   %dl,%dl
   1242e:	0f 84 91 00 00 00    	je     124c5 <copy_to_cooked+0x215>
   12434:	0f be 6c 24 0f       	movsbl 0xf(%esp),%ebp
   12439:	39 d5                	cmp    %edx,%ebp
   1243b:	0f 85 84 00 00 00    	jne    124c5 <copy_to_cooked+0x215>
				if (EMPTY(tty->secondary) ||
   12441:	8b 44 24 14          	mov    0x14(%esp),%eax
   12445:	3b 41 08             	cmp    0x8(%ecx),%eax
   12448:	0f 84 9c fe ff ff    	je     122ea <copy_to_cooked+0x3a>
				   (c = LAST(tty->secondary)) == 10 ||
   1244e:	48                   	dec    %eax
   1244f:	25 ff 03 00 00       	and    $0x3ff,%eax
   12454:	8a 54 01 10          	mov    0x10(%ecx,%eax,1),%dl
				if (EMPTY(tty->secondary) ||
   12458:	80 fa 0a             	cmp    $0xa,%dl
   1245b:	0f 84 89 fe ff ff    	je     122ea <copy_to_cooked+0x3a>
				   ((EOF_CHAR(tty) != _POSIX_VDISABLE) &&
   12461:	0f b6 46 15          	movzbl 0x15(%esi),%eax
				   (c = LAST(tty->secondary)) == 10 ||
   12465:	84 c0                	test   %al,%al
   12467:	74 0b                	je     12474 <copy_to_cooked+0x1c4>
				    (c == EOF_CHAR(tty))))
   12469:	0f be ca             	movsbl %dl,%ecx
				   ((EOF_CHAR(tty) != _POSIX_VDISABLE) &&
   1246c:	39 c1                	cmp    %eax,%ecx
   1246e:	0f 84 76 fe ff ff    	je     122ea <copy_to_cooked+0x3a>
					continue;
				if (L_ECHO(tty)) {							// 若本地回显标志置位.
   12474:	f6 44 24 10 08       	testb  $0x8,0x10(%esp)
   12479:	74 36                	je     124b1 <copy_to_cooked+0x201>
					if (c < 32)
   1247b:	80 fa 1f             	cmp    $0x1f,%dl
   1247e:	8b 46 38             	mov    0x38(%esi),%eax
   12481:	7f 12                	jg     12495 <copy_to_cooked+0x1e5>
   12483:	8b 50 04             	mov    0x4(%eax),%edx
						PUTCH(127, tty->write_q);
   12486:	c6 44 10 10 7f       	movb   $0x7f,0x10(%eax,%edx,1)
   1248b:	42                   	inc    %edx
   1248c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   12492:	89 50 04             	mov    %edx,0x4(%eax)
					PUTCH(127, tty->write_q);
   12495:	8b 50 04             	mov    0x4(%eax),%edx
					tty->write(tty);
   12498:	83 ec 0c             	sub    $0xc,%esp
					PUTCH(127, tty->write_q);
   1249b:	c6 44 10 10 7f       	movb   $0x7f,0x10(%eax,%edx,1)
   124a0:	42                   	inc    %edx
   124a1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   124a7:	89 50 04             	mov    %edx,0x4(%eax)
					tty->write(tty);
   124aa:	56                   	push   %esi
   124ab:	ff 56 30             	call   *0x30(%esi)
   124ae:	83 c4 10             	add    $0x10,%esp
				}
				DEC(tty->secondary->head);
   124b1:	8b 56 3c             	mov    0x3c(%esi),%edx
   124b4:	8b 42 04             	mov    0x4(%edx),%eax
   124b7:	48                   	dec    %eax
   124b8:	25 ff 03 00 00       	and    $0x3ff,%eax
   124bd:	89 42 04             	mov    %eax,0x4(%edx)
   124c0:	e9 25 fe ff ff       	jmp    122ea <copy_to_cooked+0x3a>
		// 如果设置了IXON标志,则使终端停止/开始输出控制字符起作用.如果没有设置此标志,那么停止和开始字符将被作为一般字符供进程读取.在这段代码中,如果读取的字符是停止
		// 字符STOP(^S),则置tty停止标志,让tty暂停输出.同时丢弃该特殊控制字符(不放入辅助队列中),并继续处理其他字符.如果字符是开始字符START(^Q),则复位tty停止
		// 标志,恢复tty输出.同时丢弃该控制字符,并继续处理其他字符.对于控制台来说,这里的tty->write()是console.c中的con_write()函数.因此对于伪终端也是由于设置
		// 了终端stopped标志而会暂停写操作(chr_drv/console.c).对于伪终端也是由于设置了终端stopped标志而会暂停写操作(chr_drv/pty.c).
		// 对于串行终端,也应该在发送终端过程中根据终端stopped标志暂停发送,但本版未实现.
		if (I_IXON(tty)) {
   124c5:	0f ba e7 0a          	bt     $0xa,%edi
   124c9:	73 3b                	jae    12506 <copy_to_cooked+0x256>
			if ((STOP_CHAR(tty) != _POSIX_VDISABLE) && (c==STOP_CHAR(tty))) {
   124cb:	0f b6 56 1a          	movzbl 0x1a(%esi),%edx
   124cf:	84 d2                	test   %dl,%dl
   124d1:	74 12                	je     124e5 <copy_to_cooked+0x235>
   124d3:	0f be 7c 24 0f       	movsbl 0xf(%esp),%edi
   124d8:	39 d7                	cmp    %edx,%edi
   124da:	75 09                	jne    124e5 <copy_to_cooked+0x235>
				tty->stopped = 1;
   124dc:	c7 46 2c 01 00 00 00 	movl   $0x1,0x2c(%esi)
   124e3:	eb 18                	jmp    124fd <copy_to_cooked+0x24d>
				tty->write(tty);
				continue;
			}
			if ((START_CHAR(tty) != _POSIX_VDISABLE) && (c==START_CHAR(tty))) {
   124e5:	0f b6 56 19          	movzbl 0x19(%esi),%edx
   124e9:	84 d2                	test   %dl,%dl
   124eb:	74 19                	je     12506 <copy_to_cooked+0x256>
   124ed:	0f be 7c 24 0f       	movsbl 0xf(%esp),%edi
   124f2:	39 d7                	cmp    %edx,%edi
   124f4:	75 10                	jne    12506 <copy_to_cooked+0x256>
				tty->stopped = 0;
   124f6:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
				tty->write(tty);
   124fd:	83 ec 0c             	sub    $0xc,%esp
   12500:	56                   	push   %esi
   12501:	ff 56 30             	call   *0x30(%esi)
   12504:	eb 6b                	jmp    12571 <copy_to_cooked+0x2c1>
        }
		// 若输入模式标志集中ISIG标志置位,表示终端键盘可以产生信号,则在收到控制字符INTR,QUIT,SUSP或DSUSP时,需要为进程产生相应的信号.如果该字符是键盘中断符(^C),则向
		// 当前进程之进程组中所有进程发送键盘中断信号SIGINT,并继续处理下一字符.如果该字符是退出符(^\),则向当前进程之进程组中所有进程发送键盘退出信号SIGQUIT,并继续处理
		// 下一字符.如果字符是暂停符(^Z),则向当前进程发送暂停信息SIGTSTP.同样,若定义了_POSIX_VDISABLE(\0),那么在对字符处理过程中,若字符代码值等于_POSIX_VDISABLE
		// 的值时,表示禁止使用相应特殊控制字符的功能.
		if (L_ISIG(tty)) {
   12506:	f6 44 24 10 01       	testb  $0x1,0x10(%esp)
   1250b:	74 6c                	je     12579 <copy_to_cooked+0x2c9>
			if ((INTR_CHAR(tty) != _POSIX_VDISABLE) && (c==INTR_CHAR(tty))) {
   1250d:	0f b6 56 11          	movzbl 0x11(%esi),%edx
   12511:	84 d2                	test   %dl,%dl
   12513:	74 10                	je     12525 <copy_to_cooked+0x275>
   12515:	0f be 7c 24 0f       	movsbl 0xf(%esp),%edi
   1251a:	39 d7                	cmp    %edx,%edi
   1251c:	75 07                	jne    12525 <copy_to_cooked+0x275>
				kill_pg(tty->pgrp, SIGINT, 1);
   1251e:	51                   	push   %ecx
   1251f:	6a 01                	push   $0x1
   12521:	6a 02                	push   $0x2
   12523:	eb 44                	jmp    12569 <copy_to_cooked+0x2b9>
				continue;
			}
			if ((QUIT_CHAR(tty) != _POSIX_VDISABLE) && (c==QUIT_CHAR(tty))) {
   12525:	0f b6 56 12          	movzbl 0x12(%esi),%edx
   12529:	84 d2                	test   %dl,%dl
   1252b:	74 10                	je     1253d <copy_to_cooked+0x28d>
   1252d:	0f be 7c 24 0f       	movsbl 0xf(%esp),%edi
   12532:	39 d7                	cmp    %edx,%edi
   12534:	75 07                	jne    1253d <copy_to_cooked+0x28d>
				kill_pg(tty->pgrp, SIGQUIT, 1);
   12536:	52                   	push   %edx
   12537:	6a 01                	push   $0x1
   12539:	6a 03                	push   $0x3
   1253b:	eb 2c                	jmp    12569 <copy_to_cooked+0x2b9>
				continue;
			}
			if ((SUSPEND_CHAR(tty) != _POSIX_VDISABLE) && (c == SUSPEND_CHAR(tty))) {
   1253d:	0f b6 56 1b          	movzbl 0x1b(%esi),%edx
   12541:	84 d2                	test   %dl,%dl
   12543:	74 34                	je     12579 <copy_to_cooked+0x2c9>
   12545:	0f be 7c 24 0f       	movsbl 0xf(%esp),%edi
   1254a:	39 d7                	cmp    %edx,%edi
   1254c:	75 2b                	jne    12579 <copy_to_cooked+0x2c9>
				if (!is_orphaned_pgrp(tty->pgrp))				// 判断一个进程组是否孤儿进程
   1254e:	83 ec 0c             	sub    $0xc,%esp
   12551:	ff 76 24             	pushl  0x24(%esi)
   12554:	e8 2a 70 ff ff       	call   9583 <is_orphaned_pgrp>
   12559:	83 c4 10             	add    $0x10,%esp
   1255c:	85 c0                	test   %eax,%eax
   1255e:	0f 85 86 fd ff ff    	jne    122ea <copy_to_cooked+0x3a>
					kill_pg(tty->pgrp, SIGTSTP, 1);
   12564:	50                   	push   %eax
   12565:	6a 01                	push   $0x1
   12567:	6a 14                	push   $0x14
   12569:	ff 76 24             	pushl  0x24(%esi)
   1256c:	e8 c4 6e ff ff       	call   9435 <kill_pg>
   12571:	83 c4 10             	add    $0x10,%esp
   12574:	e9 71 fd ff ff       	jmp    122ea <copy_to_cooked+0x3a>
				continue;
			}
		}
		// 如果该字符是换行符NL(10),或者是文件结束符EOF(4,^D),表示一行字符已处理完,则把辅助缓冲队列中当前含有字符行数值secondar.data增1.如果在函数tty_read()中取走一行
		// 字符,该值即会减1.
		if (c == 10 || (EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)))
   12579:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1257e:	74 11                	je     12591 <copy_to_cooked+0x2e1>
   12580:	0f b6 56 15          	movzbl 0x15(%esi),%edx
   12584:	84 d2                	test   %dl,%dl
   12586:	74 0b                	je     12593 <copy_to_cooked+0x2e3>
   12588:	0f be 7c 24 0f       	movsbl 0xf(%esp),%edi
   1258d:	39 d7                	cmp    %edx,%edi
   1258f:	75 02                	jne    12593 <copy_to_cooked+0x2e3>
			tty->secondary->data++;
   12591:	ff 01                	incl   (%ecx)
		// 如果本地模式标志中回显标志ECHO在置位状态,那么,如果字符是换行符NL(10),则将换行符NL(10)和回车符(13)放入tty写队列缓冲区中;如果字符是控制字符(值<32)并且回显控制
		// 字符标志ECHOCTL置位,则将字符'^'和字符c+64放入tty写队列中(也即会显示^C,^H等);否则将该字符直接放入tty写缓冲队列中.最后调用该tty写操作函数.
		if (L_ECHO(tty)) {
   12593:	f6 44 24 10 08       	testb  $0x8,0x10(%esp)
   12598:	74 70                	je     1260a <copy_to_cooked+0x35a>
			if (c == 10) {
   1259a:	80 7c 24 0f 0a       	cmpb   $0xa,0xf(%esp)
   1259f:	75 19                	jne    125ba <copy_to_cooked+0x30a>
				PUTCH(10, tty->write_q);
   125a1:	8b 4e 38             	mov    0x38(%esi),%ecx
   125a4:	8b 51 04             	mov    0x4(%ecx),%edx
   125a7:	c6 44 11 10 0a       	movb   $0xa,0x10(%ecx,%edx,1)
   125ac:	42                   	inc    %edx
   125ad:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
				PUTCH(13, tty->write_q);
   125b3:	c6 44 11 10 0d       	movb   $0xd,0x10(%ecx,%edx,1)
   125b8:	eb 3c                	jmp    125f6 <copy_to_cooked+0x346>
			} else if (c < 32) {
   125ba:	80 7c 24 0f 1f       	cmpb   $0x1f,0xf(%esp)
   125bf:	7f 27                	jg     125e8 <copy_to_cooked+0x338>
				if (L_ECHOCTL(tty)) {
   125c1:	8b 44 24 10          	mov    0x10(%esp),%eax
   125c5:	0f ba e0 09          	bt     $0x9,%eax
   125c9:	73 35                	jae    12600 <copy_to_cooked+0x350>
					PUTCH('^', tty->write_q);
   125cb:	8b 4e 38             	mov    0x38(%esi),%ecx
					PUTCH(c + 64, tty->write_q);
   125ce:	8a 44 24 0f          	mov    0xf(%esp),%al
					PUTCH('^', tty->write_q);
   125d2:	8b 51 04             	mov    0x4(%ecx),%edx
					PUTCH(c + 64, tty->write_q);
   125d5:	8d 78 40             	lea    0x40(%eax),%edi
   125d8:	89 f8                	mov    %edi,%eax
					PUTCH('^', tty->write_q);
   125da:	c6 44 11 10 5e       	movb   $0x5e,0x10(%ecx,%edx,1)
   125df:	42                   	inc    %edx
   125e0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   125e6:	eb 0a                	jmp    125f2 <copy_to_cooked+0x342>
				}
			} else
				PUTCH(c, tty->write_q);
   125e8:	8b 4e 38             	mov    0x38(%esi),%ecx
   125eb:	8a 44 24 0f          	mov    0xf(%esp),%al
   125ef:	8b 51 04             	mov    0x4(%ecx),%edx
   125f2:	88 44 11 10          	mov    %al,0x10(%ecx,%edx,1)
   125f6:	42                   	inc    %edx
   125f7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   125fd:	89 51 04             	mov    %edx,0x4(%ecx)
			tty->write(tty);
   12600:	83 ec 0c             	sub    $0xc,%esp
   12603:	56                   	push   %esi
   12604:	ff 56 30             	call   *0x30(%esi)
   12607:	83 c4 10             	add    $0x10,%esp
		}
		// 每一次循环末将处理过的字符放入辅助队列中
		PUTCH(c, tty->secondary);
   1260a:	8b 4e 3c             	mov    0x3c(%esi),%ecx
   1260d:	8a 44 24 0f          	mov    0xf(%esp),%al
   12611:	8b 51 04             	mov    0x4(%ecx),%edx
   12614:	88 44 11 10          	mov    %al,0x10(%ecx,%edx,1)
   12618:	42                   	inc    %edx
   12619:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1261f:	89 51 04             	mov    %edx,0x4(%ecx)
   12622:	e9 c3 fc ff ff       	jmp    122ea <copy_to_cooked+0x3a>
    }
	// 在退出循环体后唤醒等待该辅助缓冲队列的进程(如果有的话).
	wake_up(&tty->secondary->proc_list);
   12627:	83 ec 0c             	sub    $0xc,%esp
   1262a:	83 c1 0c             	add    $0xc,%ecx
   1262d:	51                   	push   %ecx
   1262e:	e8 60 48 ff ff       	call   6e93 <wake_up>
   12633:	eb 19                	jmp    1264e <copy_to_cooked+0x39e>
	if (!(tty->read_q || tty->write_q || tty->secondary)) {
   12635:	83 7e 3c 00          	cmpl   $0x0,0x3c(%esi)
   12639:	0f 85 97 fc ff ff    	jne    122d6 <copy_to_cooked+0x26>
		printk("copy_to_cooked: missing queues\n\r");
   1263f:	8d 83 2e 7d ff ff    	lea    -0x82d2(%ebx),%eax
   12645:	83 ec 0c             	sub    $0xc,%esp
   12648:	50                   	push   %eax
   12649:	e8 d3 5a ff ff       	call   8121 <printk>
		return;
   1264e:	83 c4 10             	add    $0x10,%esp
}
   12651:	83 c4 2c             	add    $0x2c,%esp
   12654:	5b                   	pop    %ebx
   12655:	5e                   	pop    %esi
   12656:	5f                   	pop    %edi
   12657:	5d                   	pop    %ebp
   12658:	c3                   	ret    

00012659 <tty_signal>:
 */
// 向使用终端的进程组中所有进程发送信号。
// 在后台进程组中的一个进程访问控制终端时，该函数用于向后台进程组中的所有进程发送SIGTTIN或SIGTTOU信号。无论后台进程组
// 中的进程是否已经阻塞或忽略掉了这两个信号，当前进程都将立刻退出读写操作而返回。
int tty_signal(int sig, struct tty_struct *tty)
{
   12659:	57                   	push   %edi
   1265a:	56                   	push   %esi
   1265b:	53                   	push   %ebx
   1265c:	8b 74 24 10          	mov    0x10(%esp),%esi
   12660:	e8 c7 43 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   12665:	81 c3 9b e9 00 00    	add    $0xe99b,%ebx
	// 我们不希望停止一个孤儿进程组的进程（参见文件kernel/exit.c的说明）。
	// 因此如果当前进程组是孤儿进程组，就出错返回。否则就向当前进程组所有进程发送指定信号。
	if (is_orphaned_pgrp(current->pgrp))
   1266b:	83 ec 0c             	sub    $0xc,%esp
   1266e:	c7 c7 60 23 02 00    	mov    $0x22360,%edi
   12674:	8b 07                	mov    (%edi),%eax
   12676:	ff b0 30 02 00 00    	pushl  0x230(%eax)
   1267c:	e8 02 6f ff ff       	call   9583 <is_orphaned_pgrp>
   12681:	83 c4 10             	add    $0x10,%esp
   12684:	85 c0                	test   %eax,%eax
   12686:	74 07                	je     1268f <tty_signal+0x36>
		return -EIO;									/* don't stop an orphaned pgrp */
   12688:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   1268d:	eb 3b                	jmp    126ca <tty_signal+0x71>
	(void) kill_pg(current->pgrp, sig, 1);            	// 发送信号sig。
   1268f:	50                   	push   %eax
   12690:	8b 07                	mov    (%edi),%eax
   12692:	6a 01                	push   $0x1
   12694:	56                   	push   %esi
   12695:	ff b0 30 02 00 00    	pushl  0x230(%eax)
   1269b:	e8 95 6d ff ff       	call   9435 <kill_pg>
	// 如果这个信号被当前进程阻塞（屏蔽），或者被当前进程忽略掉，则出错返回。否则，如果当前进程的对信号sig设置了新的处理句柄
	// 那么就返回我们可被中断的信息。否则就返回在系统调用重新启动后可以继续执行的信息。
	if ((current->blocked & (1 << (sig - 1))) ||
   126a0:	8b 17                	mov    (%edi),%edx
   126a2:	8d 4e ff             	lea    -0x1(%esi),%ecx
   126a5:	b8 01 00 00 00       	mov    $0x1,%eax
   126aa:	83 c4 10             	add    $0x10,%esp
   126ad:	d3 e0                	shl    %cl,%eax
   126af:	85 82 10 02 00 00    	test   %eax,0x210(%edx)
   126b5:	75 d1                	jne    12688 <tty_signal+0x2f>
	    ((int) current->sigaction[sig - 1].sa_handler == 1))
   126b7:	c1 e6 04             	shl    $0x4,%esi
	if ((current->blocked & (1 << (sig - 1))) ||
   126ba:	83 3c 32 01          	cmpl   $0x1,(%edx,%esi,1)
   126be:	74 c8                	je     12688 <tty_signal+0x2f>
		return -EIO;		/* Our signal will be ignored */
	else if (current->sigaction[sig-1].sa_handler)
		return -EINTR;		/* We _will_ be interrupted :-) */
	else
		return -ERESTARTSYS;	/* We _will_ be interrupted :-) */
   126c0:	19 c0                	sbb    %eax,%eax
   126c2:	25 04 fe ff ff       	and    $0xfffffe04,%eax
   126c7:	83 e8 04             	sub    $0x4,%eax
					/* (but restart after we continue) */
}
   126ca:	5b                   	pop    %ebx
   126cb:	5e                   	pop    %esi
   126cc:	5f                   	pop    %edi
   126cd:	c3                   	ret    

000126ce <tty_read>:

// tty读函数。
// 从终端辅助缓冲队列读取指定数量的字符，放到用户指定的缓冲区中。
// 参数：channel - 子设备号；buf - 用户缓冲区指针；nr - 欲读字节数。
int tty_read(unsigned channel, char * buf, int nr)
{
   126ce:	55                   	push   %ebp
   126cf:	57                   	push   %edi
   126d0:	56                   	push   %esi
   126d1:	53                   	push   %ebx
   126d2:	e8 a2 09 00 00       	call   13079 <__x86.get_pc_thunk.bp>
   126d7:	81 c5 29 e9 00 00    	add    $0xe929,%ebp
   126dd:	83 ec 4c             	sub    $0x4c,%esp
   126e0:	8b 44 24 64          	mov    0x64(%esp),%eax
   126e4:	8b 7c 24 60          	mov    0x60(%esp),%edi
   126e8:	89 44 24 18          	mov    %eax,0x18(%esp)
   126ec:	8b 44 24 68          	mov    0x68(%esp),%eax
	char c, *b = buf;
	int minimum, time;

	// 首先判断参数有效性并取终端的tty结构指针。如果tty终端的三个缓冲队列指针都是NULL，则返回EIO出错信息。如果tty
	// 终端是一个伪终端，则再取得另一个对应伪终端的tty结构other_tty。
	if (channel > 255)
   126f0:	81 ff ff 00 00 00    	cmp    $0xff,%edi
{
   126f6:	89 44 24 04          	mov    %eax,0x4(%esp)
	if (channel > 255)
   126fa:	0f 87 cf 02 00 00    	ja     129cf <tty_read+0x301>
		return -EIO;
	tty = TTY_TABLE(channel);
   12700:	85 ff                	test   %edi,%edi
   12702:	c7 c2 00 57 03 00    	mov    $0x35700,%edx
   12708:	74 0f                	je     12719 <tty_read+0x4b>
   1270a:	83 ff 3f             	cmp    $0x3f,%edi
   1270d:	8d b7 ff ff ff 03    	lea    0x3ffffff(%edi),%esi
   12713:	76 0a                	jbe    1271f <tty_read+0x51>
   12715:	89 fe                	mov    %edi,%esi
   12717:	eb 06                	jmp    1271f <tty_read+0x51>
   12719:	8b b5 a0 41 00 00    	mov    0x41a0(%ebp),%esi
   1271f:	c1 e6 06             	shl    $0x6,%esi
   12722:	01 d6                	add    %edx,%esi
	if (!(tty->write_q || tty->read_q || tty->secondary))
   12724:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
   12728:	75 10                	jne    1273a <tty_read+0x6c>
   1272a:	83 7e 34 00          	cmpl   $0x0,0x34(%esi)
   1272e:	75 0a                	jne    1273a <tty_read+0x6c>
   12730:	83 7e 3c 00          	cmpl   $0x0,0x3c(%esi)
   12734:	0f 84 95 02 00 00    	je     129cf <tty_read+0x301>
		return -EIO;
	// 如果当前进程使用的是这里正在处理的tty终端，但该终端的进程组号却与当前进程组号不同，表示当前进程是后台进程组中
	// 的一个进程，即进程不在前台。于是我们要停止当前进程组的所有进程。因此这里就需要向当前进程组发送SIGTTIN信号，
	// 并返回等待成为前台进程组后再执行读操作。
	if ((current->tty == channel) && (tty->pgrp != current->pgrp))
   1273a:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   12740:	89 44 24 20          	mov    %eax,0x20(%esp)
   12744:	8b 00                	mov    (%eax),%eax
   12746:	39 b8 2c 03 00 00    	cmp    %edi,0x32c(%eax)
   1274c:	75 23                	jne    12771 <tty_read+0xa3>
   1274e:	8b 98 30 02 00 00    	mov    0x230(%eax),%ebx
   12754:	39 5e 24             	cmp    %ebx,0x24(%esi)
   12757:	74 18                	je     12771 <tty_read+0xa3>
		return(tty_signal(SIGTTIN, tty));
   12759:	89 74 24 64          	mov    %esi,0x64(%esp)
   1275d:	c7 44 24 60 15 00 00 	movl   $0x15,0x60(%esp)
   12764:	00 
	// 则以重新启动系统调用号“-ERESTARTSYS”返回。否则就返回已读取的字符数（b-buf）。
	current->timeout = 0;
	if ((current->signal & ~current->blocked) && !(b - buf))
		return -ERESTARTSYS;
	return (b - buf);
}
   12765:	83 c4 4c             	add    $0x4c,%esp
   12768:	5b                   	pop    %ebx
   12769:	5e                   	pop    %esi
   1276a:	5f                   	pop    %edi
   1276b:	5d                   	pop    %ebp
		return(tty_signal(SIGTTIN, tty));
   1276c:	e9 e8 fe ff ff       	jmp    12659 <tty_signal>
	if (channel & 0x80)
   12771:	f7 c7 80 00 00 00    	test   $0x80,%edi
	struct tty_struct * other_tty = NULL;
   12777:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   1277e:	00 
	if (channel & 0x80)
   1277f:	74 0f                	je     12790 <tty_read+0xc2>
		other_tty = tty_table + (channel ^ 0x40);
   12781:	89 f9                	mov    %edi,%ecx
   12783:	83 f1 40             	xor    $0x40,%ecx
   12786:	c1 e1 06             	shl    $0x6,%ecx
   12789:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
   1278c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
	if (L_CANON(tty)) {
   12790:	f6 46 0c 02          	testb  $0x2,0xc(%esi)
   12794:	74 14                	je     127aa <tty_read+0xdc>
		current->timeout = 0xffffffff;
   12796:	c7 80 d8 02 00 00 ff 	movl   $0xffffffff,0x2d8(%eax)
   1279d:	ff ff ff 
   127a0:	8b 44 24 04          	mov    0x4(%esp),%eax
   127a4:	89 44 24 14          	mov    %eax,0x14(%esp)
   127a8:	eb 4d                	jmp    127f7 <tty_read+0x129>
	time = 10L * tty->termios.c_cc[VTIME];            				// 设置读操作超时定时值。
   127aa:	0f b6 56 16          	movzbl 0x16(%esi),%edx
   127ae:	6b da 0a             	imul   $0xa,%edx,%ebx
	minimum = tty->termios.c_cc[VMIN];              				// 最少需要读取的字符个数。
   127b1:	0f b6 56 17          	movzbl 0x17(%esi),%edx
	time = 10L * tty->termios.c_cc[VTIME];            				// 设置读操作超时定时值。
   127b5:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
	} else if (minimum)
   127b9:	85 d2                	test   %edx,%edx
   127bb:	74 19                	je     127d6 <tty_read+0x108>
   127bd:	3b 54 24 04          	cmp    0x4(%esp),%edx
		current->timeout = 0xffffffff;
   127c1:	c7 80 d8 02 00 00 ff 	movl   $0xffffffff,0x2d8(%eax)
   127c8:	ff ff ff 
   127cb:	0f 4f 54 24 04       	cmovg  0x4(%esp),%edx
   127d0:	89 54 24 14          	mov    %edx,0x14(%esp)
   127d4:	eb 29                	jmp    127ff <tty_read+0x131>
		if (time)
   127d6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   127db:	8b 5c 24 04          	mov    0x4(%esp),%ebx
   127df:	89 5c 24 14          	mov    %ebx,0x14(%esp)
   127e3:	74 1a                	je     127ff <tty_read+0x131>
			current->timeout = time + jiffies;
   127e5:	c7 c2 6c 2a 02 00    	mov    $0x22a6c,%edx
   127eb:	8b 12                	mov    (%edx),%edx
   127ed:	03 54 24 0c          	add    0xc(%esp),%edx
   127f1:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%eax)
   127f7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   127fe:	00 
   127ff:	8b 44 24 18          	mov    0x18(%esp),%eax
   12803:	89 44 24 08          	mov    %eax,0x8(%esp)
			current->timeout = time + jiffies;
   12807:	c7 c0 6c 2a 02 00    	mov    $0x22a6c,%eax
   1280d:	89 44 24 38          	mov    %eax,0x38(%esp)
   12811:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   12817:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	while (nr > 0) {
   1281b:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
   12820:	0f 8e 73 01 00 00    	jle    12999 <tty_read+0x2cb>
		if (other_tty)
   12826:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
   1282b:	74 11                	je     1283e <tty_read+0x170>
			other_tty->write(other_tty);
   1282d:	83 ec 0c             	sub    $0xc,%esp
   12830:	ff 74 24 1c          	pushl  0x1c(%esp)
   12834:	8b 44 24 20          	mov    0x20(%esp),%eax
   12838:	ff 50 30             	call   *0x30(%eax)
   1283b:	83 c4 10             	add    $0x10,%esp
		cli();
   1283e:	fa                   	cli    
		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
   1283f:	8b 46 3c             	mov    0x3c(%esi),%eax
   12842:	8b 58 04             	mov    0x4(%eax),%ebx
   12845:	3b 58 08             	cmp    0x8(%eax),%ebx
   12848:	89 5c 24 24          	mov    %ebx,0x24(%esp)
   1284c:	74 25                	je     12873 <tty_read+0x1a5>
   1284e:	8b 4e 0c             	mov    0xc(%esi),%ecx
   12851:	8b 5e 34             	mov    0x34(%esi),%ebx
   12854:	83 e1 02             	and    $0x2,%ecx
   12857:	89 4c 24 28          	mov    %ecx,0x28(%esp)
   1285b:	74 6f                	je     128cc <tty_read+0x1fe>
		    !FULL(tty->read_q) && !tty->secondary->data)) {
   1285d:	8b 4b 08             	mov    0x8(%ebx),%ecx
   12860:	8d 51 ff             	lea    -0x1(%ecx),%edx
   12863:	2b 53 04             	sub    0x4(%ebx),%edx
		if (EMPTY(tty->secondary) || (L_CANON(tty) &&
   12866:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   1286c:	74 5e                	je     128cc <tty_read+0x1fe>
		    !FULL(tty->read_q) && !tty->secondary->data)) {
   1286e:	83 38 00             	cmpl   $0x0,(%eax)
   12871:	75 59                	jne    128cc <tty_read+0x1fe>
			if (!current->timeout ||
   12873:	8b 5c 24 20          	mov    0x20(%esp),%ebx
   12877:	8b 0b                	mov    (%ebx),%ecx
   12879:	8b 91 10 02 00 00    	mov    0x210(%ecx),%edx
   1287f:	f7 d2                	not    %edx
   12881:	23 51 0c             	and    0xc(%ecx),%edx
   12884:	83 b9 d8 02 00 00 00 	cmpl   $0x0,0x2d8(%ecx)
   1288b:	74 04                	je     12891 <tty_read+0x1c3>
   1288d:	85 d2                	test   %edx,%edx
   1288f:	74 06                	je     12897 <tty_read+0x1c9>
			  	sti();
   12891:	fb                   	sti    
				break;
   12892:	e9 02 01 00 00       	jmp    12999 <tty_read+0x2cb>
			if (IS_A_PTY_SLAVE(channel) && C_HUP(other_tty))
   12897:	89 fa                	mov    %edi,%edx
   12899:	81 e2 c0 00 00 00    	and    $0xc0,%edx
   1289f:	81 fa c0 00 00 00    	cmp    $0xc0,%edx
   128a5:	75 0e                	jne    128b5 <tty_read+0x1e7>
   128a7:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   128ab:	f6 41 08 0f          	testb  $0xf,0x8(%ecx)
   128af:	0f 84 e4 00 00 00    	je     12999 <tty_read+0x2cb>
			interruptible_sleep_on(&tty->secondary->proc_list);
   128b5:	83 ec 0c             	sub    $0xc,%esp
   128b8:	83 c0 0c             	add    $0xc,%eax
   128bb:	89 eb                	mov    %ebp,%ebx
   128bd:	50                   	push   %eax
   128be:	e8 b4 45 ff ff       	call   6e77 <interruptible_sleep_on>
			sti();
   128c3:	fb                   	sti    
			continue;
   128c4:	83 c4 10             	add    $0x10,%esp
   128c7:	e9 4f ff ff ff       	jmp    1281b <tty_read+0x14d>
		sti();
   128cc:	fb                   	sti    
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) || c == 10)
   128cd:	0f b6 4e 15          	movzbl 0x15(%esi),%ecx
   128d1:	88 4c 24 1f          	mov    %cl,0x1f(%esp)
   128d5:	89 4c 24 30          	mov    %ecx,0x30(%esp)
				put_fs_byte(c, b++);
   128d9:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   128dd:	89 4c 24 34          	mov    %ecx,0x34(%esp)
			GETCH(tty->secondary, c);
   128e1:	8b 48 08             	mov    0x8(%eax),%ecx
   128e4:	8a 54 08 10          	mov    0x10(%eax,%ecx,1),%dl
   128e8:	41                   	inc    %ecx
   128e9:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) || c == 10)
   128ef:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
			GETCH(tty->secondary, c);
   128f4:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
   128f8:	89 48 08             	mov    %ecx,0x8(%eax)
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) || c == 10)
   128fb:	0f 84 d5 00 00 00    	je     129d6 <tty_read+0x308>
   12901:	0f be ca             	movsbl %dl,%ecx
   12904:	3b 4c 24 30          	cmp    0x30(%esp),%ecx
   12908:	75 1c                	jne    12926 <tty_read+0x258>
				tty->secondary->data--;
   1290a:	ff 08                	decl   (%eax)
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) && L_CANON(tty))
   1290c:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
   12911:	75 18                	jne    1292b <tty_read+0x25d>
				put_fs_byte(c, b++);
   12913:	ff 44 24 08          	incl   0x8(%esp)
//// 将一字节存放在fs段中指定内存地址处.
// 参数:val - 字节值;addr - 内存地址.
// %0 - 寄存器(字节值val);%1 - (内存地址addr).
static inline void put_fs_byte(char val,char *addr)
{
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   12917:	8b 4c 24 34          	mov    0x34(%esp),%ecx
   1291b:	64 88 11             	mov    %dl,%fs:(%ecx)
				if (!--nr)
   1291e:	ff 4c 24 04          	decl   0x4(%esp)
   12922:	75 19                	jne    1293d <tty_read+0x26f>
   12924:	eb 2d                	jmp    12953 <tty_read+0x285>
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) || c == 10)
   12926:	80 fa 0a             	cmp    $0xa,%dl
   12929:	74 df                	je     1290a <tty_read+0x23c>
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) && L_CANON(tty))
   1292b:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   12930:	74 e1                	je     12913 <tty_read+0x245>
   12932:	0f be ca             	movsbl %dl,%ecx
   12935:	3b 4c 24 30          	cmp    0x30(%esp),%ecx
   12939:	75 d8                	jne    12913 <tty_read+0x245>
   1293b:	eb 16                	jmp    12953 <tty_read+0x285>
			if (c == 10 && L_CANON(tty))
   1293d:	80 fa 0a             	cmp    $0xa,%dl
   12940:	75 07                	jne    12949 <tty_read+0x27b>
   12942:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
   12947:	75 0a                	jne    12953 <tty_read+0x285>
		} while (nr > 0 && !EMPTY(tty->secondary));
   12949:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
   1294d:	39 4c 24 24          	cmp    %ecx,0x24(%esp)
   12951:	75 86                	jne    128d9 <tty_read+0x20b>
		wake_up(&tty->read_q->proc_list);
   12953:	83 ec 0c             	sub    $0xc,%esp
   12956:	83 c3 0c             	add    $0xc,%ebx
   12959:	53                   	push   %ebx
   1295a:	89 eb                	mov    %ebp,%ebx
   1295c:	e8 32 45 ff ff       	call   6e93 <wake_up>
		if (time)
   12961:	83 c4 10             	add    $0x10,%esp
   12964:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12969:	74 16                	je     12981 <tty_read+0x2b3>
			current->timeout = time + jiffies;
   1296b:	8b 44 24 38          	mov    0x38(%esp),%eax
   1296f:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
   12973:	8b 00                	mov    (%eax),%eax
   12975:	03 44 24 0c          	add    0xc(%esp),%eax
   12979:	8b 13                	mov    (%ebx),%edx
   1297b:	89 82 d8 02 00 00    	mov    %eax,0x2d8(%edx)
		if (L_CANON(tty) || b - buf >= minimum)
   12981:	f6 46 0c 02          	testb  $0x2,0xc(%esi)
   12985:	75 12                	jne    12999 <tty_read+0x2cb>
   12987:	8b 44 24 08          	mov    0x8(%esp),%eax
   1298b:	2b 44 24 18          	sub    0x18(%esp),%eax
   1298f:	3b 44 24 14          	cmp    0x14(%esp),%eax
   12993:	0f 8c 82 fe ff ff    	jl     1281b <tty_read+0x14d>
	current->timeout = 0;
   12999:	8b 44 24 20          	mov    0x20(%esp),%eax
   1299d:	8b 00                	mov    (%eax),%eax
	if ((current->signal & ~current->blocked) && !(b - buf))
   1299f:	8b 90 10 02 00 00    	mov    0x210(%eax),%edx
	current->timeout = 0;
   129a5:	c7 80 d8 02 00 00 00 	movl   $0x0,0x2d8(%eax)
   129ac:	00 00 00 
	if ((current->signal & ~current->blocked) && !(b - buf))
   129af:	f7 d2                	not    %edx
   129b1:	85 50 0c             	test   %edx,0xc(%eax)
   129b4:	74 0f                	je     129c5 <tty_read+0x2f7>
   129b6:	8b 74 24 18          	mov    0x18(%esp),%esi
   129ba:	39 74 24 08          	cmp    %esi,0x8(%esp)
		return -ERESTARTSYS;
   129be:	b8 00 fe ff ff       	mov    $0xfffffe00,%eax
	if ((current->signal & ~current->blocked) && !(b - buf))
   129c3:	74 1f                	je     129e4 <tty_read+0x316>
	return (b - buf);
   129c5:	8b 44 24 08          	mov    0x8(%esp),%eax
   129c9:	2b 44 24 18          	sub    0x18(%esp),%eax
   129cd:	eb 15                	jmp    129e4 <tty_read+0x316>
		return -EIO;
   129cf:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   129d4:	eb 0e                	jmp    129e4 <tty_read+0x316>
			if ((EOF_CHAR(tty) != _POSIX_VDISABLE && c == EOF_CHAR(tty)) || c == 10)
   129d6:	80 fa 0a             	cmp    $0xa,%dl
   129d9:	0f 85 34 ff ff ff    	jne    12913 <tty_read+0x245>
   129df:	e9 26 ff ff ff       	jmp    1290a <tty_read+0x23c>
}
   129e4:	83 c4 4c             	add    $0x4c,%esp
   129e7:	5b                   	pop    %ebx
   129e8:	5e                   	pop    %esi
   129e9:	5f                   	pop    %edi
   129ea:	5d                   	pop    %ebp
   129eb:	c3                   	ret    

000129ec <tty_write>:
// tty写函数.
// 把用户缓冲区中的字符放入tty写队列缓冲区中.
// 参数:channel - 子设备号;buf - 缓冲区指针;nr - 写字节数.
// 返回已写字节数.
int tty_write(unsigned channel, char * buf, int nr)
{
   129ec:	55                   	push   %ebp
   129ed:	57                   	push   %edi
   129ee:	56                   	push   %esi
   129ef:	53                   	push   %ebx
   129f0:	e8 37 40 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   129f5:	81 c3 0b e6 00 00    	add    $0xe60b,%ebx
   129fb:	83 ec 2c             	sub    $0x2c,%esp
   129fe:	8b 44 24 40          	mov    0x40(%esp),%eax
   12a02:	8b 7c 24 44          	mov    0x44(%esp),%edi
   12a06:	8b 4c 24 48          	mov    0x48(%esp),%ecx
	static int cr_flag=0;
	struct tty_struct * tty;
	char c, *b = buf;

	// 首先判断参数有效性并取终端的tty结构指针.如果tty终端的三个缓冲队列指针都是NULL,则返回EIO出错信息.
	if (channel > 255)
   12a0a:	3d ff 00 00 00       	cmp    $0xff,%eax
{
   12a0f:	89 7c 24 08          	mov    %edi,0x8(%esp)
   12a13:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	if (channel > 255)
   12a17:	0f 87 ec 01 00 00    	ja     12c09 <tty_write+0x21d>
		return -EIO;
	tty = TTY_TABLE(channel);
   12a1d:	85 c0                	test   %eax,%eax
   12a1f:	c7 c2 00 57 03 00    	mov    $0x35700,%edx
   12a25:	74 0f                	je     12a36 <tty_write+0x4a>
   12a27:	83 f8 3f             	cmp    $0x3f,%eax
   12a2a:	8d b0 ff ff ff 03    	lea    0x3ffffff(%eax),%esi
   12a30:	76 0a                	jbe    12a3c <tty_write+0x50>
   12a32:	89 c6                	mov    %eax,%esi
   12a34:	eb 06                	jmp    12a3c <tty_write+0x50>
   12a36:	8b b3 a0 41 00 00    	mov    0x41a0(%ebx),%esi
   12a3c:	c1 e6 06             	shl    $0x6,%esi
   12a3f:	01 d6                	add    %edx,%esi
	if (!(tty->write_q || tty->read_q || tty->secondary))
   12a41:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
   12a45:	75 10                	jne    12a57 <tty_write+0x6b>
   12a47:	83 7e 34 00          	cmpl   $0x0,0x34(%esi)
   12a4b:	75 0a                	jne    12a57 <tty_write+0x6b>
   12a4d:	83 7e 3c 00          	cmpl   $0x0,0x3c(%esi)
   12a51:	0f 84 b2 01 00 00    	je     12c09 <tty_write+0x21d>
		return -EIO;
	// 如果若终端本地模式标志集中设置了TOSTOP,表示后台进程输出时需要发送信号SIGTTOU.如果当前进程使用的是这里正在处理的tty终端,但该终端的进程组号却与当前
	// 进程组号不同,即表示当前进程是后台进程组中的一个进程,即进程不在前台.于是我们要停止当前进程组的所有进程.因此这里就需要向当前进程组发送SIGTTOU信号,并返回
	// 等待成为前台进程组后再执行写操作.
	if (L_TOSTOP(tty) &&
   12a57:	f6 46 0d 01          	testb  $0x1,0xd(%esi)
   12a5b:	74 37                	je     12a94 <tty_write+0xa8>
	    (current->tty == channel) && (tty->pgrp != current->pgrp))
   12a5d:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
   12a63:	8b 7c 24 08          	mov    0x8(%esp),%edi
   12a67:	8b 12                	mov    (%edx),%edx
	if (L_TOSTOP(tty) &&
   12a69:	39 82 2c 03 00 00    	cmp    %eax,0x32c(%edx)
   12a6f:	75 27                	jne    12a98 <tty_write+0xac>
	    (current->tty == channel) && (tty->pgrp != current->pgrp))
   12a71:	8b 82 30 02 00 00    	mov    0x230(%edx),%eax
   12a77:	39 46 24             	cmp    %eax,0x24(%esi)
   12a7a:	74 1c                	je     12a98 <tty_write+0xac>
		return(tty_signal(SIGTTOU, tty));
   12a7c:	89 74 24 44          	mov    %esi,0x44(%esp)
   12a80:	c7 44 24 40 16 00 00 	movl   $0x16,0x40(%esp)
   12a87:	00 
		tty->write(tty);
		if (nr > 0)
			schedule();
        }
	return (b - buf);												// 最后返回写入的字节数.
}
   12a88:	83 c4 2c             	add    $0x2c,%esp
   12a8b:	5b                   	pop    %ebx
   12a8c:	5e                   	pop    %esi
   12a8d:	5f                   	pop    %edi
   12a8e:	5d                   	pop    %ebp
		return(tty_signal(SIGTTOU, tty));
   12a8f:	e9 c5 fb ff ff       	jmp    12659 <tty_signal>
   12a94:	8b 7c 24 08          	mov    0x8(%esp),%edi
   12a98:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   12a9e:	89 44 24 10          	mov    %eax,0x10(%esp)
					c = toupper(c);									// 小写转成大写字符.
   12aa2:	c7 c0 00 97 03 00    	mov    $0x39700,%eax
   12aa8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	while (nr > 0) {
   12aac:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12ab1:	7e 5b                	jle    12b0e <tty_write+0x122>
		sleep_if_full(tty->write_q);
   12ab3:	8b 6e 38             	mov    0x38(%esi),%ebp
	if (!FULL(queue))
   12ab6:	8b 45 08             	mov    0x8(%ebp),%eax
   12ab9:	48                   	dec    %eax
   12aba:	2b 45 04             	sub    0x4(%ebp),%eax
   12abd:	a9 ff 03 00 00       	test   $0x3ff,%eax
   12ac2:	75 37                	jne    12afb <tty_write+0x10f>
	cli();
   12ac4:	fa                   	cli    
	while (!(current->signal & ~current->blocked) && LEFT(queue) < 128)
   12ac5:	8b 44 24 10          	mov    0x10(%esp),%eax
   12ac9:	8b 10                	mov    (%eax),%edx
   12acb:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
   12ad1:	f7 d0                	not    %eax
   12ad3:	85 42 0c             	test   %eax,0xc(%edx)
   12ad6:	75 22                	jne    12afa <tty_write+0x10e>
   12ad8:	8b 45 08             	mov    0x8(%ebp),%eax
   12adb:	48                   	dec    %eax
   12adc:	2b 45 04             	sub    0x4(%ebp),%eax
   12adf:	25 ff 03 00 00       	and    $0x3ff,%eax
   12ae4:	83 f8 7f             	cmp    $0x7f,%eax
   12ae7:	77 11                	ja     12afa <tty_write+0x10e>
		interruptible_sleep_on(&queue->proc_list);
   12ae9:	8d 45 0c             	lea    0xc(%ebp),%eax
   12aec:	83 ec 0c             	sub    $0xc,%esp
   12aef:	50                   	push   %eax
   12af0:	e8 82 43 ff ff       	call   6e77 <interruptible_sleep_on>
   12af5:	83 c4 10             	add    $0x10,%esp
   12af8:	eb cb                	jmp    12ac5 <tty_write+0xd9>
	sti();
   12afa:	fb                   	sti    
		if (current->signal & ~current->blocked)
   12afb:	8b 44 24 10          	mov    0x10(%esp),%eax
   12aff:	8b 10                	mov    (%eax),%edx
   12b01:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
   12b07:	f7 d0                	not    %eax
   12b09:	85 42 0c             	test   %eax,0xc(%edx)
   12b0c:	74 0b                	je     12b19 <tty_write+0x12d>
	return (b - buf);												// 最后返回写入的字节数.
   12b0e:	89 f8                	mov    %edi,%eax
   12b10:	2b 44 24 08          	sub    0x8(%esp),%eax
   12b14:	e9 f5 00 00 00       	jmp    12c0e <tty_write+0x222>
		while (nr > 0 && !FULL(tty->write_q)) {
   12b19:	8b 4e 38             	mov    0x38(%esi),%ecx
   12b1c:	8b 41 08             	mov    0x8(%ecx),%eax
   12b1f:	48                   	dec    %eax
   12b20:	89 44 24 14          	mov    %eax,0x14(%esp)
					c = toupper(c);									// 小写转成大写字符.
   12b24:	c7 c0 00 25 02 00    	mov    $0x22500,%eax
   12b2a:	89 44 24 18          	mov    %eax,0x18(%esp)
		while (nr > 0 && !FULL(tty->write_q)) {
   12b2e:	8b 41 04             	mov    0x4(%ecx),%eax
   12b31:	89 44 24 04          	mov    %eax,0x4(%esp)
   12b35:	8b 44 24 14          	mov    0x14(%esp),%eax
   12b39:	2b 44 24 04          	sub    0x4(%esp),%eax
   12b3d:	a9 ff 03 00 00       	test   $0x3ff,%eax
   12b42:	0f 84 a2 00 00 00    	je     12bea <tty_write+0x1fe>
			if (O_POST(tty)) {
   12b48:	8b 6e 04             	mov    0x4(%esi),%ebp
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   12b4b:	64 8a 07             	mov    %fs:(%edi),%al
   12b4e:	f7 c5 01 00 00 00    	test   $0x1,%ebp
   12b54:	74 6d                	je     12bc3 <tty_write+0x1d7>
				if (c == '\r' && O_CRNL(tty))
   12b56:	3c 0d                	cmp    $0xd,%al
   12b58:	75 0a                	jne    12b64 <tty_write+0x178>
   12b5a:	f7 c5 08 00 00 00    	test   $0x8,%ebp
   12b60:	75 0e                	jne    12b70 <tty_write+0x184>
   12b62:	eb 42                	jmp    12ba6 <tty_write+0x1ba>
				else if (c == '\n' && O_NLRET(tty))
   12b64:	3c 0a                	cmp    $0xa,%al
   12b66:	75 3e                	jne    12ba6 <tty_write+0x1ba>
   12b68:	f7 c5 20 00 00 00    	test   $0x20,%ebp
   12b6e:	75 34                	jne    12ba4 <tty_write+0x1b8>
				if (c == '\n' && !cr_flag && O_NLCR(tty)) {
   12b70:	83 bb a4 41 00 00 00 	cmpl   $0x0,0x41a4(%ebx)
   12b77:	b0 0a                	mov    $0xa,%al
   12b79:	75 2b                	jne    12ba6 <tty_write+0x1ba>
   12b7b:	f7 c5 04 00 00 00    	test   $0x4,%ebp
   12b81:	74 23                	je     12ba6 <tty_write+0x1ba>
					PUTCH(13, tty->write_q);
   12b83:	8b 44 24 04          	mov    0x4(%esp),%eax
					cr_flag = 1;
   12b87:	c7 83 a4 41 00 00 01 	movl   $0x1,0x41a4(%ebx)
   12b8e:	00 00 00 
					PUTCH(13, tty->write_q);
   12b91:	89 c2                	mov    %eax,%edx
   12b93:	c6 44 01 10 0d       	movb   $0xd,0x10(%ecx,%eax,1)
   12b98:	42                   	inc    %edx
   12b99:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   12b9f:	89 51 04             	mov    %edx,0x4(%ecx)
   12ba2:	eb 8a                	jmp    12b2e <tty_write+0x142>
   12ba4:	b0 0d                	mov    $0xd,%al
				if (O_LCUC(tty))
   12ba6:	83 e5 02             	and    $0x2,%ebp
   12ba9:	74 18                	je     12bc3 <tty_write+0x1d7>
					c = toupper(c);									// 小写转成大写字符.
   12bab:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
   12baf:	8b 54 24 18          	mov    0x18(%esp),%edx
   12bb3:	88 45 00             	mov    %al,0x0(%ebp)
   12bb6:	0f be e8             	movsbl %al,%ebp
   12bb9:	f6 44 15 01 02       	testb  $0x2,0x1(%ebp,%edx,1)
   12bbe:	74 03                	je     12bc3 <tty_write+0x1d7>
   12bc0:	83 e8 20             	sub    $0x20,%eax
			PUTCH(c, tty->write_q);
   12bc3:	8b 54 24 04          	mov    0x4(%esp),%edx
			b++; nr--;
   12bc7:	47                   	inc    %edi
			cr_flag = 0;
   12bc8:	c7 83 a4 41 00 00 00 	movl   $0x0,0x41a4(%ebx)
   12bcf:	00 00 00 
			PUTCH(c, tty->write_q);
   12bd2:	88 44 11 10          	mov    %al,0x10(%ecx,%edx,1)
   12bd6:	42                   	inc    %edx
   12bd7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
		while (nr > 0 && !FULL(tty->write_q)) {
   12bdd:	ff 4c 24 0c          	decl   0xc(%esp)
			PUTCH(c, tty->write_q);
   12be1:	89 51 04             	mov    %edx,0x4(%ecx)
		while (nr > 0 && !FULL(tty->write_q)) {
   12be4:	0f 85 44 ff ff ff    	jne    12b2e <tty_write+0x142>
		tty->write(tty);
   12bea:	83 ec 0c             	sub    $0xc,%esp
   12bed:	56                   	push   %esi
   12bee:	ff 56 30             	call   *0x30(%esi)
		if (nr > 0)
   12bf1:	83 c4 10             	add    $0x10,%esp
   12bf4:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   12bf9:	0f 84 0f ff ff ff    	je     12b0e <tty_write+0x122>
			schedule();
   12bff:	e8 a8 40 ff ff       	call   6cac <schedule>
   12c04:	e9 a3 fe ff ff       	jmp    12aac <tty_write+0xc0>
		return -EIO;
   12c09:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
   12c0e:	83 c4 2c             	add    $0x2c,%esp
   12c11:	5b                   	pop    %ebx
   12c12:	5e                   	pop    %esi
   12c13:	5f                   	pop    %edi
   12c14:	5d                   	pop    %ebp
   12c15:	c3                   	ret    

00012c16 <do_tty_interrupt>:
// tty中断处理调用函数 - 字符规范模式处理.
// 参数:tty - 指定的tty终端号.
// 将指定tty终端队列缓冲区中的字符复制或转换成规范(熟)模式字符并存放在辅助队列中.该函数会在串口读字符中断(rs_io.s)和键盘中断(
// kerboard.S)中被调用.
void do_tty_interrupt(int tty)
{
   12c16:	8b 44 24 04          	mov    0x4(%esp),%eax
   12c1a:	e8 5f 72 ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
   12c1f:	81 c1 e1 e3 00 00    	add    $0xe3e1,%ecx
	copy_to_cooked(TTY_TABLE(tty));
   12c25:	85 c0                	test   %eax,%eax
   12c27:	c7 c2 00 57 03 00    	mov    $0x35700,%edx
   12c2d:	74 08                	je     12c37 <do_tty_interrupt+0x21>
   12c2f:	83 f8 3f             	cmp    $0x3f,%eax
   12c32:	7f 09                	jg     12c3d <do_tty_interrupt+0x27>
   12c34:	48                   	dec    %eax
   12c35:	eb 06                	jmp    12c3d <do_tty_interrupt+0x27>
   12c37:	8b 81 a0 41 00 00    	mov    0x41a0(%ecx),%eax
   12c3d:	c1 e0 06             	shl    $0x6,%eax
   12c40:	01 d0                	add    %edx,%eax
   12c42:	89 44 24 04          	mov    %eax,0x4(%esp)
   12c46:	e9 65 f6 ff ff       	jmp    122b0 <copy_to_cooked>

00012c4b <chr_dev_init>:
}

//字符设备初始化函数.空,为以后扩展做准备.
void chr_dev_init(void)
{
}
   12c4b:	c3                   	ret    

00012c4c <tty_init>:

// tty终端初始化函数
// 初始化所有终端缓冲队列,初始化串口终端和控制台终端.
void tty_init(void)
{
   12c4c:	55                   	push   %ebp
   12c4d:	57                   	push   %edi
   12c4e:	e8 26 04 00 00       	call   13079 <__x86.get_pc_thunk.bp>
   12c53:	81 c5 ad e3 00 00    	add    $0xe3ad,%ebp
   12c59:	56                   	push   %esi
   12c5a:	53                   	push   %ebx
   12c5b:	8d 85 c0 41 00 00    	lea    0x41c0(%ebp),%eax
   12c61:	83 ec 2c             	sub    $0x2c,%esp
   12c64:	89 44 24 0c          	mov    %eax,0xc(%esp)
   12c68:	8d 98 60 db 00 00    	lea    0xdb60(%eax),%ebx
   12c6e:	89 c2                	mov    %eax,%edx

	// 首先初始化所有终端的缓冲队列结构,设置初值.对于串行终端的读/写缓冲队列,将它们的data字段设置为串行端口基地址值.串中1是0x3f8,
	// 串口2是0x2f8.然后先初步设置所有终端的tty结构.
	// 其中特殊字符数组c_cc[]设置的初值定义在include/linux/tty.h文件中.
	for (i = 0 ; i < QUEUES ; i++)
		tty_queues[i] = (struct tty_queue) {0, 0, 0, 0, ""};
   12c70:	31 c0                	xor    %eax,%eax
   12c72:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
   12c78:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
   12c7f:	8d 7a 14             	lea    0x14(%edx),%edi
   12c82:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
   12c89:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
   12c90:	81 c2 10 04 00 00    	add    $0x410,%edx
   12c96:	c7 82 00 fc ff ff 00 	movl   $0x0,-0x400(%edx)
   12c9d:	00 00 00 
   12ca0:	b9 ff 00 00 00       	mov    $0xff,%ecx
	for (i = 0 ; i < QUEUES ; i++)
   12ca5:	39 da                	cmp    %ebx,%edx
		tty_queues[i] = (struct tty_queue) {0, 0, 0, 0, ""};
   12ca7:	f3 ab                	rep stos %eax,%es:(%edi)
	for (i = 0 ; i < QUEUES ; i++)
   12ca9:	75 c7                	jne    12c72 <tty_init+0x26>
	rs_queues[0] = (struct tty_queue) {0x3f8, 0, 0, 0, ""};
   12cab:	8d 85 80 7d ff ff    	lea    -0x8280(%ebp),%eax
   12cb1:	c7 c2 00 57 03 00    	mov    $0x35700,%edx
   12cb7:	8d bd 40 a3 00 00    	lea    0xa340(%ebp),%edi
   12cbd:	b9 04 01 00 00       	mov    $0x104,%ecx
   12cc2:	89 c6                	mov    %eax,%esi
   12cc4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	rs_queues[1] = (struct tty_queue) {0x3f8, 0, 0, 0, ""};
   12cc6:	89 c6                	mov    %eax,%esi
	rs_queues[3] = (struct tty_queue) {0x2f8, 0, 0, 0, ""};
   12cc8:	8d 85 a0 81 ff ff    	lea    -0x7e60(%ebp),%eax
	rs_queues[1] = (struct tty_queue) {0x3f8, 0, 0, 0, ""};
   12cce:	8d bd 50 a7 00 00    	lea    0xa750(%ebp),%edi
   12cd4:	b9 04 01 00 00       	mov    $0x104,%ecx
   12cd9:	8d 9a 00 40 00 00    	lea    0x4000(%edx),%ebx
   12cdf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	rs_queues[3] = (struct tty_queue) {0x2f8, 0, 0, 0, ""};
   12ce1:	89 c6                	mov    %eax,%esi
   12ce3:	8d bd 70 af 00 00    	lea    0xaf70(%ebp),%edi
   12ce9:	b9 04 01 00 00       	mov    $0x104,%ecx
   12cee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	rs_queues[4] = (struct tty_queue) {0x2f8, 0, 0, 0, ""};
   12cf0:	89 c6                	mov    %eax,%esi
   12cf2:	8d bd 80 b3 00 00    	lea    0xb380(%ebp),%edi
   12cf8:	b9 04 01 00 00       	mov    $0x104,%ecx
   12cfd:	89 d0                	mov    %edx,%eax
   12cff:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	for (i = 0 ; i < 256 ; i++) {
		tty_table[i] =  (struct tty_struct) {
   12d01:	8d bd c0 85 ff ff    	lea    -0x7a40(%ebp),%edi
   12d07:	89 7c 24 10          	mov    %edi,0x10(%esp)
   12d0b:	89 c7                	mov    %eax,%edi
   12d0d:	83 c0 40             	add    $0x40,%eax
   12d10:	b9 10 00 00 00       	mov    $0x10,%ecx
	for (i = 0 ; i < 256 ; i++) {
   12d15:	39 d8                	cmp    %ebx,%eax
		tty_table[i] =  (struct tty_struct) {
   12d17:	8b 74 24 10          	mov    0x10(%esp),%esi
   12d1b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	for (i = 0 ; i < 256 ; i++) {
   12d1d:	75 ec                	jne    12d0b <tty_init+0xbf>
	// 接着初始化控制台终端(console.c).把con_init()放在这里,是因为我们需要根据显示卡类型和显示内存容量来确定系统虚拟控制台的数量
	// NR_CONSOLES.该值被用于随后的控制tty结构初始化循环中.对于控制台的tty结构,425--430行是tty结构中包含的termios结构字段.其中
	// 输入模式标志集被初始化为ICRNL标志;输出模式标志被初始化含有后处理标志OPOST和把NL转换成CRNL的标志ONLCR;本地模式标志集被初始化
	// 含有IXON,ICAON,ECHO,ECHOCTL和ECHOKE标志;控制字符数组c_cc[]被设置含有初始值INIT_C_CC.
	// 435行上初始化控制台终端tty结构中的读缓冲,写缓冲和辅助缓冲队列结构,它们分别指向tty缓冲队列结构数组tty_table[]中的相应结构项.
	con_init();
   12d1f:	89 eb                	mov    %ebp,%ebx
   12d21:	89 54 24 10          	mov    %edx,0x10(%esp)
	for (i = 0 ; i < NR_CONSOLES ; i++) {
		con_table[i] = (struct tty_struct) {
   12d25:	8d bd 00 86 ff ff    	lea    -0x7a00(%ebp),%edi
	con_init();
   12d2b:	e8 31 13 00 00       	call   14061 <con_init>
	for (i = 0 ; i < NR_CONSOLES ; i++) {
   12d30:	c7 c0 2c 2d 03 00    	mov    $0x32d2c,%eax
   12d36:	8b 54 24 10          	mov    0x10(%esp),%edx
		con_table[i] = (struct tty_struct) {
   12d3a:	c7 c6 37 36 01 00    	mov    $0x13637,%esi
	for (i = 0 ; i < NR_CONSOLES ; i++) {
   12d40:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   12d44:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   12d4b:	00 
		con_table[i] = (struct tty_struct) {
   12d4c:	89 7c 24 18          	mov    %edi,0x18(%esp)
	for (i = 0 ; i < NR_CONSOLES ; i++) {
   12d50:	8b 00                	mov    (%eax),%eax
		con_table[i] = (struct tty_struct) {
   12d52:	89 74 24 1c          	mov    %esi,0x1c(%esp)
	for (i = 0 ; i < NR_CONSOLES ; i++) {
   12d56:	89 44 24 14          	mov    %eax,0x14(%esp)
   12d5a:	89 d0                	mov    %edx,%eax
   12d5c:	8b 7c 24 10          	mov    0x10(%esp),%edi
   12d60:	39 7c 24 14          	cmp    %edi,0x14(%esp)
   12d64:	7e 6d                	jle    12dd3 <tty_init+0x187>
		con_table[i] = (struct tty_struct) {
   12d66:	c7 00 00 01 00 00    	movl   $0x100,(%eax)
   12d6c:	c7 40 04 05 00 00 00 	movl   $0x5,0x4(%eax)
   12d73:	8d 78 11             	lea    0x11(%eax),%edi
   12d76:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   12d7d:	c7 40 0c 0b 0e 00 00 	movl   $0xe0b,0xc(%eax)
   12d84:	b9 11 00 00 00       	mov    $0x11,%ecx
   12d89:	c6 40 10 00          	movb   $0x0,0x10(%eax)
   12d8d:	8b 74 24 18          	mov    0x18(%esp),%esi
   12d91:	83 c0 40             	add    $0x40,%eax
   12d94:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   12d96:	8d 8b 10 04 00 00    	lea    0x410(%ebx),%ecx
   12d9c:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
   12da0:	89 58 f4             	mov    %ebx,-0xc(%eax)
   12da3:	c7 40 e4 00 00 00 00 	movl   $0x0,-0x1c(%eax)
   12daa:	c7 40 e8 00 00 00 00 	movl   $0x0,-0x18(%eax)
   12db1:	89 48 f8             	mov    %ecx,-0x8(%eax)
   12db4:	8d 8b 20 08 00 00    	lea    0x820(%ebx),%ecx
   12dba:	c7 40 ec 00 00 00 00 	movl   $0x0,-0x14(%eax)
   12dc1:	89 78 f0             	mov    %edi,-0x10(%eax)
	for (i = 0 ; i < NR_CONSOLES ; i++) {
   12dc4:	ff 44 24 10          	incl   0x10(%esp)
   12dc8:	81 c3 30 0c 00 00    	add    $0xc30,%ebx
		con_table[i] = (struct tty_struct) {
   12dce:	89 48 fc             	mov    %ecx,-0x4(%eax)
   12dd1:	eb 89                	jmp    12d5c <tty_init+0x110>
		};
	}
	// 然后初始化串行终端的tty结构各字段。450行初始化串行终端tty结构中的读/写和辅助缓冲队列结构，它们分别指向tty缓冲队列
	// 结构数组tty_table[]中相应结构项。
	for (i = 0 ; i < NR_SERIALS ; i++) {
		rs_table[i] = (struct tty_struct) {
   12dd3:	c7 c0 00 57 03 00    	mov    $0x35700,%eax
   12dd9:	8d 9d 00 86 ff ff    	lea    -0x7a00(%ebp),%ebx
   12ddf:	b9 11 00 00 00       	mov    $0x11,%ecx
   12de4:	89 de                	mov    %ebx,%esi
   12de6:	89 5c 24 10          	mov    %ebx,0x10(%esp)
   12dea:	c7 c3 ab 4d 01 00    	mov    $0x14dab,%ebx
   12df0:	8d b8 11 10 00 00    	lea    0x1011(%eax),%edi
   12df6:	c7 80 00 10 00 00 00 	movl   $0x0,0x1000(%eax)
   12dfd:	00 00 00 
   12e00:	c7 80 04 10 00 00 00 	movl   $0x0,0x1004(%eax)
   12e07:	00 00 00 
   12e0a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   12e0c:	8d 8d 40 a3 00 00    	lea    0xa340(%ebp),%ecx
   12e12:	8d b8 51 10 00 00    	lea    0x1051(%eax),%edi
   12e18:	8b 74 24 10          	mov    0x10(%esp),%esi
   12e1c:	c7 80 08 10 00 00 3b 	movl   $0x3b,0x1008(%eax)
   12e23:	00 00 00 
   12e26:	c7 80 0c 10 00 00 00 	movl   $0x0,0x100c(%eax)
   12e2d:	00 00 00 
   12e30:	89 88 34 10 00 00    	mov    %ecx,0x1034(%eax)
   12e36:	8d 8d 50 a7 00 00    	lea    0xa750(%ebp),%ecx
   12e3c:	c6 80 10 10 00 00 00 	movb   $0x0,0x1010(%eax)
   12e43:	c7 80 24 10 00 00 00 	movl   $0x0,0x1024(%eax)
   12e4a:	00 00 00 
   12e4d:	c7 80 28 10 00 00 00 	movl   $0x0,0x1028(%eax)
   12e54:	00 00 00 
   12e57:	89 88 38 10 00 00    	mov    %ecx,0x1038(%eax)
   12e5d:	8d 8d 60 ab 00 00    	lea    0xab60(%ebp),%ecx
   12e63:	c7 80 2c 10 00 00 00 	movl   $0x0,0x102c(%eax)
   12e6a:	00 00 00 
   12e6d:	89 98 30 10 00 00    	mov    %ebx,0x1030(%eax)
   12e73:	c7 80 40 10 00 00 00 	movl   $0x0,0x1040(%eax)
   12e7a:	00 00 00 
   12e7d:	89 88 3c 10 00 00    	mov    %ecx,0x103c(%eax)
   12e83:	b9 11 00 00 00       	mov    $0x11,%ecx
   12e88:	c7 80 44 10 00 00 00 	movl   $0x0,0x1044(%eax)
   12e8f:	00 00 00 
   12e92:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   12e94:	8d 8d 70 af 00 00    	lea    0xaf70(%ebp),%ecx
   12e9a:	c7 80 48 10 00 00 3b 	movl   $0x3b,0x1048(%eax)
   12ea1:	00 00 00 
   12ea4:	c7 80 4c 10 00 00 00 	movl   $0x0,0x104c(%eax)
   12eab:	00 00 00 
   12eae:	c6 80 50 10 00 00 00 	movb   $0x0,0x1050(%eax)
   12eb5:	c7 80 64 10 00 00 00 	movl   $0x0,0x1064(%eax)
   12ebc:	00 00 00 
   12ebf:	89 88 74 10 00 00    	mov    %ecx,0x1074(%eax)
   12ec5:	8d 8d 80 b3 00 00    	lea    0xb380(%ebp),%ecx
   12ecb:	c7 80 68 10 00 00 00 	movl   $0x0,0x1068(%eax)
   12ed2:	00 00 00 
   12ed5:	c7 80 6c 10 00 00 00 	movl   $0x0,0x106c(%eax)
   12edc:	00 00 00 
   12edf:	89 98 70 10 00 00    	mov    %ebx,0x1070(%eax)
   12ee5:	89 88 78 10 00 00    	mov    %ecx,0x1078(%eax)
   12eeb:	8d 8d 90 b7 00 00    	lea    0xb790(%ebp),%ecx
   12ef1:	89 88 7c 10 00 00    	mov    %ecx,0x107c(%eax)
		};
	}
	// 然后再初始化伪终端使用的tty结构。伪终端是配对使用的，即一个主（master）伪终端配有一个从（slave）伪终端。因此对它们
	// 都要进行初始化设置。在循环中，我们首先初始化每个主伪终端的tty结构，然后再初始化其对应的从伪终端的tty结构。
	for (i = 0 ; i < NR_PTYS ; i++) {
		mpty_table[i] = (struct tty_struct) {
   12ef7:	c7 c3 47 53 01 00    	mov    $0x15347,%ebx
		rs_table[i] = (struct tty_struct) {
   12efd:	31 c0                	xor    %eax,%eax
			0,                              						// 初始会话组。
			0,                              						// 初始停止标志。
			mpty_write,                     						// 主伪终端写函数。
			mpty_queues + 0 + i * 3, mpty_queues + 1 + i * 3, mpty_queues + 2 + i * 3
		};
		spty_table[i] = (struct tty_struct) {
   12eff:	c7 c6 8d 53 01 00    	mov    $0x1538d,%esi
   12f05:	89 74 24 14          	mov    %esi,0x14(%esp)
		mpty_table[i] = (struct tty_struct) {
   12f09:	8d b5 00 86 ff ff    	lea    -0x7a00(%ebp),%esi
   12f0f:	c7 82 00 20 00 00 00 	movl   $0x0,0x2000(%edx)
   12f16:	00 00 00 
   12f19:	c7 82 04 20 00 00 00 	movl   $0x0,0x2004(%edx)
   12f20:	00 00 00 
   12f23:	c7 82 08 20 00 00 3d 	movl   $0x3d,0x2008(%edx)
   12f2a:	00 00 00 
   12f2d:	c7 82 0c 20 00 00 00 	movl   $0x0,0x200c(%edx)
   12f34:	00 00 00 
   12f37:	8d ba 11 20 00 00    	lea    0x2011(%edx),%edi
   12f3d:	c6 82 10 20 00 00 00 	movb   $0x0,0x2010(%edx)
   12f44:	89 74 24 10          	mov    %esi,0x10(%esp)
   12f48:	b9 11 00 00 00       	mov    $0x11,%ecx
   12f4d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   12f4f:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   12f53:	c7 82 24 20 00 00 00 	movl   $0x0,0x2024(%edx)
   12f5a:	00 00 00 
   12f5d:	c7 82 28 20 00 00 00 	movl   $0x0,0x2028(%edx)
   12f64:	00 00 00 
   12f67:	c7 82 2c 20 00 00 00 	movl   $0x0,0x202c(%edx)
   12f6e:	00 00 00 
   12f71:	89 9a 30 20 00 00    	mov    %ebx,0x2030(%edx)
		spty_table[i] = (struct tty_struct) {
   12f77:	c7 82 00 30 00 00 00 	movl   $0x0,0x3000(%edx)
   12f7e:	00 00 00 
		mpty_table[i] = (struct tty_struct) {
   12f81:	8d 8c 07 e0 79 00 00 	lea    0x79e0(%edi,%eax,1),%ecx
		spty_table[i] = (struct tty_struct) {
   12f88:	c7 82 04 30 00 00 00 	movl   $0x0,0x3004(%edx)
   12f8f:	00 00 00 
   12f92:	c7 82 08 30 00 00 3d 	movl   $0x3d,0x3008(%edx)
   12f99:	00 00 00 
   12f9c:	c7 82 0c 30 00 00 03 	movl   $0x403,0x300c(%edx)
   12fa3:	04 00 00 
   12fa6:	c6 82 10 30 00 00 00 	movb   $0x0,0x3010(%edx)
		mpty_table[i] = (struct tty_struct) {
   12fad:	89 8a 34 20 00 00    	mov    %ecx,0x2034(%edx)
   12fb3:	8d 8c 07 f0 7d 00 00 	lea    0x7df0(%edi,%eax,1),%ecx
		spty_table[i] = (struct tty_struct) {
   12fba:	8b 74 24 10          	mov    0x10(%esp),%esi
		mpty_table[i] = (struct tty_struct) {
   12fbe:	89 8a 38 20 00 00    	mov    %ecx,0x2038(%edx)
   12fc4:	8d 8c 07 00 82 00 00 	lea    0x8200(%edi,%eax,1),%ecx
		spty_table[i] = (struct tty_struct) {
   12fcb:	8d ba 11 30 00 00    	lea    0x3011(%edx),%edi
   12fd1:	83 c2 40             	add    $0x40,%edx
		mpty_table[i] = (struct tty_struct) {
   12fd4:	89 8a fc 1f 00 00    	mov    %ecx,0x1ffc(%edx)
		spty_table[i] = (struct tty_struct) {
   12fda:	b9 11 00 00 00       	mov    $0x11,%ecx
   12fdf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   12fe1:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   12fe5:	8b 74 24 14          	mov    0x14(%esp),%esi
   12fe9:	c7 82 e4 2f 00 00 00 	movl   $0x0,0x2fe4(%edx)
   12ff0:	00 00 00 
   12ff3:	c7 82 e8 2f 00 00 00 	movl   $0x0,0x2fe8(%edx)
   12ffa:	00 00 00 
   12ffd:	c7 82 ec 2f 00 00 00 	movl   $0x0,0x2fec(%edx)
   13004:	00 00 00 
   13007:	8d 8c 07 a0 aa 00 00 	lea    0xaaa0(%edi,%eax,1),%ecx
   1300e:	89 b2 f0 2f 00 00    	mov    %esi,0x2ff0(%edx)
   13014:	89 8a f4 2f 00 00    	mov    %ecx,0x2ff4(%edx)
   1301a:	8d 8c 07 b0 ae 00 00 	lea    0xaeb0(%edi,%eax,1),%ecx
   13021:	89 8a f8 2f 00 00    	mov    %ecx,0x2ff8(%edx)
   13027:	8d 8c 07 c0 b2 00 00 	lea    0xb2c0(%edi,%eax,1),%ecx
   1302e:	05 30 0c 00 00       	add    $0xc30,%eax
   13033:	89 8a fc 2f 00 00    	mov    %ecx,0x2ffc(%edx)
	for (i = 0 ; i < NR_PTYS ; i++) {
   13039:	3d c0 30 00 00       	cmp    $0x30c0,%eax
   1303e:	0f 85 c5 fe ff ff    	jne    12f09 <tty_init+0x2bd>
			spty_write,                     						// 从伪终端写函数。
			spty_queues + 0 + i * 3, spty_queues + 1 + i * 3, spty_queues + 2 + i * 3
		};
	}
	// 最后初始化串行中断处理程序和串行接口1和2（serial.c），并显示系统含有的虚拟控制台数NR_CONSOLES和伪终端数NR_PTYS。
	rs_init();
   13044:	89 eb                	mov    %ebp,%ebx
   13046:	e8 e5 1c 00 00       	call   14d30 <rs_init>
	printk("%d virtual consoles\n\r", NR_CONSOLES);
   1304b:	50                   	push   %eax
   1304c:	50                   	push   %eax
   1304d:	c7 c0 2c 2d 03 00    	mov    $0x32d2c,%eax
   13053:	ff 30                	pushl  (%eax)
   13055:	8d 85 4f 7d ff ff    	lea    -0x82b1(%ebp),%eax
   1305b:	50                   	push   %eax
   1305c:	e8 c0 50 ff ff       	call   8121 <printk>
	printk("%d pty's\n\r", NR_PTYS);
   13061:	5a                   	pop    %edx
   13062:	8d 85 65 7d ff ff    	lea    -0x829b(%ebp),%eax
   13068:	59                   	pop    %ecx
   13069:	6a 04                	push   $0x4
   1306b:	50                   	push   %eax
   1306c:	e8 b0 50 ff ff       	call   8121 <printk>
}
   13071:	83 c4 3c             	add    $0x3c,%esp
   13074:	5b                   	pop    %ebx
   13075:	5e                   	pop    %esi
   13076:	5f                   	pop    %edi
   13077:	5d                   	pop    %ebp
   13078:	c3                   	ret    

00013079 <__x86.get_pc_thunk.bp>:
   13079:	8b 2c 24             	mov    (%esp),%ebp
   1307c:	c3                   	ret    

0001307d <gotoxy>:
// 光标行号不低于显示的最大行数,则退出.否则就更新当前光标变量和新光标位置对应在显示内存中位置pos.
// 注意,函数中的所有变量实际上是vc_cons[currcons]结构中的相应字段.以下函数相同.
/* NOTE! gotoxy thinks x==video_num_columns is ok */
/* 注意!gotoxy函数认为x==video_num_columns时是正确的 */
static inline void gotoxy(int currcons, int new_x, unsigned int new_y)
{
   1307d:	56                   	push   %esi
   1307e:	53                   	push   %ebx
   1307f:	e8 a8 39 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   13084:	81 c3 7c df 00 00    	add    $0xdf7c,%ebx
	if (new_x > video_num_columns || new_y >= video_num_lines)
   1308a:	3b 93 d8 21 01 00    	cmp    0x121d8(%ebx),%edx
   13090:	77 30                	ja     130c2 <gotoxy+0x45>
   13092:	39 8b c8 21 01 00    	cmp    %ecx,0x121c8(%ebx)
   13098:	76 28                	jbe    130c2 <gotoxy+0x45>
		return;
	x = new_x;
   1309a:	69 c0 90 00 00 00    	imul   $0x90,%eax,%eax
   130a0:	8d b4 03 40 1d 01 00 	lea    0x11d40(%ebx,%eax,1),%esi
	y = new_y;
   130a7:	89 4e 28             	mov    %ecx,0x28(%esi)
	x = new_x;
   130aa:	89 56 24             	mov    %edx,0x24(%esi)
	pos = origin + y * video_size_row + (x << 1);	// 1列用2个字节表示,所以x<<1.
   130ad:	01 d2                	add    %edx,%edx
   130af:	0f af 8b cc 21 01 00 	imul   0x121cc(%ebx),%ecx
   130b6:	03 4e 18             	add    0x18(%esi),%ecx
   130b9:	01 d1                	add    %edx,%ecx
   130bb:	89 8c 03 60 1d 01 00 	mov    %ecx,0x11d60(%ebx,%eax,1)
}
   130c2:	5b                   	pop    %ebx
   130c3:	5e                   	pop    %esi
   130c4:	c3                   	ret    

000130c5 <scrdown>:
static void scrdown(int currcons)
{
	// 同样,滚屏区域必须至少有2行.如果滚屏区域顶行号大于等于区域底行号,则不满足进行滚行操作的条件.另外,对于EGA/VGA卡,我们可以指定屏内行范围(区域)
	// 进行滚屏操作,而MDA单色显示卡只能进行整屏操作.由于窗口向上移动最多移动以当前控制台实际显示内存末端的情况,所以这里只需要处理普通的内存数据
	// 移动情况.
	if (bottom <= top)
   130c5:	69 c0 90 00 00 00    	imul   $0x90,%eax,%eax
{
   130cb:	55                   	push   %ebp
   130cc:	57                   	push   %edi
   130cd:	e8 56 39 ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
   130d2:	81 c2 2e df 00 00    	add    $0xdf2e,%edx
   130d8:	56                   	push   %esi
   130d9:	53                   	push   %ebx
	if (bottom <= top)
   130da:	8d b4 02 40 1d 01 00 	lea    0x11d40(%edx,%eax,1),%esi
   130e1:	8b 7e 30             	mov    0x30(%esi),%edi
   130e4:	8b 4e 2c             	mov    0x2c(%esi),%ecx
   130e7:	39 cf                	cmp    %ecx,%edi
   130e9:	76 3b                	jbe    13126 <scrdown+0x61>
   130eb:	8d 6f ff             	lea    -0x1(%edi),%ebp
   130ee:	89 f3                	mov    %esi,%ebx
   130f0:	8b 06                	mov    (%esi),%eax
   130f2:	8b 5b 18             	mov    0x18(%ebx),%ebx
   130f5:	89 ee                	mov    %ebp,%esi
   130f7:	29 ce                	sub    %ecx,%esi
   130f9:	8b 8a d8 21 01 00    	mov    0x121d8(%edx),%ecx
   130ff:	83 eb 04             	sub    $0x4,%ebx
   13102:	0f af ce             	imul   %esi,%ecx
   13105:	8b b2 cc 21 01 00    	mov    0x121cc(%edx),%esi
   1310b:	0f af fe             	imul   %esi,%edi
   1310e:	d1 e9                	shr    %ecx
   13110:	0f af f5             	imul   %ebp,%esi
   13113:	01 df                	add    %ebx,%edi
   13115:	01 de                	add    %ebx,%esi
			:);
	}
	// 如果不是EGA显示类型,则执行以下操作(与上面完成一样).
	else														/* Not EGA/VGA */
	{
		__asm__("std\n\t"
   13117:	fd                   	std    
   13118:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1311a:	83 c7 02             	add    $0x2,%edi
   1311d:	8b 0d d8 31 03 00    	mov    0x331d8,%ecx
   13123:	f3 66 ab             	rep stos %ax,%es:(%edi)
			"c" ((bottom - top - 1) * video_num_columns >> 1),
			"D" (origin + video_size_row * bottom - 4),
			"S" (origin + video_size_row * (bottom - 1) - 4)
			:);
	}
}
   13126:	5b                   	pop    %ebx
   13127:	5e                   	pop    %esi
   13128:	5f                   	pop    %edi
   13129:	5d                   	pop    %ebp
   1312a:	c3                   	ret    

0001312b <cr>:
// 光标回到第1列(0列).
// 调整光标对应内存位置pos.光标所在列号*2即是0列到光标所在列对应的内存字节长度.
// 函数名称cr(carriage return回车)指明处理的控制字符的回车.
static void cr(int currcons)
{
	pos -= x << 1;										// 减去0列到光标处占用的内存字节数.
   1312b:	69 c0 90 00 00 00    	imul   $0x90,%eax,%eax
{
   13131:	53                   	push   %ebx
   13132:	e8 47 6d ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
   13137:	81 c1 c9 de 00 00    	add    $0xdec9,%ecx
	pos -= x << 1;										// 减去0列到光标处占用的内存字节数.
   1313d:	8d 9c 01 40 1d 01 00 	lea    0x11d40(%ecx,%eax,1),%ebx
   13144:	8b 53 24             	mov    0x24(%ebx),%edx
	x = 0;
   13147:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
}
   1314e:	5b                   	pop    %ebx
	pos -= x << 1;										// 减去0列到光标处占用的内存字节数.
   1314f:	01 d2                	add    %edx,%edx
   13151:	29 94 01 60 1d 01 00 	sub    %edx,0x11d60(%ecx,%eax,1)
}
   13158:	c3                   	ret    

00013159 <csi_P>:
// 删除光标处的nr个字符.
// ANSI转义序列:'ESC [ Pn P'.该控制序列从光标处删除Pn个字符.当一个字符被删除时,光标右所有字符都左移,这会在右边界处产生一个空字符.其属性应该与最后一个左移字符
// 相同,但这里作了简化处理,仅使用字符的默认属性(黑底白字空格0x0720)来设置空字符.
// 参数nr = 转义字符序列中的参数Pn.
static void csi_P(int currcons, unsigned int nr)
{
   13159:	55                   	push   %ebp
   1315a:	57                   	push   %edi
   1315b:	56                   	push   %esi
   1315c:	53                   	push   %ebx
   1315d:	e8 20 6d ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   13162:	81 c6 9e de 00 00    	add    $0xde9e,%esi
   13168:	83 ec 10             	sub    $0x10,%esp
	// 如果删除的字符数大于一行字符数,则截为一行字符数;若删除字符数nr为0,则删除1个字符.然后循环删除光标处指定字符数nr.
	if (nr > video_num_columns)
   1316b:	8b 8e d8 21 01 00    	mov    0x121d8(%esi),%ecx
   13171:	39 d1                	cmp    %edx,%ecx
   13173:	72 0b                	jb     13180 <csi_P+0x27>
		nr = video_num_columns;
	else if (!nr)
   13175:	85 d2                	test   %edx,%edx
   13177:	75 09                	jne    13182 <csi_P+0x29>
		nr = 1;
   13179:	ba 01 00 00 00       	mov    $0x1,%edx
   1317e:	eb 02                	jmp    13182 <csi_P+0x29>
   13180:	89 ca                	mov    %ecx,%edx
	if (x >= video_num_columns)
   13182:	69 c0 90 00 00 00    	imul   $0x90,%eax,%eax
   13188:	8d 3c 30             	lea    (%eax,%esi,1),%edi
   1318b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
	while (nr--)
   1318f:	4a                   	dec    %edx
   13190:	83 fa ff             	cmp    $0xffffffff,%edx
   13193:	74 59                	je     131ee <csi_P+0x95>
	if (x >= video_num_columns)
   13195:	8b 7c 24 0c          	mov    0xc(%esp),%edi
   13199:	8b 9f 64 1d 01 00    	mov    0x11d64(%edi),%ebx
   1319f:	39 d9                	cmp    %ebx,%ecx
   131a1:	89 1c 24             	mov    %ebx,(%esp)
   131a4:	76 e9                	jbe    1318f <csi_P+0x36>
	unsigned short * p = (unsigned short *) pos;
   131a6:	8d ae 40 1d 01 00    	lea    0x11d40(%esi),%ebp
   131ac:	8b 5c 05 20          	mov    0x20(%ebp,%eax,1),%ebx
   131b0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
	i = x;
   131b4:	8b 1c 24             	mov    (%esp),%ebx
   131b7:	89 5c 24 08          	mov    %ebx,0x8(%esp)
	unsigned short * p = (unsigned short *) pos;
   131bb:	8b 5c 24 04          	mov    0x4(%esp),%ebx
	while (++i < video_num_columns) {				// 光标右所有字符左移1格.
   131bf:	ff 44 24 08          	incl   0x8(%esp)
   131c3:	39 4c 24 08          	cmp    %ecx,0x8(%esp)
   131c7:	74 0d                	je     131d6 <csi_P+0x7d>
		*p = *(p + 1);
   131c9:	66 8b 7b 02          	mov    0x2(%ebx),%di
		p++;
   131cd:	83 c3 02             	add    $0x2,%ebx
		*p = *(p + 1);
   131d0:	66 89 7b fe          	mov    %di,-0x2(%ebx)
   131d4:	eb e9                	jmp    131bf <csi_P+0x66>
	*p = video_erase_char;							// 最后填入擦除字符.
   131d6:	8d 99 ff ff ff 7f    	lea    0x7fffffff(%ecx),%ebx
   131dc:	2b 1c 24             	sub    (%esp),%ebx
   131df:	8b 7c 05 00          	mov    0x0(%ebp,%eax,1),%edi
   131e3:	8b 6c 24 04          	mov    0x4(%esp),%ebp
   131e7:	66 89 7c 5d 00       	mov    %di,0x0(%ebp,%ebx,2)
   131ec:	eb a1                	jmp    1318f <csi_P+0x36>
		delete_char(currcons);
}
   131ee:	83 c4 10             	add    $0x10,%esp
   131f1:	5b                   	pop    %ebx
   131f2:	5e                   	pop    %esi
   131f3:	5f                   	pop    %edi
   131f4:	5d                   	pop    %ebp
   131f5:	c3                   	ret    

000131f6 <set_origin>:
{
   131f6:	56                   	push   %esi
   131f7:	53                   	push   %ebx
   131f8:	e8 2f 38 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   131fd:	81 c3 03 de 00 00    	add    $0xde03,%ebx
	if (video_type != VIDEO_TYPE_EGAC && video_type != VIDEO_TYPE_EGAM)
   13203:	8a 93 dc 21 01 00    	mov    0x121dc(%ebx),%dl
   13209:	83 ea 20             	sub    $0x20,%edx
   1320c:	80 fa 01             	cmp    $0x1,%dl
   1320f:	77 62                	ja     13273 <set_origin+0x7d>
	if (currcons != fg_console)
   13211:	c7 c2 a0 51 02 00    	mov    $0x251a0,%edx
   13217:	8b 0a                	mov    (%edx),%ecx
   13219:	39 c1                	cmp    %eax,%ecx
   1321b:	75 56                	jne    13273 <set_origin+0x7d>
	cli();
   1321d:	fa                   	cli    
	outb_p(12, video_port_reg);											// 选择数据寄存器r12,输出滚屏起始位置高字节.
   1321e:	66 8b b3 c6 21 01 00 	mov    0x121c6(%ebx),%si
   13225:	b8 0c 00 00 00       	mov    $0xc,%eax
   1322a:	89 f2                	mov    %esi,%edx
   1322c:	ee                   	out    %al,(%dx)
   1322d:	eb 00                	jmp    1322f <set_origin+0x39>
   1322f:	eb 00                	jmp    13231 <set_origin+0x3b>
	outb_p(0xff & ((origin - video_mem_base) >> 9), video_port_val);
   13231:	69 c9 90 00 00 00    	imul   $0x90,%ecx,%ecx
   13237:	8b 8c 0b 58 1d 01 00 	mov    0x11d58(%ebx,%ecx,1),%ecx
   1323e:	2b 8b d4 21 01 00    	sub    0x121d4(%ebx),%ecx
   13244:	66 8b 9b c4 21 01 00 	mov    0x121c4(%ebx),%bx
   1324b:	89 c8                	mov    %ecx,%eax
   1324d:	89 da                	mov    %ebx,%edx
   1324f:	c1 e8 09             	shr    $0x9,%eax
   13252:	0f b6 c0             	movzbl %al,%eax
   13255:	ee                   	out    %al,(%dx)
   13256:	eb 00                	jmp    13258 <set_origin+0x62>
   13258:	eb 00                	jmp    1325a <set_origin+0x64>
	outb_p(13, video_port_reg);											// 选择数据寄存器r13,输出滚屏起始位置低字节.
   1325a:	b8 0d 00 00 00       	mov    $0xd,%eax
   1325f:	89 f2                	mov    %esi,%edx
   13261:	ee                   	out    %al,(%dx)
   13262:	eb 00                	jmp    13264 <set_origin+0x6e>
   13264:	eb 00                	jmp    13266 <set_origin+0x70>
	outb_p(0xff & ((origin - video_mem_base) >> 1), video_port_val);
   13266:	d1 e9                	shr    %ecx
   13268:	89 da                	mov    %ebx,%edx
   1326a:	0f b6 c1             	movzbl %cl,%eax
   1326d:	ee                   	out    %al,(%dx)
   1326e:	eb 00                	jmp    13270 <set_origin+0x7a>
   13270:	eb 00                	jmp    13272 <set_origin+0x7c>
	sti();
   13272:	fb                   	sti    
}
   13273:	5b                   	pop    %ebx
   13274:	5e                   	pop    %esi
   13275:	c3                   	ret    

00013276 <scrup>:
{
   13276:	55                   	push   %ebp
   13277:	57                   	push   %edi
   13278:	56                   	push   %esi
   13279:	53                   	push   %ebx
   1327a:	e8 ff 6b ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
   1327f:	81 c1 81 dd 00 00    	add    $0xdd81,%ecx
   13285:	83 ec 10             	sub    $0x10,%esp
   13288:	89 44 24 08          	mov    %eax,0x8(%esp)
	if (bottom <= top)
   1328c:	8d 81 40 1d 01 00    	lea    0x11d40(%ecx),%eax
   13292:	89 44 24 0c          	mov    %eax,0xc(%esp)
   13296:	8b 74 24 0c          	mov    0xc(%esp),%esi
   1329a:	69 44 24 08 90 00 00 	imul   $0x90,0x8(%esp),%eax
   132a1:	00 
   132a2:	8d 2c 30             	lea    (%eax,%esi,1),%ebp
   132a5:	8d 9c 01 40 1d 01 00 	lea    0x11d40(%ecx,%eax,1),%ebx
   132ac:	8b 75 30             	mov    0x30(%ebp),%esi
   132af:	8b 7b 2c             	mov    0x2c(%ebx),%edi
   132b2:	39 fe                	cmp    %edi,%esi
   132b4:	89 34 24             	mov    %esi,(%esp)
   132b7:	0f 86 d9 00 00 00    	jbe    13396 <scrup+0x120>
   132bd:	8b 81 d8 21 01 00    	mov    0x121d8(%ecx),%eax
   132c3:	8b 73 18             	mov    0x18(%ebx),%esi
   132c6:	8b 91 cc 21 01 00    	mov    0x121cc(%ecx),%edx
   132cc:	89 44 24 04          	mov    %eax,0x4(%esp)
	if (video_type == VIDEO_TYPE_EGAC || video_type == VIDEO_TYPE_EGAM)
   132d0:	8a 81 dc 21 01 00    	mov    0x121dc(%ecx),%al
   132d6:	83 e8 20             	sub    $0x20,%eax
   132d9:	3c 01                	cmp    $0x1,%al
   132db:	0f 87 8d 00 00 00    	ja     1336e <scrup+0xf8>
		if (!top && bottom == video_num_lines) {
   132e1:	85 ff                	test   %edi,%edi
   132e3:	75 73                	jne    13358 <scrup+0xe2>
   132e5:	8b 04 24             	mov    (%esp),%eax
   132e8:	3b 81 c8 21 01 00    	cmp    0x121c8(%ecx),%eax
   132ee:	75 68                	jne    13358 <scrup+0xe2>
			pos += video_size_row;
   132f0:	8b 45 20             	mov    0x20(%ebp),%eax
			scr_end += video_size_row;
   132f3:	8b 7b 1c             	mov    0x1c(%ebx),%edi
			origin += video_size_row;
   132f6:	01 d6                	add    %edx,%esi
   132f8:	89 73 18             	mov    %esi,0x18(%ebx)
			pos += video_size_row;
   132fb:	01 d0                	add    %edx,%eax
			scr_end += video_size_row;
   132fd:	01 fa                	add    %edi,%edx
			if (scr_end > video_mem_end) {
   132ff:	3b 53 7c             	cmp    0x7c(%ebx),%edx
			pos += video_size_row;
   13302:	89 44 24 0c          	mov    %eax,0xc(%esp)
   13306:	89 45 20             	mov    %eax,0x20(%ebp)
			scr_end += video_size_row;
   13309:	89 53 1c             	mov    %edx,0x1c(%ebx)
   1330c:	8b 45 00             	mov    0x0(%ebp),%eax
			if (scr_end > video_mem_end) {
   1330f:	76 2f                	jbe    13340 <scrup+0xca>
					"c" ((video_num_lines - 1) * video_num_columns >> 1),
   13311:	8b 0c 24             	mov    (%esp),%ecx
					"D" (video_mem_start),
   13314:	8b 7b 78             	mov    0x78(%ebx),%edi
					"c" ((video_num_lines - 1) * video_num_columns >> 1),
   13317:	49                   	dec    %ecx
   13318:	0f af 4c 24 04       	imul   0x4(%esp),%ecx
   1331d:	d1 e9                	shr    %ecx
				__asm__("cld\n\t"											// 清方向位
   1331f:	fc                   	cld    
   13320:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   13322:	8b 0d d8 31 03 00    	mov    0x331d8,%ecx
   13328:	f3 66 ab             	rep stos %ax,%es:(%edi)
				scr_end -= origin - video_mem_start;
   1332b:	89 f8                	mov    %edi,%eax
				origin = video_mem_start;
   1332d:	89 7b 18             	mov    %edi,0x18(%ebx)
				scr_end -= origin - video_mem_start;
   13330:	29 f0                	sub    %esi,%eax
   13332:	01 c2                	add    %eax,%edx
				pos -= origin - video_mem_start;
   13334:	03 44 24 0c          	add    0xc(%esp),%eax
				scr_end -= origin - video_mem_start;
   13338:	89 53 1c             	mov    %edx,0x1c(%ebx)
				pos -= origin - video_mem_start;
   1333b:	89 45 20             	mov    %eax,0x20(%ebp)
   1333e:	eb 08                	jmp    13348 <scrup+0xd2>
				__asm__("cld\n\t"
   13340:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   13344:	fc                   	cld    
   13345:	f3 66 ab             	rep stos %ax,%es:(%edi)
			set_origin(currcons);
   13348:	8b 44 24 08          	mov    0x8(%esp),%eax
}
   1334c:	83 c4 10             	add    $0x10,%esp
   1334f:	5b                   	pop    %ebx
   13350:	5e                   	pop    %esi
   13351:	5f                   	pop    %edi
   13352:	5d                   	pop    %ebp
			set_origin(currcons);
   13353:	e9 9e fe ff ff       	jmp    131f6 <set_origin>
				::"a" (video_erase_char),
   13358:	69 44 24 08 90 00 00 	imul   $0x90,0x8(%esp),%eax
   1335f:	00 
			__asm__("cld\n\t"
   13360:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
				"D" (origin + video_size_row * top),
   13364:	89 fb                	mov    %edi,%ebx
   13366:	0f af da             	imul   %edx,%ebx
			__asm__("cld\n\t"
   13369:	8b 04 01             	mov    (%ecx,%eax,1),%eax
   1336c:	eb 08                	jmp    13376 <scrup+0x100>
			"D" (origin + video_size_row * top),
   1336e:	89 fb                	mov    %edi,%ebx
		__asm__("cld\n\t"
   13370:	8b 45 00             	mov    0x0(%ebp),%eax
			"D" (origin + video_size_row * top),
   13373:	0f af da             	imul   %edx,%ebx
			"c" ((bottom - top - 1) * video_num_columns >> 1),
   13376:	8b 0c 24             	mov    (%esp),%ecx
			"S" (origin + video_size_row * (top + 1))
   13379:	01 da                	add    %ebx,%edx
			"c" ((bottom - top - 1) * video_num_columns >> 1),
   1337b:	49                   	dec    %ecx
   1337c:	29 f9                	sub    %edi,%ecx
			"D" (origin + video_size_row * top),
   1337e:	8d 3c 33             	lea    (%ebx,%esi,1),%edi
			"S" (origin + video_size_row * (top + 1))
   13381:	01 d6                	add    %edx,%esi
			"c" ((bottom - top - 1) * video_num_columns >> 1),
   13383:	0f af 4c 24 04       	imul   0x4(%esp),%ecx
   13388:	d1 e9                	shr    %ecx
		__asm__("cld\n\t"
   1338a:	fc                   	cld    
   1338b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
   1338d:	8b 0d d8 31 03 00    	mov    0x331d8,%ecx
   13393:	f3 66 ab             	rep stos %ax,%es:(%edi)
}
   13396:	83 c4 10             	add    $0x10,%esp
   13399:	5b                   	pop    %ebx
   1339a:	5e                   	pop    %esi
   1339b:	5f                   	pop    %edi
   1339c:	5d                   	pop    %ebp
   1339d:	c3                   	ret    

0001339e <lf>:
	if (y + 1 < bottom) {
   1339e:	69 c8 90 00 00 00    	imul   $0x90,%eax,%ecx
{
   133a4:	56                   	push   %esi
   133a5:	53                   	push   %ebx
   133a6:	e8 81 36 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   133ab:	81 c3 55 dc 00 00    	add    $0xdc55,%ebx
	if (y + 1 < bottom) {
   133b1:	8d b4 0b 40 1d 01 00 	lea    0x11d40(%ebx,%ecx,1),%esi
   133b8:	8b 56 28             	mov    0x28(%esi),%edx
   133bb:	42                   	inc    %edx
   133bc:	3b 56 30             	cmp    0x30(%esi),%edx
   133bf:	73 0f                	jae    133d0 <lf+0x32>
		pos += video_size_row;							// 加上屏幕一行占用内存的字节数.
   133c1:	8b 83 cc 21 01 00    	mov    0x121cc(%ebx),%eax
		y++;
   133c7:	89 56 28             	mov    %edx,0x28(%esi)
		pos += video_size_row;							// 加上屏幕一行占用内存的字节数.
   133ca:	01 46 20             	add    %eax,0x20(%esi)
}
   133cd:	5b                   	pop    %ebx
   133ce:	5e                   	pop    %esi
   133cf:	c3                   	ret    
   133d0:	5b                   	pop    %ebx
   133d1:	5e                   	pop    %esi
	scrup(currcons);									// 将屏幕窗口内容上移一行.
   133d2:	e9 9f fe ff ff       	jmp    13276 <scrup>

000133d7 <set_cursor>:
{
   133d7:	56                   	push   %esi
   133d8:	53                   	push   %ebx
   133d9:	e8 4e 36 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   133de:	81 c3 22 dc 00 00    	add    $0xdc22,%ebx
	blankcount = blankinterval;						// 复位黑屏操作的计数值.
   133e4:	8b 93 28 1d 01 00    	mov    0x11d28(%ebx),%edx
   133ea:	89 93 24 1d 01 00    	mov    %edx,0x11d24(%ebx)
	if (currcons != fg_console)
   133f0:	c7 c2 a0 51 02 00    	mov    $0x251a0,%edx
   133f6:	8b 0a                	mov    (%edx),%ecx
   133f8:	39 c1                	cmp    %eax,%ecx
   133fa:	75 56                	jne    13452 <set_cursor+0x7b>
	cli();
   133fc:	fa                   	cli    
	outb_p(14, video_port_reg);
   133fd:	66 8b b3 c6 21 01 00 	mov    0x121c6(%ebx),%si
   13404:	b8 0e 00 00 00       	mov    $0xe,%eax
   13409:	89 f2                	mov    %esi,%edx
   1340b:	ee                   	out    %al,(%dx)
   1340c:	eb 00                	jmp    1340e <set_cursor+0x37>
   1340e:	eb 00                	jmp    13410 <set_cursor+0x39>
	outb_p(0xff & ((pos - video_mem_base) >> 9), video_port_val);
   13410:	69 c9 90 00 00 00    	imul   $0x90,%ecx,%ecx
   13416:	8b 8c 0b 60 1d 01 00 	mov    0x11d60(%ebx,%ecx,1),%ecx
   1341d:	2b 8b d4 21 01 00    	sub    0x121d4(%ebx),%ecx
   13423:	66 8b 9b c4 21 01 00 	mov    0x121c4(%ebx),%bx
   1342a:	89 c8                	mov    %ecx,%eax
   1342c:	89 da                	mov    %ebx,%edx
   1342e:	c1 e8 09             	shr    $0x9,%eax
   13431:	0f b6 c0             	movzbl %al,%eax
   13434:	ee                   	out    %al,(%dx)
   13435:	eb 00                	jmp    13437 <set_cursor+0x60>
   13437:	eb 00                	jmp    13439 <set_cursor+0x62>
	outb_p(15, video_port_reg);
   13439:	b8 0f 00 00 00       	mov    $0xf,%eax
   1343e:	89 f2                	mov    %esi,%edx
   13440:	ee                   	out    %al,(%dx)
   13441:	eb 00                	jmp    13443 <set_cursor+0x6c>
   13443:	eb 00                	jmp    13445 <set_cursor+0x6e>
	outb_p(0xff & ((pos - video_mem_base) >> 1), video_port_val);
   13445:	d1 e9                	shr    %ecx
   13447:	89 da                	mov    %ebx,%edx
   13449:	0f b6 c1             	movzbl %cl,%eax
   1344c:	ee                   	out    %al,(%dx)
   1344d:	eb 00                	jmp    1344f <set_cursor+0x78>
   1344f:	eb 00                	jmp    13451 <set_cursor+0x7a>
	sti();
   13451:	fb                   	sti    
}
   13452:	5b                   	pop    %ebx
   13453:	5e                   	pop    %esi
   13454:	c3                   	ret    

00013455 <csi_m>:
{
   13455:	55                   	push   %ebp
   13456:	57                   	push   %edi
   13457:	56                   	push   %esi
   13458:	53                   	push   %ebx
	for (i = 0; i <= npar; i++)
   13459:	31 f6                	xor    %esi,%esi
   1345b:	e8 1a 6a ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   13460:	05 a0 db 00 00       	add    $0xdba0,%eax
{
   13465:	83 ec 08             	sub    $0x8,%esp
	for (i = 0; i <= npar; i++)
   13468:	69 54 24 1c 90 00 00 	imul   $0x90,0x1c(%esp),%edx
   1346f:	00 
   13470:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   13473:	8b b9 74 1d 01 00    	mov    0x11d74(%ecx),%edi
   13479:	89 7c 24 04          	mov    %edi,0x4(%esp)
			  if (!can_do_colour)
   1347d:	8b b8 c0 21 01 00    	mov    0x121c0(%eax),%edi
   13483:	8d 84 10 40 1d 01 00 	lea    0x11d40(%eax,%edx,1),%eax
   1348a:	89 04 24             	mov    %eax,(%esp)
	for (i = 0; i <= npar; i++)
   1348d:	3b 74 24 04          	cmp    0x4(%esp),%esi
   13491:	0f 87 98 01 00 00    	ja     1362f <csi_m+0x1da>
		switch (par[i]) {
   13497:	8b 04 24             	mov    (%esp),%eax
   1349a:	8b 44 b0 38          	mov    0x38(%eax,%esi,4),%eax
   1349e:	83 f8 16             	cmp    $0x16,%eax
   134a1:	0f 84 14 01 00 00    	je     135bb <csi_m+0x166>
   134a7:	77 37                	ja     134e0 <csi_m+0x8b>
   134a9:	83 f8 04             	cmp    $0x4,%eax
   134ac:	0f 84 a6 00 00 00    	je     13558 <csi_m+0x103>
   134b2:	77 0e                	ja     134c2 <csi_m+0x6d>
   134b4:	85 c0                	test   %eax,%eax
   134b6:	74 76                	je     1352e <csi_m+0xd9>
   134b8:	83 f8 01             	cmp    $0x1,%eax
   134bb:	74 79                	je     13536 <csi_m+0xe1>
   134bd:	e9 27 01 00 00       	jmp    135e9 <csi_m+0x194>
   134c2:	83 f8 05             	cmp    $0x5,%eax
   134c5:	0f 84 e7 00 00 00    	je     135b2 <csi_m+0x15d>
   134cb:	83 f8 07             	cmp    $0x7,%eax
   134ce:	0f 85 15 01 00 00    	jne    135e9 <csi_m+0x194>
			case 7: attr = (attr << 4) | (attr >> 4); break;  				/* negative */
   134d4:	c0 81 42 1d 01 00 04 	rolb   $0x4,0x11d42(%ecx)
   134db:	e9 49 01 00 00       	jmp    13629 <csi_m+0x1d4>
		switch (par[i]) {
   134e0:	83 f8 1b             	cmp    $0x1b,%eax
   134e3:	74 49                	je     1352e <csi_m+0xd9>
   134e5:	77 1e                	ja     13505 <csi_m+0xb0>
   134e7:	83 f8 18             	cmp    $0x18,%eax
   134ea:	0f 84 d4 00 00 00    	je     135c4 <csi_m+0x16f>
   134f0:	83 f8 19             	cmp    $0x19,%eax
   134f3:	0f 85 f0 00 00 00    	jne    135e9 <csi_m+0x194>
			case 25: attr = attr & 0x7f; break;  							/* not blinking */
   134f9:	80 a1 42 1d 01 00 7f 	andb   $0x7f,0x11d42(%ecx)
   13500:	e9 24 01 00 00       	jmp    13629 <csi_m+0x1d4>
		switch (par[i]) {
   13505:	83 f8 27             	cmp    $0x27,%eax
   13508:	0f 84 bf 00 00 00    	je     135cd <csi_m+0x178>
   1350e:	83 f8 31             	cmp    $0x31,%eax
   13511:	0f 85 d2 00 00 00    	jne    135e9 <csi_m+0x194>
			case 49: attr = (attr & 0x0f) | (def_attr & 0xf0); break;
   13517:	8a 81 42 1d 01 00    	mov    0x11d42(%ecx),%al
   1351d:	8a 99 43 1d 01 00    	mov    0x11d43(%ecx),%bl
   13523:	83 e0 0f             	and    $0xf,%eax
   13526:	83 e3 f0             	and    $0xfffffff0,%ebx
   13529:	e9 b1 00 00 00       	jmp    135df <csi_m+0x18a>
				attr = def_attr; break;  									/* default */
   1352e:	8a 91 43 1d 01 00    	mov    0x11d43(%ecx),%dl
   13534:	eb 74                	jmp    135aa <csi_m+0x155>
   13536:	8a 91 42 1d 01 00    	mov    0x11d42(%ecx),%dl
				attr = (iscolor ? attr | 0x08 : attr | 0x0f); break;  		/* bold */
   1353c:	88 d0                	mov    %dl,%al
   1353e:	83 c8 0f             	or     $0xf,%eax
   13541:	83 b9 c8 1d 01 00 00 	cmpl   $0x0,0x11dc8(%ecx)
   13548:	0f 84 93 00 00 00    	je     135e1 <csi_m+0x18c>
   1354e:	88 d0                	mov    %dl,%al
   13550:	83 c8 08             	or     $0x8,%eax
   13553:	e9 89 00 00 00       	jmp    135e1 <csi_m+0x18c>
   13558:	8d 81 40 1d 01 00    	lea    0x11d40(%ecx),%eax
			  if (!iscolor)
   1355e:	83 b8 88 00 00 00 00 	cmpl   $0x0,0x88(%eax)
   13565:	8a 58 02             	mov    0x2(%eax),%bl
   13568:	75 05                	jne    1356f <csi_m+0x11a>
			    attr |= 0x01;												// 单色则带下划线显示.
   1356a:	83 cb 01             	or     $0x1,%ebx
   1356d:	eb 10                	jmp    1357f <csi_m+0x12a>
			    if (vc_cons[currcons].vc_bold_attr != -1)
   1356f:	8b 68 04             	mov    0x4(%eax),%ebp
   13572:	83 fd ff             	cmp    $0xffffffff,%ebp
   13575:	74 10                	je     13587 <csi_m+0x132>
			      attr = (vc_cons[currcons].vc_bold_attr & 0x0f) | (0xf0 & (attr));
   13577:	83 e5 0f             	and    $0xf,%ebp
   1357a:	83 e3 f0             	and    $0xfffffff0,%ebx
   1357d:	09 eb                	or     %ebp,%ebx
   1357f:	88 58 02             	mov    %bl,0x2(%eax)
   13582:	e9 a2 00 00 00       	jmp    13629 <csi_m+0x1d4>
			    	short newattr = (attr&0xf0)|(0xf&(~attr));
   13587:	88 da                	mov    %bl,%dl
			      	attr = ((newattr&0xf)==((attr>>4)&0xf)?
   13589:	88 d8                	mov    %bl,%al
			    	short newattr = (attr&0xf0)|(0xf&(~attr));
   1358b:	83 f2 0f             	xor    $0xf,%edx
			      	attr = ((newattr&0xf)==((attr>>4)&0xf)?
   1358e:	c0 e8 04             	shr    $0x4,%al
   13591:	31 d0                	xor    %edx,%eax
   13593:	a8 0f                	test   $0xf,%al
   13595:	75 13                	jne    135aa <csi_m+0x155>
			        (attr&0xf0)|(((attr&0xf)+1)%0xf):
   13597:	89 d8                	mov    %ebx,%eax
   13599:	bd 0f 00 00 00       	mov    $0xf,%ebp
   1359e:	83 e3 f0             	and    $0xfffffff0,%ebx
   135a1:	83 e0 0f             	and    $0xf,%eax
   135a4:	40                   	inc    %eax
   135a5:	99                   	cltd   
   135a6:	f7 fd                	idiv   %ebp
   135a8:	09 da                	or     %ebx,%edx
			      	attr = ((newattr&0xf)==((attr>>4)&0xf)?
   135aa:	88 91 42 1d 01 00    	mov    %dl,0x11d42(%ecx)
   135b0:	eb 77                	jmp    13629 <csi_m+0x1d4>
			case 5: attr = attr | 0x80; break;  							/* blinking */
   135b2:	80 89 42 1d 01 00 80 	orb    $0x80,0x11d42(%ecx)
   135b9:	eb 6e                	jmp    13629 <csi_m+0x1d4>
			case 22: attr = attr & 0xf7; break; 							/* not bold */
   135bb:	80 a1 42 1d 01 00 f7 	andb   $0xf7,0x11d42(%ecx)
   135c2:	eb 65                	jmp    13629 <csi_m+0x1d4>
			case 24: attr = attr & 0xfe; break;  							/* not underline */
   135c4:	80 a1 42 1d 01 00 fe 	andb   $0xfe,0x11d42(%ecx)
   135cb:	eb 5c                	jmp    13629 <csi_m+0x1d4>
			case 39: attr = (attr & 0xf0) | (def_attr & 0x0f); break;
   135cd:	8a 81 42 1d 01 00    	mov    0x11d42(%ecx),%al
   135d3:	8a 99 43 1d 01 00    	mov    0x11d43(%ecx),%bl
   135d9:	83 e0 f0             	and    $0xfffffff0,%eax
   135dc:	83 e3 0f             	and    $0xf,%ebx
   135df:	09 d8                	or     %ebx,%eax
   135e1:	88 81 42 1d 01 00    	mov    %al,0x11d42(%ecx)
   135e7:	eb 40                	jmp    13629 <csi_m+0x1d4>
			  if (!can_do_colour)
   135e9:	85 ff                	test   %edi,%edi
   135eb:	74 3c                	je     13629 <csi_m+0x1d4>
			  if ((par[i] >= 30) && (par[i] <= 38))		 					// 设置前景色.
   135ed:	8d 58 e2             	lea    -0x1e(%eax),%ebx
			  iscolor = 1;
   135f0:	8d 91 40 1d 01 00    	lea    0x11d40(%ecx),%edx
			  if ((par[i] >= 30) && (par[i] <= 38))		 					// 设置前景色.
   135f6:	83 fb 08             	cmp    $0x8,%ebx
			  iscolor = 1;
   135f9:	c7 82 88 00 00 00 01 	movl   $0x1,0x88(%edx)
   13600:	00 00 00 
			  if ((par[i] >= 30) && (par[i] <= 38))		 					// 设置前景色.
   13603:	77 0b                	ja     13610 <csi_m+0x1bb>
			    attr = (attr & 0xf0) | (par[i] - 30);
   13605:	8a 5a 02             	mov    0x2(%edx),%bl
   13608:	83 e8 1e             	sub    $0x1e,%eax
   1360b:	83 e3 f0             	and    $0xfffffff0,%ebx
   1360e:	eb 14                	jmp    13624 <csi_m+0x1cf>
			    if ((par[i] >= 40) && (par[i] <= 48))
   13610:	8d 58 d8             	lea    -0x28(%eax),%ebx
   13613:	83 fb 08             	cmp    $0x8,%ebx
   13616:	77 11                	ja     13629 <csi_m+0x1d4>
			      attr = (attr & 0x0f) | ((par[i] - 40) << 4);
   13618:	8a 5a 02             	mov    0x2(%edx),%bl
   1361b:	83 e8 28             	sub    $0x28,%eax
   1361e:	c1 e0 04             	shl    $0x4,%eax
   13621:	83 e3 0f             	and    $0xf,%ebx
   13624:	09 d8                	or     %ebx,%eax
   13626:	88 42 02             	mov    %al,0x2(%edx)
	for (i = 0; i <= npar; i++)
   13629:	46                   	inc    %esi
   1362a:	e9 5e fe ff ff       	jmp    1348d <csi_m+0x38>
}
   1362f:	83 c4 08             	add    $0x8,%esp
   13632:	5b                   	pop    %ebx
   13633:	5e                   	pop    %esi
   13634:	5f                   	pop    %edi
   13635:	5d                   	pop    %ebp
   13636:	c3                   	ret    

00013637 <con_write>:
// 控制台写函数
// 从终端对应的tty写缓冲队列中取字符针对每个字符进行分析.若是控制字符或转义或控制序列,则进行光标定位,字符删除等的控制处理;对于普通字符就直接在光标处
// 显示.
// 参数:tty是当前控制台使用的tty结构指针.
void con_write(struct tty_struct * tty)
{
   13637:	55                   	push   %ebp
   13638:	57                   	push   %edi
   13639:	56                   	push   %esi
   1363a:	53                   	push   %ebx
   1363b:	e8 ec 33 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   13640:	81 c3 c0 d9 00 00    	add    $0xd9c0,%ebx
   13646:	83 ec 3c             	sub    $0x3c,%esp
   13649:	8b 44 24 50          	mov    0x50(%esp),%eax
   1364d:	89 44 24 10          	mov    %eax,0x10(%esp)

	// 该函数首先根据当前控制台使用的tty在tty表的项位置取得对应控制台号currcons,然后计算出(CHARS())目前tty写队列中含有的字符数nr,并循环取出其中的每个
	// 字符进行处理.不过如果当前控制台由于接收键盘或发出的暂停命令(如按键Ctrl-S)而处于停止状态,那么本函数就停止处理写队列中的字符,退出函数.另外,如果取出的
	// 是控制字符CAN(24)或SUB(6),那么若是在转义或控制序列期间收到的,则序列不会执行而立刻终止,同时显示随后的字符.注意,con_write()函数只处理取队列字符数
	// 时写队列中当前含有的字符.这有可能在一个序列被放到写队列期间读取字符数,因此本函数前一次退出时state有可能处于处理转义或控制序列的其他状态上.
	currcons = tty - tty_table;
   13651:	81 e8 00 57 03 00    	sub    $0x35700,%eax
   13657:	c1 f8 06             	sar    $0x6,%eax
	if ((currcons >= MAX_CONSOLES) || (currcons < 0))
   1365a:	83 f8 07             	cmp    $0x7,%eax
	currcons = tty - tty_table;
   1365d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if ((currcons >= MAX_CONSOLES) || (currcons < 0))
   13661:	76 12                	jbe    13675 <con_write+0x3e>
		panic("con_write: illegal tty");
   13663:	8d 83 1a 86 ff ff    	lea    -0x79e6(%ebx),%eax
   13669:	83 ec 0c             	sub    $0xc,%esp
   1366c:	50                   	push   %eax
   1366d:	e8 60 4a ff ff       	call   80d2 <panic>
   13672:	83 c4 10             	add    $0x10,%esp

	nr = CHARS(tty->write_q);										// 取写队列中字符数,在tty.h文件中
   13675:	8b 44 24 10          	mov    0x10(%esp),%eax
	while (nr--) {
		if (tty->stopped)
			break;
		GETCH(tty->write_q, c);										// 取1字符到c中
		if (c == 24 || c == 26)										// 控制字符CAN,SUB - 取消,替换
			state = ESnormal;
   13679:	69 6c 24 0c 90 00 00 	imul   $0x90,0xc(%esp),%ebp
   13680:	00 
	nr = CHARS(tty->write_q);										// 取写队列中字符数,在tty.h文件中
   13681:	8b 50 38             	mov    0x38(%eax),%edx
   13684:	8b 42 04             	mov    0x4(%edx),%eax
   13687:	2b 42 08             	sub    0x8(%edx),%eax
   1368a:	25 ff 03 00 00       	and    $0x3ff,%eax
   1368f:	89 44 24 14          	mov    %eax,0x14(%esp)
			case ESgetpars:
				if (c == ';' && npar < NPAR - 1) {
					npar++;
					break;
				} else if (c >= '0' && c <= '9') {
					par[npar] = 10 * par[npar] + c - '0';
   13693:	6b 44 24 0c 24       	imul   $0x24,0xc(%esp),%eax
   13698:	89 44 24 20          	mov    %eax,0x20(%esp)

0001369c <.L81>:
	while (nr--) {
   1369c:	ff 4c 24 14          	decl   0x14(%esp)
   136a0:	83 7c 24 14 ff       	cmpl   $0xffffffff,0x14(%esp)
   136a5:	0f 84 86 09 00 00    	je     14031 <.L93+0x41>
		if (tty->stopped)
   136ab:	8b 44 24 10          	mov    0x10(%esp),%eax
   136af:	83 78 2c 00          	cmpl   $0x0,0x2c(%eax)
   136b3:	0f 85 78 09 00 00    	jne    14031 <.L93+0x41>
		GETCH(tty->write_q, c);										// 取1字符到c中
   136b9:	8b 48 38             	mov    0x38(%eax),%ecx
   136bc:	8b 41 08             	mov    0x8(%ecx),%eax
   136bf:	0f be 54 01 10       	movsbl 0x10(%ecx,%eax,1),%edx
   136c4:	40                   	inc    %eax
   136c5:	25 ff 03 00 00       	and    $0x3ff,%eax
   136ca:	89 41 08             	mov    %eax,0x8(%ecx)
		if (c == 24 || c == 26)										// 控制字符CAN,SUB - 取消,替换
   136cd:	88 d0                	mov    %dl,%al
   136cf:	83 e0 fd             	and    $0xfffffffd,%eax
   136d2:	3c 18                	cmp    $0x18,%al
   136d4:	75 0b                	jne    136e1 <.L81+0x45>
			state = ESnormal;
   136d6:	c7 84 2b 4c 1d 01 00 	movl   $0x0,0x11d4c(%ebx,%ebp,1)
   136dd:	00 00 00 00 
		switch(state) {
   136e1:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   136e8:	83 78 0c 07          	cmpl   $0x7,0xc(%eax)
   136ec:	0f 87 33 09 00 00    	ja     14025 <.L93+0x35>
   136f2:	8b 40 0c             	mov    0xc(%eax),%eax
   136f5:	8b bc 83 44 87 ff ff 	mov    -0x78bc(%ebx,%eax,4),%edi
   136fc:	01 df                	add    %ebx,%edi
   136fe:	ff e7                	jmp    *%edi

00013700 <.L85>:
				if (c > 31 && c < 127) {							// 是普通显示字符
   13700:	8d 42 e0             	lea    -0x20(%edx),%eax
   13703:	3c 5e                	cmp    $0x5e,%al
   13705:	77 5f                	ja     13766 <.L85+0x66>
					if (x >= video_num_columns) {					// 要换行?
   13707:	8d 8c 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%ecx
   1370e:	8b b3 d8 21 01 00    	mov    0x121d8(%ebx),%esi
   13714:	8b 41 24             	mov    0x24(%ecx),%eax
   13717:	39 f0                	cmp    %esi,%eax
   13719:	72 23                	jb     1373e <.L85+0x3e>
						x -= video_num_columns;
   1371b:	29 f0                	sub    %esi,%eax
   1371d:	88 54 24 18          	mov    %dl,0x18(%esp)
   13721:	89 41 24             	mov    %eax,0x24(%ecx)
						pos -= video_size_row;
   13724:	8b 41 20             	mov    0x20(%ecx),%eax
   13727:	2b 83 cc 21 01 00    	sub    0x121cc(%ebx),%eax
   1372d:	89 41 20             	mov    %eax,0x20(%ecx)
						lf(currcons);
   13730:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13734:	e8 65 fc ff ff       	call   1339e <lf>
   13739:	0f be 54 24 18       	movsbl 0x18(%esp),%edx
						"m" (*(short *)pos),
   1373e:	8d bc 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edi
						::"a" (translate[c - 32]),
   13745:	8b 87 8c 00 00 00    	mov    0x8c(%edi),%eax
						"m" (*(short *)pos),
   1374b:	8b 77 20             	mov    0x20(%edi),%esi
					__asm__("movb %2, %%ah\n\t"						// 写字符
   1374e:	8a 44 10 e0          	mov    -0x20(%eax,%edx,1),%al
   13752:	8a 67 02             	mov    0x2(%edi),%ah
   13755:	66 89 06             	mov    %ax,(%esi)
					pos += 2;
   13758:	83 c6 02             	add    $0x2,%esi
					x++;
   1375b:	ff 47 24             	incl   0x24(%edi)
					pos += 2;
   1375e:	89 77 20             	mov    %esi,0x20(%edi)
   13761:	e9 36 ff ff ff       	jmp    1369c <.L81>
				} else if (c == 27)									// ESC - 转义控制字符
   13766:	80 fa 1b             	cmp    $0x1b,%dl
   13769:	75 10                	jne    1377b <.L85+0x7b>
					state = ESesc;
   1376b:	c7 84 2b 4c 1d 01 00 	movl   $0x1,0x11d4c(%ebx,%ebp,1)
   13772:	01 00 00 00 
   13776:	e9 21 ff ff ff       	jmp    1369c <.L81>
				else if (c == 10 || c == 11 || c == 12)
   1377b:	8d 42 f6             	lea    -0xa(%edx),%eax
   1377e:	3c 02                	cmp    $0x2,%al
   13780:	0f 86 b9 00 00 00    	jbe    1383f <.L85+0x13f>
				else if (c == 13)									// CR - 回车
   13786:	80 fa 0d             	cmp    $0xd,%dl
   13789:	75 0e                	jne    13799 <.L85+0x99>
					cr(currcons);
   1378b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1378f:	e8 97 f9 ff ff       	call   1312b <cr>
   13794:	e9 03 ff ff ff       	jmp    1369c <.L81>
				else if (c == ERASE_CHAR(tty))
   13799:	8b 7c 24 10          	mov    0x10(%esp),%edi
   1379d:	0f be c2             	movsbl %dl,%eax
   137a0:	0f b6 4f 13          	movzbl 0x13(%edi),%ecx
   137a4:	39 c8                	cmp    %ecx,%eax
   137a6:	75 2a                	jne    137d2 <.L85+0xd2>
	if (x) {
   137a8:	8d b4 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%esi
   137af:	8b 46 24             	mov    0x24(%esi),%eax
   137b2:	85 c0                	test   %eax,%eax
   137b4:	0f 84 e2 fe ff ff    	je     1369c <.L81>
		pos -= 2;
   137ba:	8b 4e 20             	mov    0x20(%esi),%ecx
		x--;
   137bd:	48                   	dec    %eax
   137be:	89 46 24             	mov    %eax,0x24(%esi)
		*(unsigned short *)pos = video_erase_char;
   137c1:	8b 06                	mov    (%esi),%eax
		pos -= 2;
   137c3:	8d 79 fe             	lea    -0x2(%ecx),%edi
   137c6:	89 7e 20             	mov    %edi,0x20(%esi)
		*(unsigned short *)pos = video_erase_char;
   137c9:	66 89 41 fe          	mov    %ax,-0x2(%ecx)
   137cd:	e9 ca fe ff ff       	jmp    1369c <.L81>
				else if (c == 8) {									// BS - 后退.
   137d2:	80 fa 08             	cmp    $0x8,%dl
   137d5:	75 23                	jne    137fa <.L85+0xfa>
					if (x) {
   137d7:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   137de:	8b 42 24             	mov    0x24(%edx),%eax
   137e1:	85 c0                	test   %eax,%eax
   137e3:	0f 84 b3 fe ff ff    	je     1369c <.L81>
						x--;
   137e9:	48                   	dec    %eax
						pos -= 2;
   137ea:	83 ac 2b 60 1d 01 00 	subl   $0x2,0x11d60(%ebx,%ebp,1)
   137f1:	02 
						x--;
   137f2:	89 42 24             	mov    %eax,0x24(%edx)
   137f5:	e9 a2 fe ff ff       	jmp    1369c <.L81>
				} else if (c == 9) {								// HT - 水平制表
   137fa:	80 fa 09             	cmp    $0x9,%dl
   137fd:	75 4e                	jne    1384d <.L85+0x14d>
					c = 8 - (x & 7);
   137ff:	8d 8c 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%ecx
   13806:	b0 08                	mov    $0x8,%al
					if (x > video_num_columns) {
   13808:	8b bb d8 21 01 00    	mov    0x121d8(%ebx),%edi
					c = 8 - (x & 7);
   1380e:	8b 71 24             	mov    0x24(%ecx),%esi
   13811:	89 f2                	mov    %esi,%edx
   13813:	83 e2 07             	and    $0x7,%edx
   13816:	29 d0                	sub    %edx,%eax
					x += c;
   13818:	0f b6 c0             	movzbl %al,%eax
   1381b:	8d 14 30             	lea    (%eax,%esi,1),%edx
					pos += c << 1;
   1381e:	01 c0                	add    %eax,%eax
   13820:	03 41 20             	add    0x20(%ecx),%eax
					if (x > video_num_columns) {
   13823:	39 fa                	cmp    %edi,%edx
					x += c;
   13825:	89 51 24             	mov    %edx,0x24(%ecx)
					pos += c << 1;
   13828:	89 41 20             	mov    %eax,0x20(%ecx)
					if (x > video_num_columns) {
   1382b:	0f 86 6b fe ff ff    	jbe    1369c <.L81>
						pos -= video_size_row;
   13831:	2b 83 cc 21 01 00    	sub    0x121cc(%ebx),%eax
						x -= video_num_columns;
   13837:	29 fa                	sub    %edi,%edx
   13839:	89 51 24             	mov    %edx,0x24(%ecx)
						pos -= video_size_row;
   1383c:	89 41 20             	mov    %eax,0x20(%ecx)
						lf(currcons);
   1383f:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13843:	e8 56 fb ff ff       	call   1339e <lf>
   13848:	e9 4f fe ff ff       	jmp    1369c <.L81>
				} else if (c == 7)									// BEL - 响铃
   1384d:	80 fa 07             	cmp    $0x7,%dl
   13850:	75 48                	jne    1389a <.L85+0x19a>
// 8255A芯片PB端口的位1用作扬声器的开门信号;位0用作8253定时器2门信号,该定时器的输出脉冲送往扬声器,作为扬声器发声频率.因此要使扬声器
// 发声,需要两步:首先开启PB端口(0x61)位1和位0(置位),然后设置定时器2通道发送一定的定时频率即可.
static void sysbeep(void)
{
	/* enable counter 2 */		/* 开启定时器2 */
	outb_p(inb_p(0x61)|3, 0x61);
   13852:	ba 61 00 00 00       	mov    $0x61,%edx
   13857:	ec                   	in     (%dx),%al
   13858:	eb 00                	jmp    1385a <.L85+0x15a>
   1385a:	eb 00                	jmp    1385c <.L85+0x15c>
   1385c:	83 c8 03             	or     $0x3,%eax
   1385f:	0f b6 c0             	movzbl %al,%eax
   13862:	ee                   	out    %al,(%dx)
   13863:	eb 00                	jmp    13865 <.L85+0x165>
   13865:	eb 00                	jmp    13867 <.L85+0x167>
	/* set command for counter 2, 2 byte write */	/* 送设置定时器2命令 */
	outb_p(0xB6, 0x43);		// 定时器芯片控制字寄存器端口.
   13867:	b8 b6 00 00 00       	mov    $0xb6,%eax
   1386c:	ba 43 00 00 00       	mov    $0x43,%edx
   13871:	ee                   	out    %al,(%dx)
   13872:	eb 00                	jmp    13874 <.L85+0x174>
   13874:	eb 00                	jmp    13876 <.L85+0x176>
	/* send 0x637 for 750 HZ */	/* 设置频率为720Hz,因此送定时值0x637 */
	outb_p(0x37, 0x42);		// 通过2数据端口分别送计数高低字节
   13876:	ba 42 00 00 00       	mov    $0x42,%edx
   1387b:	b8 37 00 00 00       	mov    $0x37,%eax
   13880:	ee                   	out    %al,(%dx)
   13881:	eb 00                	jmp    13883 <.L85+0x183>
   13883:	eb 00                	jmp    13885 <.L85+0x185>
	outb(0x06, 0x42);
   13885:	b8 06 00 00 00       	mov    $0x6,%eax
   1388a:	ee                   	out    %al,(%dx)
	/* 1/8 second */		/* 蜂鸣时间为1/8s */
	beepcount = HZ / 8;
   1388b:	c7 83 20 1d 01 00 0c 	movl   $0xc,0x11d20(%ebx)
   13892:	00 00 00 
   13895:	e9 02 fe ff ff       	jmp    1369c <.L81>
			  	else if (c == 14)									// SO - 换出,使用G1.
   1389a:	80 fa 0e             	cmp    $0xe,%dl
			  		translate = GRAF_TRANS;
   1389d:	8d 83 31 86 ff ff    	lea    -0x79cf(%ebx),%eax
			  	else if (c == 14)									// SO - 换出,使用G1.
   138a3:	74 0f                	je     138b4 <.L85+0x1b4>
			  	else if (c == 15)									// SI - 换进,使用G0.
   138a5:	80 fa 0f             	cmp    $0xf,%dl
   138a8:	0f 85 ee fd ff ff    	jne    1369c <.L81>
					translate = NORM_TRANS;
   138ae:	8d 83 95 86 ff ff    	lea    -0x796b(%ebx),%eax
   138b4:	89 84 2b cc 1d 01 00 	mov    %eax,0x11dcc(%ebx,%ebp,1)
   138bb:	e9 dc fd ff ff       	jmp    1369c <.L81>

000138c0 <.L87>:
				state = ESnormal;
   138c0:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
				switch (c)
   138c7:	80 fa 44             	cmp    $0x44,%dl
				state = ESnormal;
   138ca:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				switch (c)
   138d1:	0f 84 68 ff ff ff    	je     1383f <.L85+0x13f>
   138d7:	7f 40                	jg     13919 <.L87+0x59>
   138d9:	80 fa 29             	cmp    $0x29,%dl
   138dc:	7f 1e                	jg     138fc <.L87+0x3c>
   138de:	80 fa 28             	cmp    $0x28,%dl
   138e1:	0f 8d 03 01 00 00    	jge    139ea <.L151+0x1c>
   138e7:	80 fa 23             	cmp    $0x23,%dl
   138ea:	0f 85 ac fd ff ff    	jne    1369c <.L81>
				  	state = -1;
   138f0:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
				  	break;
   138f7:	e9 a0 fd ff ff       	jmp    1369c <.L81>
				switch (c)
   138fc:	80 fa 37             	cmp    $0x37,%dl
   138ff:	0f 84 36 06 00 00    	je     13f3b <.L150+0x7>
   13905:	80 fa 38             	cmp    $0x38,%dl
   13908:	0f 85 8e fd ff ff    	jne    1369c <.L81>
	gotoxy(currcons, saved_x, saved_y);
   1390e:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
   13914:	e9 bc 00 00 00       	jmp    139d5 <.L151+0x7>
				switch (c)
   13919:	80 fa 50             	cmp    $0x50,%dl
   1391c:	0f 84 d4 00 00 00    	je     139f6 <.L151+0x28>
   13922:	7f 0f                	jg     13933 <.L87+0x73>
   13924:	80 fa 45             	cmp    $0x45,%dl
   13927:	74 36                	je     1395f <.L87+0x9f>
   13929:	80 fa 4d             	cmp    $0x4d,%dl
   1392c:	74 3a                	je     13968 <.L87+0xa8>
   1392e:	e9 69 fd ff ff       	jmp    1369c <.L81>
   13933:	80 fa 5b             	cmp    $0x5b,%dl
   13936:	74 1b                	je     13953 <.L87+0x93>
   13938:	80 fa 63             	cmp    $0x63,%dl
   1393b:	0f 84 c1 00 00 00    	je     13a02 <.L151+0x34>
   13941:	80 fa 5a             	cmp    $0x5a,%dl
   13944:	0f 85 52 fd ff ff    	jne    1369c <.L81>
	cli();
   1394a:	fa                   	cli    
	char * p = RESPONSE;
   1394b:	8d 93 12 86 ff ff    	lea    -0x79ee(%ebx),%edx
   13951:	eb 47                	jmp    1399a <.L87+0xda>
					state = ESsquare;
   13953:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
					break;
   1395a:	e9 3d fd ff ff       	jmp    1369c <.L81>
					gotoxy(currcons, 0, y + 1);
   1395f:	8b 48 28             	mov    0x28(%eax),%ecx
   13962:	41                   	inc    %ecx
   13963:	e9 a6 02 00 00       	jmp    13c0e <.L137+0x22>
	if (y > top) {
   13968:	8b 50 28             	mov    0x28(%eax),%edx
   1396b:	3b 50 2c             	cmp    0x2c(%eax),%edx
   1396e:	76 1c                	jbe    1398c <.L87+0xcc>
		y--;											// 减去屏幕一行占用内存的字节数
   13970:	4a                   	dec    %edx
   13971:	89 50 28             	mov    %edx,0x28(%eax)
		pos -= video_size_row;
   13974:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   1397b:	8b 42 20             	mov    0x20(%edx),%eax
   1397e:	2b 83 cc 21 01 00    	sub    0x121cc(%ebx),%eax
   13984:	89 42 20             	mov    %eax,0x20(%edx)
   13987:	e9 10 fd ff ff       	jmp    1369c <.L81>
	scrdown(currcons);									// 将屏幕窗口内容下移一行
   1398c:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13990:	e8 30 f7 ff ff       	call   130c5 <scrdown>
   13995:	e9 02 fd ff ff       	jmp    1369c <.L81>
	while (*p) {									// 将应答序列放入读队列.
   1399a:	8a 02                	mov    (%edx),%al
   1399c:	84 c0                	test   %al,%al
   1399e:	74 1c                	je     139bc <.L87+0xfc>
		PUTCH(*p, tty->read_q);						// 逐字符放入.include/linux/tty.h
   139a0:	8b 7c 24 10          	mov    0x10(%esp),%edi
		p++;
   139a4:	42                   	inc    %edx
		PUTCH(*p, tty->read_q);						// 逐字符放入.include/linux/tty.h
   139a5:	8b 4f 34             	mov    0x34(%edi),%ecx
   139a8:	8b 71 04             	mov    0x4(%ecx),%esi
   139ab:	88 44 31 10          	mov    %al,0x10(%ecx,%esi,1)
   139af:	8d 46 01             	lea    0x1(%esi),%eax
   139b2:	25 ff 03 00 00       	and    $0x3ff,%eax
   139b7:	89 41 04             	mov    %eax,0x4(%ecx)
   139ba:	eb de                	jmp    1399a <.L87+0xda>
	sti();
   139bc:	fb                   	sti    
	copy_to_cooked(tty);							// 转换成规范模式(放入辅助队列中).tty_io.c
   139bd:	83 ec 0c             	sub    $0xc,%esp
   139c0:	ff 74 24 1c          	pushl  0x1c(%esp)
   139c4:	e8 e7 e8 ff ff       	call   122b0 <copy_to_cooked>
   139c9:	e9 06 05 00 00       	jmp    13ed4 <.L148+0xc>

000139ce <.L151>:
	gotoxy(currcons, saved_x, saved_y);
   139ce:	8b 8c 2b c4 1d 01 00 	mov    0x11dc4(%ebx,%ebp,1),%ecx
   139d5:	8b 94 2b c0 1d 01 00 	mov    0x11dc0(%ebx,%ebp,1),%edx
   139dc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   139e0:	e8 98 f6 ff ff       	call   1307d <gotoxy>
   139e5:	e9 b2 fc ff ff       	jmp    1369c <.L81>
				    	state = ESsetgraph;
   139ea:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
					break;
   139f1:	e9 a6 fc ff ff       	jmp    1369c <.L81>
				    	state = ESsetterm;
   139f6:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
				    	break;
   139fd:	e9 9a fc ff ff       	jmp    1369c <.L81>
					tty->termios = DEF_TERMIOS;
   13a02:	8d b3 20 87 ff ff    	lea    -0x78e0(%ebx),%esi
   13a08:	b9 09 00 00 00       	mov    $0x9,%ecx
   13a0d:	8b 7c 24 10          	mov    0x10(%esp),%edi
   13a11:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
				  	state = restate = ESnormal;
   13a13:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
					checkin = 0;
   13a1a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
				  	state = restate = ESnormal;
   13a21:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
					top = 0;
   13a28:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
					bottom = video_num_lines;
   13a2f:	8b 83 c8 21 01 00    	mov    0x121c8(%ebx),%eax
				  	state = restate = ESnormal;
   13a35:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
					bottom = video_num_lines;
   13a3c:	89 42 30             	mov    %eax,0x30(%edx)
					break;
   13a3f:	e9 58 fc ff ff       	jmp    1369c <.L81>

00013a44 <.L88>:
				for(npar = 0; npar < NPAR; npar++)					// 初始化参数数组.
   13a44:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13a4b:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
   13a52:	89 c6                	mov    %eax,%esi
   13a54:	8b 4e 34             	mov    0x34(%esi),%ecx
   13a57:	83 f9 0f             	cmp    $0xf,%ecx
   13a5a:	77 19                	ja     13a75 <.L88+0x31>
					par[npar] = 0;
   13a5c:	8b 7c 24 20          	mov    0x20(%esp),%edi
   13a60:	8d 7c 39 0c          	lea    0xc(%ecx,%edi,1),%edi
				for(npar = 0; npar < NPAR; npar++)					// 初始化参数数组.
   13a64:	41                   	inc    %ecx
   13a65:	89 4e 34             	mov    %ecx,0x34(%esi)
					par[npar] = 0;
   13a68:	c7 84 bb 48 1d 01 00 	movl   $0x0,0x11d48(%ebx,%edi,4)
   13a6f:	00 00 00 00 
   13a73:	eb df                	jmp    13a54 <.L88+0x10>
				if (c == '[')  										/* Function key */	// 'ESC [['是功能键.
   13a75:	80 fa 5b             	cmp    $0x5b,%dl
				npar = 0;
   13a78:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
				state = ESgetpars;
   13a7f:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
				if (c == '[')  										/* Function key */	// 'ESC [['是功能键.
   13a86:	75 0c                	jne    13a94 <.L88+0x50>
					state = ESfunckey;
   13a88:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
					break;
   13a8f:	e9 08 fc ff ff       	jmp    1369c <.L81>
				if (ques = (c == '?'))
   13a94:	31 c9                	xor    %ecx,%ecx
   13a96:	80 fa 3f             	cmp    $0x3f,%dl
   13a99:	0f 94 c1             	sete   %cl
   13a9c:	89 48 08             	mov    %ecx,0x8(%eax)
   13a9f:	0f 84 f7 fb ff ff    	je     1369c <.L81>
   13aa5:	eb 13                	jmp    13aba <.L89+0x13>

00013aa7 <.L89>:
				if (c == ';' && npar < NPAR - 1) {
   13aa7:	80 fa 3b             	cmp    $0x3b,%dl
   13aaa:	75 22                	jne    13ace <.L89+0x27>
   13aac:	8b 84 2b 74 1d 01 00 	mov    0x11d74(%ebx,%ebp,1),%eax
   13ab3:	83 f8 0e             	cmp    $0xe,%eax
   13ab6:	77 16                	ja     13ace <.L89+0x27>
   13ab8:	eb 07                	jmp    13ac1 <.L89+0x1a>
   13aba:	80 fa 3b             	cmp    $0x3b,%dl
   13abd:	75 0f                	jne    13ace <.L89+0x27>
   13abf:	31 c0                	xor    %eax,%eax
					npar++;
   13ac1:	40                   	inc    %eax
   13ac2:	89 84 2b 74 1d 01 00 	mov    %eax,0x11d74(%ebx,%ebp,1)
					break;
   13ac9:	e9 ce fb ff ff       	jmp    1369c <.L81>
				} else if (c >= '0' && c <= '9') {
   13ace:	8d 42 d0             	lea    -0x30(%edx),%eax
   13ad1:	3c 09                	cmp    $0x9,%al
   13ad3:	77 22                	ja     13af7 <.L90>
					par[npar] = 10 * par[npar] + c - '0';
   13ad5:	8b 44 24 20          	mov    0x20(%esp),%eax
   13ad9:	03 84 2b 74 1d 01 00 	add    0x11d74(%ebx,%ebp,1),%eax
   13ae0:	8d 84 83 70 1d 01 00 	lea    0x11d70(%ebx,%eax,4),%eax
   13ae7:	6b 48 08 0a          	imul   $0xa,0x8(%eax),%ecx
   13aeb:	8d 54 11 d0          	lea    -0x30(%ecx,%edx,1),%edx
   13aef:	89 50 08             	mov    %edx,0x8(%eax)
					break;
   13af2:	e9 a5 fb ff ff       	jmp    1369c <.L81>

00013af7 <.L90>:
				state = ESnormal;
   13af7:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
				if (ques)
   13afe:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
				state = ESnormal;
   13b02:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				if (ques)
   13b09:	74 0c                	je     13b17 <.L90+0x20>
				{ ques =0;
   13b0b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				  break;
   13b12:	e9 85 fb ff ff       	jmp    1369c <.L81>
				switch(c) {
   13b17:	8d 42 c0             	lea    -0x40(%edx),%eax
   13b1a:	3c 35                	cmp    $0x35,%al
   13b1c:	0f 87 7a fb ff ff    	ja     1369c <.L81>
   13b22:	0f b6 c0             	movzbl %al,%eax
   13b25:	8b b4 83 64 87 ff ff 	mov    -0x789c(%ebx,%eax,4),%esi
   13b2c:	01 de                	add    %ebx,%esi
   13b2e:	ff e6                	jmp    *%esi

00013b30 <.L139>:
						if (par[0]) par[0]--;
   13b30:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   13b37:	8b 42 38             	mov    0x38(%edx),%eax
   13b3a:	85 c0                	test   %eax,%eax
   13b3c:	74 04                	je     13b42 <.L139+0x12>
   13b3e:	48                   	dec    %eax
   13b3f:	89 42 38             	mov    %eax,0x38(%edx)
						gotoxy(currcons, par[0], y);
   13b42:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13b49:	8b 48 28             	mov    0x28(%eax),%ecx
   13b4c:	8b 50 38             	mov    0x38(%eax),%edx
   13b4f:	e9 88 fe ff ff       	jmp    139dc <.L151+0xe>

00013b54 <.L133>:
						if (!par[0]) par[0]++;
   13b54:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13b5b:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
   13b5f:	75 07                	jne    13b68 <.L133+0x14>
   13b61:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
						gotoxy(currcons, x, y - par[0]);
   13b68:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13b6f:	8b 48 28             	mov    0x28(%eax),%ecx
   13b72:	2b 48 38             	sub    0x38(%eax),%ecx
   13b75:	eb 21                	jmp    13b98 <.L134+0x21>

00013b77 <.L134>:
						if (!par[0]) par[0]++;
   13b77:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13b7e:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
   13b82:	75 07                	jne    13b8b <.L134+0x14>
   13b84:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
						gotoxy(currcons, x, y + par[0]);
   13b8b:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13b92:	8b 48 38             	mov    0x38(%eax),%ecx
   13b95:	03 48 28             	add    0x28(%eax),%ecx
   13b98:	8b 50 24             	mov    0x24(%eax),%edx
   13b9b:	e9 3c fe ff ff       	jmp    139dc <.L151+0xe>

00013ba0 <.L135>:
						if (!par[0]) par[0]++;
   13ba0:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13ba7:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
   13bab:	75 07                	jne    13bb4 <.L135+0x14>
   13bad:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
						gotoxy(currcons, x + par[0], y);
   13bb4:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13bbb:	8b 50 38             	mov    0x38(%eax),%edx
   13bbe:	03 50 24             	add    0x24(%eax),%edx
   13bc1:	eb 21                	jmp    13be4 <.L136+0x21>

00013bc3 <.L136>:
						if (!par[0]) par[0]++;
   13bc3:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13bca:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
   13bce:	75 07                	jne    13bd7 <.L136+0x14>
   13bd0:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
						gotoxy(currcons, x - par[0], y);
   13bd7:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13bde:	8b 50 24             	mov    0x24(%eax),%edx
   13be1:	2b 50 38             	sub    0x38(%eax),%edx
   13be4:	8b 48 28             	mov    0x28(%eax),%ecx
   13be7:	e9 f0 fd ff ff       	jmp    139dc <.L151+0xe>

00013bec <.L137>:
						if (!par[0]) par[0]++;
   13bec:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13bf3:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
   13bf7:	75 07                	jne    13c00 <.L137+0x14>
   13bf9:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
						gotoxy(currcons, 0, y + par[0]);
   13c00:	8b 8c 2b 68 1d 01 00 	mov    0x11d68(%ebx,%ebp,1),%ecx
   13c07:	03 8c 2b 78 1d 01 00 	add    0x11d78(%ebx,%ebp,1),%ecx
   13c0e:	31 d2                	xor    %edx,%edx
   13c10:	e9 c7 fd ff ff       	jmp    139dc <.L151+0xe>

00013c15 <.L138>:
						if (!par[0]) par[0]++;
   13c15:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13c1c:	83 78 38 00          	cmpl   $0x0,0x38(%eax)
   13c20:	75 07                	jne    13c29 <.L138+0x14>
   13c22:	c7 40 38 01 00 00 00 	movl   $0x1,0x38(%eax)
						gotoxy(currcons, 0, y - par[0]);
   13c29:	8b 8c 2b 68 1d 01 00 	mov    0x11d68(%ebx,%ebp,1),%ecx
   13c30:	2b 8c 2b 78 1d 01 00 	sub    0x11d78(%ebx,%ebp,1),%ecx
   13c37:	eb d5                	jmp    13c0e <.L137+0x22>

00013c39 <.L147>:
						if (par[0]) par[0]--;
   13c39:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   13c40:	8b 42 38             	mov    0x38(%edx),%eax
   13c43:	85 c0                	test   %eax,%eax
   13c45:	74 04                	je     13c4b <.L147+0x12>
   13c47:	48                   	dec    %eax
   13c48:	89 42 38             	mov    %eax,0x38(%edx)
						gotoxy(currcons, x, par[0]);
   13c4b:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13c52:	8b 48 38             	mov    0x38(%eax),%ecx
   13c55:	e9 3e ff ff ff       	jmp    13b98 <.L134+0x21>

00013c5a <.L140>:
						if (par[0]) par[0]--;
   13c5a:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   13c61:	8b 42 38             	mov    0x38(%edx),%eax
   13c64:	85 c0                	test   %eax,%eax
   13c66:	74 04                	je     13c6c <.L140+0x12>
   13c68:	48                   	dec    %eax
   13c69:	89 42 38             	mov    %eax,0x38(%edx)
						if (par[1]) par[1]--;
   13c6c:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   13c73:	8b 42 3c             	mov    0x3c(%edx),%eax
   13c76:	85 c0                	test   %eax,%eax
   13c78:	74 04                	je     13c7e <.L140+0x24>
   13c7a:	48                   	dec    %eax
   13c7b:	89 42 3c             	mov    %eax,0x3c(%edx)
						gotoxy(currcons, par[1], par[0]);
   13c7e:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13c85:	8b 48 38             	mov    0x38(%eax),%ecx
   13c88:	8b 50 3c             	mov    0x3c(%eax),%edx
   13c8b:	e9 4c fd ff ff       	jmp    139dc <.L151+0xe>

00013c90 <.L141>:
						csi_J(currcons, par[0]);
   13c90:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
	switch (vpar) {
   13c97:	8b 50 38             	mov    0x38(%eax),%edx
   13c9a:	83 fa 01             	cmp    $0x1,%edx
   13c9d:	74 2c                	je     13ccb <.L141+0x3b>
   13c9f:	72 1e                	jb     13cbf <.L141+0x2f>
   13ca1:	83 fa 02             	cmp    $0x2,%edx
   13ca4:	0f 85 f2 f9 ff ff    	jne    1369c <.L81>
			count = video_num_columns * video_num_lines;	/* 删除整个屏幕上的所有字符 */
   13caa:	8b 8b d8 21 01 00    	mov    0x121d8(%ebx),%ecx
			start = origin;
   13cb0:	8b 78 18             	mov    0x18(%eax),%edi
			count = video_num_columns * video_num_lines;	/* 删除整个屏幕上的所有字符 */
   13cb3:	0f af 8b c8 21 01 00 	imul   0x121c8(%ebx),%ecx
   13cba:	e9 84 00 00 00       	jmp    13d43 <.L142+0x68>
			count = (scr_end - pos) >> 1;					/* 擦除光标到屏幕底端所有字符 */
   13cbf:	8b bc 2b 60 1d 01 00 	mov    0x11d60(%ebx,%ebp,1),%edi
   13cc6:	8b 48 1c             	mov    0x1c(%eax),%ecx
   13cc9:	eb 0a                	jmp    13cd5 <.L141+0x45>
			count = (pos - origin) >> 1;					/* 删除从屏幕开始到光标处的字符 */
   13ccb:	8b 78 18             	mov    0x18(%eax),%edi
   13cce:	8b 8c 2b 60 1d 01 00 	mov    0x11d60(%ebx,%ebp,1),%ecx
   13cd5:	29 f9                	sub    %edi,%ecx
   13cd7:	d1 e9                	shr    %ecx
   13cd9:	eb 68                	jmp    13d43 <.L142+0x68>

00013cdb <.L142>:
						csi_K(currcons,par[0]);
   13cdb:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
	switch (vpar) {
   13ce2:	8b 50 38             	mov    0x38(%eax),%edx
   13ce5:	83 fa 01             	cmp    $0x1,%edx
   13ce8:	74 3d                	je     13d27 <.L142+0x4c>
   13cea:	72 1f                	jb     13d0b <.L142+0x30>
   13cec:	83 fa 02             	cmp    $0x2,%edx
   13cef:	0f 85 a7 f9 ff ff    	jne    1369c <.L81>
			start = pos - (x << 1);								/* 将整行字符全删除 */
   13cf5:	8b 40 24             	mov    0x24(%eax),%eax
   13cf8:	8b bc 2b 60 1d 01 00 	mov    0x11d60(%ebx,%ebp,1),%edi
			count = video_num_columns;
   13cff:	8b 8b d8 21 01 00    	mov    0x121d8(%ebx),%ecx
			start = pos - (x << 1);								/* 将整行字符全删除 */
   13d05:	01 c0                	add    %eax,%eax
   13d07:	29 c7                	sub    %eax,%edi
   13d09:	eb 38                	jmp    13d43 <.L142+0x68>
			if (x >= video_num_columns)							/* 删除光标到行尾所有字符 */
   13d0b:	8b 40 24             	mov    0x24(%eax),%eax
   13d0e:	8b 8b d8 21 01 00    	mov    0x121d8(%ebx),%ecx
   13d14:	39 c8                	cmp    %ecx,%eax
   13d16:	0f 83 80 f9 ff ff    	jae    1369c <.L81>
			count = video_num_columns - x;
   13d1c:	29 c1                	sub    %eax,%ecx
			start = pos;
   13d1e:	8b bc 2b 60 1d 01 00 	mov    0x11d60(%ebx,%ebp,1),%edi
   13d25:	eb 1c                	jmp    13d43 <.L142+0x68>
			start = pos - (x << 1);								/* 删除从行开始到光标处 */
   13d27:	8b 48 24             	mov    0x24(%eax),%ecx
   13d2a:	8b bc 2b 60 1d 01 00 	mov    0x11d60(%ebx,%ebp,1),%edi
   13d31:	8d 04 09             	lea    (%ecx,%ecx,1),%eax
   13d34:	29 c7                	sub    %eax,%edi
			count = (x < video_num_columns) ? x : video_num_columns;
   13d36:	39 8b d8 21 01 00    	cmp    %ecx,0x121d8(%ebx)
   13d3c:	0f 46 8b d8 21 01 00 	cmovbe 0x121d8(%ebx),%ecx
	__asm__("cld\n\t"
   13d43:	8b 84 2b 40 1d 01 00 	mov    0x11d40(%ebx,%ebp,1),%eax
   13d4a:	fc                   	cld    
   13d4b:	f3 66 ab             	rep stos %ax,%es:(%edi)
   13d4e:	e9 49 f9 ff ff       	jmp    1369c <.L81>

00013d53 <.L143>:
						csi_L(currcons, par[0]);
   13d53:	8b b4 2b 78 1d 01 00 	mov    0x11d78(%ebx,%ebp,1),%esi
	if (nr > video_num_lines)
   13d5a:	8b 93 c8 21 01 00    	mov    0x121c8(%ebx),%edx
   13d60:	39 d6                	cmp    %edx,%esi
   13d62:	77 0b                	ja     13d6f <.L143+0x1c>
	else if (!nr)
   13d64:	85 f6                	test   %esi,%esi
   13d66:	75 09                	jne    13d71 <.L143+0x1e>
		nr = 1;
   13d68:	be 01 00 00 00       	mov    $0x1,%esi
   13d6d:	eb 02                	jmp    13d71 <.L143+0x1e>
	if (nr > video_num_lines)
   13d6f:	89 d6                	mov    %edx,%esi
	while (nr--)
   13d71:	4e                   	dec    %esi
   13d72:	83 fe ff             	cmp    $0xffffffff,%esi
   13d75:	0f 84 21 f9 ff ff    	je     1369c <.L81>
	oldtop = top;
   13d7b:	8d bc 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edi
	bottom = video_num_lines;
   13d82:	89 54 24 28          	mov    %edx,0x28(%esp)
	oldtop = top;
   13d86:	8b 47 2c             	mov    0x2c(%edi),%eax
	bottom = video_num_lines;
   13d89:	89 7c 24 24          	mov    %edi,0x24(%esp)
	oldtop = top;
   13d8d:	89 44 24 18          	mov    %eax,0x18(%esp)
	oldbottom = bottom;
   13d91:	8b 47 30             	mov    0x30(%edi),%eax
	bottom = video_num_lines;
   13d94:	89 57 30             	mov    %edx,0x30(%edi)
	oldbottom = bottom;
   13d97:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	top = y;										// 设置屏幕卷动开始行和结束行.
   13d9b:	8b 47 28             	mov    0x28(%edi),%eax
   13d9e:	89 47 2c             	mov    %eax,0x2c(%edi)
	scrdown(currcons);								// 从光标开始处,屏幕内容向下滚动一行.
   13da1:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13da5:	e8 1b f3 ff ff       	call   130c5 <scrdown>
	top = oldtop;
   13daa:	8b 44 24 18          	mov    0x18(%esp),%eax
	bottom = oldbottom;
   13dae:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   13db2:	8b 54 24 28          	mov    0x28(%esp),%edx
	top = oldtop;
   13db6:	89 47 2c             	mov    %eax,0x2c(%edi)
	bottom = oldbottom;
   13db9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   13dbd:	89 41 30             	mov    %eax,0x30(%ecx)
   13dc0:	eb af                	jmp    13d71 <.L143+0x1e>

00013dc2 <.L144>:
						csi_M(currcons, par[0]);
   13dc2:	8b b4 2b 78 1d 01 00 	mov    0x11d78(%ebx,%ebp,1),%esi
	if (nr > video_num_lines)
   13dc9:	8b 93 c8 21 01 00    	mov    0x121c8(%ebx),%edx
   13dcf:	39 d6                	cmp    %edx,%esi
   13dd1:	77 0b                	ja     13dde <.L144+0x1c>
	else if (!nr)
   13dd3:	85 f6                	test   %esi,%esi
   13dd5:	75 09                	jne    13de0 <.L144+0x1e>
		nr=1;
   13dd7:	be 01 00 00 00       	mov    $0x1,%esi
   13ddc:	eb 02                	jmp    13de0 <.L144+0x1e>
	if (nr > video_num_lines)
   13dde:	89 d6                	mov    %edx,%esi
	while (nr--)
   13de0:	4e                   	dec    %esi
   13de1:	83 fe ff             	cmp    $0xffffffff,%esi
   13de4:	0f 84 b2 f8 ff ff    	je     1369c <.L81>
	oldtop = top;
   13dea:	8d bc 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edi
	bottom = video_num_lines;
   13df1:	89 54 24 28          	mov    %edx,0x28(%esp)
	oldtop = top;
   13df5:	8b 47 2c             	mov    0x2c(%edi),%eax
	bottom = video_num_lines;
   13df8:	89 7c 24 24          	mov    %edi,0x24(%esp)
	oldtop = top;
   13dfc:	89 44 24 18          	mov    %eax,0x18(%esp)
	oldbottom = bottom;
   13e00:	8b 47 30             	mov    0x30(%edi),%eax
	bottom = video_num_lines;
   13e03:	89 57 30             	mov    %edx,0x30(%edi)
	oldbottom = bottom;
   13e06:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	top = y;										// 设置屏幕卷动开始行和最后行.
   13e0a:	8b 47 28             	mov    0x28(%edi),%eax
   13e0d:	89 47 2c             	mov    %eax,0x2c(%edi)
	scrup(currcons);								// 从光标开始处,屏幕内容向上滚动一行.
   13e10:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13e14:	e8 5d f4 ff ff       	call   13276 <scrup>
	top = oldtop;
   13e19:	8b 44 24 18          	mov    0x18(%esp),%eax
	bottom = oldbottom;
   13e1d:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   13e21:	8b 54 24 28          	mov    0x28(%esp),%edx
	top = oldtop;
   13e25:	89 47 2c             	mov    %eax,0x2c(%edi)
	bottom = oldbottom;
   13e28:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   13e2c:	89 41 30             	mov    %eax,0x30(%ecx)
   13e2f:	eb af                	jmp    13de0 <.L144+0x1e>

00013e31 <.L145>:
						csi_P(currcons, par[0]);
   13e31:	8b 94 2b 78 1d 01 00 	mov    0x11d78(%ebx,%ebp,1),%edx
   13e38:	8b 44 24 0c          	mov    0xc(%esp),%eax
   13e3c:	e8 18 f3 ff ff       	call   13159 <csi_P>
						break;
   13e41:	e9 56 f8 ff ff       	jmp    1369c <.L81>

00013e46 <.L131>:
						csi_at(currcons, par[0]);
   13e46:	8b 84 2b 78 1d 01 00 	mov    0x11d78(%ebx,%ebp,1),%eax
	if (nr > video_num_columns)
   13e4d:	8b bb d8 21 01 00    	mov    0x121d8(%ebx),%edi
   13e53:	39 f8                	cmp    %edi,%eax
   13e55:	77 0b                	ja     13e62 <.L131+0x1c>
	else if (!nr)
   13e57:	85 c0                	test   %eax,%eax
   13e59:	75 09                	jne    13e64 <.L131+0x1e>
		nr = 1;
   13e5b:	b8 01 00 00 00       	mov    $0x1,%eax
   13e60:	eb 02                	jmp    13e64 <.L131+0x1e>
	if (nr > video_num_columns)
   13e62:	89 f8                	mov    %edi,%eax
	int i = x;
   13e64:	8d 74 1d 00          	lea    0x0(%ebp,%ebx,1),%esi
   13e68:	89 74 24 2c          	mov    %esi,0x2c(%esp)
	while (nr--)
   13e6c:	48                   	dec    %eax
   13e6d:	83 f8 ff             	cmp    $0xffffffff,%eax
   13e70:	0f 84 26 f8 ff ff    	je     1369c <.L81>
	int i = x;
   13e76:	8b 74 24 2c          	mov    0x2c(%esp),%esi
	unsigned short tmp, old = video_erase_char;		// 擦除字符(加属性)
   13e7a:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
	unsigned short * p = (unsigned short *) pos;	// 光标对应内存位置.
   13e81:	8b 4a 20             	mov    0x20(%edx),%ecx
	int i = x;
   13e84:	8b b6 64 1d 01 00    	mov    0x11d64(%esi),%esi
	unsigned short * p = (unsigned short *) pos;	// 光标对应内存位置.
   13e8a:	89 4c 24 28          	mov    %ecx,0x28(%esp)
	int i = x;
   13e8e:	89 74 24 18          	mov    %esi,0x18(%esp)
	unsigned short tmp, old = video_erase_char;		// 擦除字符(加属性)
   13e92:	8b 32                	mov    (%edx),%esi
	unsigned short * p = (unsigned short *) pos;	// 光标对应内存位置.
   13e94:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	unsigned short tmp, old = video_erase_char;		// 擦除字符(加属性)
   13e98:	66 89 74 24 1c       	mov    %si,0x1c(%esp)
   13e9d:	89 ca                	mov    %ecx,%edx
   13e9f:	2b 54 24 18          	sub    0x18(%esp),%edx
   13ea3:	01 d2                	add    %edx,%edx
   13ea5:	03 54 24 28          	add    0x28(%esp),%edx
	while (i++ < video_num_columns) {
   13ea9:	39 f9                	cmp    %edi,%ecx
   13eab:	73 bf                	jae    13e6c <.L131+0x26>
		tmp = *p;
   13ead:	66 8b 32             	mov    (%edx),%si
   13eb0:	41                   	inc    %ecx
   13eb1:	66 89 74 24 24       	mov    %si,0x24(%esp)
		*p = old;
   13eb6:	8b 74 24 1c          	mov    0x1c(%esp),%esi
   13eba:	66 89 32             	mov    %si,(%edx)
		old = tmp;
   13ebd:	8b 74 24 24          	mov    0x24(%esp),%esi
   13ec1:	66 89 74 24 1c       	mov    %si,0x1c(%esp)
   13ec6:	eb d5                	jmp    13e9d <.L131+0x57>

00013ec8 <.L148>:
						csi_m(currcons);
   13ec8:	83 ec 0c             	sub    $0xc,%esp
   13ecb:	ff 74 24 18          	pushl  0x18(%esp)
   13ecf:	e8 81 f5 ff ff       	call   13455 <csi_m>
						break;
   13ed4:	83 c4 10             	add    $0x10,%esp
   13ed7:	e9 c0 f7 ff ff       	jmp    1369c <.L81>

00013edc <.L149>:
						if (par[0]) par[0]--;
   13edc:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   13ee3:	8b 42 38             	mov    0x38(%edx),%eax
   13ee6:	85 c0                	test   %eax,%eax
   13ee8:	74 04                	je     13eee <.L149+0x12>
   13eea:	48                   	dec    %eax
   13eeb:	89 42 38             	mov    %eax,0x38(%edx)
						if (!par[1]) par[1] = video_num_lines;
   13eee:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13ef5:	83 78 3c 00          	cmpl   $0x0,0x3c(%eax)
   13ef9:	75 09                	jne    13f04 <.L149+0x28>
   13efb:	8b 93 c8 21 01 00    	mov    0x121c8(%ebx),%edx
   13f01:	89 50 3c             	mov    %edx,0x3c(%eax)
						if (par[0] < par[1] &&
   13f04:	8d 94 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%edx
   13f0b:	8b 4a 38             	mov    0x38(%edx),%ecx
   13f0e:	8b 42 3c             	mov    0x3c(%edx),%eax
   13f11:	39 c1                	cmp    %eax,%ecx
   13f13:	0f 83 83 f7 ff ff    	jae    1369c <.L81>
   13f19:	3b 83 c8 21 01 00    	cmp    0x121c8(%ebx),%eax
   13f1f:	0f 87 77 f7 ff ff    	ja     1369c <.L81>
							top = par[0];
   13f25:	89 4a 2c             	mov    %ecx,0x2c(%edx)
							bottom = par[1];
   13f28:	89 84 2b 70 1d 01 00 	mov    %eax,0x11d70(%ebx,%ebp,1)
   13f2f:	e9 68 f7 ff ff       	jmp    1369c <.L81>

00013f34 <.L150>:
	saved_x = x;
   13f34:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
   13f3b:	8b 50 24             	mov    0x24(%eax),%edx
   13f3e:	89 94 2b c0 1d 01 00 	mov    %edx,0x11dc0(%ebx,%ebp,1)
	saved_y = y;
   13f45:	8b 50 28             	mov    0x28(%eax),%edx
   13f48:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
   13f4e:	e9 49 f7 ff ff       	jmp    1369c <.L81>

00013f53 <.L146>:
						  if (!((npar >= 2) &&
   13f53:	8d 8c 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%ecx
   13f5a:	83 79 34 01          	cmpl   $0x1,0x34(%ecx)
   13f5e:	0f 86 38 f7 ff ff    	jbe    1369c <.L81>
						  ((par[1] - 13) == par[0]) &&
   13f64:	8b 41 3c             	mov    0x3c(%ecx),%eax
   13f67:	83 e8 0d             	sub    $0xd,%eax
						  if (!((npar >= 2) &&
   13f6a:	3b 41 38             	cmp    0x38(%ecx),%eax
   13f6d:	0f 85 29 f7 ff ff    	jne    1369c <.L81>
						  ((par[2] - 17) == par[0])))
   13f73:	8b 79 40             	mov    0x40(%ecx),%edi
   13f76:	8d 77 ef             	lea    -0x11(%edi),%esi
						  if (!((npar >= 2) &&
   13f79:	39 f0                	cmp    %esi,%eax
   13f7b:	0f 85 1b f7 ff ff    	jne    1369c <.L81>
						if ((c == 'l') && (par[0] >= 0) && (par[0] <= 60))
   13f81:	80 fa 6c             	cmp    $0x6c,%dl
   13f84:	75 20                	jne    13fa6 <.L146+0x53>
   13f86:	83 f8 3c             	cmp    $0x3c,%eax
   13f89:	0f 87 0d f7 ff ff    	ja     1369c <.L81>
						  blankinterval = HZ * 60 * par[0];
   13f8f:	69 c0 70 17 00 00    	imul   $0x1770,%eax,%eax
   13f95:	89 83 28 1d 01 00    	mov    %eax,0x11d28(%ebx)
						  blankcount = blankinterval;
   13f9b:	89 83 24 1d 01 00    	mov    %eax,0x11d24(%ebx)
   13fa1:	e9 f6 f6 ff ff       	jmp    1369c <.L81>
						if (c == 'b')
   13fa6:	80 fa 62             	cmp    $0x62,%dl
   13fa9:	0f 85 ed f6 ff ff    	jne    1369c <.L81>
						  vc_cons[currcons].vc_bold_attr = par[0];
   13faf:	89 41 04             	mov    %eax,0x4(%ecx)
   13fb2:	e9 e5 f6 ff ff       	jmp    1369c <.L81>

00013fb7 <.L91>:
				state = ESnormal;
   13fb7:	c7 84 2b 4c 1d 01 00 	movl   $0x0,0x11d4c(%ebx,%ebp,1)
   13fbe:	00 00 00 00 
				break;
   13fc2:	e9 d5 f6 ff ff       	jmp    1369c <.L81>

00013fc7 <.L92>:
				state = ESnormal;
   13fc7:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
				if (c == 'S') {
   13fce:	80 fa 53             	cmp    $0x53,%dl
				state = ESnormal;
   13fd1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				if (c == 'S') {
   13fd8:	0f 85 be f6 ff ff    	jne    1369c <.L81>
					def_attr = attr;
   13fde:	8a 50 02             	mov    0x2(%eax),%dl
   13fe1:	88 50 03             	mov    %dl,0x3(%eax)
					video_erase_char = (video_erase_char & 0x0ff) | (def_attr << 8);
   13fe4:	88 94 2b 41 1d 01 00 	mov    %dl,0x11d41(%ebx,%ebp,1)
   13feb:	e9 ac f6 ff ff       	jmp    1369c <.L81>

00013ff0 <.L93>:
				state = ESnormal;
   13ff0:	8d 84 2b 40 1d 01 00 	lea    0x11d40(%ebx,%ebp,1),%eax
				if (c == '0')
   13ff7:	80 fa 30             	cmp    $0x30,%dl
				state = ESnormal;
   13ffa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				if (c == '0')
   14001:	75 08                	jne    1400b <.L93+0x1b>
					translate = GRAF_TRANS;
   14003:	8d 93 31 86 ff ff    	lea    -0x79cf(%ebx),%edx
   14009:	eb 0f                	jmp    1401a <.L93+0x2a>
				else if (c == 'B')
   1400b:	80 fa 42             	cmp    $0x42,%dl
   1400e:	0f 85 88 f6 ff ff    	jne    1369c <.L81>
					translate = NORM_TRANS;
   14014:	8d 93 95 86 ff ff    	lea    -0x796b(%ebx),%edx
   1401a:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
   14020:	e9 77 f6 ff ff       	jmp    1369c <.L81>
				state = ESnormal;
   14025:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   1402c:	e9 6b f6 ff ff       	jmp    1369c <.L81>
	set_cursor(currcons);									// 最后根据上面设置的光标位置,设置显示控制器中光标位置.
   14031:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
   14035:	83 c4 3c             	add    $0x3c,%esp
   14038:	5b                   	pop    %ebx
   14039:	5e                   	pop    %esi
   1403a:	5f                   	pop    %edi
   1403b:	5d                   	pop    %ebp
	set_cursor(currcons);									// 最后根据上面设置的光标位置,设置显示控制器中光标位置.
   1403c:	e9 96 f3 ff ff       	jmp    133d7 <set_cursor>

00014041 <update_screen>:
{
   14041:	e8 34 5e ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   14046:	05 ba cf 00 00       	add    $0xcfba,%eax
   1404b:	53                   	push   %ebx
	set_origin(fg_console);													// 设置滚屏起始显示内存地址.
   1404c:	c7 c3 a0 51 02 00    	mov    $0x251a0,%ebx
   14052:	8b 03                	mov    (%ebx),%eax
   14054:	e8 9d f1 ff ff       	call   131f6 <set_origin>
	set_cursor(fg_console);													// 设置显示控制器中光标显示内存位置.
   14059:	8b 03                	mov    (%ebx),%eax
}
   1405b:	5b                   	pop    %ebx
	set_cursor(fg_console);													// 设置显示控制器中光标显示内存位置.
   1405c:	e9 76 f3 ff ff       	jmp    133d7 <set_cursor>

00014061 <con_init>:
{
   14061:	55                   	push   %ebp
   14062:	57                   	push   %edi
   14063:	56                   	push   %esi
   14064:	53                   	push   %ebx
   14065:	e8 c2 29 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1406a:	81 c3 96 cf 00 00    	add    $0xcf96,%ebx
   14070:	83 ec 1c             	sub    $0x1c,%esp
	video_num_columns = ORIG_VIDEO_COLS;
   14073:	0f b6 0d 07 00 09 00 	movzbl 0x90007,%ecx
	video_num_lines = ORIG_VIDEO_LINES;
   1407a:	0f b6 3d 0e 00 09 00 	movzbl 0x9000e,%edi
	video_erase_char = 0x0720;
   14081:	66 c7 83 40 1d 01 00 	movw   $0x720,0x11d40(%ebx)
   14088:	20 07 
	blankcount = blankinterval;
   1408a:	8b 83 28 1d 01 00    	mov    0x11d28(%ebx),%eax
	video_num_columns = ORIG_VIDEO_COLS;
   14090:	89 8b d8 21 01 00    	mov    %ecx,0x121d8(%ebx)
	video_size_row = video_num_columns * 2;
   14096:	01 c9                	add    %ecx,%ecx
	if (ORIG_VIDEO_MODE == 7)					/* Is this a monochrome display? */
   14098:	80 3d 06 00 09 00 07 	cmpb   $0x7,0x90006
	video_size_row = video_num_columns * 2;
   1409f:	89 8b cc 21 01 00    	mov    %ecx,0x121cc(%ebx)
	video_num_lines = ORIG_VIDEO_LINES;
   140a5:	89 bb c8 21 01 00    	mov    %edi,0x121c8(%ebx)
	blankcount = blankinterval;
   140ab:	89 83 24 1d 01 00    	mov    %eax,0x11d24(%ebx)
	if (ORIG_VIDEO_MODE == 7)					/* Is this a monochrome display? */
   140b1:	75 57                	jne    1410a <con_init+0xa9>
		video_port_reg = 0x3b4;					// 设置单显索引寄存器端口.
   140b3:	66 c7 83 c6 21 01 00 	movw   $0x3b4,0x121c6(%ebx)
   140ba:	b4 03 
		video_port_val = 0x3b5;					// 设置单显数据寄存器端口.
   140bc:	66 c7 83 c4 21 01 00 	movw   $0x3b5,0x121c4(%ebx)
   140c3:	b5 03 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   140c5:	80 3d 0a 00 09 00 10 	cmpb   $0x10,0x9000a
		video_mem_base = 0xb0000;				// 设置单显映像内存起始地址.
   140cc:	c7 83 d4 21 01 00 00 	movl   $0xb0000,0x121d4(%ebx)
   140d3:	00 0b 00 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   140d6:	74 19                	je     140f1 <con_init+0x90>
			video_type = VIDEO_TYPE_EGAM;		// 设置显示类型(EGA单色).
   140d8:	c6 83 dc 21 01 00 20 	movb   $0x20,0x121dc(%ebx)
			video_mem_term = 0xb8000;			// 设置显示内存末端地址.
   140df:	c7 83 d0 21 01 00 00 	movl   $0xb8000,0x121d0(%ebx)
   140e6:	80 0b 00 
			display_desc = "EGAm";				// 设置显示描述字符串.
   140e9:	8d b3 05 87 ff ff    	lea    -0x78fb(%ebx),%esi
   140ef:	eb 78                	jmp    14169 <con_init+0x108>
			video_type = VIDEO_TYPE_MDA;		// 设置显示类型(MDA单色).
   140f1:	c6 83 dc 21 01 00 10 	movb   $0x10,0x121dc(%ebx)
			video_mem_term = 0xb2000;			// 设置显示内存末端地址.
   140f8:	c7 83 d0 21 01 00 00 	movl   $0xb2000,0x121d0(%ebx)
   140ff:	20 0b 00 
			display_desc = "*MDA";				// 设置显示描述字符串.
   14102:	8d b3 f6 86 ff ff    	lea    -0x790a(%ebx),%esi
   14108:	eb 5f                	jmp    14169 <con_init+0x108>
		video_port_reg	= 0x3d4;				// 设置彩色显示索引寄存器端口.
   1410a:	66 c7 83 c6 21 01 00 	movw   $0x3d4,0x121c6(%ebx)
   14111:	d4 03 
		video_port_val	= 0x3d5;				// 设置彩色显示数据寄存器端口.
   14113:	66 c7 83 c4 21 01 00 	movw   $0x3d5,0x121c4(%ebx)
   1411a:	d5 03 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   1411c:	80 3d 0a 00 09 00 10 	cmpb   $0x10,0x9000a
		can_do_colour = 1;						// 设置彩色显示标志.
   14123:	c7 83 c0 21 01 00 01 	movl   $0x1,0x121c0(%ebx)
   1412a:	00 00 00 
		video_mem_base = 0xb8000;				// 显示内存起始地址.
   1412d:	c7 83 d4 21 01 00 00 	movl   $0xb8000,0x121d4(%ebx)
   14134:	80 0b 00 
		if ((ORIG_VIDEO_EGA_BX & 0xff) != 0x10)
   14137:	74 19                	je     14152 <con_init+0xf1>
			video_type = VIDEO_TYPE_EGAC;		// 设置显示类型(EGA彩色).
   14139:	c6 83 dc 21 01 00 21 	movb   $0x21,0x121dc(%ebx)
			video_mem_term = 0xc0000;			// 设置显示内存末端地址.
   14140:	c7 83 d0 21 01 00 00 	movl   $0xc0000,0x121d0(%ebx)
   14147:	00 0c 00 
			display_desc = "EGAc";				// 设置显示描述字符串.
   1414a:	8d b3 fb 86 ff ff    	lea    -0x7905(%ebx),%esi
   14150:	eb 17                	jmp    14169 <con_init+0x108>
			display_desc = "*CGA";				// 设置显示描述字符串.
   14152:	8d b3 00 87 ff ff    	lea    -0x7900(%ebx),%esi
			video_type = VIDEO_TYPE_CGA;		// 设置显示类型(CGA).
   14158:	c6 83 dc 21 01 00 11 	movb   $0x11,0x121dc(%ebx)
			video_mem_term = 0xba000;			// 设置显示内存末端地址.
   1415f:	c7 83 d0 21 01 00 00 	movl   $0xba000,0x121d0(%ebx)
   14166:	a0 0b 00 
	video_memory = video_mem_term - video_mem_base;
   14169:	8b 83 d4 21 01 00    	mov    0x121d4(%ebx),%eax
   1416f:	8b ab d0 21 01 00    	mov    0x121d0(%ebx),%ebp
	NR_CONSOLES = video_memory / (video_num_lines * video_size_row);
   14175:	31 d2                	xor    %edx,%edx
	video_memory = video_mem_term - video_mem_base;
   14177:	29 c5                	sub    %eax,%ebp
   14179:	89 04 24             	mov    %eax,(%esp)
	NR_CONSOLES = video_memory / (video_num_lines * video_size_row);
   1417c:	89 c8                	mov    %ecx,%eax
   1417e:	0f af c7             	imul   %edi,%eax
   14181:	89 44 24 08          	mov    %eax,0x8(%esp)
   14185:	89 e8                	mov    %ebp,%eax
   14187:	f7 74 24 08          	divl   0x8(%esp)
   1418b:	ba 08 00 00 00       	mov    $0x8,%edx
   14190:	83 f8 08             	cmp    $0x8,%eax
   14193:	0f 4f c2             	cmovg  %edx,%eax
	if (!NR_CONSOLES)
   14196:	85 c0                	test   %eax,%eax
	NR_CONSOLES = video_memory / (video_num_lines * video_size_row);
   14198:	89 83 2c 1d 01 00    	mov    %eax,0x11d2c(%ebx)
	if (!NR_CONSOLES)
   1419e:	75 0a                	jne    141aa <con_init+0x149>
		NR_CONSOLES = 1;
   141a0:	c7 83 2c 1d 01 00 01 	movl   $0x1,0x11d2c(%ebx)
   141a7:	00 00 00 
	video_memory /= NR_CONSOLES;				// 每个虚拟控制台占用显示内存字节数.
   141aa:	89 e8                	mov    %ebp,%eax
   141ac:	99                   	cltd   
   141ad:	f7 bb 2c 1d 01 00    	idivl  0x11d2c(%ebx)
   141b3:	89 44 24 14          	mov    %eax,0x14(%esp)
	display_ptr = ((char *)video_mem_base) + video_size_row - 8;
   141b7:	8b 04 24             	mov    (%esp),%eax
   141ba:	8d 44 08 f8          	lea    -0x8(%eax,%ecx,1),%eax
	while (*display_desc)
   141be:	8a 16                	mov    (%esi),%dl
   141c0:	84 d2                	test   %dl,%dl
   141c2:	74 08                	je     141cc <con_init+0x16b>
		*display_ptr++ = *display_desc++;
   141c4:	88 10                	mov    %dl,(%eax)
   141c6:	46                   	inc    %esi
   141c7:	83 c0 02             	add    $0x2,%eax
   141ca:	eb f2                	jmp    141be <con_init+0x15d>
	base = origin = video_mem_start = video_mem_base;						// 默认滚屏开始内存位置.
   141cc:	8b 04 24             	mov    (%esp),%eax
	top	= 0;																// 初始设置滚动时顶行行号.
   141cf:	c7 83 6c 1d 01 00 00 	movl   $0x0,0x11d6c(%ebx)
   141d6:	00 00 00 
   141d9:	8d ab 40 1d 01 00    	lea    0x11d40(%ebx),%ebp
	bottom	= video_num_lines;												// 初始设置滚动时底行行号.
   141df:	89 bb 70 1d 01 00    	mov    %edi,0x11d70(%ebx)
	iscolor = 0;															// 彩色显示标志.
   141e5:	c7 83 c8 1d 01 00 00 	movl   $0x0,0x11dc8(%ebx)
   141ec:	00 00 00 
	attr = 0x07;															// 初始设置显示字符属性(黑底白字).
   141ef:	c7 83 42 1d 01 00 07 	movl   $0xffff0707,0x11d42(%ebx)
   141f6:	07 ff ff 
	vc_cons[0].vc_bold_attr = -1;											// 粗体字符属性标志(-1表示不用).
   141f9:	c7 83 46 1d 01 00 ff 	movl   $0xffff,0x11d46(%ebx)
   14200:	ff 00 00 
	base = origin = video_mem_start = video_mem_base;						// 默认滚屏开始内存位置.
   14203:	89 83 b8 1d 01 00    	mov    %eax,0x11db8(%ebx)
   14209:	89 83 58 1d 01 00    	mov    %eax,0x11d58(%ebx)
	term = video_mem_end = base + video_memory;								// 0号屏幕内存末端位置.
   1420f:	03 44 24 14          	add    0x14(%esp),%eax
	ques = 0;																// 收到问号字符标志.
   14213:	c7 83 4a 1d 01 00 00 	movl   $0x0,0x11d4a(%ebx)
   1421a:	00 00 00 
	restate = state = ESnormal;												// 初始化转义序列操作的前和下一状态.
   1421d:	c7 83 4e 1d 01 00 00 	movl   $0x0,0x11d4e(%ebx)
   14224:	00 00 00 
   14227:	c7 83 52 1d 01 00 00 	movl   $0x0,0x11d52(%ebx)
   1422e:	00 00 00 
	checkin = 0;
   14231:	66 c7 83 56 1d 01 00 	movw   $0x0,0x11d56(%ebx)
   14238:	00 00 
	term = video_mem_end = base + video_memory;								// 0号屏幕内存末端位置.
   1423a:	89 44 24 0c          	mov    %eax,0xc(%esp)
   1423e:	89 83 bc 1d 01 00    	mov    %eax,0x11dbc(%ebx)
	scr_end	= video_mem_start + video_num_lines * video_size_row;			// 滚屏末端位置.
   14244:	8b 04 24             	mov    (%esp),%eax
   14247:	03 44 24 08          	add    0x8(%esp),%eax
   1424b:	89 83 5c 1d 01 00    	mov    %eax,0x11d5c(%ebx)
	translate = NORM_TRANS;													// 使用的字符集(普通ASCII码表).
   14251:	8d 83 95 86 ff ff    	lea    -0x796b(%ebx),%eax
   14257:	89 83 cc 1d 01 00    	mov    %eax,0x11dcc(%ebx)
	gotoxy(currcons, ORIG_X, ORIG_Y);
   1425d:	0f b6 0d 01 00 09 00 	movzbl 0x90001,%ecx
   14264:	31 c0                	xor    %eax,%eax
   14266:	0f b6 15 00 00 09 00 	movzbl 0x90000,%edx
   1426d:	e8 0b ee ff ff       	call   1307d <gotoxy>
  	for (currcons = 1; currcons < NR_CONSOLES; currcons++) {
   14272:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14276:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
   1427d:	00 
   1427e:	89 6c 24 18          	mov    %ebp,0x18(%esp)
   14282:	89 44 24 04          	mov    %eax,0x4(%esp)
   14286:	81 c5 90 00 00 00    	add    $0x90,%ebp
   1428c:	8b 44 24 10          	mov    0x10(%esp),%eax
   14290:	39 83 2c 1d 01 00    	cmp    %eax,0x11d2c(%ebx)
   14296:	7e 49                	jle    142e1 <con_init+0x280>
		origin = video_mem_start = (base += video_memory);
   14298:	8b 44 24 04          	mov    0x4(%esp),%eax
		vc_cons[currcons] = vc_cons[0];         							// 复制0号结构的参数.
   1429c:	8b 74 24 18          	mov    0x18(%esp),%esi
   142a0:	b9 24 00 00 00       	mov    $0x24,%ecx
   142a5:	89 ef                	mov    %ebp,%edi
		gotoxy(currcons, 0, 0);                           					// 光标都初始化在屏幕左上角位置.
   142a7:	31 d2                	xor    %edx,%edx
		vc_cons[currcons] = vc_cons[0];         							// 复制0号结构的参数.
   142a9:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		origin = video_mem_start = (base += video_memory);
   142ab:	89 45 78             	mov    %eax,0x78(%ebp)
   142ae:	89 45 18             	mov    %eax,0x18(%ebp)
		scr_end = origin + video_num_lines * video_size_row;
   142b1:	8b 44 24 08          	mov    0x8(%esp),%eax
   142b5:	03 44 24 04          	add    0x4(%esp),%eax
   142b9:	89 45 1c             	mov    %eax,0x1c(%ebp)
		video_mem_end = (term += video_memory);
   142bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
   142c0:	2b 04 24             	sub    (%esp),%eax
   142c3:	03 44 24 04          	add    0x4(%esp),%eax
   142c7:	89 45 7c             	mov    %eax,0x7c(%ebp)
		gotoxy(currcons, 0, 0);                           					// 光标都初始化在屏幕左上角位置.
   142ca:	8b 44 24 10          	mov    0x10(%esp),%eax
   142ce:	e8 aa ed ff ff       	call   1307d <gotoxy>
   142d3:	8b 74 24 14          	mov    0x14(%esp),%esi
  	for (currcons = 1; currcons < NR_CONSOLES; currcons++) {
   142d7:	ff 44 24 10          	incl   0x10(%esp)
   142db:	01 74 24 04          	add    %esi,0x4(%esp)
   142df:	eb a5                	jmp    14286 <con_init+0x225>
	update_screen();														// 更新前台原点来设置光标位置.
   142e1:	e8 5b fd ff ff       	call   14041 <update_screen>
	set_trap_gate(0x21, &keyboard_interrupt);								// 参见system.h,设置键盘的系统中断门
   142e6:	c7 c1 88 57 00 00    	mov    $0x5788,%ecx
   142ec:	c7 c2 db 44 01 00    	mov    $0x144db,%edx
   142f2:	b8 00 00 08 00       	mov    $0x80000,%eax
   142f7:	66 89 d0             	mov    %dx,%ax
   142fa:	66 ba 00 8f          	mov    $0x8f00,%dx
   142fe:	89 81 08 01 00 00    	mov    %eax,0x108(%ecx)
   14304:	89 91 0c 01 00 00    	mov    %edx,0x10c(%ecx)
	outb_p(inb_p(0x21) & 0xfd, 0x21);										// 取消对键盘中断的屏蔽,允许IRQ1.
   1430a:	ba 21 00 00 00       	mov    $0x21,%edx
   1430f:	ec                   	in     (%dx),%al
   14310:	eb 00                	jmp    14312 <con_init+0x2b1>
   14312:	eb 00                	jmp    14314 <con_init+0x2b3>
   14314:	25 fd 00 00 00       	and    $0xfd,%eax
   14319:	ee                   	out    %al,(%dx)
   1431a:	eb 00                	jmp    1431c <con_init+0x2bb>
   1431c:	eb 00                	jmp    1431e <con_init+0x2bd>
	a = inb_p(0x61);														// 读取键盘端口0x61(8255A端口PB).
   1431e:	ba 61 00 00 00       	mov    $0x61,%edx
   14323:	ec                   	in     (%dx),%al
   14324:	eb 00                	jmp    14326 <con_init+0x2c5>
   14326:	eb 00                	jmp    14328 <con_init+0x2c7>
   14328:	88 c1                	mov    %al,%cl
	outb_p(a | 0x80, 0x61);													// 设置禁止键盘工作(位7置位).
   1432a:	83 c8 80             	or     $0xffffff80,%eax
   1432d:	0f b6 c0             	movzbl %al,%eax
   14330:	ee                   	out    %al,(%dx)
   14331:	eb 00                	jmp    14333 <con_init+0x2d2>
   14333:	eb 00                	jmp    14335 <con_init+0x2d4>
	outb_p(a, 0x61);														// 再允许键盘工作,用以复位键盘.
   14335:	88 c8                	mov    %cl,%al
   14337:	ee                   	out    %al,(%dx)
   14338:	eb 00                	jmp    1433a <con_init+0x2d9>
   1433a:	eb 00                	jmp    1433c <con_init+0x2db>
}
   1433c:	83 c4 1c             	add    $0x1c,%esp
   1433f:	5b                   	pop    %ebx
   14340:	5e                   	pop    %esi
   14341:	5f                   	pop    %edi
   14342:	5d                   	pop    %ebp
   14343:	c3                   	ret    

00014344 <sysbeepstop>:
	outb(inb_p(0x61)&0xFC, 0x61);
   14344:	ba 61 00 00 00       	mov    $0x61,%edx
   14349:	ec                   	in     (%dx),%al
   1434a:	eb 00                	jmp    1434c <sysbeepstop+0x8>
   1434c:	eb 00                	jmp    1434e <sysbeepstop+0xa>
   1434e:	25 fc 00 00 00       	and    $0xfc,%eax
   14353:	ee                   	out    %al,(%dx)
}
   14354:	c3                   	ret    

00014355 <do_screendump>:

// 拷贝屏幕
// 把屏幕内容复制到参数指定的用户缓冲区arg中。
// 参数arg有两个用途：一是用于传递控制台号，二是作为用户缓冲区指针。
int do_screendump(int arg)
{
   14355:	56                   	push   %esi
   14356:	53                   	push   %ebx
   14357:	e8 d0 26 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1435c:	81 c3 a4 cc 00 00    	add    $0xcca4,%ebx
   14362:	83 ec 0c             	sub    $0xc,%esp
	char *sptr, *buf = (char *)arg;
	int currcons, l;

	// 函数首先验证用户提供的缓冲区容量，若不够则进行适当扩展。然后从其开始处取出控制台号currcons.
	// 在判断控制台号有效后，就把该控制台屏幕的所有内存内容复制到用户缓冲区中。
	verify_area(buf, video_num_columns * video_num_lines);
   14365:	8b 83 d8 21 01 00    	mov    0x121d8(%ebx),%eax
{
   1436b:	8b 74 24 18          	mov    0x18(%esp),%esi
	verify_area(buf, video_num_columns * video_num_lines);
   1436f:	0f af 83 c8 21 01 00 	imul   0x121c8(%ebx),%eax
   14376:	50                   	push   %eax
   14377:	56                   	push   %esi
   14378:	e8 6e 38 ff ff       	call   7beb <verify_area>
   1437d:	64 8a 16             	mov    %fs:(%esi),%dl
	currcons = get_fs_byte(buf);
   14380:	0f b6 d2             	movzbl %dl,%edx
	if ((currcons < 1) || (currcons > NR_CONSOLES))
   14383:	83 c4 10             	add    $0x10,%esp
		return -EIO;
   14386:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	if ((currcons < 1) || (currcons > NR_CONSOLES))
   1438b:	85 d2                	test   %edx,%edx
   1438d:	74 40                	je     143cf <do_screendump+0x7a>
   1438f:	39 93 2c 1d 01 00    	cmp    %edx,0x11d2c(%ebx)
   14395:	7c 38                	jl     143cf <do_screendump+0x7a>
	currcons--;
	sptr = (char *) origin;
   14397:	4a                   	dec    %edx
   14398:	69 d2 90 00 00 00    	imul   $0x90,%edx,%edx
   1439e:	8b 84 13 58 1d 01 00 	mov    0x11d58(%ebx,%edx,1),%eax
	for (l = video_num_lines * video_num_columns; l > 0 ; l--)
   143a5:	8b 93 c8 21 01 00    	mov    0x121c8(%ebx),%edx
   143ab:	0f af 93 d8 21 01 00 	imul   0x121d8(%ebx),%edx
   143b2:	29 c6                	sub    %eax,%esi
   143b4:	01 c2                	add    %eax,%edx
   143b6:	89 d1                	mov    %edx,%ecx
   143b8:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
   143bb:	29 c1                	sub    %eax,%ecx
   143bd:	85 c9                	test   %ecx,%ecx
   143bf:	7e 0c                	jle    143cd <do_screendump+0x78>
		put_fs_byte(*sptr++, buf++);
   143c1:	8d 48 01             	lea    0x1(%eax),%ecx
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   143c4:	8a 00                	mov    (%eax),%al
   143c6:	64 88 03             	mov    %al,%fs:(%ebx)
   143c9:	89 c8                	mov    %ecx,%eax
   143cb:	eb e9                	jmp    143b6 <do_screendump+0x61>
	return(0);
   143cd:	31 c0                	xor    %eax,%eax
}
   143cf:	5a                   	pop    %edx
   143d0:	5b                   	pop    %ebx
   143d1:	5e                   	pop    %esi
   143d2:	c3                   	ret    

000143d3 <blank_screen>:
void blank_screen()
{
	if (video_type != VIDEO_TYPE_EGAC && video_type != VIDEO_TYPE_EGAM)
		return;
	/* blank here. I can't find out how to do it, though */
}
   143d3:	c3                   	ret    

000143d4 <unblank_screen>:
   143d4:	c3                   	ret    

000143d5 <console_print>:
// 控制台显示函数
// 该函数仅用于内核显示函数printk()(kernel/printk.c),用于在当前前台控制台上显示内核信息.
// 处理方法是循环取出缓冲区中的字符,并根据字符的特性控制光标移动或直接显示在屏幕上.
// 参数b是null结尾的字符串缓冲区指针。
void console_print(const char * b)
{
   143d5:	55                   	push   %ebp
   143d6:	57                   	push   %edi
   143d7:	56                   	push   %esi
   143d8:	53                   	push   %ebx
   143d9:	e8 4e 26 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   143de:	81 c3 22 cc 00 00    	add    $0xcc22,%ebx
   143e4:	83 ec 0c             	sub    $0xc,%esp
   143e7:	8b 44 24 20          	mov    0x20(%esp),%eax
   143eb:	89 44 24 04          	mov    %eax,0x4(%esp)
	int currcons = fg_console;
   143ef:	c7 c0 a0 51 02 00    	mov    $0x251a0,%eax
   143f5:	8b 00                	mov    (%eax),%eax
			cr(currcons);
			continue;
		}
		// 在读取了一个不是回车或换行字符后，如果发现当前光标列位置x已经到达屏幕右末端，则让光标折返到下一行开始处。
		// 然后把字符放到光标所处显示内存位置处，即在屏幕上显示出来。再把光标右移一格位置，为显示下一个字符作准备。
		if (x >= video_num_columns) {
   143f7:	69 f0 90 00 00 00    	imul   $0x90,%eax,%esi
	int currcons = fg_console;
   143fd:	89 04 24             	mov    %eax,(%esp)
	while (c = *(b++)) {
   14400:	ff 44 24 04          	incl   0x4(%esp)
   14404:	8b 44 24 04          	mov    0x4(%esp),%eax
   14408:	8a 50 ff             	mov    -0x1(%eax),%dl
   1440b:	84 d2                	test   %dl,%dl
   1440d:	74 7b                	je     1448a <console_print+0xb5>
		if (c == 10) {
   1440f:	80 fa 0a             	cmp    $0xa,%dl
   14412:	75 12                	jne    14426 <console_print+0x51>
			cr(currcons);
   14414:	8b 04 24             	mov    (%esp),%eax
   14417:	e8 0f ed ff ff       	call   1312b <cr>
			lf(currcons);
   1441c:	8b 04 24             	mov    (%esp),%eax
   1441f:	e8 7a ef ff ff       	call   1339e <lf>
			continue;
   14424:	eb da                	jmp    14400 <console_print+0x2b>
		if (c == 13) {
   14426:	80 fa 0d             	cmp    $0xd,%dl
   14429:	75 0a                	jne    14435 <console_print+0x60>
			cr(currcons);
   1442b:	8b 04 24             	mov    (%esp),%eax
   1442e:	e8 f8 ec ff ff       	call   1312b <cr>
			continue;
   14433:	eb cb                	jmp    14400 <console_print+0x2b>
		if (x >= video_num_columns) {
   14435:	8d 8c 33 40 1d 01 00 	lea    0x11d40(%ebx,%esi,1),%ecx
   1443c:	8b bb d8 21 01 00    	mov    0x121d8(%ebx),%edi
   14442:	8b 41 24             	mov    0x24(%ecx),%eax
   14445:	39 f8                	cmp    %edi,%eax
   14447:	72 21                	jb     1446a <console_print+0x95>
			x -= video_num_columns;
   14449:	29 f8                	sub    %edi,%eax
   1444b:	88 54 24 0b          	mov    %dl,0xb(%esp)
   1444f:	89 41 24             	mov    %eax,0x24(%ecx)
			pos -= video_size_row;
   14452:	8b 41 20             	mov    0x20(%ecx),%eax
   14455:	2b 83 cc 21 01 00    	sub    0x121cc(%ebx),%eax
   1445b:	89 41 20             	mov    %eax,0x20(%ecx)
			lf(currcons);
   1445e:	8b 04 24             	mov    (%esp),%eax
   14461:	e8 38 ef ff ff       	call   1339e <lf>
   14466:	8a 54 24 0b          	mov    0xb(%esp),%dl
		}
		// 寄存器al中是需要显示的字符，这里把属性字节放到ah中，然后把ax内容存储到光标内存位置pos处，即在光标处显示字符。
		__asm__("movb %2, %%ah\n\t"              				// 属性字节放到ah中。
			"movw %%ax, %1\n\t"              					// ax内容放到pos处。
			::"a" (c),
			"m" (*(short *)pos),
   1446a:	8d ac 33 40 1d 01 00 	lea    0x11d40(%ebx,%esi,1),%ebp
		__asm__("movb %2, %%ah\n\t"              				// 属性字节放到ah中。
   14471:	88 d0                	mov    %dl,%al
			"m" (*(short *)pos),
   14473:	8b 4d 20             	mov    0x20(%ebp),%ecx
		__asm__("movb %2, %%ah\n\t"              				// 属性字节放到ah中。
   14476:	8a 65 02             	mov    0x2(%ebp),%ah
   14479:	66 89 01             	mov    %ax,(%ecx)
			"m" (attr)
			:);
		pos += 2;
   1447c:	83 c1 02             	add    $0x2,%ecx
		x++;
   1447f:	ff 45 24             	incl   0x24(%ebp)
		pos += 2;
   14482:	89 4d 20             	mov    %ecx,0x20(%ebp)
   14485:	e9 76 ff ff ff       	jmp    14400 <console_print+0x2b>
	}
	set_cursor(currcons);           							// 最后设置的光标内存位置，设置显示控制器中光标位置。
   1448a:	8b 04 24             	mov    (%esp),%eax
}
   1448d:	83 c4 0c             	add    $0xc,%esp
   14490:	5b                   	pop    %ebx
   14491:	5e                   	pop    %esi
   14492:	5f                   	pop    %edi
   14493:	5d                   	pop    %ebp
	set_cursor(currcons);           							// 最后设置的光标内存位置，设置显示控制器中光标位置。
   14494:	e9 3e ef ff ff       	jmp    133d7 <set_cursor>

00014499 <del_col>:


void del_col(int i){
   14499:	e8 dc 59 ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   1449e:	05 62 cb 00 00       	add    $0xcb62,%eax
   144a3:	56                   	push   %esi
   144a4:	53                   	push   %ebx
	int currcons = fg_console;
   144a5:	c7 c2 a0 51 02 00    	mov    $0x251a0,%edx
void del_col(int i){
   144ab:	8b 74 24 0c          	mov    0xc(%esp),%esi
	int currcons = fg_console;
   144af:	8b 1a                	mov    (%edx),%ebx
	gotoxy(currcons, x - i, y);
   144b1:	69 d3 90 00 00 00    	imul   $0x90,%ebx,%edx
   144b7:	8d 84 10 40 1d 01 00 	lea    0x11d40(%eax,%edx,1),%eax
   144be:	8b 50 24             	mov    0x24(%eax),%edx
   144c1:	8b 48 28             	mov    0x28(%eax),%ecx
   144c4:	89 d8                	mov    %ebx,%eax
   144c6:	29 f2                	sub    %esi,%edx
   144c8:	e8 b0 eb ff ff       	call   1307d <gotoxy>
	csi_P(currcons, i);
   144cd:	89 f2                	mov    %esi,%edx
   144cf:	89 d8                	mov    %ebx,%eax
}
   144d1:	5b                   	pop    %ebx
   144d2:	5e                   	pop    %esi
	csi_P(currcons, i);
   144d3:	e9 81 ec ff ff       	jmp    13159 <csi_P>

000144d8 <mode>:
	...

000144d9 <leds>:
   144d9:	02                   	.byte 0x2

000144da <e0>:
	...

000144db <keyboard_interrupt>:
   144db:	50                   	push   %eax
   144dc:	53                   	push   %ebx
   144dd:	51                   	push   %ecx
   144de:	52                   	push   %edx
   144df:	1e                   	push   %ds
   144e0:	06                   	push   %es
   144e1:	b8 10 00 00 00       	mov    $0x10,%eax
   144e6:	8e d8                	mov    %eax,%ds
   144e8:	8e c0                	mov    %eax,%es
   144ea:	a1 28 2d 03 00       	mov    0x32d28,%eax
   144ef:	a3 24 2d 03 00       	mov    %eax,0x32d24
   144f4:	31 c0                	xor    %eax,%eax
   144f6:	e4 60                	in     $0x60,%al
   144f8:	3c e0                	cmp    $0xe0,%al
   144fa:	74 3d                	je     14539 <set_e0>
   144fc:	3c e1                	cmp    $0xe1,%al
   144fe:	74 42                	je     14542 <set_e1>
   14500:	ff 14 85 bd 48 01 00 	call   *0x148bd(,%eax,4)
   14507:	c6 05 da 44 01 00 00 	movb   $0x0,0x144da

0001450e <e0_e1>:
   1450e:	e4 61                	in     $0x61,%al
   14510:	eb 00                	jmp    14512 <e0_e1+0x4>
   14512:	eb 00                	jmp    14514 <e0_e1+0x6>
   14514:	0c 80                	or     $0x80,%al
   14516:	eb 00                	jmp    14518 <e0_e1+0xa>
   14518:	eb 00                	jmp    1451a <e0_e1+0xc>
   1451a:	e6 61                	out    %al,$0x61
   1451c:	eb 00                	jmp    1451e <e0_e1+0x10>
   1451e:	eb 00                	jmp    14520 <e0_e1+0x12>
   14520:	24 7f                	and    $0x7f,%al
   14522:	e6 61                	out    %al,$0x61
   14524:	b0 20                	mov    $0x20,%al
   14526:	e6 20                	out    %al,$0x20
   14528:	6a 00                	push   $0x0
   1452a:	e8 e7 e6 ff ff       	call   12c16 <do_tty_interrupt>
   1452f:	83 c4 04             	add    $0x4,%esp
   14532:	07                   	pop    %es
   14533:	1f                   	pop    %ds
   14534:	5a                   	pop    %edx
   14535:	59                   	pop    %ecx
   14536:	5b                   	pop    %ebx
   14537:	58                   	pop    %eax
   14538:	cf                   	iret   

00014539 <set_e0>:
   14539:	c6 05 da 44 01 00 01 	movb   $0x1,0x144da
   14540:	eb cc                	jmp    1450e <e0_e1>

00014542 <set_e1>:
   14542:	c6 05 da 44 01 00 02 	movb   $0x2,0x144da
   14549:	eb c3                	jmp    1450e <e0_e1>

0001454b <put_queue>:
   1454b:	51                   	push   %ecx
   1454c:	52                   	push   %edx
   1454d:	8b 15 e8 24 02 00    	mov    0x224e8,%edx
   14553:	8b 4a 04             	mov    0x4(%edx),%ecx
   14556:	88 44 0a 10          	mov    %al,0x10(%edx,%ecx,1)
   1455a:	41                   	inc    %ecx
   1455b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
   14561:	3b 4a 08             	cmp    0x8(%edx),%ecx
   14564:	74 1b                	je     14581 <put_queue+0x36>
   14566:	0f ac d8 08          	shrd   $0x8,%ebx,%eax
   1456a:	74 05                	je     14571 <put_queue+0x26>
   1456c:	c1 eb 08             	shr    $0x8,%ebx
   1456f:	eb e5                	jmp    14556 <put_queue+0xb>
   14571:	89 4a 04             	mov    %ecx,0x4(%edx)
   14574:	8b 4a 0c             	mov    0xc(%edx),%ecx
   14577:	85 c9                	test   %ecx,%ecx
   14579:	74 06                	je     14581 <put_queue+0x36>
   1457b:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
   14581:	5a                   	pop    %edx
   14582:	59                   	pop    %ecx
   14583:	c3                   	ret    

00014584 <ctrl>:
   14584:	b0 04                	mov    $0x4,%al
   14586:	eb 02                	jmp    1458a <alt+0x2>

00014588 <alt>:
   14588:	b0 10                	mov    $0x10,%al
   1458a:	80 3d da 44 01 00 00 	cmpb   $0x0,0x144da
   14591:	74 02                	je     14595 <alt+0xd>
   14593:	00 c0                	add    %al,%al
   14595:	08 05 d8 44 01 00    	or     %al,0x144d8
   1459b:	c3                   	ret    

0001459c <unctrl>:
   1459c:	b0 04                	mov    $0x4,%al
   1459e:	eb 02                	jmp    145a2 <unalt+0x2>

000145a0 <unalt>:
   145a0:	b0 10                	mov    $0x10,%al
   145a2:	80 3d da 44 01 00 00 	cmpb   $0x0,0x144da
   145a9:	74 02                	je     145ad <unalt+0xd>
   145ab:	00 c0                	add    %al,%al
   145ad:	f6 d0                	not    %al
   145af:	20 05 d8 44 01 00    	and    %al,0x144d8
   145b5:	c3                   	ret    

000145b6 <lshift>:
   145b6:	80 0d d8 44 01 00 01 	orb    $0x1,0x144d8
   145bd:	c3                   	ret    

000145be <unlshift>:
   145be:	80 25 d8 44 01 00 fe 	andb   $0xfe,0x144d8
   145c5:	c3                   	ret    

000145c6 <rshift>:
   145c6:	80 0d d8 44 01 00 02 	orb    $0x2,0x144d8
   145cd:	c3                   	ret    

000145ce <unrshift>:
   145ce:	80 25 d8 44 01 00 fd 	andb   $0xfd,0x144d8
   145d5:	c3                   	ret    

000145d6 <caps>:
   145d6:	f6 05 d8 44 01 00 80 	testb  $0x80,0x144d8
   145dd:	75 43                	jne    14622 <scroll+0x10>
   145df:	80 35 d9 44 01 00 04 	xorb   $0x4,0x144d9
   145e6:	80 35 d8 44 01 00 40 	xorb   $0x40,0x144d8
   145ed:	80 0d d8 44 01 00 80 	orb    $0x80,0x144d8

000145f4 <set_leds>:
   145f4:	e8 c4 06 00 00       	call   14cbd <kb_wait>
   145f9:	b0 ed                	mov    $0xed,%al
   145fb:	e6 60                	out    %al,$0x60
   145fd:	e8 bb 06 00 00       	call   14cbd <kb_wait>
   14602:	a0 d9 44 01 00       	mov    0x144d9,%al
   14607:	e6 60                	out    %al,$0x60
   14609:	c3                   	ret    

0001460a <uncaps>:
   1460a:	80 25 d8 44 01 00 7f 	andb   $0x7f,0x144d8
   14611:	c3                   	ret    

00014612 <scroll>:
   14612:	f6 05 d8 44 01 00 03 	testb  $0x3,0x144d8
   14619:	74 07                	je     14622 <scroll+0x10>
   1461b:	e8 75 61 ff ff       	call   a795 <show_mem>
   14620:	eb 05                	jmp    14627 <scroll+0x15>
   14622:	e8 f1 25 ff ff       	call   6c18 <show_state>
   14627:	80 35 d9 44 01 00 01 	xorb   $0x1,0x144d9
   1462e:	eb c4                	jmp    145f4 <set_leds>

00014630 <num>:
   14630:	80 35 d9 44 01 00 02 	xorb   $0x2,0x144d9
   14637:	eb bb                	jmp    145f4 <set_leds>

00014639 <cursor>:
   14639:	2c 47                	sub    $0x47,%al
   1463b:	72 44                	jb     14681 <cur2+0x28>
   1463d:	3c 0c                	cmp    $0xc,%al
   1463f:	77 40                	ja     14681 <cur2+0x28>
   14641:	75 16                	jne    14659 <cur2>
   14643:	f6 05 d8 44 01 00 0c 	testb  $0xc,0x144d8
   1464a:	74 0d                	je     14659 <cur2>
   1464c:	f6 05 d8 44 01 00 30 	testb  $0x30,0x144d8
   14653:	0f 85 6d 06 00 00    	jne    14cc6 <reboot>

00014659 <cur2>:
   14659:	80 3d da 44 01 00 01 	cmpb   $0x1,0x144da
   14660:	74 20                	je     14682 <cur>
   14662:	f6 05 d9 44 01 00 02 	testb  $0x2,0x144d9
   14669:	74 17                	je     14682 <cur>
   1466b:	f6 05 d8 44 01 00 03 	testb  $0x3,0x144d8
   14672:	75 0e                	jne    14682 <cur>
   14674:	31 db                	xor    %ebx,%ebx
   14676:	8a 80 9c 46 01 00    	mov    0x1469c(%eax),%al
   1467c:	e9 ca fe ff ff       	jmp    1454b <put_queue>
   14681:	c3                   	ret    

00014682 <cur>:
   14682:	8a 80 a9 46 01 00    	mov    0x146a9(%eax),%al
   14688:	3c 39                	cmp    $0x39,%al
   1468a:	77 02                	ja     1468e <ok_cur>
   1468c:	b4 7e                	mov    $0x7e,%ah

0001468e <ok_cur>:
   1468e:	c1 e0 10             	shl    $0x10,%eax
   14691:	66 b8 1b 5b          	mov    $0x5b1b,%ax
   14695:	31 db                	xor    %ebx,%ebx
   14697:	e9 af fe ff ff       	jmp    1454b <put_queue>

0001469c <num_table>:
   1469c:	37                   	aaa    
   1469d:	38 39                	cmp    %bh,(%ecx)
   1469f:	20 34 35 36 20 31 32 	and    %dh,0x32312036(,%esi,1)
   146a6:	33 30                	xor    (%eax),%esi
   146a8:	2c                   	.byte 0x2c

000146a9 <cur_table>:
   146a9:	48                   	dec    %eax
   146aa:	41                   	inc    %ecx
   146ab:	35 20 44 47 43       	xor    $0x43474420,%eax
   146b0:	20 59 42             	and    %bl,0x42(%ecx)
   146b3:	36 32 33             	xor    %ss:(%ebx),%dh

000146b6 <func>:
   146b6:	2c 3b                	sub    $0x3b,%al
   146b8:	72 31                	jb     146eb <end_func>
   146ba:	3c 09                	cmp    $0x9,%al
   146bc:	76 0a                	jbe    146c8 <ok_func>
   146be:	2c 12                	sub    $0x12,%al
   146c0:	3c 0a                	cmp    $0xa,%al
   146c2:	72 27                	jb     146eb <end_func>
   146c4:	3c 0b                	cmp    $0xb,%al
   146c6:	77 23                	ja     146eb <end_func>

000146c8 <ok_func>:
   146c8:	f6 05 d8 44 01 00 10 	testb  $0x10,0x144d8
   146cf:	75 13                	jne    146e4 <alt_func>
   146d1:	83 f9 04             	cmp    $0x4,%ecx
   146d4:	7c 15                	jl     146eb <end_func>
   146d6:	8b 04 85 ec 46 01 00 	mov    0x146ec(,%eax,4),%eax
   146dd:	31 db                	xor    %ebx,%ebx
   146df:	e9 67 fe ff ff       	jmp    1454b <put_queue>

000146e4 <alt_func>:
   146e4:	50                   	push   %eax
   146e5:	e8 1b db ff ff       	call   12205 <change_console>
   146ea:	58                   	pop    %eax

000146eb <end_func>:
   146eb:	c3                   	ret    

000146ec <func_table>:
   146ec:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   146ef:	41                   	inc    %ecx
   146f0:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   146f3:	42                   	inc    %edx
   146f4:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   146f7:	43                   	inc    %ebx
   146f8:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   146fb:	44                   	inc    %esp
   146fc:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   146ff:	45                   	inc    %ebp
   14700:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   14703:	46                   	inc    %esi
   14704:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   14707:	47                   	inc    %edi
   14708:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   1470b:	48                   	dec    %eax
   1470c:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   1470f:	49                   	dec    %ecx
   14710:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   14713:	4a                   	dec    %edx
   14714:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   14717:	4b                   	dec    %ebx
   14718:	1b 5b 5b             	sbb    0x5b(%ebx),%ebx
   1471b:	4c                   	dec    %esp

0001471c <key_map>:
   1471c:	00 1b                	add    %bl,(%ebx)
   1471e:	31 32                	xor    %esi,(%edx)
   14720:	33 34 35 36 37 38 39 	xor    0x39383736(,%esi,1),%esi
   14727:	30 2d 3d 7f 09 71    	xor    %ch,0x71097f3d
   1472d:	77 65                	ja     14794 <shift_map+0x17>
   1472f:	72 74                	jb     147a5 <shift_map+0x28>
   14731:	79 75                	jns    147a8 <shift_map+0x2b>
   14733:	69 6f 70 5b 5d 0d 00 	imul   $0xd5d5b,0x70(%edi),%ebp
   1473a:	61                   	popa   
   1473b:	73 64                	jae    147a1 <shift_map+0x24>
   1473d:	66 67 68 6a 6b       	addr16 pushw $0x6b6a
   14742:	6c                   	insb   (%dx),%es:(%edi)
   14743:	3b 27                	cmp    (%edi),%esp
   14745:	60                   	pusha  
   14746:	00 5c 7a 78          	add    %bl,0x78(%edx,%edi,2)
   1474a:	63 76 62             	arpl   %si,0x62(%esi)
   1474d:	6e                   	outsb  %ds:(%esi),(%dx)
   1474e:	6d                   	insl   (%dx),%es:(%edi)
   1474f:	2c 2e                	sub    $0x2e,%al
   14751:	2f                   	das    
   14752:	00 2a                	add    %ch,(%edx)
   14754:	00 20                	add    %ah,(%eax)
	...
   14766:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   1476b:	00 00                	add    %al,(%eax)
   1476d:	00 00                	add    %al,(%eax)
   1476f:	00 00                	add    %al,(%eax)
   14771:	00 3c 00             	add    %bh,(%eax,%eax,1)
	...

0001477d <shift_map>:
   1477d:	00 1b                	add    %bl,(%ebx)
   1477f:	21 40 23             	and    %eax,0x23(%eax)
   14782:	24 25                	and    $0x25,%al
   14784:	5e                   	pop    %esi
   14785:	26 2a 28             	sub    %es:(%eax),%ch
   14788:	29 5f 2b             	sub    %ebx,0x2b(%edi)
   1478b:	7f 09                	jg     14796 <shift_map+0x19>
   1478d:	51                   	push   %ecx
   1478e:	57                   	push   %edi
   1478f:	45                   	inc    %ebp
   14790:	52                   	push   %edx
   14791:	54                   	push   %esp
   14792:	59                   	pop    %ecx
   14793:	55                   	push   %ebp
   14794:	49                   	dec    %ecx
   14795:	4f                   	dec    %edi
   14796:	50                   	push   %eax
   14797:	7b 7d                	jnp    14816 <alt_map+0x38>
   14799:	0d 00 41 53 44       	or     $0x44534100,%eax
   1479e:	46                   	inc    %esi
   1479f:	47                   	inc    %edi
   147a0:	48                   	dec    %eax
   147a1:	4a                   	dec    %edx
   147a2:	4b                   	dec    %ebx
   147a3:	4c                   	dec    %esp
   147a4:	3a 22                	cmp    (%edx),%ah
   147a6:	7e 00                	jle    147a8 <shift_map+0x2b>
   147a8:	7c 5a                	jl     14804 <alt_map+0x26>
   147aa:	58                   	pop    %eax
   147ab:	43                   	inc    %ebx
   147ac:	56                   	push   %esi
   147ad:	42                   	inc    %edx
   147ae:	4e                   	dec    %esi
   147af:	4d                   	dec    %ebp
   147b0:	3c 3e                	cmp    $0x3e,%al
   147b2:	3f                   	aas    
   147b3:	00 2a                	add    %ch,(%edx)
   147b5:	00 20                	add    %ah,(%eax)
	...
   147c7:	2d 00 00 00 2b       	sub    $0x2b000000,%eax
   147cc:	00 00                	add    %al,(%eax)
   147ce:	00 00                	add    %al,(%eax)
   147d0:	00 00                	add    %al,(%eax)
   147d2:	00 3e                	add    %bh,(%esi)
	...

000147de <alt_map>:
   147de:	00 00                	add    %al,(%eax)
   147e0:	00 40 00             	add    %al,0x0(%eax)
   147e3:	24 00                	and    $0x0,%al
   147e5:	00 7b 5b             	add    %bh,0x5b(%ebx)
   147e8:	5d                   	pop    %ebp
   147e9:	7d 5c                	jge    14847 <do_self+0x8>
	...
   147f7:	00 00                	add    %al,(%eax)
   147f9:	7e 0d                	jle    14808 <alt_map+0x2a>
	...
   14833:	00 7c 00 00          	add    %bh,0x0(%eax,%eax,1)
	...

0001483f <do_self>:
   1483f:	8d 1d de 47 01 00    	lea    0x147de,%ebx
   14845:	f6 05 d8 44 01 00 20 	testb  $0x20,0x144d8
   1484c:	75 15                	jne    14863 <do_self+0x24>
   1484e:	8d 1d 7d 47 01 00    	lea    0x1477d,%ebx
   14854:	f6 05 d8 44 01 00 03 	testb  $0x3,0x144d8
   1485b:	75 06                	jne    14863 <do_self+0x24>
   1485d:	8d 1d 1c 47 01 00    	lea    0x1471c,%ebx
   14863:	8a 04 03             	mov    (%ebx,%eax,1),%al
   14866:	08 c0                	or     %al,%al
   14868:	74 3d                	je     148a7 <none>
   1486a:	f6 05 d8 44 01 00 4c 	testb  $0x4c,0x144d8
   14871:	74 0a                	je     1487d <do_self+0x3e>
   14873:	3c 61                	cmp    $0x61,%al
   14875:	72 06                	jb     1487d <do_self+0x3e>
   14877:	3c 7d                	cmp    $0x7d,%al
   14879:	77 02                	ja     1487d <do_self+0x3e>
   1487b:	2c 20                	sub    $0x20,%al
   1487d:	f6 05 d8 44 01 00 0c 	testb  $0xc,0x144d8
   14884:	74 0a                	je     14890 <do_self+0x51>
   14886:	3c 40                	cmp    $0x40,%al
   14888:	72 06                	jb     14890 <do_self+0x51>
   1488a:	3c 60                	cmp    $0x60,%al
   1488c:	73 02                	jae    14890 <do_self+0x51>
   1488e:	2c 40                	sub    $0x40,%al
   14890:	f6 05 d8 44 01 00 10 	testb  $0x10,0x144d8
   14897:	74 02                	je     1489b <do_self+0x5c>
   14899:	0c 80                	or     $0x80,%al
   1489b:	25 ff 00 00 00       	and    $0xff,%eax
   148a0:	31 db                	xor    %ebx,%ebx
   148a2:	e8 a4 fc ff ff       	call   1454b <put_queue>

000148a7 <none>:
   148a7:	c3                   	ret    

000148a8 <minus>:
   148a8:	80 3d da 44 01 00 01 	cmpb   $0x1,0x144da
   148af:	75 8e                	jne    1483f <do_self>
   148b1:	b8 2f 00 00 00       	mov    $0x2f,%eax
   148b6:	31 db                	xor    %ebx,%ebx
   148b8:	e9 8e fc ff ff       	jmp    1454b <put_queue>

000148bd <key_table>:
   148bd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   148be:	48                   	dec    %eax
   148bf:	01 00                	add    %eax,(%eax)
   148c1:	3f                   	aas    
   148c2:	48                   	dec    %eax
   148c3:	01 00                	add    %eax,(%eax)
   148c5:	3f                   	aas    
   148c6:	48                   	dec    %eax
   148c7:	01 00                	add    %eax,(%eax)
   148c9:	3f                   	aas    
   148ca:	48                   	dec    %eax
   148cb:	01 00                	add    %eax,(%eax)
   148cd:	3f                   	aas    
   148ce:	48                   	dec    %eax
   148cf:	01 00                	add    %eax,(%eax)
   148d1:	3f                   	aas    
   148d2:	48                   	dec    %eax
   148d3:	01 00                	add    %eax,(%eax)
   148d5:	3f                   	aas    
   148d6:	48                   	dec    %eax
   148d7:	01 00                	add    %eax,(%eax)
   148d9:	3f                   	aas    
   148da:	48                   	dec    %eax
   148db:	01 00                	add    %eax,(%eax)
   148dd:	3f                   	aas    
   148de:	48                   	dec    %eax
   148df:	01 00                	add    %eax,(%eax)
   148e1:	3f                   	aas    
   148e2:	48                   	dec    %eax
   148e3:	01 00                	add    %eax,(%eax)
   148e5:	3f                   	aas    
   148e6:	48                   	dec    %eax
   148e7:	01 00                	add    %eax,(%eax)
   148e9:	3f                   	aas    
   148ea:	48                   	dec    %eax
   148eb:	01 00                	add    %eax,(%eax)
   148ed:	3f                   	aas    
   148ee:	48                   	dec    %eax
   148ef:	01 00                	add    %eax,(%eax)
   148f1:	3f                   	aas    
   148f2:	48                   	dec    %eax
   148f3:	01 00                	add    %eax,(%eax)
   148f5:	3f                   	aas    
   148f6:	48                   	dec    %eax
   148f7:	01 00                	add    %eax,(%eax)
   148f9:	3f                   	aas    
   148fa:	48                   	dec    %eax
   148fb:	01 00                	add    %eax,(%eax)
   148fd:	3f                   	aas    
   148fe:	48                   	dec    %eax
   148ff:	01 00                	add    %eax,(%eax)
   14901:	3f                   	aas    
   14902:	48                   	dec    %eax
   14903:	01 00                	add    %eax,(%eax)
   14905:	3f                   	aas    
   14906:	48                   	dec    %eax
   14907:	01 00                	add    %eax,(%eax)
   14909:	3f                   	aas    
   1490a:	48                   	dec    %eax
   1490b:	01 00                	add    %eax,(%eax)
   1490d:	3f                   	aas    
   1490e:	48                   	dec    %eax
   1490f:	01 00                	add    %eax,(%eax)
   14911:	3f                   	aas    
   14912:	48                   	dec    %eax
   14913:	01 00                	add    %eax,(%eax)
   14915:	3f                   	aas    
   14916:	48                   	dec    %eax
   14917:	01 00                	add    %eax,(%eax)
   14919:	3f                   	aas    
   1491a:	48                   	dec    %eax
   1491b:	01 00                	add    %eax,(%eax)
   1491d:	3f                   	aas    
   1491e:	48                   	dec    %eax
   1491f:	01 00                	add    %eax,(%eax)
   14921:	3f                   	aas    
   14922:	48                   	dec    %eax
   14923:	01 00                	add    %eax,(%eax)
   14925:	3f                   	aas    
   14926:	48                   	dec    %eax
   14927:	01 00                	add    %eax,(%eax)
   14929:	3f                   	aas    
   1492a:	48                   	dec    %eax
   1492b:	01 00                	add    %eax,(%eax)
   1492d:	3f                   	aas    
   1492e:	48                   	dec    %eax
   1492f:	01 00                	add    %eax,(%eax)
   14931:	84 45 01             	test   %al,0x1(%ebp)
   14934:	00 3f                	add    %bh,(%edi)
   14936:	48                   	dec    %eax
   14937:	01 00                	add    %eax,(%eax)
   14939:	3f                   	aas    
   1493a:	48                   	dec    %eax
   1493b:	01 00                	add    %eax,(%eax)
   1493d:	3f                   	aas    
   1493e:	48                   	dec    %eax
   1493f:	01 00                	add    %eax,(%eax)
   14941:	3f                   	aas    
   14942:	48                   	dec    %eax
   14943:	01 00                	add    %eax,(%eax)
   14945:	3f                   	aas    
   14946:	48                   	dec    %eax
   14947:	01 00                	add    %eax,(%eax)
   14949:	3f                   	aas    
   1494a:	48                   	dec    %eax
   1494b:	01 00                	add    %eax,(%eax)
   1494d:	3f                   	aas    
   1494e:	48                   	dec    %eax
   1494f:	01 00                	add    %eax,(%eax)
   14951:	3f                   	aas    
   14952:	48                   	dec    %eax
   14953:	01 00                	add    %eax,(%eax)
   14955:	3f                   	aas    
   14956:	48                   	dec    %eax
   14957:	01 00                	add    %eax,(%eax)
   14959:	3f                   	aas    
   1495a:	48                   	dec    %eax
   1495b:	01 00                	add    %eax,(%eax)
   1495d:	3f                   	aas    
   1495e:	48                   	dec    %eax
   1495f:	01 00                	add    %eax,(%eax)
   14961:	3f                   	aas    
   14962:	48                   	dec    %eax
   14963:	01 00                	add    %eax,(%eax)
   14965:	b6 45                	mov    $0x45,%dh
   14967:	01 00                	add    %eax,(%eax)
   14969:	3f                   	aas    
   1496a:	48                   	dec    %eax
   1496b:	01 00                	add    %eax,(%eax)
   1496d:	3f                   	aas    
   1496e:	48                   	dec    %eax
   1496f:	01 00                	add    %eax,(%eax)
   14971:	3f                   	aas    
   14972:	48                   	dec    %eax
   14973:	01 00                	add    %eax,(%eax)
   14975:	3f                   	aas    
   14976:	48                   	dec    %eax
   14977:	01 00                	add    %eax,(%eax)
   14979:	3f                   	aas    
   1497a:	48                   	dec    %eax
   1497b:	01 00                	add    %eax,(%eax)
   1497d:	3f                   	aas    
   1497e:	48                   	dec    %eax
   1497f:	01 00                	add    %eax,(%eax)
   14981:	3f                   	aas    
   14982:	48                   	dec    %eax
   14983:	01 00                	add    %eax,(%eax)
   14985:	3f                   	aas    
   14986:	48                   	dec    %eax
   14987:	01 00                	add    %eax,(%eax)
   14989:	3f                   	aas    
   1498a:	48                   	dec    %eax
   1498b:	01 00                	add    %eax,(%eax)
   1498d:	3f                   	aas    
   1498e:	48                   	dec    %eax
   1498f:	01 00                	add    %eax,(%eax)
   14991:	a8 48                	test   $0x48,%al
   14993:	01 00                	add    %eax,(%eax)
   14995:	c6 45 01 00          	movb   $0x0,0x1(%ebp)
   14999:	3f                   	aas    
   1499a:	48                   	dec    %eax
   1499b:	01 00                	add    %eax,(%eax)
   1499d:	88 45 01             	mov    %al,0x1(%ebp)
   149a0:	00 3f                	add    %bh,(%edi)
   149a2:	48                   	dec    %eax
   149a3:	01 00                	add    %eax,(%eax)
   149a5:	d6                   	(bad)  
   149a6:	45                   	inc    %ebp
   149a7:	01 00                	add    %eax,(%eax)
   149a9:	b6 46                	mov    $0x46,%dh
   149ab:	01 00                	add    %eax,(%eax)
   149ad:	b6 46                	mov    $0x46,%dh
   149af:	01 00                	add    %eax,(%eax)
   149b1:	b6 46                	mov    $0x46,%dh
   149b3:	01 00                	add    %eax,(%eax)
   149b5:	b6 46                	mov    $0x46,%dh
   149b7:	01 00                	add    %eax,(%eax)
   149b9:	b6 46                	mov    $0x46,%dh
   149bb:	01 00                	add    %eax,(%eax)
   149bd:	b6 46                	mov    $0x46,%dh
   149bf:	01 00                	add    %eax,(%eax)
   149c1:	b6 46                	mov    $0x46,%dh
   149c3:	01 00                	add    %eax,(%eax)
   149c5:	b6 46                	mov    $0x46,%dh
   149c7:	01 00                	add    %eax,(%eax)
   149c9:	b6 46                	mov    $0x46,%dh
   149cb:	01 00                	add    %eax,(%eax)
   149cd:	b6 46                	mov    $0x46,%dh
   149cf:	01 00                	add    %eax,(%eax)
   149d1:	30 46 01             	xor    %al,0x1(%esi)
   149d4:	00 12                	add    %dl,(%edx)
   149d6:	46                   	inc    %esi
   149d7:	01 00                	add    %eax,(%eax)
   149d9:	39 46 01             	cmp    %eax,0x1(%esi)
   149dc:	00 39                	add    %bh,(%ecx)
   149de:	46                   	inc    %esi
   149df:	01 00                	add    %eax,(%eax)
   149e1:	39 46 01             	cmp    %eax,0x1(%esi)
   149e4:	00 3f                	add    %bh,(%edi)
   149e6:	48                   	dec    %eax
   149e7:	01 00                	add    %eax,(%eax)
   149e9:	39 46 01             	cmp    %eax,0x1(%esi)
   149ec:	00 39                	add    %bh,(%ecx)
   149ee:	46                   	inc    %esi
   149ef:	01 00                	add    %eax,(%eax)
   149f1:	39 46 01             	cmp    %eax,0x1(%esi)
   149f4:	00 3f                	add    %bh,(%edi)
   149f6:	48                   	dec    %eax
   149f7:	01 00                	add    %eax,(%eax)
   149f9:	39 46 01             	cmp    %eax,0x1(%esi)
   149fc:	00 39                	add    %bh,(%ecx)
   149fe:	46                   	inc    %esi
   149ff:	01 00                	add    %eax,(%eax)
   14a01:	39 46 01             	cmp    %eax,0x1(%esi)
   14a04:	00 39                	add    %bh,(%ecx)
   14a06:	46                   	inc    %esi
   14a07:	01 00                	add    %eax,(%eax)
   14a09:	39 46 01             	cmp    %eax,0x1(%esi)
   14a0c:	00 a7 48 01 00 a7    	add    %ah,-0x58fffeb8(%edi)
   14a12:	48                   	dec    %eax
   14a13:	01 00                	add    %eax,(%eax)
   14a15:	3f                   	aas    
   14a16:	48                   	dec    %eax
   14a17:	01 00                	add    %eax,(%eax)
   14a19:	b6 46                	mov    $0x46,%dh
   14a1b:	01 00                	add    %eax,(%eax)
   14a1d:	b6 46                	mov    $0x46,%dh
   14a1f:	01 00                	add    %eax,(%eax)
   14a21:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a22:	48                   	dec    %eax
   14a23:	01 00                	add    %eax,(%eax)
   14a25:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a26:	48                   	dec    %eax
   14a27:	01 00                	add    %eax,(%eax)
   14a29:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a2a:	48                   	dec    %eax
   14a2b:	01 00                	add    %eax,(%eax)
   14a2d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a2e:	48                   	dec    %eax
   14a2f:	01 00                	add    %eax,(%eax)
   14a31:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a32:	48                   	dec    %eax
   14a33:	01 00                	add    %eax,(%eax)
   14a35:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a36:	48                   	dec    %eax
   14a37:	01 00                	add    %eax,(%eax)
   14a39:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a3a:	48                   	dec    %eax
   14a3b:	01 00                	add    %eax,(%eax)
   14a3d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a3e:	48                   	dec    %eax
   14a3f:	01 00                	add    %eax,(%eax)
   14a41:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a42:	48                   	dec    %eax
   14a43:	01 00                	add    %eax,(%eax)
   14a45:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a46:	48                   	dec    %eax
   14a47:	01 00                	add    %eax,(%eax)
   14a49:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a4a:	48                   	dec    %eax
   14a4b:	01 00                	add    %eax,(%eax)
   14a4d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a4e:	48                   	dec    %eax
   14a4f:	01 00                	add    %eax,(%eax)
   14a51:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a52:	48                   	dec    %eax
   14a53:	01 00                	add    %eax,(%eax)
   14a55:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a56:	48                   	dec    %eax
   14a57:	01 00                	add    %eax,(%eax)
   14a59:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a5a:	48                   	dec    %eax
   14a5b:	01 00                	add    %eax,(%eax)
   14a5d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a5e:	48                   	dec    %eax
   14a5f:	01 00                	add    %eax,(%eax)
   14a61:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a62:	48                   	dec    %eax
   14a63:	01 00                	add    %eax,(%eax)
   14a65:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a66:	48                   	dec    %eax
   14a67:	01 00                	add    %eax,(%eax)
   14a69:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a6a:	48                   	dec    %eax
   14a6b:	01 00                	add    %eax,(%eax)
   14a6d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a6e:	48                   	dec    %eax
   14a6f:	01 00                	add    %eax,(%eax)
   14a71:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a72:	48                   	dec    %eax
   14a73:	01 00                	add    %eax,(%eax)
   14a75:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a76:	48                   	dec    %eax
   14a77:	01 00                	add    %eax,(%eax)
   14a79:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a7a:	48                   	dec    %eax
   14a7b:	01 00                	add    %eax,(%eax)
   14a7d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a7e:	48                   	dec    %eax
   14a7f:	01 00                	add    %eax,(%eax)
   14a81:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a82:	48                   	dec    %eax
   14a83:	01 00                	add    %eax,(%eax)
   14a85:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a86:	48                   	dec    %eax
   14a87:	01 00                	add    %eax,(%eax)
   14a89:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a8a:	48                   	dec    %eax
   14a8b:	01 00                	add    %eax,(%eax)
   14a8d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a8e:	48                   	dec    %eax
   14a8f:	01 00                	add    %eax,(%eax)
   14a91:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a92:	48                   	dec    %eax
   14a93:	01 00                	add    %eax,(%eax)
   14a95:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a96:	48                   	dec    %eax
   14a97:	01 00                	add    %eax,(%eax)
   14a99:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a9a:	48                   	dec    %eax
   14a9b:	01 00                	add    %eax,(%eax)
   14a9d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14a9e:	48                   	dec    %eax
   14a9f:	01 00                	add    %eax,(%eax)
   14aa1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aa2:	48                   	dec    %eax
   14aa3:	01 00                	add    %eax,(%eax)
   14aa5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aa6:	48                   	dec    %eax
   14aa7:	01 00                	add    %eax,(%eax)
   14aa9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aaa:	48                   	dec    %eax
   14aab:	01 00                	add    %eax,(%eax)
   14aad:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aae:	48                   	dec    %eax
   14aaf:	01 00                	add    %eax,(%eax)
   14ab1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ab2:	48                   	dec    %eax
   14ab3:	01 00                	add    %eax,(%eax)
   14ab5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ab6:	48                   	dec    %eax
   14ab7:	01 00                	add    %eax,(%eax)
   14ab9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aba:	48                   	dec    %eax
   14abb:	01 00                	add    %eax,(%eax)
   14abd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14abe:	48                   	dec    %eax
   14abf:	01 00                	add    %eax,(%eax)
   14ac1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ac2:	48                   	dec    %eax
   14ac3:	01 00                	add    %eax,(%eax)
   14ac5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ac6:	48                   	dec    %eax
   14ac7:	01 00                	add    %eax,(%eax)
   14ac9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aca:	48                   	dec    %eax
   14acb:	01 00                	add    %eax,(%eax)
   14acd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ace:	48                   	dec    %eax
   14acf:	01 00                	add    %eax,(%eax)
   14ad1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ad2:	48                   	dec    %eax
   14ad3:	01 00                	add    %eax,(%eax)
   14ad5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ad6:	48                   	dec    %eax
   14ad7:	01 00                	add    %eax,(%eax)
   14ad9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ada:	48                   	dec    %eax
   14adb:	01 00                	add    %eax,(%eax)
   14add:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ade:	48                   	dec    %eax
   14adf:	01 00                	add    %eax,(%eax)
   14ae1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ae2:	48                   	dec    %eax
   14ae3:	01 00                	add    %eax,(%eax)
   14ae5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ae6:	48                   	dec    %eax
   14ae7:	01 00                	add    %eax,(%eax)
   14ae9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aea:	48                   	dec    %eax
   14aeb:	01 00                	add    %eax,(%eax)
   14aed:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14aee:	48                   	dec    %eax
   14aef:	01 00                	add    %eax,(%eax)
   14af1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14af2:	48                   	dec    %eax
   14af3:	01 00                	add    %eax,(%eax)
   14af5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14af6:	48                   	dec    %eax
   14af7:	01 00                	add    %eax,(%eax)
   14af9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14afa:	48                   	dec    %eax
   14afb:	01 00                	add    %eax,(%eax)
   14afd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14afe:	48                   	dec    %eax
   14aff:	01 00                	add    %eax,(%eax)
   14b01:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b02:	48                   	dec    %eax
   14b03:	01 00                	add    %eax,(%eax)
   14b05:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b06:	48                   	dec    %eax
   14b07:	01 00                	add    %eax,(%eax)
   14b09:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b0a:	48                   	dec    %eax
   14b0b:	01 00                	add    %eax,(%eax)
   14b0d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b0e:	48                   	dec    %eax
   14b0f:	01 00                	add    %eax,(%eax)
   14b11:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b12:	48                   	dec    %eax
   14b13:	01 00                	add    %eax,(%eax)
   14b15:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b16:	48                   	dec    %eax
   14b17:	01 00                	add    %eax,(%eax)
   14b19:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b1a:	48                   	dec    %eax
   14b1b:	01 00                	add    %eax,(%eax)
   14b1d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b1e:	48                   	dec    %eax
   14b1f:	01 00                	add    %eax,(%eax)
   14b21:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b22:	48                   	dec    %eax
   14b23:	01 00                	add    %eax,(%eax)
   14b25:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b26:	48                   	dec    %eax
   14b27:	01 00                	add    %eax,(%eax)
   14b29:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b2a:	48                   	dec    %eax
   14b2b:	01 00                	add    %eax,(%eax)
   14b2d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b2e:	48                   	dec    %eax
   14b2f:	01 00                	add    %eax,(%eax)
   14b31:	9c                   	pushf  
   14b32:	45                   	inc    %ebp
   14b33:	01 00                	add    %eax,(%eax)
   14b35:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b36:	48                   	dec    %eax
   14b37:	01 00                	add    %eax,(%eax)
   14b39:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b3a:	48                   	dec    %eax
   14b3b:	01 00                	add    %eax,(%eax)
   14b3d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b3e:	48                   	dec    %eax
   14b3f:	01 00                	add    %eax,(%eax)
   14b41:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b42:	48                   	dec    %eax
   14b43:	01 00                	add    %eax,(%eax)
   14b45:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b46:	48                   	dec    %eax
   14b47:	01 00                	add    %eax,(%eax)
   14b49:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b4a:	48                   	dec    %eax
   14b4b:	01 00                	add    %eax,(%eax)
   14b4d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b4e:	48                   	dec    %eax
   14b4f:	01 00                	add    %eax,(%eax)
   14b51:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b52:	48                   	dec    %eax
   14b53:	01 00                	add    %eax,(%eax)
   14b55:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b56:	48                   	dec    %eax
   14b57:	01 00                	add    %eax,(%eax)
   14b59:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b5a:	48                   	dec    %eax
   14b5b:	01 00                	add    %eax,(%eax)
   14b5d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b5e:	48                   	dec    %eax
   14b5f:	01 00                	add    %eax,(%eax)
   14b61:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b62:	48                   	dec    %eax
   14b63:	01 00                	add    %eax,(%eax)
   14b65:	be 45 01 00 a7       	mov    $0xa7000145,%esi
   14b6a:	48                   	dec    %eax
   14b6b:	01 00                	add    %eax,(%eax)
   14b6d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b6e:	48                   	dec    %eax
   14b6f:	01 00                	add    %eax,(%eax)
   14b71:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b72:	48                   	dec    %eax
   14b73:	01 00                	add    %eax,(%eax)
   14b75:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b76:	48                   	dec    %eax
   14b77:	01 00                	add    %eax,(%eax)
   14b79:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b7a:	48                   	dec    %eax
   14b7b:	01 00                	add    %eax,(%eax)
   14b7d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b7e:	48                   	dec    %eax
   14b7f:	01 00                	add    %eax,(%eax)
   14b81:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b82:	48                   	dec    %eax
   14b83:	01 00                	add    %eax,(%eax)
   14b85:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b86:	48                   	dec    %eax
   14b87:	01 00                	add    %eax,(%eax)
   14b89:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b8a:	48                   	dec    %eax
   14b8b:	01 00                	add    %eax,(%eax)
   14b8d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b8e:	48                   	dec    %eax
   14b8f:	01 00                	add    %eax,(%eax)
   14b91:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b92:	48                   	dec    %eax
   14b93:	01 00                	add    %eax,(%eax)
   14b95:	ce                   	into   
   14b96:	45                   	inc    %ebp
   14b97:	01 00                	add    %eax,(%eax)
   14b99:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14b9a:	48                   	dec    %eax
   14b9b:	01 00                	add    %eax,(%eax)
   14b9d:	a0 45 01 00 a7       	mov    0xa7000145,%al
   14ba2:	48                   	dec    %eax
   14ba3:	01 00                	add    %eax,(%eax)
   14ba5:	0a 46 01             	or     0x1(%esi),%al
   14ba8:	00 a7 48 01 00 a7    	add    %ah,-0x58fffeb8(%edi)
   14bae:	48                   	dec    %eax
   14baf:	01 00                	add    %eax,(%eax)
   14bb1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bb2:	48                   	dec    %eax
   14bb3:	01 00                	add    %eax,(%eax)
   14bb5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bb6:	48                   	dec    %eax
   14bb7:	01 00                	add    %eax,(%eax)
   14bb9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bba:	48                   	dec    %eax
   14bbb:	01 00                	add    %eax,(%eax)
   14bbd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bbe:	48                   	dec    %eax
   14bbf:	01 00                	add    %eax,(%eax)
   14bc1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bc2:	48                   	dec    %eax
   14bc3:	01 00                	add    %eax,(%eax)
   14bc5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bc6:	48                   	dec    %eax
   14bc7:	01 00                	add    %eax,(%eax)
   14bc9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bca:	48                   	dec    %eax
   14bcb:	01 00                	add    %eax,(%eax)
   14bcd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bce:	48                   	dec    %eax
   14bcf:	01 00                	add    %eax,(%eax)
   14bd1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bd2:	48                   	dec    %eax
   14bd3:	01 00                	add    %eax,(%eax)
   14bd5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bd6:	48                   	dec    %eax
   14bd7:	01 00                	add    %eax,(%eax)
   14bd9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bda:	48                   	dec    %eax
   14bdb:	01 00                	add    %eax,(%eax)
   14bdd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bde:	48                   	dec    %eax
   14bdf:	01 00                	add    %eax,(%eax)
   14be1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14be2:	48                   	dec    %eax
   14be3:	01 00                	add    %eax,(%eax)
   14be5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14be6:	48                   	dec    %eax
   14be7:	01 00                	add    %eax,(%eax)
   14be9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bea:	48                   	dec    %eax
   14beb:	01 00                	add    %eax,(%eax)
   14bed:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bee:	48                   	dec    %eax
   14bef:	01 00                	add    %eax,(%eax)
   14bf1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bf2:	48                   	dec    %eax
   14bf3:	01 00                	add    %eax,(%eax)
   14bf5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bf6:	48                   	dec    %eax
   14bf7:	01 00                	add    %eax,(%eax)
   14bf9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bfa:	48                   	dec    %eax
   14bfb:	01 00                	add    %eax,(%eax)
   14bfd:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14bfe:	48                   	dec    %eax
   14bff:	01 00                	add    %eax,(%eax)
   14c01:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c02:	48                   	dec    %eax
   14c03:	01 00                	add    %eax,(%eax)
   14c05:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c06:	48                   	dec    %eax
   14c07:	01 00                	add    %eax,(%eax)
   14c09:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c0a:	48                   	dec    %eax
   14c0b:	01 00                	add    %eax,(%eax)
   14c0d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c0e:	48                   	dec    %eax
   14c0f:	01 00                	add    %eax,(%eax)
   14c11:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c12:	48                   	dec    %eax
   14c13:	01 00                	add    %eax,(%eax)
   14c15:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c16:	48                   	dec    %eax
   14c17:	01 00                	add    %eax,(%eax)
   14c19:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c1a:	48                   	dec    %eax
   14c1b:	01 00                	add    %eax,(%eax)
   14c1d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c1e:	48                   	dec    %eax
   14c1f:	01 00                	add    %eax,(%eax)
   14c21:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c22:	48                   	dec    %eax
   14c23:	01 00                	add    %eax,(%eax)
   14c25:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c26:	48                   	dec    %eax
   14c27:	01 00                	add    %eax,(%eax)
   14c29:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c2a:	48                   	dec    %eax
   14c2b:	01 00                	add    %eax,(%eax)
   14c2d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c2e:	48                   	dec    %eax
   14c2f:	01 00                	add    %eax,(%eax)
   14c31:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c32:	48                   	dec    %eax
   14c33:	01 00                	add    %eax,(%eax)
   14c35:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c36:	48                   	dec    %eax
   14c37:	01 00                	add    %eax,(%eax)
   14c39:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c3a:	48                   	dec    %eax
   14c3b:	01 00                	add    %eax,(%eax)
   14c3d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c3e:	48                   	dec    %eax
   14c3f:	01 00                	add    %eax,(%eax)
   14c41:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c42:	48                   	dec    %eax
   14c43:	01 00                	add    %eax,(%eax)
   14c45:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c46:	48                   	dec    %eax
   14c47:	01 00                	add    %eax,(%eax)
   14c49:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c4a:	48                   	dec    %eax
   14c4b:	01 00                	add    %eax,(%eax)
   14c4d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c4e:	48                   	dec    %eax
   14c4f:	01 00                	add    %eax,(%eax)
   14c51:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c52:	48                   	dec    %eax
   14c53:	01 00                	add    %eax,(%eax)
   14c55:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c56:	48                   	dec    %eax
   14c57:	01 00                	add    %eax,(%eax)
   14c59:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c5a:	48                   	dec    %eax
   14c5b:	01 00                	add    %eax,(%eax)
   14c5d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c5e:	48                   	dec    %eax
   14c5f:	01 00                	add    %eax,(%eax)
   14c61:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c62:	48                   	dec    %eax
   14c63:	01 00                	add    %eax,(%eax)
   14c65:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c66:	48                   	dec    %eax
   14c67:	01 00                	add    %eax,(%eax)
   14c69:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c6a:	48                   	dec    %eax
   14c6b:	01 00                	add    %eax,(%eax)
   14c6d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c6e:	48                   	dec    %eax
   14c6f:	01 00                	add    %eax,(%eax)
   14c71:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c72:	48                   	dec    %eax
   14c73:	01 00                	add    %eax,(%eax)
   14c75:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c76:	48                   	dec    %eax
   14c77:	01 00                	add    %eax,(%eax)
   14c79:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c7a:	48                   	dec    %eax
   14c7b:	01 00                	add    %eax,(%eax)
   14c7d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c7e:	48                   	dec    %eax
   14c7f:	01 00                	add    %eax,(%eax)
   14c81:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c82:	48                   	dec    %eax
   14c83:	01 00                	add    %eax,(%eax)
   14c85:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c86:	48                   	dec    %eax
   14c87:	01 00                	add    %eax,(%eax)
   14c89:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c8a:	48                   	dec    %eax
   14c8b:	01 00                	add    %eax,(%eax)
   14c8d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c8e:	48                   	dec    %eax
   14c8f:	01 00                	add    %eax,(%eax)
   14c91:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c92:	48                   	dec    %eax
   14c93:	01 00                	add    %eax,(%eax)
   14c95:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c96:	48                   	dec    %eax
   14c97:	01 00                	add    %eax,(%eax)
   14c99:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c9a:	48                   	dec    %eax
   14c9b:	01 00                	add    %eax,(%eax)
   14c9d:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14c9e:	48                   	dec    %eax
   14c9f:	01 00                	add    %eax,(%eax)
   14ca1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ca2:	48                   	dec    %eax
   14ca3:	01 00                	add    %eax,(%eax)
   14ca5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14ca6:	48                   	dec    %eax
   14ca7:	01 00                	add    %eax,(%eax)
   14ca9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14caa:	48                   	dec    %eax
   14cab:	01 00                	add    %eax,(%eax)
   14cad:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14cae:	48                   	dec    %eax
   14caf:	01 00                	add    %eax,(%eax)
   14cb1:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14cb2:	48                   	dec    %eax
   14cb3:	01 00                	add    %eax,(%eax)
   14cb5:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14cb6:	48                   	dec    %eax
   14cb7:	01 00                	add    %eax,(%eax)
   14cb9:	a7                   	cmpsl  %es:(%edi),%ds:(%esi)
   14cba:	48                   	dec    %eax
   14cbb:	01 00                	add    %eax,(%eax)

00014cbd <kb_wait>:
   14cbd:	50                   	push   %eax
   14cbe:	e4 64                	in     $0x64,%al
   14cc0:	a8 02                	test   $0x2,%al
   14cc2:	75 fa                	jne    14cbe <kb_wait+0x1>
   14cc4:	58                   	pop    %eax
   14cc5:	c3                   	ret    

00014cc6 <reboot>:
   14cc6:	e8 f2 ff ff ff       	call   14cbd <kb_wait>
   14ccb:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
   14cd2:	34 12 
   14cd4:	b0 fc                	mov    $0xfc,%al
   14cd6:	e6 64                	out    %al,$0x64

00014cd8 <die>:
   14cd8:	eb fe                	jmp    14cd8 <die>

00014cda <init>:
// 初始化串行端口。
// 设置指定串行端口的传输波特率（2400bps）并允许除了写保持寄存器空以外所有中断源。另外，在输出2字节的波特率因子时，须
// 首先设置线路控制寄存器的DLAB位（位7）。
// 参数：port是串行端口基地址，串口1 - 0x3F8；串口2 - 0x2F8。
static void init(int port)
{
   14cda:	56                   	push   %esi
	outb_p(0x80, port + 3);										/* set DLAB of line control reg */
   14cdb:	8d 70 03             	lea    0x3(%eax),%esi
{
   14cde:	53                   	push   %ebx
   14cdf:	89 c1                	mov    %eax,%ecx
	outb_p(0x80, port + 3);										/* set DLAB of line control reg */
   14ce1:	b8 80 00 00 00       	mov    $0x80,%eax
   14ce6:	89 f2                	mov    %esi,%edx
   14ce8:	ee                   	out    %al,(%dx)
   14ce9:	eb 00                	jmp    14ceb <init+0x11>
   14ceb:	eb 00                	jmp    14ced <init+0x13>
	outb_p(0x30, port);											/* LS of divisor (48 -> 2400 bps */
   14ced:	b8 30 00 00 00       	mov    $0x30,%eax
   14cf2:	89 ca                	mov    %ecx,%edx
   14cf4:	ee                   	out    %al,(%dx)
   14cf5:	eb 00                	jmp    14cf7 <init+0x1d>
   14cf7:	eb 00                	jmp    14cf9 <init+0x1f>
	outb_p(0x00, port + 1);										/* MS of divisor */
   14cf9:	8d 59 01             	lea    0x1(%ecx),%ebx
   14cfc:	31 c0                	xor    %eax,%eax
   14cfe:	89 da                	mov    %ebx,%edx
   14d00:	ee                   	out    %al,(%dx)
   14d01:	eb 00                	jmp    14d03 <init+0x29>
   14d03:	eb 00                	jmp    14d05 <init+0x2b>
	outb_p(0x03, port + 3);										/* reset DLAB */
   14d05:	b8 03 00 00 00       	mov    $0x3,%eax
   14d0a:	89 f2                	mov    %esi,%edx
   14d0c:	ee                   	out    %al,(%dx)
   14d0d:	eb 00                	jmp    14d0f <init+0x35>
   14d0f:	eb 00                	jmp    14d11 <init+0x37>
	outb_p(0x0b, port + 4);										/* set DTR,RTS, OUT_2 */
   14d11:	b8 0b 00 00 00       	mov    $0xb,%eax
   14d16:	8d 51 04             	lea    0x4(%ecx),%edx
   14d19:	ee                   	out    %al,(%dx)
   14d1a:	eb 00                	jmp    14d1c <init+0x42>
   14d1c:	eb 00                	jmp    14d1e <init+0x44>
	outb_p(0x0d, port + 1);										/* enable all intrs but writes */
   14d1e:	b8 0d 00 00 00       	mov    $0xd,%eax
   14d23:	89 da                	mov    %ebx,%edx
   14d25:	ee                   	out    %al,(%dx)
   14d26:	eb 00                	jmp    14d28 <init+0x4e>
   14d28:	eb 00                	jmp    14d2a <init+0x50>
	(void)inb(port);											/* read data port to reset things (?) */
   14d2a:	89 ca                	mov    %ecx,%edx
   14d2c:	ec                   	in     (%dx),%al
}
   14d2d:	5b                   	pop    %ebx
   14d2e:	5e                   	pop    %esi
   14d2f:	c3                   	ret    

00014d30 <rs_init>:

// 初始化串行中断程序和串行接口。
// 中断描述符表IDT中的门描述符设置宏set_intr_gate()在include/asm/system.h中实现。
void rs_init(void)
{
   14d30:	e8 49 51 ff ff       	call   9e7e <__x86.get_pc_thunk.cx>
   14d35:	81 c1 cb c2 00 00    	add    $0xc2cb,%ecx
   14d3b:	53                   	push   %ebx
	// 下面两句用于设置两个串行口的中断门描述符。rs1_interrupt是口串1的中断处理过程指针。
	// 串口1使用的中断是int 0x24，串口2的是int 0x23。
	set_intr_gate(0x24, rs1_interrupt);      					// 设置串行口1的中断向量（IRQ4信号）。
   14d3c:	b8 00 00 08 00       	mov    $0x80000,%eax
   14d41:	c7 c3 88 57 00 00    	mov    $0x5788,%ebx
   14d47:	c7 c2 cc 4d 01 00    	mov    $0x14dcc,%edx
   14d4d:	66 89 d0             	mov    %dx,%ax
   14d50:	66 ba 00 8e          	mov    $0x8e00,%dx
   14d54:	89 83 20 01 00 00    	mov    %eax,0x120(%ebx)
   14d5a:	89 93 24 01 00 00    	mov    %edx,0x124(%ebx)
	set_intr_gate(0x23, rs2_interrupt);      					// 设置串行口2的中断向量（IRQ3信号）。
   14d60:	c7 c2 d4 4d 01 00    	mov    $0x14dd4,%edx
   14d66:	66 89 d0             	mov    %dx,%ax
   14d69:	66 ba 00 8e          	mov    $0x8e00,%dx
   14d6d:	89 83 18 01 00 00    	mov    %eax,0x118(%ebx)
   14d73:	89 93 1c 01 00 00    	mov    %edx,0x11c(%ebx)
	init(tty_table[64].read_q->data);       					// 初始化串行口1（.data是端口基地址）。
   14d79:	c7 c3 00 57 03 00    	mov    $0x35700,%ebx
   14d7f:	8b 83 34 10 00 00    	mov    0x1034(%ebx),%eax
   14d85:	8b 00                	mov    (%eax),%eax
   14d87:	e8 4e ff ff ff       	call   14cda <init>
	init(tty_table[65].read_q->data);       					// 初始化串行口2.
   14d8c:	8b 83 74 10 00 00    	mov    0x1074(%ebx),%eax
   14d92:	8b 00                	mov    (%eax),%eax
   14d94:	e8 41 ff ff ff       	call   14cda <init>
	outb(inb_p(0x21) & 0xE7, 0x21);            					// 允许主8259A响应IRQ3、IRQ4中断请求。
   14d99:	ba 21 00 00 00       	mov    $0x21,%edx
   14d9e:	ec                   	in     (%dx),%al
   14d9f:	eb 00                	jmp    14da1 <rs_init+0x71>
   14da1:	eb 00                	jmp    14da3 <rs_init+0x73>
   14da3:	25 e7 00 00 00       	and    $0xe7,%eax
   14da8:	ee                   	out    %al,(%dx)
}
   14da9:	5b                   	pop    %ebx
   14daa:	c3                   	ret    

00014dab <rs_write>:
void rs_write(struct tty_struct * tty)
{
	// 如果写队列不空，则首先从0x3f9（或0x2f9）读取中断允许寄存器内容，添上发送保持寄存器中断允许标志（位1）后，再写
	// 回该寄存器。这样，当发送保持寄存器空时UART就能够因期望获得欲发送的字符而引发中断。write_q.data中是串行端口基
	// 地址。
	cli();
   14dab:	fa                   	cli    
	if (!EMPTY(tty->write_q))
   14dac:	8b 44 24 04          	mov    0x4(%esp),%eax
   14db0:	8b 40 38             	mov    0x38(%eax),%eax
   14db3:	8b 48 08             	mov    0x8(%eax),%ecx
   14db6:	39 48 04             	cmp    %ecx,0x4(%eax)
   14db9:	74 0f                	je     14dca <rs_write+0x1f>
		outb(inb_p(tty->write_q->data + 1) | 0x02, tty->write_q->data + 1);
   14dbb:	8b 10                	mov    (%eax),%edx
   14dbd:	42                   	inc    %edx
   14dbe:	ec                   	in     (%dx),%al
   14dbf:	eb 00                	jmp    14dc1 <rs_write+0x16>
   14dc1:	eb 00                	jmp    14dc3 <rs_write+0x18>
   14dc3:	83 c8 02             	or     $0x2,%eax
   14dc6:	0f b6 c0             	movzbl %al,%eax
   14dc9:	ee                   	out    %al,(%dx)
	sti();
   14dca:	fb                   	sti    
}
   14dcb:	c3                   	ret    

00014dcc <rs1_interrupt>:
   14dcc:	68 f0 24 02 00       	push   $0x224f0
   14dd1:	eb 06                	jmp    14dd9 <rs_int>
   14dd3:	90                   	nop

00014dd4 <rs2_interrupt>:
   14dd4:	68 f8 24 02 00       	push   $0x224f8

00014dd9 <rs_int>:
   14dd9:	52                   	push   %edx
   14dda:	51                   	push   %ecx
   14ddb:	53                   	push   %ebx
   14ddc:	50                   	push   %eax
   14ddd:	06                   	push   %es
   14dde:	1e                   	push   %ds
   14ddf:	6a 10                	push   $0x10
   14de1:	1f                   	pop    %ds
   14de2:	6a 10                	push   $0x10
   14de4:	07                   	pop    %es
   14de5:	8b 54 24 18          	mov    0x18(%esp),%edx
   14de9:	8b 12                	mov    (%edx),%edx
   14deb:	8b 12                	mov    (%edx),%edx
   14ded:	83 c2 02             	add    $0x2,%edx

00014df0 <rep_int>:
   14df0:	31 c0                	xor    %eax,%eax
   14df2:	ec                   	in     (%dx),%al
   14df3:	a8 01                	test   $0x1,%al
   14df5:	75 16                	jne    14e0d <end>
   14df7:	3c 06                	cmp    $0x6,%al
   14df9:	77 12                	ja     14e0d <end>
   14dfb:	8b 4c 24 18          	mov    0x18(%esp),%ecx
   14dff:	52                   	push   %edx
   14e00:	83 ea 02             	sub    $0x2,%edx
   14e03:	ff 14 45 1b 4e 01 00 	call   *0x14e1b(,%eax,2)
   14e0a:	5a                   	pop    %edx
   14e0b:	eb e3                	jmp    14df0 <rep_int>

00014e0d <end>:
   14e0d:	b0 20                	mov    $0x20,%al
   14e0f:	e6 20                	out    %al,$0x20
   14e11:	1f                   	pop    %ds
   14e12:	07                   	pop    %es
   14e13:	58                   	pop    %eax
   14e14:	5b                   	pop    %ebx
   14e15:	59                   	pop    %ecx
   14e16:	5a                   	pop    %edx
   14e17:	83 c4 04             	add    $0x4,%esp
   14e1a:	cf                   	iret   

00014e1b <jmp_table>:
   14e1b:	2c 4e                	sub    $0x4e,%al
   14e1d:	01 00                	add    %eax,(%eax)
   14e1f:	70 4e                	jo     14e6f <read_char+0x33>
   14e21:	01 00                	add    %eax,(%eax)
   14e23:	3c 4e                	cmp    $0x4e,%al
   14e25:	01 00                	add    %eax,(%eax)
   14e27:	34 4e                	xor    $0x4e,%al
   14e29:	01 00                	add    %eax,(%eax)
   14e2b:	90                   	nop

00014e2c <modem_status>:
   14e2c:	83 c2 06             	add    $0x6,%edx
   14e2f:	ec                   	in     (%dx),%al
   14e30:	c3                   	ret    
   14e31:	8d 76 00             	lea    0x0(%esi),%esi

00014e34 <line_status>:
   14e34:	83 c2 05             	add    $0x5,%edx
   14e37:	ec                   	in     (%dx),%al
   14e38:	c3                   	ret    
   14e39:	8d 76 00             	lea    0x0(%esi),%esi

00014e3c <read_char>:
   14e3c:	ec                   	in     (%dx),%al
   14e3d:	89 ca                	mov    %ecx,%edx
   14e3f:	81 ea e8 24 02 00    	sub    $0x224e8,%edx
   14e45:	c1 ea 03             	shr    $0x3,%edx
   14e48:	8b 09                	mov    (%ecx),%ecx
   14e4a:	8b 59 04             	mov    0x4(%ecx),%ebx
   14e4d:	88 44 19 10          	mov    %al,0x10(%ecx,%ebx,1)
   14e51:	43                   	inc    %ebx
   14e52:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   14e58:	3b 59 08             	cmp    0x8(%ecx),%ebx
   14e5b:	74 03                	je     14e60 <read_char+0x24>
   14e5d:	89 59 04             	mov    %ebx,0x4(%ecx)
   14e60:	83 c2 3f             	add    $0x3f,%edx
   14e63:	52                   	push   %edx
   14e64:	e8 ad dd ff ff       	call   12c16 <do_tty_interrupt>
   14e69:	83 c4 04             	add    $0x4,%esp
   14e6c:	c3                   	ret    
   14e6d:	8d 76 00             	lea    0x0(%esi),%esi

00014e70 <write_char>:
   14e70:	8b 49 04             	mov    0x4(%ecx),%ecx
   14e73:	8b 59 04             	mov    0x4(%ecx),%ebx
   14e76:	2b 59 08             	sub    0x8(%ecx),%ebx
   14e79:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   14e7f:	74 2f                	je     14eb0 <write_buffer_empty>
   14e81:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
   14e87:	77 0d                	ja     14e96 <write_char+0x26>
   14e89:	8b 59 0c             	mov    0xc(%ecx),%ebx
   14e8c:	85 db                	test   %ebx,%ebx
   14e8e:	74 06                	je     14e96 <write_char+0x26>
   14e90:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   14e96:	8b 59 08             	mov    0x8(%ecx),%ebx
   14e99:	8a 44 19 10          	mov    0x10(%ecx,%ebx,1),%al
   14e9d:	ee                   	out    %al,(%dx)
   14e9e:	43                   	inc    %ebx
   14e9f:	81 e3 ff 03 00 00    	and    $0x3ff,%ebx
   14ea5:	89 59 08             	mov    %ebx,0x8(%ecx)
   14ea8:	3b 59 04             	cmp    0x4(%ecx),%ebx
   14eab:	74 03                	je     14eb0 <write_buffer_empty>
   14ead:	c3                   	ret    
   14eae:	66 90                	xchg   %ax,%ax

00014eb0 <write_buffer_empty>:
   14eb0:	8b 59 0c             	mov    0xc(%ecx),%ebx
   14eb3:	85 db                	test   %ebx,%ebx
   14eb5:	74 06                	je     14ebd <write_buffer_empty+0xd>
   14eb7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
   14ebd:	42                   	inc    %edx
   14ebe:	ec                   	in     (%dx),%al
   14ebf:	eb 00                	jmp    14ec1 <write_buffer_empty+0x11>
   14ec1:	eb 00                	jmp    14ec3 <write_buffer_empty+0x13>
   14ec3:	24 0d                	and    $0xd,%al
   14ec5:	ee                   	out    %al,(%dx)
   14ec6:	c3                   	ret    

00014ec7 <change_speed>:
// 修改传输波特率。
// 参数：tty - 终端对应的tty数据结构。
// 在除数锁存标志DLAB置位情况下，通过端口0x3f8和0x3f9向UART分别写入波特率因子低字节和高字节。写完后再复位DLAB
// 位。对于串口2,这两个端口分别是0x2f8和0x2f9。
static void change_speed(struct tty_struct * tty)
{
   14ec7:	57                   	push   %edi
   14ec8:	56                   	push   %esi
   14ec9:	53                   	push   %ebx

	// 函数首先检查参数tty指定的终端是否是串行终端，若不是则退出。对于串口终端的tty结构，其读缓冲队列data字段存放着
	// 串行端口基址（0x3f8或0x2f8），而一般控制台终端的tty结构的read_q.data字段值为0。然后从终端termios结构的控制
	// 模式标志集中取得已设置的波特率索引号，并据此从波特率因子数组quotient[]中取得对应的波特率因子值quot。CBAUD是
	// 控制模式标志集中波特率位屏蔽码。
	if (!(port = tty->read_q->data))
   14eca:	8b 48 34             	mov    0x34(%eax),%ecx
   14ecd:	e8 56 1b ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
   14ed2:	81 c2 2e c1 00 00    	add    $0xc12e,%edx
   14ed8:	8b 39                	mov    (%ecx),%edi
   14eda:	66 85 ff             	test   %di,%di
   14edd:	74 3f                	je     14f1e <change_speed+0x57>
		return;
	quot = quotient[tty->termios.c_cflag & CBAUD];
   14edf:	8b 40 08             	mov    0x8(%eax),%eax
   14ee2:	83 e0 0f             	and    $0xf,%eax
   14ee5:	66 8b 8c 42 e0 88 ff 	mov    -0x7720(%edx,%eax,2),%cx
   14eec:	ff 
	// 接着把波特率因子quot写入串行端口对应UART芯片的波特率因子锁存器中。在写之前我们先要把线路控制寄存器LCR的除数锁存
	// 访问位DLAB（位7）置1。然后把16位的波特率因子低、高字节分别写入端口0x3f8、0x3f9（分别对应波特率因子低、高字节
	// 锁存器）。最后再复位LCR的DLAB标志位。
	cli();
   14eed:	fa                   	cli    
	outb_p(0x80, port + 3);									/* set DLAB */          // 首先设置除数锁定标志DLAB。
   14eee:	0f b7 df             	movzwl %di,%ebx
   14ef1:	b8 80 00 00 00       	mov    $0x80,%eax
   14ef6:	8d 73 03             	lea    0x3(%ebx),%esi
   14ef9:	89 f2                	mov    %esi,%edx
   14efb:	ee                   	out    %al,(%dx)
   14efc:	eb 00                	jmp    14efe <change_speed+0x37>
   14efe:	eb 00                	jmp    14f00 <change_speed+0x39>
	outb_p(quot & 0xff, port);								/* LS of divisor */     // 输出因子低字节。
   14f00:	0f b6 c1             	movzbl %cl,%eax
   14f03:	89 fa                	mov    %edi,%edx
   14f05:	ee                   	out    %al,(%dx)
   14f06:	eb 00                	jmp    14f08 <change_speed+0x41>
   14f08:	eb 00                	jmp    14f0a <change_speed+0x43>
	outb_p(quot >> 8, port + 1);							/* MS of divisor */     // 输出因子高字节。
   14f0a:	0f b6 c5             	movzbl %ch,%eax
   14f0d:	8d 53 01             	lea    0x1(%ebx),%edx
   14f10:	ee                   	out    %al,(%dx)
   14f11:	eb 00                	jmp    14f13 <change_speed+0x4c>
   14f13:	eb 00                	jmp    14f15 <change_speed+0x4e>
	outb(0x03, port + 3);									/* reset DLAB */        // 复位DLAB。
   14f15:	b8 03 00 00 00       	mov    $0x3,%eax
   14f1a:	89 f2                	mov    %esi,%edx
   14f1c:	ee                   	out    %al,(%dx)
	sti();
   14f1d:	fb                   	sti    
}
   14f1e:	5b                   	pop    %ebx
   14f1f:	5e                   	pop    %esi
   14f20:	5f                   	pop    %edi
   14f21:	c3                   	ret    

00014f22 <tty_ioctl>:

// tty终端设备输入输出控制函数。
// 参数：dev - 设备号；cmd - ioctl命令；arg - 操作参数指针。
// 该函数首先根据参数给出的设备号找出对应终端的tty结构，然后根据控制命令cmd分别进行处理。
int tty_ioctl(int dev, int cmd, int arg)
{
   14f22:	55                   	push   %ebp
   14f23:	57                   	push   %edi
   14f24:	56                   	push   %esi
   14f25:	53                   	push   %ebx
   14f26:	e8 01 1b ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   14f2b:	81 c3 d5 c0 00 00    	add    $0xc0d5,%ebx
   14f31:	83 ec 3c             	sub    $0x3c,%esp
   14f34:	8b 44 24 50          	mov    0x50(%esp),%eax
   14f38:	8b 7c 24 58          	mov    0x58(%esp),%edi
   14f3c:	c7 c5 00 57 03 00    	mov    $0x35700,%ebp
	int	pgrp;

	// 首先根据设备号取得tty子设备号，从而取得终端的tty结构。若主设备号是5（控制终端），则进程的tty字段即是tty子设备
	// 号。此时如果进程的tty子设备号是负数，表明该进程没有控制终端，即不能发出该ioctl调用，于是显示出错信息并停机。如果
	// 主设备号不是5而是4,我们就可以从设备号中取出子设备号。子设备号可以是0（控制台终端）、1（串口1终端）、2（串口2终端）。
	if (MAJOR(dev) == 5) {
   14f42:	89 c2                	mov    %eax,%edx
   14f44:	0f b6 c0             	movzbl %al,%eax
   14f47:	c1 ea 08             	shr    $0x8,%edx
   14f4a:	83 fa 05             	cmp    $0x5,%edx
   14f4d:	75 2e                	jne    14f7d <tty_ioctl+0x5b>
		dev = current->tty;
   14f4f:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   14f55:	8b 00                	mov    (%eax),%eax
   14f57:	8b 80 2c 03 00 00    	mov    0x32c(%eax),%eax
		if (dev < 0)
   14f5d:	85 c0                	test   %eax,%eax
   14f5f:	79 1c                	jns    14f7d <tty_ioctl+0x5b>
			panic("tty_ioctl: dev<0");
   14f61:	8d 93 3c 88 ff ff    	lea    -0x77c4(%ebx),%edx
   14f67:	89 44 24 0c          	mov    %eax,0xc(%esp)
   14f6b:	83 ec 0c             	sub    $0xc,%esp
   14f6e:	52                   	push   %edx
   14f6f:	e8 5e 31 ff ff       	call   80d2 <panic>
   14f74:	83 c4 10             	add    $0x10,%esp
   14f77:	8b 44 24 0c          	mov    0xc(%esp),%eax
   14f7b:	eb 0b                	jmp    14f88 <tty_ioctl+0x66>
	// ioctl命令cmd进行分别处理。144行后半部分用于根据子设备号dev在tty_table[]表中选择对应的tty结构。如果dev = 0，表示
	// 正在使用前台终端，因此直接使用终端号fg_console作为tty_table[]项索引取tty结构。如果dev大于0,那么就要分两种情况考虑：
	// 1、dev是虚拟终端号；2、dev是串行终端号或者伪终端号。对于虚拟终端其tty结构在tty_table[]中索引项是dev-1（0--63）。
	// 对于其他类型终端，则它们的tty结构索引项就是dev。例如，如果dev = 64，表示是一个串行终端1,则其tty结构就是tty_table[dev]
	// 如果dev = 1，则对应终端的tty结构是tty_table[0]。
	tty = tty_table + (dev ? ((dev < 64)? dev - 1 : dev) : fg_console);
   14f7d:	85 c0                	test   %eax,%eax
   14f7f:	74 0c                	je     14f8d <tty_ioctl+0x6b>
   14f81:	83 f8 3f             	cmp    $0x3f,%eax
   14f84:	89 c6                	mov    %eax,%esi
   14f86:	7f 0d                	jg     14f95 <tty_ioctl+0x73>
   14f88:	8d 70 ff             	lea    -0x1(%eax),%esi
   14f8b:	eb 08                	jmp    14f95 <tty_ioctl+0x73>
   14f8d:	c7 c2 a0 51 02 00    	mov    $0x251a0,%edx
   14f93:	8b 32                	mov    (%edx),%esi
	switch (cmd) {
   14f95:	8b 4c 24 54          	mov    0x54(%esp),%ecx
	tty = tty_table + (dev ? ((dev < 64)? dev - 1 : dev) : fg_console);
   14f99:	c1 e6 06             	shl    $0x6,%esi
   14f9c:	01 ee                	add    %ebp,%esi
	switch (cmd) {
   14f9e:	8d 91 ff ab ff ff    	lea    -0x5401(%ecx),%edx
   14fa4:	83 fa 1a             	cmp    $0x1a,%edx
   14fa7:	0f 87 b7 02 00 00    	ja     15264 <.L47>
   14fad:	8b 8c 93 60 88 ff ff 	mov    -0x77a0(%ebx,%edx,4),%ecx
   14fb4:	01 d9                	add    %ebx,%ecx
   14fb6:	ff e1                	jmp    *%ecx

00014fb8 <.L13>:
	verify_area(termios, sizeof (*termios));
   14fb8:	50                   	push   %eax
   14fb9:	50                   	push   %eax
   14fba:	6a 24                	push   $0x24
   14fbc:	57                   	push   %edi
   14fbd:	e8 29 2c ff ff       	call   7beb <verify_area>
   14fc2:	83 c4 10             	add    $0x10,%esp
	for (i = 0 ; i < (sizeof (*termios)) ; i++)
   14fc5:	31 c0                	xor    %eax,%eax
   14fc7:	8a 14 06             	mov    (%esi,%eax,1),%dl
   14fca:	64 88 14 07          	mov    %dl,%fs:(%edi,%eax,1)
   14fce:	40                   	inc    %eax
   14fcf:	83 f8 24             	cmp    $0x24,%eax
   14fd2:	75 f3                	jne    14fc7 <.L13+0xf>
   14fd4:	eb 60                	jmp    15036 <.L68>

00014fd6 <.L16>:
		case TCGETS:
			return get_termios(tty, (struct termios *) arg);
		// 在设置termios结构信息之前，需要先等待输出队列中所有数据处理完毕，并且刷新（清空）输入队列。再接着执行下面的设置终端termios
		// 结构的操作。
		case TCSETSF:
			flush(tty->read_q); 							/* fallthrough */
   14fd6:	8b 56 34             	mov    0x34(%esi),%edx
	cli();
   14fd9:	fa                   	cli    
	queue->head = queue->tail;
   14fda:	8b 4a 08             	mov    0x8(%edx),%ecx
   14fdd:	89 4a 04             	mov    %ecx,0x4(%edx)
	sti();
   14fe0:	fb                   	sti    

00014fe1 <.L15>:
	if ((current->tty == channel) && (tty->pgrp != current->pgrp)) {
   14fe1:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
   14fe7:	8b 12                	mov    (%edx),%edx
   14fe9:	39 82 2c 03 00 00    	cmp    %eax,0x32c(%edx)
   14fef:	74 04                	je     14ff5 <.L15+0x14>
	for (i = 0 ; i < (sizeof (*termios)) ; i++)
   14ff1:	31 c0                	xor    %eax,%eax
   14ff3:	eb 2d                	jmp    15022 <.L15+0x41>
	if ((current->tty == channel) && (tty->pgrp != current->pgrp)) {
   14ff5:	8b 82 30 02 00 00    	mov    0x230(%edx),%eax
   14ffb:	39 46 24             	cmp    %eax,0x24(%esi)
   14ffe:	74 f1                	je     14ff1 <.L15+0x10>
		retsig = tty_signal(SIGTTOU, tty);
   15000:	50                   	push   %eax
   15001:	50                   	push   %eax
   15002:	56                   	push   %esi
   15003:	6a 16                	push   $0x16
   15005:	e8 4f d6 ff ff       	call   12659 <tty_signal>
		if (retsig == -ERESTARTSYS || retsig == -EINTR)
   1500a:	83 c4 10             	add    $0x10,%esp
   1500d:	3d 00 fe ff ff       	cmp    $0xfffffe00,%eax
   15012:	0f 84 51 02 00 00    	je     15269 <.L47+0x5>
   15018:	83 f8 fc             	cmp    $0xfffffffc,%eax
   1501b:	75 d4                	jne    14ff1 <.L15+0x10>
   1501d:	e9 47 02 00 00       	jmp    15269 <.L47+0x5>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   15022:	64 8a 14 07          	mov    %fs:(%edi,%eax,1),%dl
		((char *) & tty->termios)[i] = get_fs_byte(i + (char *)termios);
   15026:	88 14 06             	mov    %dl,(%esi,%eax,1)
	for (i = 0 ; i < (sizeof (*termios)) ; i++)
   15029:	40                   	inc    %eax
   1502a:	83 f8 24             	cmp    $0x24,%eax
   1502d:	75 f3                	jne    15022 <.L15+0x41>
	change_speed(tty);
   1502f:	89 f0                	mov    %esi,%eax
   15031:	e8 91 fe ff ff       	call   14ec7 <change_speed>

00015036 <.L68>:
	return 0;
   15036:	31 c0                	xor    %eax,%eax
   15038:	e9 2c 02 00 00       	jmp    15269 <.L47+0x5>

0001503d <.L17>:
	verify_area(termio, sizeof (*termio));
   1503d:	50                   	push   %eax
   1503e:	50                   	push   %eax
   1503f:	6a 12                	push   $0x12
   15041:	57                   	push   %edi
   15042:	e8 a4 2b ff ff       	call   7beb <verify_area>
	tmp_termio.c_iflag = tty->termios.c_iflag;
   15047:	8b 06                	mov    (%esi),%eax
   15049:	66 89 44 24 2e       	mov    %ax,0x2e(%esp)
	tmp_termio.c_oflag = tty->termios.c_oflag;
   1504e:	8b 46 04             	mov    0x4(%esi),%eax
   15051:	66 89 44 24 30       	mov    %ax,0x30(%esp)
	tmp_termio.c_cflag = tty->termios.c_cflag;
   15056:	8b 46 08             	mov    0x8(%esi),%eax
   15059:	66 89 44 24 32       	mov    %ax,0x32(%esp)
	tmp_termio.c_lflag = tty->termios.c_lflag;
   1505e:	8b 46 0c             	mov    0xc(%esi),%eax
   15061:	66 89 44 24 34       	mov    %ax,0x34(%esp)
	tmp_termio.c_line = tty->termios.c_line;
   15066:	8a 46 10             	mov    0x10(%esi),%al
   15069:	88 44 24 36          	mov    %al,0x36(%esp)
   1506d:	83 c4 10             	add    $0x10,%esp
	for(i = 0 ; i < NCC ; i++)
   15070:	31 c0                	xor    %eax,%eax
		tmp_termio.c_cc[i] = tty->termios.c_cc[i];
   15072:	8d 4c 24 27          	lea    0x27(%esp),%ecx
   15076:	8a 54 06 11          	mov    0x11(%esi,%eax,1),%dl
   1507a:	88 14 01             	mov    %dl,(%ecx,%eax,1)
	for(i = 0 ; i < NCC ; i++)
   1507d:	40                   	inc    %eax
   1507e:	83 f8 08             	cmp    $0x8,%eax
   15081:	75 f3                	jne    15076 <.L17+0x39>
	for (i = 0 ; i < (sizeof (*termio)) ; i++)
   15083:	31 c0                	xor    %eax,%eax
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   15085:	8a 54 04 1e          	mov    0x1e(%esp,%eax,1),%dl
   15089:	64 88 14 07          	mov    %dl,%fs:(%edi,%eax,1)
   1508d:	40                   	inc    %eax
   1508e:	83 f8 12             	cmp    $0x12,%eax
   15091:	75 f2                	jne    15085 <.L17+0x48>
   15093:	eb a1                	jmp    15036 <.L68>

00015095 <.L19>:
		case TCGETA:
			return get_termio(tty,(struct termio *) arg);
		// 在设置termio结构信息之前，需要先等待输出队列中所有数据处理完毕，并且刷新（清空）输入队列。再接着执行下面的设置终端termio
		// 结构的操作。
		case TCSETAF:
			flush(tty->read_q); 							/* fallthrough */
   15095:	8b 56 34             	mov    0x34(%esi),%edx
	cli();
   15098:	fa                   	cli    
	queue->head = queue->tail;
   15099:	8b 4a 08             	mov    0x8(%edx),%ecx
   1509c:	89 4a 04             	mov    %ecx,0x4(%edx)
	sti();
   1509f:	fb                   	sti    

000150a0 <.L18>:
	if ((current->tty == channel) && (tty->pgrp != current->pgrp)) {
   150a0:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
   150a6:	8b 12                	mov    (%edx),%edx
   150a8:	39 82 2c 03 00 00    	cmp    %eax,0x32c(%edx)
   150ae:	74 04                	je     150b4 <.L18+0x14>
	for (i = 0 ; i < (sizeof (*termio)) ; i++)
   150b0:	31 c0                	xor    %eax,%eax
   150b2:	eb 2d                	jmp    150e1 <.L18+0x41>
	if ((current->tty == channel) && (tty->pgrp != current->pgrp)) {
   150b4:	8b 82 30 02 00 00    	mov    0x230(%edx),%eax
   150ba:	39 46 24             	cmp    %eax,0x24(%esi)
   150bd:	74 f1                	je     150b0 <.L18+0x10>
		retsig = tty_signal(SIGTTOU, tty);
   150bf:	55                   	push   %ebp
   150c0:	55                   	push   %ebp
   150c1:	56                   	push   %esi
   150c2:	6a 16                	push   $0x16
   150c4:	e8 90 d5 ff ff       	call   12659 <tty_signal>
		if (retsig == -ERESTARTSYS || retsig == -EINTR)
   150c9:	83 c4 10             	add    $0x10,%esp
   150cc:	3d 00 fe ff ff       	cmp    $0xfffffe00,%eax
   150d1:	0f 84 92 01 00 00    	je     15269 <.L47+0x5>
   150d7:	83 f8 fc             	cmp    $0xfffffffc,%eax
   150da:	75 d4                	jne    150b0 <.L18+0x10>
   150dc:	e9 88 01 00 00       	jmp    15269 <.L47+0x5>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   150e1:	64 8a 14 07          	mov    %fs:(%edi,%eax,1),%dl
		((char *)&tmp_termio)[i] = get_fs_byte(i + (char *)termio);
   150e5:	88 54 04 1e          	mov    %dl,0x1e(%esp,%eax,1)
	for (i = 0 ; i< (sizeof (*termio)) ; i++)
   150e9:	40                   	inc    %eax
   150ea:	83 f8 12             	cmp    $0x12,%eax
   150ed:	75 f2                	jne    150e1 <.L18+0x41>
	*(unsigned short *)&tty->termios.c_iflag = tmp_termio.c_iflag;
   150ef:	66 8b 44 24 1e       	mov    0x1e(%esp),%ax
		tty->termios.c_cc[i] = tmp_termio.c_cc[i];
   150f4:	8d 4c 24 27          	lea    0x27(%esp),%ecx
	*(unsigned short *)&tty->termios.c_iflag = tmp_termio.c_iflag;
   150f8:	66 89 06             	mov    %ax,(%esi)
	*(unsigned short *)&tty->termios.c_oflag = tmp_termio.c_oflag;
   150fb:	8b 44 24 20          	mov    0x20(%esp),%eax
   150ff:	66 89 46 04          	mov    %ax,0x4(%esi)
	*(unsigned short *)&tty->termios.c_cflag = tmp_termio.c_cflag;
   15103:	66 8b 44 24 22       	mov    0x22(%esp),%ax
   15108:	66 89 46 08          	mov    %ax,0x8(%esi)
	*(unsigned short *)&tty->termios.c_lflag = tmp_termio.c_lflag;
   1510c:	8b 44 24 24          	mov    0x24(%esp),%eax
   15110:	66 89 46 0c          	mov    %ax,0xc(%esi)
	tty->termios.c_line = tmp_termio.c_line;
   15114:	8a 44 24 26          	mov    0x26(%esp),%al
   15118:	88 46 10             	mov    %al,0x10(%esi)
	for(i = 0 ; i < NCC ; i++)
   1511b:	31 c0                	xor    %eax,%eax
		tty->termios.c_cc[i] = tmp_termio.c_cc[i];
   1511d:	8a 14 01             	mov    (%ecx,%eax,1),%dl
   15120:	88 54 06 11          	mov    %dl,0x11(%esi,%eax,1)
	for(i = 0 ; i < NCC ; i++)
   15124:	40                   	inc    %eax
   15125:	83 f8 08             	cmp    $0x8,%eax
   15128:	75 f3                	jne    1511d <.L18+0x7d>
   1512a:	e9 00 ff ff ff       	jmp    1502f <.L15+0x4e>

0001512f <.L21>:
			return 0;
		// 开始/停止流控制。如果参数arg是TCOOFF（Terminal Control Output OFF），则挂起输出；如果是TCOON，则恢复挂起的输出。在挂
		// 起或恢复输出同时需要把写队列中的字符输出，以加快用户交互响应速度。如果arg是TCIOFF（Terminal Control Input ON），则挂起
		// 输入；如果是TCION，则重新开启挂起的输入。
		case TCXONC:
			switch (arg) {
   1512f:	83 ff 01             	cmp    $0x1,%edi
   15132:	74 26                	je     1515a <.L21+0x2b>
   15134:	7f 11                	jg     15147 <.L21+0x18>
   15136:	85 ff                	test   %edi,%edi
   15138:	0f 85 26 01 00 00    	jne    15264 <.L47>
			case TCOOFF:
				tty->stopped = 1;       					// 停止终端输出。
   1513e:	c7 46 2c 01 00 00 00 	movl   $0x1,0x2c(%esi)
   15145:	eb 1a                	jmp    15161 <.L21+0x32>
			switch (arg) {
   15147:	83 ff 02             	cmp    $0x2,%edi
   1514a:	74 21                	je     1516d <.L21+0x3e>
   1514c:	83 ff 03             	cmp    $0x3,%edi
   1514f:	0f 85 0f 01 00 00    	jne    15264 <.L47>
			case TCIOFF:
				if (STOP_CHAR(tty))
					PUTCH(STOP_CHAR(tty), tty->write_q);
				return 0;
			case TCION:
				if (START_CHAR(tty))
   15155:	8a 4e 19             	mov    0x19(%esi),%cl
   15158:	eb 16                	jmp    15170 <.L21+0x41>
				tty->stopped = 0;       					// 恢复终端输出。
   1515a:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
				tty->write(tty);
   15161:	83 ec 0c             	sub    $0xc,%esp
   15164:	56                   	push   %esi
   15165:	ff 56 30             	call   *0x30(%esi)
   15168:	e9 ef 00 00 00       	jmp    1525c <.L26+0x1b>
				if (STOP_CHAR(tty))
   1516d:	8a 4e 1a             	mov    0x1a(%esi),%cl
				if (START_CHAR(tty))
   15170:	84 c9                	test   %cl,%cl
   15172:	0f 84 be fe ff ff    	je     15036 <.L68>
					PUTCH(START_CHAR(tty), tty->write_q);
   15178:	8b 56 38             	mov    0x38(%esi),%edx
   1517b:	8b 42 04             	mov    0x4(%edx),%eax
   1517e:	88 4c 02 10          	mov    %cl,0x10(%edx,%eax,1)
   15182:	40                   	inc    %eax
   15183:	25 ff 03 00 00       	and    $0x3ff,%eax
   15188:	89 42 04             	mov    %eax,0x4(%edx)
   1518b:	e9 a6 fe ff ff       	jmp    15036 <.L68>

00015190 <.L22>:
			}
			return -EINVAL; 								/* not implemented */
		// 刷新已写输出但还没有发送、或已接收但还没有读的数据。如果参数arg是0，则刷新（清空）输入队列；如果是1，则刷新输出队列；如果
		// 2，则刷新输入和输出队列。
		case TCFLSH:
			if (arg == 0)
   15190:	85 ff                	test   %edi,%edi
   15192:	75 05                	jne    15199 <.L22+0x9>
				flush(tty->read_q);
   15194:	8b 46 34             	mov    0x34(%esi),%eax
   15197:	eb 21                	jmp    151ba <.L22+0x2a>
			else if (arg == 1)
   15199:	83 ff 01             	cmp    $0x1,%edi
   1519c:	74 19                	je     151b7 <.L22+0x27>
				flush(tty->write_q);
			else if (arg == 2) {
   1519e:	83 ff 02             	cmp    $0x2,%edi
				flush(tty->read_q);
				flush(tty->write_q);
			} else
				return -EINVAL;
   151a1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			else if (arg == 2) {
   151a6:	0f 85 bd 00 00 00    	jne    15269 <.L47+0x5>
				flush(tty->read_q);
   151ac:	8b 46 34             	mov    0x34(%esi),%eax
	cli();
   151af:	fa                   	cli    
	queue->head = queue->tail;
   151b0:	8b 50 08             	mov    0x8(%eax),%edx
   151b3:	89 50 04             	mov    %edx,0x4(%eax)
	sti();
   151b6:	fb                   	sti    
				flush(tty->write_q);
   151b7:	8b 46 38             	mov    0x38(%esi),%eax
	cli();
   151ba:	fa                   	cli    
	queue->head = queue->tail;
   151bb:	8b 50 08             	mov    0x8(%eax),%edx
   151be:	89 50 04             	mov    %edx,0x4(%eax)
	sti();
   151c1:	fb                   	sti    
   151c2:	e9 6f fe ff ff       	jmp    15036 <.L68>

000151c7 <.L23>:
		case TIOCSCTTY:
			return -EINVAL; 							/* set controlling term NI */
		// 读取终端进程组号（即读取前台进程组号）。首先验证用户缓冲区长度，然后复制终端tty的pgrp字段到用户缓冲区。此时参数arg是用户
		// 缓冲区指针。
		case TIOCGPGRP:
			verify_area((void *) arg, 4);            	// 实现库函数tcgetpgrp()。
   151c7:	51                   	push   %ecx
   151c8:	51                   	push   %ecx
   151c9:	6a 04                	push   $0x4
   151cb:	57                   	push   %edi
   151cc:	e8 1a 2a ff ff       	call   7beb <verify_area>
//// 将一长字存放在fs段中指定内存地址处.
// 参数:val - 长字值;addr - 内存地址.
// %0 - 寄存器(长字值val);%1 - (内存地址addr).
static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   151d1:	8b 46 24             	mov    0x24(%esi),%eax
   151d4:	e9 80 00 00 00       	jmp    15259 <.L26+0x18>

000151d9 <.L24>:
			return 0;
		// 设置终端进程组号pgrp（即设置前台进程组号）。此时参数arg是用户缓冲区中进程组号pgrp的指针。执行该命令的前提条件是进程必须
		// 有控制终端。如果当前进程没有控制终端，或者dev不是其控制终端，或者控制终端现在的确是正在处理的终端dev，但进程的会话号与该
		// 终端dev的会话号不同，则返回无终端错误信息。
		case TIOCSPGRP:                                 // 实现库函数tcsetpgrp()。
			if ((current->tty < 0) ||
   151d9:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
   151df:	8b 55 00             	mov    0x0(%ebp),%edx
   151e2:	8b 8a 2c 03 00 00    	mov    0x32c(%edx),%ecx
   151e8:	39 c1                	cmp    %eax,%ecx
			    (current->tty != dev) ||
			    (tty->session != current->session))
				return -ENOTTY;
   151ea:	b8 e7 ff ff ff       	mov    $0xffffffe7,%eax
			if ((current->tty < 0) ||
   151ef:	75 78                	jne    15269 <.L47+0x5>
   151f1:	85 c9                	test   %ecx,%ecx
   151f3:	78 74                	js     15269 <.L47+0x5>
			    (current->tty != dev) ||
   151f5:	8b 8a 34 02 00 00    	mov    0x234(%edx),%ecx
   151fb:	39 4e 28             	cmp    %ecx,0x28(%esi)
   151fe:	75 69                	jne    15269 <.L47+0x5>
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   15200:	64 8b 07             	mov    %fs:(%edi),%eax
   15203:	89 c7                	mov    %eax,%edi
				return -EINVAL;
   15205:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
			// 然后我们就从用户缓冲区中取得欲设置的进程号，并对该组号的有效性进行验证。如果组号pgrp小于0,则返回无效组号错误信息；如果pgrp
			// 的会话号与当前进程的不同，则返回许可错误信息。否则我们可以设置终端进程组号为pgrp。此时pgrp成为前台进程组。
			pgrp = get_fs_long((unsigned long *) arg);
			if (pgrp < 0)
   1520a:	85 ff                	test   %edi,%edi
   1520c:	78 5b                	js     15269 <.L47+0x5>
				return -EINVAL;
			if (session_of_pgrp(pgrp) != current->session)
   1520e:	83 ec 0c             	sub    $0xc,%esp
   15211:	57                   	push   %edi
   15212:	e8 e5 41 ff ff       	call   93fc <session_of_pgrp>
   15217:	8b 55 00             	mov    0x0(%ebp),%edx
   1521a:	89 c1                	mov    %eax,%ecx
   1521c:	83 c4 10             	add    $0x10,%esp
				return -EPERM;
   1521f:	83 c8 ff             	or     $0xffffffff,%eax
			if (session_of_pgrp(pgrp) != current->session)
   15222:	3b 8a 34 02 00 00    	cmp    0x234(%edx),%ecx
   15228:	75 3f                	jne    15269 <.L47+0x5>
			tty->pgrp = pgrp;
   1522a:	89 7e 24             	mov    %edi,0x24(%esi)
   1522d:	e9 04 fe ff ff       	jmp    15036 <.L68>

00015232 <.L25>:
			return 0;
		// 返回输出队列中还未送出的字符数。首先验证用户缓冲区长度，然后复制队列中字符数给用户。此时参数arg是用户缓冲区指针。
		case TIOCOUTQ:
			verify_area((void *) arg, 4);
   15232:	52                   	push   %edx
   15233:	52                   	push   %edx
   15234:	6a 04                	push   $0x4
   15236:	57                   	push   %edi
   15237:	e8 af 29 ff ff       	call   7beb <verify_area>
			put_fs_long(CHARS(tty->write_q), (unsigned long *) arg);
   1523c:	8b 56 38             	mov    0x38(%esi),%edx
   1523f:	eb 0d                	jmp    1524e <.L26+0xd>

00015241 <.L26>:
			return 0;
		// 返回输入队列中还未读取的字符数。首先验证用户缓冲区长度，然后复制队列中字符数给用户。此时参数arg是用户缓冲区指针。
		case TIOCINQ:
			verify_area((void *) arg, 4);
   15241:	50                   	push   %eax
   15242:	50                   	push   %eax
   15243:	6a 04                	push   $0x4
   15245:	57                   	push   %edi
   15246:	e8 a0 29 ff ff       	call   7beb <verify_area>
			put_fs_long(CHARS(tty->secondary),
   1524b:	8b 56 3c             	mov    0x3c(%esi),%edx
   1524e:	8b 42 04             	mov    0x4(%edx),%eax
   15251:	2b 42 08             	sub    0x8(%edx),%eax
   15254:	25 ff 03 00 00       	and    $0x3ff,%eax
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   15259:	64 89 07             	mov    %eax,%fs:(%edi)
				(unsigned long *) arg);
			return 0;
   1525c:	83 c4 10             	add    $0x10,%esp
   1525f:	e9 d2 fd ff ff       	jmp    15036 <.L68>

00015264 <.L47>:
			return -EINVAL; 							/* not implemented */   /* 未实现 */
   15264:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		case TIOCSSOFTCAR:
			return -EINVAL; 							/* not implemented */
		default:
			return -EINVAL;
        }
}
   15269:	83 c4 3c             	add    $0x3c,%esp
   1526c:	5b                   	pop    %ebx
   1526d:	5e                   	pop    %esi
   1526e:	5f                   	pop    %edi
   1526f:	5d                   	pop    %ebp
   15270:	c3                   	ret    

00015271 <pty_copy>:
#include <asm/io.h>

// 伪终端写函数。
// 参数：from - 源伪终端结构；to - 目的伪终端结构。
static inline void pty_copy(struct tty_struct * from, struct tty_struct * to)
{
   15271:	55                   	push   %ebp
   15272:	57                   	push   %edi
   15273:	89 c7                	mov    %eax,%edi
   15275:	56                   	push   %esi
   15276:	53                   	push   %ebx
   15277:	89 d6                	mov    %edx,%esi
   15279:	e8 ae 17 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1527e:	81 c3 82 bd 00 00    	add    $0xbd82,%ebx
   15284:	83 ec 1c             	sub    $0x1c,%esp
			continue;
		}
		GETCH(from->write_q, c);         					// 从源终端写队列中取一个字符，放入c，
		PUTCH(c, to->read_q);            					// 然后把c中的字符放入目的终端读队列中。
		// 判断当前进程是否有信号需要处理，如果有，则退出循环。
		if (current->signal & ~current->blocked)
   15287:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   1528d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while (!from->stopped && !EMPTY(from->write_q)) {
   15291:	83 7f 2c 00          	cmpl   $0x0,0x2c(%edi)
   15295:	74 1f                	je     152b6 <pty_copy+0x45>
			break;
	}
	copy_to_cooked(to);     								// 把读队列中的字符处理成成规范模式字符序列放入辅助队列。
   15297:	83 ec 0c             	sub    $0xc,%esp
   1529a:	56                   	push   %esi
   1529b:	e8 10 d0 ff ff       	call   122b0 <copy_to_cooked>
	wake_up(&from->write_q->proc_list);     				// 唤醒等待源终端写队列的进程，如果有。
   152a0:	8b 47 38             	mov    0x38(%edi),%eax
   152a3:	83 c0 0c             	add    $0xc,%eax
   152a6:	89 04 24             	mov    %eax,(%esp)
   152a9:	e8 e5 1b ff ff       	call   6e93 <wake_up>
}
   152ae:	83 c4 2c             	add    $0x2c,%esp
   152b1:	5b                   	pop    %ebx
   152b2:	5e                   	pop    %esi
   152b3:	5f                   	pop    %edi
   152b4:	5d                   	pop    %ebp
   152b5:	c3                   	ret    
	while (!from->stopped && !EMPTY(from->write_q)) {
   152b6:	8b 57 38             	mov    0x38(%edi),%edx
   152b9:	8b 4a 08             	mov    0x8(%edx),%ecx
   152bc:	39 4a 04             	cmp    %ecx,0x4(%edx)
   152bf:	74 d6                	je     15297 <pty_copy+0x26>
		if (FULL(to->read_q)) {
   152c1:	8b 46 34             	mov    0x34(%esi),%eax
   152c4:	89 44 24 04          	mov    %eax,0x4(%esp)
   152c8:	8b 40 04             	mov    0x4(%eax),%eax
   152cb:	89 c5                	mov    %eax,%ebp
   152cd:	89 44 24 08          	mov    %eax,0x8(%esp)
   152d1:	8b 44 24 04          	mov    0x4(%esp),%eax
   152d5:	f7 d5                	not    %ebp
   152d7:	03 68 08             	add    0x8(%eax),%ebp
   152da:	81 e5 ff 03 00 00    	and    $0x3ff,%ebp
   152e0:	75 1f                	jne    15301 <pty_copy+0x90>
			if (FULL(to->secondary))
   152e2:	8b 56 3c             	mov    0x3c(%esi),%edx
   152e5:	8b 42 08             	mov    0x8(%edx),%eax
   152e8:	48                   	dec    %eax
   152e9:	2b 42 04             	sub    0x4(%edx),%eax
   152ec:	a9 ff 03 00 00       	test   $0x3ff,%eax
   152f1:	74 a4                	je     15297 <pty_copy+0x26>
			copy_to_cooked(to);     						// 把读队列中的字符处理成成规范模式字符序列放入辅助队列。
   152f3:	83 ec 0c             	sub    $0xc,%esp
   152f6:	56                   	push   %esi
   152f7:	e8 b4 cf ff ff       	call   122b0 <copy_to_cooked>
			continue;
   152fc:	83 c4 10             	add    $0x10,%esp
   152ff:	eb 90                	jmp    15291 <pty_copy+0x20>
		GETCH(from->write_q, c);         					// 从源终端写队列中取一个字符，放入c，
   15301:	8a 44 0a 10          	mov    0x10(%edx,%ecx,1),%al
   15305:	41                   	inc    %ecx
   15306:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
   1530c:	89 4a 08             	mov    %ecx,0x8(%edx)
		PUTCH(c, to->read_q);            					// 然后把c中的字符放入目的终端读队列中。
   1530f:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   15313:	8b 54 24 04          	mov    0x4(%esp),%edx
   15317:	88 44 0a 10          	mov    %al,0x10(%edx,%ecx,1)
   1531b:	8b 44 24 04          	mov    0x4(%esp),%eax
   1531f:	8d 51 01             	lea    0x1(%ecx),%edx
   15322:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
   15328:	89 50 04             	mov    %edx,0x4(%eax)
		if (current->signal & ~current->blocked)
   1532b:	8b 44 24 0c          	mov    0xc(%esp),%eax
   1532f:	8b 10                	mov    (%eax),%edx
   15331:	8b 82 10 02 00 00    	mov    0x210(%edx),%eax
   15337:	f7 d0                	not    %eax
   15339:	85 42 0c             	test   %eax,0xc(%edx)
   1533c:	0f 84 4f ff ff ff    	je     15291 <pty_copy+0x20>
   15342:	e9 50 ff ff ff       	jmp    15297 <pty_copy+0x26>

00015347 <mpty_write>:
 * 这个函数被调用时，tty_write函数已经把一些字符放到写队列write_queue中。它将复制这些输入到它的从伪终端的
 * 输出队列中。
 */
// 主伪终端写函数。
void mpty_write(struct tty_struct * tty)
{
   15347:	53                   	push   %ebx
   15348:	e8 df 16 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1534d:	81 c3 b3 bc 00 00    	add    $0xbcb3,%ebx
   15353:	83 ec 08             	sub    $0x8,%esp
   15356:	8b 44 24 10          	mov    0x10(%esp),%eax
	int nr = tty - tty_table;       						// 获取终端号
   1535a:	89 c2                	mov    %eax,%edx
   1535c:	81 ea 00 57 03 00    	sub    $0x35700,%edx

	// 终端号除以64取整如果为2则是“主伪终端”，否则显示出错信息。
	if ((nr >> 6) != 2)
   15362:	c1 fa 0c             	sar    $0xc,%edx
   15365:	83 fa 02             	cmp    $0x2,%edx
   15368:	74 14                	je     1537e <mpty_write+0x37>
		printk("bad mpty\n\r");
   1536a:	8d 83 00 89 ff ff    	lea    -0x7700(%ebx),%eax
   15370:	83 ec 0c             	sub    $0xc,%esp
   15373:	50                   	push   %eax
   15374:	e8 a8 2d ff ff       	call   8121 <printk>
	else
		pty_copy(tty, tty + 64);   							// 调用伪终端写函数。
}
   15379:	83 c4 18             	add    $0x18,%esp
   1537c:	5b                   	pop    %ebx
   1537d:	c3                   	ret    
   1537e:	83 c4 08             	add    $0x8,%esp
		pty_copy(tty, tty + 64);   							// 调用伪终端写函数。
   15381:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
}
   15387:	5b                   	pop    %ebx
		pty_copy(tty, tty + 64);   							// 调用伪终端写函数。
   15388:	e9 e4 fe ff ff       	jmp    15271 <pty_copy>

0001538d <spty_write>:

// 从伪终端写函数。
void spty_write(struct tty_struct * tty)
{
   1538d:	53                   	push   %ebx
   1538e:	e8 99 16 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   15393:	81 c3 6d bc 00 00    	add    $0xbc6d,%ebx
   15399:	83 ec 08             	sub    $0x8,%esp
   1539c:	8b 44 24 10          	mov    0x10(%esp),%eax
	int nr = tty - tty_table;       						// 获取终端号
   153a0:	89 c2                	mov    %eax,%edx
   153a2:	81 ea 00 57 03 00    	sub    $0x35700,%edx

	// 终端号除以64取整如果为3则是“从伪终端”，否则显示出错信息。
	if ((nr >> 6) != 3)
   153a8:	c1 fa 0c             	sar    $0xc,%edx
   153ab:	83 fa 03             	cmp    $0x3,%edx
   153ae:	74 14                	je     153c4 <spty_write+0x37>
		printk("bad spty\n\r");
   153b0:	8d 83 0b 89 ff ff    	lea    -0x76f5(%ebx),%eax
   153b6:	83 ec 0c             	sub    $0xc,%esp
   153b9:	50                   	push   %eax
   153ba:	e8 62 2d ff ff       	call   8121 <printk>
	else
		pty_copy(tty, tty - 64);   							// 调用伪终端写函数。
}
   153bf:	83 c4 18             	add    $0x18,%esp
   153c2:	5b                   	pop    %ebx
   153c3:	c3                   	ret    
   153c4:	83 c4 08             	add    $0x8,%esp
		pty_copy(tty, tty - 64);   							// 调用伪终端写函数。
   153c7:	8d 90 00 f0 ff ff    	lea    -0x1000(%eax),%edx
}
   153cd:	5b                   	pop    %ebx
		pty_copy(tty, tty - 64);   							// 调用伪终端写函数。
   153ce:	e9 9e fe ff ff       	jmp    15271 <pty_copy>

000153d3 <fpop>:
}

// 累加器栈弹出操作。
// 将状态字TOP字段值加1，并以7取模。
static void fpop(void)
{
   153d3:	e8 a2 4a ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   153d8:	05 28 bc 00 00       	add    $0xbc28,%eax
	unsigned long tmp;

	tmp = I387.swd & 0xffffc7ff;
   153dd:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   153e3:	8b 08                	mov    (%eax),%ecx
   153e5:	8b 91 1c 04 00 00    	mov    0x41c(%ecx),%edx
	I387.swd += 0x00000800;
   153eb:	8d 82 00 08 00 00    	lea    0x800(%edx),%eax
	tmp = I387.swd & 0xffffc7ff;
   153f1:	80 e6 c7             	and    $0xc7,%dh
	I387.swd &= 0x00003800;
   153f4:	25 00 38 00 00       	and    $0x3800,%eax
	I387.swd |= tmp;
   153f9:	09 d0                	or     %edx,%eax
   153fb:	89 81 1c 04 00 00    	mov    %eax,0x41c(%ecx)
}
   15401:	c3                   	ret    

00015402 <fpush>:

// 累加器栈入栈操作。
// 将状态字TOP字段减1（即加7），并以7取模。
static void fpush(void)
{
   15402:	e8 73 4a ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   15407:	05 f9 bb 00 00       	add    $0xbbf9,%eax
	unsigned long tmp;

	tmp = I387.swd & 0xffffc7ff;
   1540c:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   15412:	8b 08                	mov    (%eax),%ecx
   15414:	8b 91 1c 04 00 00    	mov    0x41c(%ecx),%edx
	I387.swd += 0x00003800;
   1541a:	8d 82 00 38 00 00    	lea    0x3800(%edx),%eax
	tmp = I387.swd & 0xffffc7ff;
   15420:	80 e6 c7             	and    $0xc7,%dh
	I387.swd &= 0x00003800;
   15423:	25 00 38 00 00       	and    $0x3800,%eax
	I387.swd |= tmp;
   15428:	09 d0                	or     %edx,%eax
   1542a:	89 81 1c 04 00 00    	mov    %eax,0x41c(%ecx)
}
   15430:	c3                   	ret    

00015431 <__st>:
}

// 取ST(i)的内存指针。
// 取状态字中TOP字段值。加上指定的物理数据寄存器号并取模，最后返回ST(i)对应的指针。
static temp_real_unaligned * __st(int i)
{
   15431:	e8 f2 15 ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
   15436:	81 c2 ca bb 00 00    	add    $0xbbca,%edx
	i += I387.swd >> 11;            // 取状态字中TOP字段值。
   1543c:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
   15442:	8b 0a                	mov    (%edx),%ecx
   15444:	8b 91 1c 04 00 00    	mov    0x41c(%ecx),%edx
   1544a:	c1 fa 0b             	sar    $0xb,%edx
   1544d:	01 d0                	add    %edx,%eax
	i &= 7;
   1544f:	83 e0 07             	and    $0x7,%eax
	return (temp_real_unaligned *) (i*10 + (char *)(I387.st_space));
   15452:	6b c0 0a             	imul   $0xa,%eax,%eax
   15455:	8d 84 01 34 04 00 00 	lea    0x434(%ecx,%eax,1),%eax
   1545c:	c3                   	ret    

0001545d <__math_abort>:
{
   1545d:	e8 c6 15 ff ff       	call   6a28 <__x86.get_pc_thunk.dx>
   15462:	81 c2 9e bb 00 00    	add    $0xbb9e,%edx
   15468:	8b 44 24 04          	mov    0x4(%esp),%eax
	current->signal |= signal;
   1546c:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
	EIP = ORIG_EIP;
   15472:	8b 48 04             	mov    0x4(%eax),%ecx
	current->signal |= signal;
   15475:	8b 12                	mov    (%edx),%edx
	EIP = ORIG_EIP;
   15477:	89 48 38             	mov    %ecx,0x38(%eax)
	current->signal |= signal;
   1547a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
   1547e:	09 4a 0c             	or     %ecx,0xc(%edx)
	__asm__("movl %0,%%esp ; ret"::"g" ((long) info));
   15481:	89 c4                	mov    %eax,%esp
   15483:	c3                   	ret    
}
   15484:	c3                   	ret    

00015485 <math_emulate>:
{
   15485:	55                   	push   %ebp
   15486:	57                   	push   %edi
   15487:	56                   	push   %esi
   15488:	53                   	push   %ebx
   15489:	e8 9e 15 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1548e:	81 c3 72 bb 00 00    	add    $0xbb72,%ebx
   15494:	83 ec 2c             	sub    $0x2c,%esp
	if (!current->used_math) {
   15497:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
   1549d:	8b 45 00             	mov    0x0(%ebp),%eax
   154a0:	66 83 b8 28 03 00 00 	cmpw   $0x0,0x328(%eax)
   154a7:	00 
   154a8:	75 27                	jne    154d1 <math_emulate+0x4c>
		current->used_math = 1;
   154aa:	66 c7 80 28 03 00 00 	movw   $0x1,0x328(%eax)
   154b1:	01 00 
		I387.cwd = 0x037f;
   154b3:	c7 80 18 04 00 00 7f 	movl   $0x37f,0x418(%eax)
   154ba:	03 00 00 
		I387.swd = 0x0000;
   154bd:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
   154c4:	00 00 00 
		I387.twd = 0x0000;
   154c7:	c7 80 20 04 00 00 00 	movl   $0x0,0x420(%eax)
   154ce:	00 00 00 
	if (I387.cwd & I387.swd & 0x3f)
   154d1:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
   154d7:	8b b0 18 04 00 00    	mov    0x418(%eax),%esi
		I387.swd |= 0x8000;             // 设置忙标志B。
   154dd:	89 d1                	mov    %edx,%ecx
	if (I387.cwd & I387.swd & 0x3f)
   154df:	21 d6                	and    %edx,%esi
		I387.swd |= 0x8000;             // 设置忙标志B。
   154e1:	80 ce 80             	or     $0x80,%dh
   154e4:	81 e1 ff 7f 00 00    	and    $0x7fff,%ecx
   154ea:	83 e6 3f             	and    $0x3f,%esi
   154ed:	0f 44 d1             	cmove  %ecx,%edx
   154f0:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)
	if (CS != 0x000F) {                     // 不是用户代码则停机。
   154f6:	0f b7 44 24 78       	movzwl 0x78(%esp),%eax
	ORIG_EIP = EIP;                         // 保存浮点指令指针。
   154fb:	8b 54 24 74          	mov    0x74(%esp),%edx
	if (CS != 0x000F) {                     // 不是用户代码则停机。
   154ff:	66 83 f8 0f          	cmp    $0xf,%ax
	ORIG_EIP = EIP;                         // 保存浮点指令指针。
   15503:	89 54 24 40          	mov    %edx,0x40(%esp)
	if (CS != 0x000F) {                     // 不是用户代码则停机。
   15507:	74 20                	je     15529 <math_emulate+0xa4>
		printk("math_emulate: %04x:%08x\n\r",CS,EIP);
   15509:	56                   	push   %esi
   1550a:	52                   	push   %edx
   1550b:	50                   	push   %eax
   1550c:	8d 83 16 89 ff ff    	lea    -0x76ea(%ebx),%eax
   15512:	50                   	push   %eax
   15513:	e8 09 2c ff ff       	call   8121 <printk>
		panic("Math emulation needed in kernel");
   15518:	8d 83 30 89 ff ff    	lea    -0x76d0(%ebx),%eax
   1551e:	89 04 24             	mov    %eax,(%esp)
   15521:	e8 ac 2b ff ff       	call   80d2 <panic>
   15526:	83 c4 10             	add    $0x10,%esp
	code = get_fs_word((unsigned short *) EIP);     // 取2字节的浮点指令或操作数。
   15529:	8b 4c 24 74          	mov    0x74(%esp),%ecx
	*(unsigned short *) &I387.fcs = CS;             // 保存代码段选择符。
   1552d:	8b 74 24 78          	mov    0x78(%esp),%esi
// 返回:返回内存fs:[addr]处的字.
static inline unsigned short get_fs_word(const unsigned short *addr)
{
	unsigned short _v;

	__asm__ ("movw %%fs:%1,%0":"=q" (_v):"m" (*addr));
   15531:	64 66 8b 01          	mov    %fs:(%ecx),%ax
	bswapw(code);                                   // 交换高低字节。
   15535:	86 c4                	xchg   %al,%ah
	code &= 0x7ff;                                  // 屏蔽代码中的ESC码。
   15537:	89 c2                	mov    %eax,%edx
	bswapw(code);                                   // 交换高低字节。
   15539:	89 c7                	mov    %eax,%edi
	I387.fip = EIP;                                 // 保存指令指针。
   1553b:	8b 45 00             	mov    0x0(%ebp),%eax
	code &= 0x7ff;                                  // 屏蔽代码中的ESC码。
   1553e:	66 81 e2 ff 07       	and    $0x7ff,%dx
	I387.fip = EIP;                                 // 保存指令指针。
   15543:	89 88 24 04 00 00    	mov    %ecx,0x424(%eax)
	EIP += 2;                                       // 指令指针指向下一个字节。
   15549:	83 c1 02             	add    $0x2,%ecx
        switch (code) {
   1554c:	66 81 fa eb 01       	cmp    $0x1eb,%dx
	*(unsigned short *) &I387.fcs = CS;             // 保存代码段选择符。
   15551:	66 89 b0 28 04 00 00 	mov    %si,0x428(%eax)
	*(1+(unsigned short *) &I387.fcs) = code;       // 保存代码。
   15558:	66 89 90 2a 04 00 00 	mov    %dx,0x42a(%eax)
        switch (code) {
   1555f:	0f b7 f2             	movzwl %dx,%esi
	EIP += 2;                                       // 指令指针指向下一个字节。
   15562:	89 4c 24 74          	mov    %ecx,0x74(%esp)
        switch (code) {
   15566:	0f 84 26 02 00 00    	je     15792 <math_emulate+0x30d>
   1556c:	0f 87 b9 00 00 00    	ja     1562b <math_emulate+0x1a6>
   15572:	66 81 fa e3 01       	cmp    $0x1e3,%dx
   15577:	77 4f                	ja     155c8 <math_emulate+0x143>
   15579:	66 81 fa e2 01       	cmp    $0x1e2,%dx
   1557e:	0f 83 8f 01 00 00    	jae    15713 <math_emulate+0x28e>
   15584:	66 81 fa d7 01       	cmp    $0x1d7,%dx
   15589:	77 15                	ja     155a0 <math_emulate+0x11b>
   1558b:	66 81 fa d1 01       	cmp    $0x1d1,%dx
   15590:	0f 83 5a 01 00 00    	jae    156f0 <math_emulate+0x26b>
   15596:	66 81 fa d0 01       	cmp    $0x1d0,%dx
   1559b:	e9 45 01 00 00       	jmp    156e5 <math_emulate+0x260>
   155a0:	66 81 fa e0 01       	cmp    $0x1e0,%dx
   155a5:	0f 84 56 01 00 00    	je     15701 <math_emulate+0x27c>
   155ab:	66 81 fa e1 01       	cmp    $0x1e1,%dx
   155b0:	0f 85 c0 02 00 00    	jne    15876 <math_emulate+0x3f1>
			ST(0).exponent &= 0x7fff;
   155b6:	31 c0                	xor    %eax,%eax
   155b8:	e8 74 fe ff ff       	call   15431 <__st>
   155bd:	66 81 60 08 ff 7f    	andw   $0x7fff,0x8(%eax)
   155c3:	e9 d5 0d 00 00       	jmp    1639d <.L130+0x99>
        switch (code) {
   155c8:	66 81 fa e7 01       	cmp    $0x1e7,%dx
   155cd:	77 46                	ja     15615 <math_emulate+0x190>
   155cf:	66 81 fa e6 01       	cmp    $0x1e6,%dx
   155d4:	0f 83 5f 01 00 00    	jae    15739 <math_emulate+0x2b4>
   155da:	66 81 fa e4 01       	cmp    $0x1e4,%dx
   155df:	0f 84 3f 01 00 00    	je     15724 <math_emulate+0x29f>
   155e5:	66 81 fa e5 01       	cmp    $0x1e5,%dx
   155ea:	0f 85 86 02 00 00    	jne    15876 <math_emulate+0x3f1>
			printk("fxam not implemented\n\r");     // 未实现。发信号退出。
   155f0:	8d 83 50 89 ff ff    	lea    -0x76b0(%ebx),%eax
   155f6:	83 ec 0c             	sub    $0xc,%esp
   155f9:	50                   	push   %eax
   155fa:	e8 22 2b ff ff       	call   8121 <printk>
			math_abort(info,1<<(SIGILL-1));
   155ff:	58                   	pop    %eax
   15600:	5a                   	pop    %edx
   15601:	6a 08                	push   $0x8
   15603:	8d 44 24 48          	lea    0x48(%esp),%eax
   15607:	50                   	push   %eax
   15608:	e8 50 fe ff ff       	call   1545d <__math_abort>
   1560d:	83 c4 10             	add    $0x10,%esp
   15610:	e9 24 01 00 00       	jmp    15739 <math_emulate+0x2b4>
        switch (code) {
   15615:	66 81 fa e9 01       	cmp    $0x1e9,%dx
   1561a:	0f 84 3e 01 00 00    	je     1575e <math_emulate+0x2d9>
   15620:	0f 86 24 01 00 00    	jbe    1574a <math_emulate+0x2c5>
   15626:	e9 53 01 00 00       	jmp    1577e <math_emulate+0x2f9>
   1562b:	66 81 fa e9 02       	cmp    $0x2e9,%dx
   15630:	0f 84 d9 01 00 00    	je     1580f <math_emulate+0x38a>
   15636:	77 55                	ja     1568d <math_emulate+0x208>
   15638:	66 81 fa ee 01       	cmp    $0x1ee,%dx
   1563d:	0f 84 77 01 00 00    	je     157ba <math_emulate+0x335>
   15643:	77 2d                	ja     15672 <math_emulate+0x1ed>
   15645:	66 81 fa ec 01       	cmp    $0x1ec,%dx
   1564a:	0f 84 56 01 00 00    	je     157a6 <math_emulate+0x321>
   15650:	66 81 fa ed 01       	cmp    $0x1ed,%dx
   15655:	0f 85 1b 02 00 00    	jne    15876 <math_emulate+0x3f1>
			fpush();
   1565b:	e8 a2 fd ff ff       	call   15402 <fpush>
			ST(0) = CONSTLN2;
   15660:	31 c0                	xor    %eax,%eax
   15662:	8d b3 ec 89 ff ff    	lea    -0x7614(%ebx),%esi
   15668:	e8 c4 fd ff ff       	call   15431 <__st>
   1566d:	e9 fe 00 00 00       	jmp    15770 <math_emulate+0x2eb>
        switch (code) {
   15672:	66 81 fa ef 01       	cmp    $0x1ef,%dx
   15677:	0f 84 5b 01 00 00    	je     157d8 <math_emulate+0x353>
   1567d:	66 81 fa ff 01       	cmp    $0x1ff,%dx
   15682:	0f 86 61 01 00 00    	jbe    157e9 <math_emulate+0x364>
   15688:	e9 e9 01 00 00       	jmp    15876 <math_emulate+0x3f1>
   1568d:	66 81 fa e3 03       	cmp    $0x3e3,%dx
   15692:	0f 84 95 01 00 00    	je     1582d <math_emulate+0x3a8>
   15698:	77 30                	ja     156ca <math_emulate+0x245>
   1569a:	66 81 fa d0 03       	cmp    $0x3d0,%dx
   1569f:	0f 82 d1 01 00 00    	jb     15876 <math_emulate+0x3f1>
   156a5:	66 81 fa d1 03       	cmp    $0x3d1,%dx
   156aa:	0f 86 ed 0c 00 00    	jbe    1639d <.L130+0x99>
   156b0:	66 81 fa e2 03       	cmp    $0x3e2,%dx
   156b5:	0f 85 bb 01 00 00    	jne    15876 <math_emulate+0x3f1>
			I387.swd &= 0x7f00;
   156bb:	81 a0 1c 04 00 00 00 	andl   $0x7f00,0x41c(%eax)
   156c2:	7f 00 00 
   156c5:	e9 d3 0c 00 00       	jmp    1639d <.L130+0x99>
        switch (code) {
   156ca:	66 81 fa d9 06       	cmp    $0x6d9,%dx
   156cf:	0f 84 7b 01 00 00    	je     15850 <math_emulate+0x3cb>
   156d5:	66 81 fa e0 07       	cmp    $0x7e0,%dx
   156da:	0f 84 bd 0c 00 00    	je     1639d <.L130+0x99>
   156e0:	66 81 fa e4 03       	cmp    $0x3e4,%dx
   156e5:	0f 84 b2 0c 00 00    	je     1639d <.L130+0x99>
   156eb:	e9 86 01 00 00       	jmp    15876 <math_emulate+0x3f1>
			math_abort(info,1<<(SIGILL-1));
   156f0:	53                   	push   %ebx
   156f1:	53                   	push   %ebx
   156f2:	6a 08                	push   $0x8
   156f4:	8d 44 24 48          	lea    0x48(%esp),%eax
   156f8:	50                   	push   %eax
   156f9:	e8 5f fd ff ff       	call   1545d <__math_abort>
   156fe:	83 c4 10             	add    $0x10,%esp
			ST(0).exponent ^= 0x8000;
   15701:	31 c0                	xor    %eax,%eax
   15703:	e8 29 fd ff ff       	call   15431 <__st>
   15708:	66 81 40 08 00 80    	addw   $0x8000,0x8(%eax)
   1570e:	e9 8a 0c 00 00       	jmp    1639d <.L130+0x99>
			math_abort(info,1<<(SIGILL-1));
   15713:	51                   	push   %ecx
   15714:	51                   	push   %ecx
   15715:	6a 08                	push   $0x8
   15717:	8d 44 24 48          	lea    0x48(%esp),%eax
   1571b:	50                   	push   %eax
   1571c:	e8 3c fd ff ff       	call   1545d <__math_abort>
   15721:	83 c4 10             	add    $0x10,%esp
			ftst(PST(0));
   15724:	31 c0                	xor    %eax,%eax
   15726:	e8 06 fd ff ff       	call   15431 <__st>
   1572b:	83 ec 0c             	sub    $0xc,%esp
   1572e:	50                   	push   %eax
   1572f:	e8 57 17 00 00       	call   16e8b <ftst>
   15734:	e9 61 0c 00 00       	jmp    1639a <.L130+0x96>
			math_abort(info,1<<(SIGILL-1));
   15739:	50                   	push   %eax
   1573a:	50                   	push   %eax
   1573b:	6a 08                	push   $0x8
   1573d:	8d 44 24 48          	lea    0x48(%esp),%eax
   15741:	50                   	push   %eax
   15742:	e8 16 fd ff ff       	call   1545d <__math_abort>
   15747:	83 c4 10             	add    $0x10,%esp
			fpush();
   1574a:	e8 b3 fc ff ff       	call   15402 <fpush>
			ST(0) = CONST1;
   1574f:	31 c0                	xor    %eax,%eax
   15751:	8d b3 f8 89 ff ff    	lea    -0x7608(%ebx),%esi
   15757:	e8 d5 fc ff ff       	call   15431 <__st>
   1575c:	eb 12                	jmp    15770 <math_emulate+0x2eb>
			ST(0) = CONSTL2T;
   1575e:	8d b3 04 8a ff ff    	lea    -0x75fc(%ebx),%esi
			fpush();
   15764:	e8 99 fc ff ff       	call   15402 <fpush>
			ST(0) = CONSTL2T;
   15769:	31 c0                	xor    %eax,%eax
   1576b:	e8 c1 fc ff ff       	call   15431 <__st>
   15770:	b9 0a 00 00 00       	mov    $0xa,%ecx
   15775:	89 c7                	mov    %eax,%edi
   15777:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
   15779:	e9 1f 0c 00 00       	jmp    1639d <.L130+0x99>
			fpush();
   1577e:	e8 7f fc ff ff       	call   15402 <fpush>
			ST(0) = CONSTL2E;
   15783:	31 c0                	xor    %eax,%eax
   15785:	8d b3 10 8a ff ff    	lea    -0x75f0(%ebx),%esi
   1578b:	e8 a1 fc ff ff       	call   15431 <__st>
   15790:	eb de                	jmp    15770 <math_emulate+0x2eb>
			fpush();
   15792:	e8 6b fc ff ff       	call   15402 <fpush>
			ST(0) = CONSTPI;
   15797:	31 c0                	xor    %eax,%eax
   15799:	8d b3 1c 8a ff ff    	lea    -0x75e4(%ebx),%esi
   1579f:	e8 8d fc ff ff       	call   15431 <__st>
   157a4:	eb ca                	jmp    15770 <math_emulate+0x2eb>
			fpush();
   157a6:	e8 57 fc ff ff       	call   15402 <fpush>
			ST(0) = CONSTLG2;
   157ab:	31 c0                	xor    %eax,%eax
   157ad:	8d b3 28 8a ff ff    	lea    -0x75d8(%ebx),%esi
   157b3:	e8 79 fc ff ff       	call   15431 <__st>
   157b8:	eb b6                	jmp    15770 <math_emulate+0x2eb>
			fpush();
   157ba:	e8 43 fc ff ff       	call   15402 <fpush>
			ST(0) = CONSTZ;
   157bf:	31 c0                	xor    %eax,%eax
   157c1:	e8 6b fc ff ff       	call   15431 <__st>
   157c6:	89 c2                	mov    %eax,%edx
   157c8:	b9 0a 00 00 00       	mov    $0xa,%ecx
   157cd:	31 c0                	xor    %eax,%eax
   157cf:	89 d7                	mov    %edx,%edi
   157d1:	f3 aa                	rep stos %al,%es:(%edi)
   157d3:	e9 c5 0b 00 00       	jmp    1639d <.L130+0x99>
			math_abort(info,1<<(SIGILL-1));
   157d8:	55                   	push   %ebp
   157d9:	55                   	push   %ebp
   157da:	6a 08                	push   $0x8
   157dc:	8d 44 24 48          	lea    0x48(%esp),%eax
   157e0:	50                   	push   %eax
   157e1:	e8 77 fc ff ff       	call   1545d <__math_abort>
   157e6:	83 c4 10             	add    $0x10,%esp
			printk("%04x fxxx not implemented\n\r",code + 0xc800);
   157e9:	8d 83 67 89 ff ff    	lea    -0x7699(%ebx),%eax
   157ef:	81 c6 00 c8 00 00    	add    $0xc800,%esi
   157f5:	51                   	push   %ecx
   157f6:	51                   	push   %ecx
   157f7:	56                   	push   %esi
   157f8:	50                   	push   %eax
   157f9:	e8 23 29 ff ff       	call   8121 <printk>
			math_abort(info,1<<(SIGILL-1));
   157fe:	5e                   	pop    %esi
   157ff:	5f                   	pop    %edi
   15800:	6a 08                	push   $0x8
   15802:	8d 44 24 48          	lea    0x48(%esp),%eax
   15806:	50                   	push   %eax
   15807:	e8 51 fc ff ff       	call   1545d <__math_abort>
   1580c:	83 c4 10             	add    $0x10,%esp
			fucom(PST(1),PST(0));
   1580f:	31 c0                	xor    %eax,%eax
   15811:	e8 1b fc ff ff       	call   15431 <__st>
   15816:	89 c6                	mov    %eax,%esi
   15818:	b8 01 00 00 00       	mov    $0x1,%eax
   1581d:	e8 0f fc ff ff       	call   15431 <__st>
   15822:	52                   	push   %edx
   15823:	52                   	push   %edx
   15824:	56                   	push   %esi
   15825:	50                   	push   %eax
   15826:	e8 25 17 00 00       	call   16f50 <fucom>
   1582b:	eb 3f                	jmp    1586c <math_emulate+0x3e7>
			I387.cwd = 0x037f;
   1582d:	c7 80 18 04 00 00 7f 	movl   $0x37f,0x418(%eax)
   15834:	03 00 00 
			I387.swd = 0x0000;
   15837:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
   1583e:	00 00 00 
			I387.twd = 0x0000;
   15841:	c7 80 20 04 00 00 00 	movl   $0x0,0x420(%eax)
   15848:	00 00 00 
   1584b:	e9 4d 0b 00 00       	jmp    1639d <.L130+0x99>
			fcom(PST(1),PST(0));
   15850:	31 c0                	xor    %eax,%eax
   15852:	e8 da fb ff ff       	call   15431 <__st>
   15857:	89 c6                	mov    %eax,%esi
   15859:	b8 01 00 00 00       	mov    $0x1,%eax
   1585e:	e8 ce fb ff ff       	call   15431 <__st>
   15863:	55                   	push   %ebp
   15864:	55                   	push   %ebp
   15865:	56                   	push   %esi
   15866:	50                   	push   %eax
   15867:	e8 9e 16 00 00       	call   16f0a <fcom>
			fpop(); fpop();
   1586c:	e8 62 fb ff ff       	call   153d3 <fpop>
   15871:	e9 51 0a 00 00       	jmp    162c7 <.L126+0x10>
	switch (code >> 3) {
   15876:	89 d0                	mov    %edx,%eax
   15878:	66 c1 e8 03          	shr    $0x3,%ax
   1587c:	66 3d 9e 00          	cmp    $0x9e,%ax
   15880:	0f 84 b3 03 00 00    	je     15c39 <math_emulate+0x7b4>
   15886:	0f 87 ff 00 00 00    	ja     1598b <math_emulate+0x506>
   1588c:	66 83 f8 38          	cmp    $0x38,%ax
   15890:	0f 84 ff 02 00 00    	je     15b95 <math_emulate+0x710>
   15896:	77 62                	ja     158fa <math_emulate+0x475>
   15898:	66 83 f8 1b          	cmp    $0x1b,%ax
   1589c:	0f 84 36 02 00 00    	je     15ad8 <math_emulate+0x653>
   158a2:	77 1f                	ja     158c3 <math_emulate+0x43e>
   158a4:	66 83 f8 19          	cmp    $0x19,%ax
   158a8:	0f 84 ee 01 00 00    	je     15a9c <math_emulate+0x617>
   158ae:	0f 87 08 02 00 00    	ja     15abc <math_emulate+0x637>
   158b4:	66 83 f8 18          	cmp    $0x18,%ax
   158b8:	0f 84 9d 02 00 00    	je     15b5b <math_emulate+0x6d6>
   158be:	e9 9b 05 00 00       	jmp    15e5e <math_emulate+0x9d9>
   158c3:	66 83 f8 1d          	cmp    $0x1d,%ax
   158c7:	0f 84 81 02 00 00    	je     15b4e <math_emulate+0x6c9>
   158cd:	0f 82 37 02 00 00    	jb     15b0a <math_emulate+0x685>
   158d3:	66 83 f8 1e          	cmp    $0x1e,%ax
   158d7:	0f 84 9a 02 00 00    	je     15b77 <math_emulate+0x6f2>
   158dd:	66 83 f8 1f          	cmp    $0x1f,%ax
   158e1:	0f 85 77 05 00 00    	jne    15e5e <math_emulate+0x9d9>
			fdiv(PST(code & 7),PST(0),&tmp);
   158e7:	31 c0                	xor    %eax,%eax
   158e9:	e8 43 fb ff ff       	call   15431 <__st>
   158ee:	89 c6                	mov    %eax,%esi
   158f0:	89 f8                	mov    %edi,%eax
   158f2:	83 e0 07             	and    $0x7,%eax
   158f5:	e9 8b 02 00 00       	jmp    15b85 <math_emulate+0x700>
	switch (code >> 3) {
   158fa:	66 3d 99 00          	cmp    $0x99,%ax
   158fe:	0f 84 af 02 00 00    	je     15bb3 <math_emulate+0x72e>
   15904:	77 23                	ja     15929 <math_emulate+0x4a4>
   15906:	66 83 f8 3b          	cmp    $0x3b,%ax
   1590a:	0f 84 28 05 00 00    	je     15e38 <math_emulate+0x9b3>
   15910:	66 3d 98 00          	cmp    $0x98,%ax
   15914:	0f 84 94 02 00 00    	je     15bae <math_emulate+0x729>
   1591a:	66 83 f8 39          	cmp    $0x39,%ax
   1591e:	0f 85 3a 05 00 00    	jne    15e5e <math_emulate+0x9d9>
   15924:	e9 aa 04 00 00       	jmp    15dd3 <math_emulate+0x94e>
   15929:	66 3d 9b 00          	cmp    $0x9b,%ax
   1592d:	0f 84 21 04 00 00    	je     15d54 <math_emulate+0x8cf>
   15933:	0f 82 b5 02 00 00    	jb     15bee <math_emulate+0x769>
   15939:	66 3d 9c 00          	cmp    $0x9c,%ax
   1593d:	0f 84 c7 02 00 00    	je     15c0a <math_emulate+0x785>
   15943:	66 3d 9d 00          	cmp    $0x9d,%ax
   15947:	0f 85 11 05 00 00    	jne    15e5e <math_emulate+0x9d9>
			real_to_real(&ST(0),&tmp);
   1594d:	31 c0                	xor    %eax,%eax
			fadd(PST(code & 7),&tmp,&tmp);
   1594f:	83 e7 07             	and    $0x7,%edi
			real_to_real(&ST(0),&tmp);
   15952:	e8 da fa ff ff       	call   15431 <__st>
   15957:	8b 50 04             	mov    0x4(%eax),%edx
   1595a:	8b 00                	mov    (%eax),%eax
   1595c:	89 44 24 14          	mov    %eax,0x14(%esp)
   15960:	31 c0                	xor    %eax,%eax
   15962:	89 54 24 18          	mov    %edx,0x18(%esp)
   15966:	e8 c6 fa ff ff       	call   15431 <__st>
			tmp.exponent ^= 0x8000;
   1596b:	66 8b 40 08          	mov    0x8(%eax),%ax
   1596f:	66 05 00 80          	add    $0x8000,%ax
   15973:	66 89 44 24 1c       	mov    %ax,0x1c(%esp)
			fadd(PST(code & 7),&tmp,&tmp);
   15978:	89 f8                	mov    %edi,%eax
   1597a:	e8 b2 fa ff ff       	call   15431 <__st>
   1597f:	51                   	push   %ecx
   15980:	8d 54 24 18          	lea    0x18(%esp),%edx
   15984:	52                   	push   %edx
   15985:	52                   	push   %edx
   15986:	e9 a6 02 00 00       	jmp    15c31 <math_emulate+0x7ac>
	switch (code >> 3) {
   1598b:	66 3d d9 00          	cmp    $0xd9,%ax
   1598f:	0f 84 9d 03 00 00    	je     15d32 <math_emulate+0x8ad>
   15995:	77 70                	ja     15a07 <math_emulate+0x582>
   15997:	66 3d ba 00          	cmp    $0xba,%ax
   1599b:	0f 84 e2 02 00 00    	je     15c83 <math_emulate+0x7fe>
   159a1:	77 2d                	ja     159d0 <math_emulate+0x54b>
   159a3:	66 3d b8 00          	cmp    $0xb8,%ax
   159a7:	0f 84 b1 02 00 00    	je     15c5e <math_emulate+0x7d9>
   159ad:	0f 87 20 04 00 00    	ja     15dd3 <math_emulate+0x94e>
   159b3:	66 3d 9f 00          	cmp    $0x9f,%ax
   159b7:	0f 85 a1 04 00 00    	jne    15e5e <math_emulate+0x9d9>
			fdiv(PST(code & 7),PST(0),&tmp);
   159bd:	31 c0                	xor    %eax,%eax
   159bf:	83 e7 07             	and    $0x7,%edi
   159c2:	e8 6a fa ff ff       	call   15431 <__st>
   159c7:	89 c6                	mov    %eax,%esi
   159c9:	89 f8                	mov    %edi,%eax
   159cb:	e9 77 02 00 00       	jmp    15c47 <math_emulate+0x7c2>
	switch (code >> 3) {
   159d0:	66 3d bc 00          	cmp    $0xbc,%ax
   159d4:	0f 84 c1 02 00 00    	je     15c9b <math_emulate+0x816>
   159da:	0f 82 58 04 00 00    	jb     15e38 <math_emulate+0x9b3>
   159e0:	66 3d bd 00          	cmp    $0xbd,%ax
   159e4:	0f 84 d2 02 00 00    	je     15cbc <math_emulate+0x837>
   159ea:	66 3d d8 00          	cmp    $0xd8,%ax
   159ee:	0f 85 6a 04 00 00    	jne    15e5e <math_emulate+0x9d9>
			fadd(PST(code & 7),PST(0),&tmp);
   159f4:	31 c0                	xor    %eax,%eax
   159f6:	83 e7 07             	and    $0x7,%edi
   159f9:	e8 33 fa ff ff       	call   15431 <__st>
   159fe:	89 c6                	mov    %eax,%esi
   15a00:	89 f8                	mov    %edi,%eax
   15a02:	e9 f1 02 00 00       	jmp    15cf8 <math_emulate+0x873>
	switch (code >> 3) {
   15a07:	66 3d df 00          	cmp    $0xdf,%ax
   15a0b:	0f 84 9d 03 00 00    	je     15dae <math_emulate+0x929>
   15a11:	77 42                	ja     15a55 <math_emulate+0x5d0>
   15a13:	66 3d dc 00          	cmp    $0xdc,%ax
   15a17:	0f 84 c0 02 00 00    	je     15cdd <math_emulate+0x858>
   15a1d:	77 0f                	ja     15a2e <math_emulate+0x5a9>
   15a1f:	66 3d da 00          	cmp    $0xda,%ax
   15a23:	0f 84 2b 03 00 00    	je     15d54 <math_emulate+0x8cf>
   15a29:	e9 30 04 00 00       	jmp    15e5e <math_emulate+0x9d9>
   15a2e:	66 3d dd 00          	cmp    $0xdd,%ax
   15a32:	0f 84 38 03 00 00    	je     15d70 <math_emulate+0x8eb>
   15a38:	66 3d de 00          	cmp    $0xde,%ax
   15a3c:	0f 85 1c 04 00 00    	jne    15e5e <math_emulate+0x9d9>
			fdiv(PST(0),PST(code & 7),&tmp);
   15a42:	83 e7 07             	and    $0x7,%edi
   15a45:	89 f8                	mov    %edi,%eax
   15a47:	e8 e5 f9 ff ff       	call   15431 <__st>
   15a4c:	89 c6                	mov    %eax,%esi
   15a4e:	31 c0                	xor    %eax,%eax
   15a50:	e9 67 03 00 00       	jmp    15dbc <math_emulate+0x937>
	switch (code >> 3) {
   15a55:	66 3d f9 00          	cmp    $0xf9,%ax
   15a59:	0f 84 74 03 00 00    	je     15dd3 <math_emulate+0x94e>
   15a5f:	77 2c                	ja     15a8d <math_emulate+0x608>
   15a61:	66 3d f8 00          	cmp    $0xf8,%ax
   15a65:	0f 85 f3 03 00 00    	jne    15e5e <math_emulate+0x9d9>
			printk("ffree not implemented\n\r");
   15a6b:	8d 83 83 89 ff ff    	lea    -0x767d(%ebx),%eax
   15a71:	83 ec 0c             	sub    $0xc,%esp
   15a74:	50                   	push   %eax
   15a75:	e8 a7 26 ff ff       	call   8121 <printk>
			math_abort(info,1<<(SIGILL-1));
   15a7a:	59                   	pop    %ecx
   15a7b:	5b                   	pop    %ebx
   15a7c:	6a 08                	push   $0x8
   15a7e:	8d 44 24 48          	lea    0x48(%esp),%eax
   15a82:	50                   	push   %eax
   15a83:	e8 d5 f9 ff ff       	call   1545d <__math_abort>
   15a88:	e9 3a 08 00 00       	jmp    162c7 <.L126+0x10>
	switch (code >> 3) {
   15a8d:	66 3d fb 00          	cmp    $0xfb,%ax
   15a91:	0f 86 a1 03 00 00    	jbe    15e38 <math_emulate+0x9b3>
   15a97:	e9 c2 03 00 00       	jmp    15e5e <math_emulate+0x9d9>
			fmul(PST(0),PST(code & 7),&tmp);
   15a9c:	89 f8                	mov    %edi,%eax
   15a9e:	83 e0 07             	and    $0x7,%eax
   15aa1:	e8 8b f9 ff ff       	call   15431 <__st>
   15aa6:	89 c6                	mov    %eax,%esi
   15aa8:	31 c0                	xor    %eax,%eax
   15aaa:	e8 82 f9 ff ff       	call   15431 <__st>
   15aaf:	57                   	push   %edi
   15ab0:	8d 54 24 18          	lea    0x18(%esp),%edx
   15ab4:	52                   	push   %edx
   15ab5:	56                   	push   %esi
   15ab6:	50                   	push   %eax
   15ab7:	e9 df 07 00 00       	jmp    1629b <.L124+0xb>
			fcom(PST(code & 7),&tmp);
   15abc:	89 f8                	mov    %edi,%eax
   15abe:	83 e0 07             	and    $0x7,%eax
   15ac1:	e8 6b f9 ff ff       	call   15431 <__st>
   15ac6:	56                   	push   %esi
   15ac7:	56                   	push   %esi
   15ac8:	8d 54 24 1c          	lea    0x1c(%esp),%edx
   15acc:	52                   	push   %edx
   15acd:	50                   	push   %eax
   15ace:	e8 37 14 00 00       	call   16f0a <fcom>
   15ad3:	e9 3c 08 00 00       	jmp    16314 <.L130+0x10>
			fcom(PST(code & 7),&tmp);
   15ad8:	89 f8                	mov    %edi,%eax
   15ada:	83 e0 07             	and    $0x7,%eax
   15add:	e8 4f f9 ff ff       	call   15431 <__st>
   15ae2:	51                   	push   %ecx
   15ae3:	51                   	push   %ecx
   15ae4:	8d 54 24 1c          	lea    0x1c(%esp),%edx
   15ae8:	52                   	push   %edx
   15ae9:	50                   	push   %eax
   15aea:	e8 1b 14 00 00       	call   16f0a <fcom>
			real_to_real(&tmp,&ST(0));
   15aef:	31 c0                	xor    %eax,%eax
   15af1:	e8 3b f9 ff ff       	call   15431 <__st>
   15af6:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   15afa:	8b 5c 24 28          	mov    0x28(%esp),%ebx
   15afe:	89 08                	mov    %ecx,(%eax)
   15b00:	89 58 04             	mov    %ebx,0x4(%eax)
   15b03:	31 c0                	xor    %eax,%eax
   15b05:	e9 16 02 00 00       	jmp    15d20 <math_emulate+0x89b>
			real_to_real(&ST(code & 7),&tmp);
   15b0a:	83 e7 07             	and    $0x7,%edi
   15b0d:	89 f8                	mov    %edi,%eax
   15b0f:	e8 1d f9 ff ff       	call   15431 <__st>
   15b14:	8b 50 04             	mov    0x4(%eax),%edx
   15b17:	8b 00                	mov    (%eax),%eax
   15b19:	89 44 24 14          	mov    %eax,0x14(%esp)
   15b1d:	89 f8                	mov    %edi,%eax
   15b1f:	89 54 24 18          	mov    %edx,0x18(%esp)
   15b23:	e8 09 f9 ff ff       	call   15431 <__st>
			tmp.exponent ^= 0x8000;
   15b28:	66 8b 40 08          	mov    0x8(%eax),%ax
   15b2c:	66 05 00 80          	add    $0x8000,%ax
   15b30:	66 89 44 24 1c       	mov    %ax,0x1c(%esp)
			fadd(PST(0),&tmp,&tmp);
   15b35:	31 c0                	xor    %eax,%eax
   15b37:	e8 f5 f8 ff ff       	call   15431 <__st>
   15b3c:	52                   	push   %edx
   15b3d:	8d 54 24 18          	lea    0x18(%esp),%edx
   15b41:	52                   	push   %edx
   15b42:	52                   	push   %edx
   15b43:	50                   	push   %eax
   15b44:	e8 71 0f 00 00       	call   16aba <fadd>
   15b49:	e9 c6 07 00 00       	jmp    16314 <.L130+0x10>
			ST(0).exponent ^= 0x8000;
   15b4e:	31 c0                	xor    %eax,%eax
   15b50:	e8 dc f8 ff ff       	call   15431 <__st>
   15b55:	66 81 40 08 00 80    	addw   $0x8000,0x8(%eax)
			fadd(PST(0),PST(code & 7),&tmp);
   15b5b:	89 f8                	mov    %edi,%eax
   15b5d:	83 e0 07             	and    $0x7,%eax
   15b60:	e8 cc f8 ff ff       	call   15431 <__st>
   15b65:	89 c6                	mov    %eax,%esi
   15b67:	31 c0                	xor    %eax,%eax
   15b69:	e8 c3 f8 ff ff       	call   15431 <__st>
   15b6e:	55                   	push   %ebp
   15b6f:	8d 54 24 18          	lea    0x18(%esp),%edx
   15b73:	52                   	push   %edx
   15b74:	56                   	push   %esi
   15b75:	eb cc                	jmp    15b43 <math_emulate+0x6be>
			fdiv(PST(0),PST(code & 7),&tmp);
   15b77:	89 f8                	mov    %edi,%eax
   15b79:	83 e0 07             	and    $0x7,%eax
   15b7c:	e8 b0 f8 ff ff       	call   15431 <__st>
   15b81:	89 c6                	mov    %eax,%esi
   15b83:	31 c0                	xor    %eax,%eax
			fdiv(PST(code & 7),PST(0),&tmp);
   15b85:	e8 a7 f8 ff ff       	call   15431 <__st>
   15b8a:	57                   	push   %edi
   15b8b:	8d 54 24 18          	lea    0x18(%esp),%edx
   15b8f:	52                   	push   %edx
   15b90:	e9 6b 07 00 00       	jmp    16300 <.L129+0x9>
			fpush();
   15b95:	e8 68 f8 ff ff       	call   15402 <fpush>
			ST(0) = ST((code & 7)+1);
   15b9a:	89 f8                	mov    %edi,%eax
   15b9c:	83 e0 07             	and    $0x7,%eax
   15b9f:	40                   	inc    %eax
   15ba0:	e8 8c f8 ff ff       	call   15431 <__st>
   15ba5:	89 c6                	mov    %eax,%esi
   15ba7:	31 c0                	xor    %eax,%eax
   15ba9:	e9 e3 00 00 00       	jmp    15c91 <math_emulate+0x80c>
			fadd(PST(0),PST(code & 7),&tmp);
   15bae:	83 e7 07             	and    $0x7,%edi
   15bb1:	eb 67                	jmp    15c1a <math_emulate+0x795>
			fmul(PST(0),PST(code & 7),&tmp);
   15bb3:	83 e7 07             	and    $0x7,%edi
   15bb6:	89 f8                	mov    %edi,%eax
   15bb8:	e8 74 f8 ff ff       	call   15431 <__st>
   15bbd:	89 c6                	mov    %eax,%esi
   15bbf:	31 c0                	xor    %eax,%eax
   15bc1:	e8 6b f8 ff ff       	call   15431 <__st>
   15bc6:	51                   	push   %ecx
   15bc7:	8d 54 24 18          	lea    0x18(%esp),%edx
   15bcb:	52                   	push   %edx
   15bcc:	56                   	push   %esi
   15bcd:	50                   	push   %eax
   15bce:	e8 16 10 00 00       	call   16be9 <fmul>
			real_to_real(&tmp,&ST(code & 7));
   15bd3:	89 f8                	mov    %edi,%eax
   15bd5:	e8 57 f8 ff ff       	call   15431 <__st>
   15bda:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   15bde:	8b 5c 24 28          	mov    0x28(%esp),%ebx
   15be2:	89 08                	mov    %ecx,(%eax)
   15be4:	89 58 04             	mov    %ebx,0x4(%eax)
   15be7:	89 f8                	mov    %edi,%eax
   15be9:	e9 3c 07 00 00       	jmp    1632a <.L130+0x26>
			fcom(PST(code & 7),PST(0));
   15bee:	31 c0                	xor    %eax,%eax
   15bf0:	e8 3c f8 ff ff       	call   15431 <__st>
   15bf5:	89 c6                	mov    %eax,%esi
   15bf7:	89 f8                	mov    %edi,%eax
   15bf9:	83 e0 07             	and    $0x7,%eax
   15bfc:	e8 30 f8 ff ff       	call   15431 <__st>
   15c01:	52                   	push   %edx
   15c02:	52                   	push   %edx
   15c03:	56                   	push   %esi
   15c04:	50                   	push   %eax
   15c05:	e9 a3 06 00 00       	jmp    162ad <.L125+0xb>
			ST(code & 7).exponent ^= 0x8000;
   15c0a:	83 e7 07             	and    $0x7,%edi
   15c0d:	89 f8                	mov    %edi,%eax
   15c0f:	e8 1d f8 ff ff       	call   15431 <__st>
   15c14:	66 81 40 08 00 80    	addw   $0x8000,0x8(%eax)
			fadd(PST(0),PST(code & 7),&tmp);
   15c1a:	89 f8                	mov    %edi,%eax
   15c1c:	e8 10 f8 ff ff       	call   15431 <__st>
   15c21:	89 c6                	mov    %eax,%esi
   15c23:	31 c0                	xor    %eax,%eax
   15c25:	e8 07 f8 ff ff       	call   15431 <__st>
   15c2a:	55                   	push   %ebp
   15c2b:	8d 54 24 18          	lea    0x18(%esp),%edx
   15c2f:	52                   	push   %edx
   15c30:	56                   	push   %esi
			fadd(PST(code & 7),&tmp,&tmp);
   15c31:	50                   	push   %eax
   15c32:	e8 83 0e 00 00       	call   16aba <fadd>
   15c37:	eb 9a                	jmp    15bd3 <math_emulate+0x74e>
			fdiv(PST(0),PST(code & 7),&tmp);
   15c39:	83 e7 07             	and    $0x7,%edi
   15c3c:	89 f8                	mov    %edi,%eax
   15c3e:	e8 ee f7 ff ff       	call   15431 <__st>
   15c43:	89 c6                	mov    %eax,%esi
   15c45:	31 c0                	xor    %eax,%eax
			fdiv(PST(code & 7),PST(0),&tmp);
   15c47:	e8 e5 f7 ff ff       	call   15431 <__st>
   15c4c:	52                   	push   %edx
   15c4d:	8d 54 24 18          	lea    0x18(%esp),%edx
   15c51:	52                   	push   %edx
   15c52:	56                   	push   %esi
   15c53:	50                   	push   %eax
   15c54:	e8 75 10 00 00       	call   16cce <fdiv>
   15c59:	e9 75 ff ff ff       	jmp    15bd3 <math_emulate+0x74e>
			printk("ffree not implemented\n\r");
   15c5e:	8d 83 83 89 ff ff    	lea    -0x767d(%ebx),%eax
   15c64:	83 ec 0c             	sub    $0xc,%esp
   15c67:	50                   	push   %eax
   15c68:	e8 b4 24 ff ff       	call   8121 <printk>
			math_abort(info,1<<(SIGILL-1));
   15c6d:	5d                   	pop    %ebp
   15c6e:	58                   	pop    %eax
   15c6f:	6a 08                	push   $0x8
   15c71:	8d 44 24 48          	lea    0x48(%esp),%eax
   15c75:	50                   	push   %eax
   15c76:	e8 e2 f7 ff ff       	call   1545d <__math_abort>
   15c7b:	83 c4 10             	add    $0x10,%esp
   15c7e:	e9 50 01 00 00       	jmp    15dd3 <math_emulate+0x94e>
			ST(code & 7) = ST(0);
   15c83:	31 c0                	xor    %eax,%eax
   15c85:	e8 a7 f7 ff ff       	call   15431 <__st>
   15c8a:	89 c6                	mov    %eax,%esi
   15c8c:	89 f8                	mov    %edi,%eax
   15c8e:	83 e0 07             	and    $0x7,%eax
   15c91:	e8 9b f7 ff ff       	call   15431 <__st>
   15c96:	e9 d5 fa ff ff       	jmp    15770 <math_emulate+0x2eb>
			fucom(PST(code & 7),PST(0));
   15c9b:	31 c0                	xor    %eax,%eax
   15c9d:	e8 8f f7 ff ff       	call   15431 <__st>
   15ca2:	89 c6                	mov    %eax,%esi
   15ca4:	89 f8                	mov    %edi,%eax
   15ca6:	83 e0 07             	and    $0x7,%eax
   15ca9:	e8 83 f7 ff ff       	call   15431 <__st>
   15cae:	57                   	push   %edi
   15caf:	57                   	push   %edi
   15cb0:	56                   	push   %esi
   15cb1:	50                   	push   %eax
   15cb2:	e8 99 12 00 00       	call   16f50 <fucom>
   15cb7:	e9 de 06 00 00       	jmp    1639a <.L130+0x96>
			fucom(PST(code & 7),PST(0));
   15cbc:	31 c0                	xor    %eax,%eax
   15cbe:	e8 6e f7 ff ff       	call   15431 <__st>
   15cc3:	89 c6                	mov    %eax,%esi
   15cc5:	89 f8                	mov    %edi,%eax
   15cc7:	83 e0 07             	and    $0x7,%eax
   15cca:	e8 62 f7 ff ff       	call   15431 <__st>
   15ccf:	51                   	push   %ecx
   15cd0:	51                   	push   %ecx
   15cd1:	56                   	push   %esi
   15cd2:	50                   	push   %eax
   15cd3:	e8 78 12 00 00       	call   16f50 <fucom>
   15cd8:	e9 ea 05 00 00       	jmp    162c7 <.L126+0x10>
			ST(code & 7).exponent ^= 0x8000;
   15cdd:	83 e7 07             	and    $0x7,%edi
   15ce0:	89 f8                	mov    %edi,%eax
   15ce2:	e8 4a f7 ff ff       	call   15431 <__st>
   15ce7:	66 81 40 08 00 80    	addw   $0x8000,0x8(%eax)
			fadd(PST(0),PST(code & 7),&tmp);
   15ced:	89 f8                	mov    %edi,%eax
   15cef:	e8 3d f7 ff ff       	call   15431 <__st>
   15cf4:	89 c6                	mov    %eax,%esi
   15cf6:	31 c0                	xor    %eax,%eax
			fadd(PST(code & 7),PST(0),&tmp);
   15cf8:	e8 34 f7 ff ff       	call   15431 <__st>
   15cfd:	52                   	push   %edx
   15cfe:	8d 54 24 18          	lea    0x18(%esp),%edx
   15d02:	52                   	push   %edx
   15d03:	56                   	push   %esi
   15d04:	50                   	push   %eax
   15d05:	e8 b0 0d 00 00       	call   16aba <fadd>
			real_to_real(&tmp,&ST(code & 7));
   15d0a:	89 f8                	mov    %edi,%eax
   15d0c:	e8 20 f7 ff ff       	call   15431 <__st>
   15d11:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   15d15:	8b 5c 24 28          	mov    0x28(%esp),%ebx
   15d19:	89 08                	mov    %ecx,(%eax)
   15d1b:	89 58 04             	mov    %ebx,0x4(%eax)
   15d1e:	89 f8                	mov    %edi,%eax
   15d20:	e8 0c f7 ff ff       	call   15431 <__st>
   15d25:	8b 54 24 2c          	mov    0x2c(%esp),%edx
   15d29:	66 89 50 08          	mov    %dx,0x8(%eax)
   15d2d:	e9 95 05 00 00       	jmp    162c7 <.L126+0x10>
			fmul(PST(code & 7),PST(0),&tmp);
   15d32:	31 c0                	xor    %eax,%eax
   15d34:	83 e7 07             	and    $0x7,%edi
   15d37:	e8 f5 f6 ff ff       	call   15431 <__st>
   15d3c:	89 c6                	mov    %eax,%esi
   15d3e:	89 f8                	mov    %edi,%eax
   15d40:	e8 ec f6 ff ff       	call   15431 <__st>
   15d45:	55                   	push   %ebp
   15d46:	8d 54 24 18          	lea    0x18(%esp),%edx
   15d4a:	52                   	push   %edx
   15d4b:	56                   	push   %esi
   15d4c:	50                   	push   %eax
   15d4d:	e8 97 0e 00 00       	call   16be9 <fmul>
   15d52:	eb b6                	jmp    15d0a <math_emulate+0x885>
			fcom(PST(code & 7),PST(0));
   15d54:	31 c0                	xor    %eax,%eax
   15d56:	e8 d6 f6 ff ff       	call   15431 <__st>
   15d5b:	89 c6                	mov    %eax,%esi
   15d5d:	89 f8                	mov    %edi,%eax
   15d5f:	83 e0 07             	and    $0x7,%eax
   15d62:	e8 ca f6 ff ff       	call   15431 <__st>
   15d67:	51                   	push   %ecx
   15d68:	51                   	push   %ecx
   15d69:	56                   	push   %esi
   15d6a:	50                   	push   %eax
   15d6b:	e9 52 05 00 00       	jmp    162c2 <.L126+0xb>
			real_to_real(&ST(0),&tmp);
   15d70:	31 c0                	xor    %eax,%eax
			fadd(PST(code & 7),&tmp,&tmp);
   15d72:	83 e7 07             	and    $0x7,%edi
			real_to_real(&ST(0),&tmp);
   15d75:	e8 b7 f6 ff ff       	call   15431 <__st>
   15d7a:	8b 50 04             	mov    0x4(%eax),%edx
   15d7d:	8b 00                	mov    (%eax),%eax
   15d7f:	89 44 24 14          	mov    %eax,0x14(%esp)
   15d83:	31 c0                	xor    %eax,%eax
   15d85:	89 54 24 18          	mov    %edx,0x18(%esp)
   15d89:	e8 a3 f6 ff ff       	call   15431 <__st>
			tmp.exponent ^= 0x8000;
   15d8e:	66 8b 40 08          	mov    0x8(%eax),%ax
   15d92:	66 05 00 80          	add    $0x8000,%ax
   15d96:	66 89 44 24 1c       	mov    %ax,0x1c(%esp)
			fadd(PST(code & 7),&tmp,&tmp);
   15d9b:	89 f8                	mov    %edi,%eax
   15d9d:	e8 8f f6 ff ff       	call   15431 <__st>
   15da2:	52                   	push   %edx
   15da3:	8d 54 24 18          	lea    0x18(%esp),%edx
   15da7:	52                   	push   %edx
   15da8:	52                   	push   %edx
   15da9:	e9 56 ff ff ff       	jmp    15d04 <math_emulate+0x87f>
			fdiv(PST(code & 7),PST(0),&tmp);
   15dae:	31 c0                	xor    %eax,%eax
   15db0:	83 e7 07             	and    $0x7,%edi
   15db3:	e8 79 f6 ff ff       	call   15431 <__st>
   15db8:	89 c6                	mov    %eax,%esi
   15dba:	89 f8                	mov    %edi,%eax
   15dbc:	e8 70 f6 ff ff       	call   15431 <__st>
   15dc1:	55                   	push   %ebp
   15dc2:	8d 54 24 18          	lea    0x18(%esp),%edx
   15dc6:	52                   	push   %edx
   15dc7:	56                   	push   %esi
   15dc8:	50                   	push   %eax
   15dc9:	e8 00 0f 00 00       	call   16cce <fdiv>
   15dce:	e9 37 ff ff ff       	jmp    15d0a <math_emulate+0x885>
			fxchg(&ST(0),&ST(code & 7));
   15dd3:	89 f8                	mov    %edi,%eax
   15dd5:	83 e0 07             	and    $0x7,%eax
   15dd8:	e8 54 f6 ff ff       	call   15431 <__st>
   15ddd:	89 c3                	mov    %eax,%ebx
   15ddf:	31 c0                	xor    %eax,%eax
   15de1:	e8 4b f6 ff ff       	call   15431 <__st>
	c = *a;
   15de6:	66 8b 78 04          	mov    0x4(%eax),%di
   15dea:	66 8b 10             	mov    (%eax),%dx
	*a = *b;
   15ded:	b9 0a 00 00 00       	mov    $0xa,%ecx
	c = *a;
   15df2:	66 8b 68 02          	mov    0x2(%eax),%bp
	*a = *b;
   15df6:	89 de                	mov    %ebx,%esi
	c = *a;
   15df8:	66 89 7c 24 08       	mov    %di,0x8(%esp)
   15dfd:	66 8b 78 06          	mov    0x6(%eax),%di
   15e01:	66 89 7c 24 0c       	mov    %di,0xc(%esp)
   15e06:	66 8b 78 08          	mov    0x8(%eax),%di
   15e0a:	66 89 7c 24 0e       	mov    %di,0xe(%esp)
	*a = *b;
   15e0f:	89 c7                	mov    %eax,%edi
	*b = c;
   15e11:	8b 44 24 08          	mov    0x8(%esp),%eax
	*a = *b;
   15e15:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	*b = c;
   15e17:	66 89 13             	mov    %dx,(%ebx)
   15e1a:	66 89 6b 02          	mov    %bp,0x2(%ebx)
   15e1e:	66 89 43 04          	mov    %ax,0x4(%ebx)
   15e22:	8b 44 24 0c          	mov    0xc(%esp),%eax
   15e26:	66 89 43 06          	mov    %ax,0x6(%ebx)
   15e2a:	66 8b 44 24 0e       	mov    0xe(%esp),%ax
   15e2f:	66 89 43 08          	mov    %ax,0x8(%ebx)
   15e33:	e9 65 05 00 00       	jmp    1639d <.L130+0x99>
			ST(code & 7) = ST(0);
   15e38:	31 c0                	xor    %eax,%eax
   15e3a:	e8 f2 f5 ff ff       	call   15431 <__st>
   15e3f:	89 c6                	mov    %eax,%esi
   15e41:	89 f8                	mov    %edi,%eax
   15e43:	83 e0 07             	and    $0x7,%eax
   15e46:	e8 e6 f5 ff ff       	call   15431 <__st>
   15e4b:	b9 0a 00 00 00       	mov    $0xa,%ecx
   15e50:	89 c7                	mov    %eax,%edi
   15e52:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
			fpop();
   15e54:	e8 7a f5 ff ff       	call   153d3 <fpop>
   15e59:	e9 3f 05 00 00       	jmp    1639d <.L130+0x99>
	switch ((code>>3) & 0xe7) {
   15e5e:	89 c1                	mov    %eax,%ecx
   15e60:	66 81 e1 e7 00       	and    $0xe7,%cx
   15e65:	66 81 f9 a2 00       	cmp    $0xa2,%cx
   15e6a:	0f 84 7c 02 00 00    	je     160ec <math_emulate+0xc67>
   15e70:	0f 87 d0 00 00 00    	ja     15f46 <math_emulate+0xac1>
   15e76:	66 83 f9 26          	cmp    $0x26,%cx
   15e7a:	0f 84 d6 01 00 00    	je     16056 <math_emulate+0xbd1>
   15e80:	77 5e                	ja     15ee0 <math_emulate+0xa5b>
   15e82:	66 83 f9 23          	cmp    $0x23,%cx
   15e86:	0f 84 82 01 00 00    	je     1600e <math_emulate+0xb89>
   15e8c:	77 1e                	ja     15eac <math_emulate+0xa27>
   15e8e:	66 83 f9 22          	cmp    $0x22,%cx
   15e92:	0f 85 7d 03 00 00    	jne    16215 <math_emulate+0xd90>
                    panic("kernel/math/math_emulate.c->do_emu(),394");
   15e98:	8d 83 9b 89 ff ff    	lea    -0x7665(%ebx),%eax
   15e9e:	83 ec 0c             	sub    $0xc,%esp
   15ea1:	50                   	push   %eax
   15ea2:	e8 2b 22 ff ff       	call   80d2 <panic>
   15ea7:	e9 ee 04 00 00       	jmp    1639a <.L130+0x96>
	switch ((code>>3) & 0xe7) {
   15eac:	66 83 f9 24          	cmp    $0x24,%cx
   15eb0:	0f 84 71 01 00 00    	je     16027 <math_emulate+0xba2>
   15eb6:	66 83 f9 25          	cmp    $0x25,%cx
   15eba:	0f 85 55 03 00 00    	jne    16215 <math_emulate+0xd90>
			address = ea(info,code);
   15ec0:	50                   	push   %eax
   15ec1:	50                   	push   %eax
   15ec2:	56                   	push   %esi
   15ec3:	8d 44 24 48          	lea    0x48(%esp),%eax
   15ec7:	50                   	push   %eax
   15ec8:	e8 f8 04 00 00       	call   163c5 <ea>
   15ecd:	64 66 8b 10          	mov    %fs:(%eax),%dx
			*(unsigned short *) &I387.cwd =
   15ed1:	8b 45 00             	mov    0x0(%ebp),%eax
   15ed4:	66 89 90 18 04 00 00 	mov    %dx,0x418(%eax)
   15edb:	e9 ba 04 00 00       	jmp    1639a <.L130+0x96>
	switch ((code>>3) & 0xe7) {
   15ee0:	66 83 f9 63          	cmp    $0x63,%cx
   15ee4:	0f 84 ce 01 00 00    	je     160b8 <math_emulate+0xc33>
   15eea:	77 2d                	ja     15f19 <math_emulate+0xa94>
   15eec:	66 83 f9 27          	cmp    $0x27,%cx
   15ef0:	0f 84 9b 01 00 00    	je     16091 <math_emulate+0xc0c>
   15ef6:	66 83 f9 62          	cmp    $0x62,%cx
   15efa:	0f 85 15 03 00 00    	jne    16215 <math_emulate+0xd90>
			put_long_int(PST(0),info,code);
   15f00:	31 c0                	xor    %eax,%eax
   15f02:	e8 2a f5 ff ff       	call   15431 <__st>
   15f07:	51                   	push   %ecx
   15f08:	56                   	push   %esi
   15f09:	8d 54 24 44          	lea    0x44(%esp),%edx
   15f0d:	52                   	push   %edx
   15f0e:	50                   	push   %eax
   15f0f:	e8 04 0a 00 00       	call   16918 <put_long_int>
   15f14:	e9 81 04 00 00       	jmp    1639a <.L130+0x96>
	switch ((code>>3) & 0xe7) {
   15f19:	66 83 f9 65          	cmp    $0x65,%cx
   15f1d:	0f 84 ae 01 00 00    	je     160d1 <math_emulate+0xc4c>
   15f23:	66 83 f9 67          	cmp    $0x67,%cx
   15f27:	0f 85 e8 02 00 00    	jne    16215 <math_emulate+0xd90>
			put_temp_real(PST(0),info,code);
   15f2d:	31 c0                	xor    %eax,%eax
   15f2f:	e8 fd f4 ff ff       	call   15431 <__st>
   15f34:	57                   	push   %edi
   15f35:	56                   	push   %esi
   15f36:	8d 54 24 44          	lea    0x44(%esp),%edx
   15f3a:	52                   	push   %edx
   15f3b:	50                   	push   %eax
   15f3c:	e8 35 09 00 00       	call   16876 <put_temp_real>
   15f41:	e9 81 03 00 00       	jmp    162c7 <.L126+0x10>
	switch ((code>>3) & 0xe7) {
   15f46:	66 81 f9 e2 00       	cmp    $0xe2,%cx
   15f4b:	0f 84 5e 02 00 00    	je     161af <math_emulate+0xd2a>
   15f51:	77 4e                	ja     15fa1 <math_emulate+0xb1c>
   15f53:	66 81 f9 a4 00       	cmp    $0xa4,%cx
   15f58:	0f 84 c0 01 00 00    	je     1611e <math_emulate+0xc99>
   15f5e:	0f 82 a1 01 00 00    	jb     16105 <math_emulate+0xc80>
   15f64:	66 81 f9 a6 00       	cmp    $0xa6,%cx
   15f69:	0f 84 de 01 00 00    	je     1614d <math_emulate+0xcc8>
   15f6f:	66 81 f9 a7 00       	cmp    $0xa7,%cx
   15f74:	0f 85 9b 02 00 00    	jne    16215 <math_emulate+0xd90>
			address = ea(info,code);
   15f7a:	57                   	push   %edi
   15f7b:	57                   	push   %edi
   15f7c:	56                   	push   %esi
   15f7d:	8d 44 24 48          	lea    0x48(%esp),%eax
   15f81:	50                   	push   %eax
   15f82:	e8 3e 04 00 00       	call   163c5 <ea>
   15f87:	89 c6                	mov    %eax,%esi
			verify_area(address,2);
   15f89:	58                   	pop    %eax
   15f8a:	5a                   	pop    %edx
   15f8b:	6a 02                	push   $0x2
   15f8d:	56                   	push   %esi
   15f8e:	e8 58 1c ff ff       	call   7beb <verify_area>
			put_fs_word(I387.swd,(short *) address);
   15f93:	8b 45 00             	mov    0x0(%ebp),%eax
   15f96:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
   15f9c:	e9 05 02 00 00       	jmp    161a6 <math_emulate+0xd21>
	switch ((code>>3) & 0xe7) {
   15fa1:	66 81 f9 e5 00       	cmp    $0xe5,%cx
   15fa6:	0f 84 35 02 00 00    	je     161e1 <math_emulate+0xd5c>
   15fac:	77 31                	ja     15fdf <math_emulate+0xb5a>
   15fae:	66 81 f9 e3 00       	cmp    $0xe3,%cx
   15fb3:	0f 84 0f 02 00 00    	je     161c8 <math_emulate+0xd43>
   15fb9:	66 81 f9 e4 00       	cmp    $0xe4,%cx
   15fbe:	0f 85 51 02 00 00    	jne    16215 <math_emulate+0xd90>
			fpush();
   15fc4:	e8 39 f4 ff ff       	call   15402 <fpush>
			get_BCD(&tmp,info,code);
   15fc9:	55                   	push   %ebp
   15fca:	56                   	push   %esi
   15fcb:	8d 44 24 44          	lea    0x44(%esp),%eax
   15fcf:	50                   	push   %eax
   15fd0:	8d 44 24 20          	lea    0x20(%esp),%eax
   15fd4:	50                   	push   %eax
   15fd5:	e8 40 07 00 00       	call   1671a <get_BCD>
   15fda:	e9 35 03 00 00       	jmp    16314 <.L130+0x10>
	switch ((code>>3) & 0xe7) {
   15fdf:	66 81 f9 e6 00       	cmp    $0xe6,%cx
   15fe4:	0f 84 12 02 00 00    	je     161fc <math_emulate+0xd77>
   15fea:	66 81 f9 e7 00       	cmp    $0xe7,%cx
   15fef:	0f 85 20 02 00 00    	jne    16215 <math_emulate+0xd90>
			put_longlong_int(PST(0),info,code);
   15ff5:	31 c0                	xor    %eax,%eax
   15ff7:	e8 35 f4 ff ff       	call   15431 <__st>
   15ffc:	52                   	push   %edx
   15ffd:	56                   	push   %esi
   15ffe:	8d 54 24 44          	lea    0x44(%esp),%edx
   16002:	52                   	push   %edx
   16003:	50                   	push   %eax
   16004:	e8 66 09 00 00       	call   1696f <put_longlong_int>
   16009:	e9 b9 02 00 00       	jmp    162c7 <.L126+0x10>
			put_short_real(PST(0),info,code);
   1600e:	31 c0                	xor    %eax,%eax
   16010:	e8 1c f4 ff ff       	call   15431 <__st>
   16015:	52                   	push   %edx
   16016:	56                   	push   %esi
   16017:	8d 54 24 44          	lea    0x44(%esp),%edx
   1601b:	52                   	push   %edx
   1601c:	50                   	push   %eax
   1601d:	e8 bc 07 00 00       	call   167de <put_short_real>
   16022:	e9 a0 02 00 00       	jmp    162c7 <.L126+0x10>
			address = ea(info,code);
   16027:	50                   	push   %eax
   16028:	50                   	push   %eax
   16029:	56                   	push   %esi
   1602a:	8d 44 24 48          	lea    0x48(%esp),%eax
   1602e:	50                   	push   %eax
   1602f:	e8 91 03 00 00       	call   163c5 <ea>
				((long *) & I387)[code] =
   16034:	8b 4d 00             	mov    0x0(%ebp),%ecx
   16037:	83 c4 10             	add    $0x10,%esp
   1603a:	31 d2                	xor    %edx,%edx
   1603c:	81 c1 18 04 00 00    	add    $0x418,%ecx
// 返回:返回内存fs:[addr]处的长字.
static inline unsigned long get_fs_long(const unsigned long *addr)
{
	unsigned long _v;

	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   16042:	64 8b 1c 10          	mov    %fs:(%eax,%edx,1),%ebx
   16046:	89 1c 11             	mov    %ebx,(%ecx,%edx,1)
   16049:	83 c2 04             	add    $0x4,%edx
			for (code = 0 ; code < 7 ; code++) {
   1604c:	83 fa 1c             	cmp    $0x1c,%edx
   1604f:	75 f1                	jne    16042 <math_emulate+0xbbd>
   16051:	e9 47 03 00 00       	jmp    1639d <.L130+0x99>
			address = ea(info,code);
   16056:	51                   	push   %ecx
   16057:	51                   	push   %ecx
   16058:	56                   	push   %esi
   16059:	8d 44 24 48          	lea    0x48(%esp),%eax
   1605d:	50                   	push   %eax
   1605e:	e8 62 03 00 00       	call   163c5 <ea>
			verify_area(address,28);
   16063:	5f                   	pop    %edi
			address = ea(info,code);
   16064:	89 c6                	mov    %eax,%esi
			verify_area(address,28);
   16066:	58                   	pop    %eax
   16067:	6a 1c                	push   $0x1c
   16069:	56                   	push   %esi
   1606a:	e8 7c 1b ff ff       	call   7beb <verify_area>
				put_fs_long( ((long *) & I387)[code],
   1606f:	8b 4d 00             	mov    0x0(%ebp),%ecx
   16072:	83 c4 10             	add    $0x10,%esp
   16075:	31 d2                	xor    %edx,%edx
   16077:	81 c1 18 04 00 00    	add    $0x418,%ecx
//// 将一长字存放在fs段中指定内存地址处.
// 参数:val - 长字值;addr - 内存地址.
// %0 - 寄存器(长字值val);%1 - (内存地址addr).
static inline void put_fs_long(unsigned long val,unsigned long * addr)
{
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   1607d:	8b 04 11             	mov    (%ecx,%edx,1),%eax
   16080:	64 89 04 16          	mov    %eax,%fs:(%esi,%edx,1)
   16084:	83 c2 04             	add    $0x4,%edx
			for (code = 0 ; code < 7 ; code++) {
   16087:	83 fa 1c             	cmp    $0x1c,%edx
   1608a:	75 f1                	jne    1607d <math_emulate+0xbf8>
   1608c:	e9 0c 03 00 00       	jmp    1639d <.L130+0x99>
			address = ea(info,code);
   16091:	57                   	push   %edi
   16092:	57                   	push   %edi
   16093:	56                   	push   %esi
   16094:	8d 44 24 48          	lea    0x48(%esp),%eax
   16098:	50                   	push   %eax
   16099:	e8 27 03 00 00       	call   163c5 <ea>
   1609e:	89 c6                	mov    %eax,%esi
			verify_area(address,2);
   160a0:	58                   	pop    %eax
   160a1:	5a                   	pop    %edx
   160a2:	6a 02                	push   $0x2
   160a4:	56                   	push   %esi
   160a5:	e8 41 1b ff ff       	call   7beb <verify_area>
			put_fs_word(I387.cwd,(short *) address);
   160aa:	8b 45 00             	mov    0x0(%ebp),%eax
   160ad:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
   160b3:	e9 ee 00 00 00       	jmp    161a6 <math_emulate+0xd21>
			put_long_int(PST(0),info,code);
   160b8:	31 c0                	xor    %eax,%eax
   160ba:	e8 72 f3 ff ff       	call   15431 <__st>
   160bf:	52                   	push   %edx
   160c0:	56                   	push   %esi
   160c1:	8d 54 24 44          	lea    0x44(%esp),%edx
   160c5:	52                   	push   %edx
   160c6:	50                   	push   %eax
   160c7:	e8 4c 08 00 00       	call   16918 <put_long_int>
   160cc:	e9 f6 01 00 00       	jmp    162c7 <.L126+0x10>
			fpush();
   160d1:	e8 2c f3 ff ff       	call   15402 <fpush>
			get_temp_real(&tmp,info,code);
   160d6:	55                   	push   %ebp
   160d7:	56                   	push   %esi
   160d8:	8d 44 24 44          	lea    0x44(%esp),%eax
   160dc:	50                   	push   %eax
   160dd:	8d 44 24 20          	lea    0x20(%esp),%eax
   160e1:	50                   	push   %eax
   160e2:	e8 dc 04 00 00       	call   165c3 <get_temp_real>
   160e7:	e9 28 02 00 00       	jmp    16314 <.L130+0x10>
			put_long_real(PST(0),info,code);
   160ec:	31 c0                	xor    %eax,%eax
   160ee:	e8 3e f3 ff ff       	call   15431 <__st>
   160f3:	51                   	push   %ecx
   160f4:	56                   	push   %esi
   160f5:	8d 54 24 44          	lea    0x44(%esp),%edx
   160f9:	52                   	push   %edx
   160fa:	50                   	push   %eax
   160fb:	e8 26 07 00 00       	call   16826 <put_long_real>
   16100:	e9 95 02 00 00       	jmp    1639a <.L130+0x96>
			put_long_real(PST(0),info,code);
   16105:	31 c0                	xor    %eax,%eax
   16107:	e8 25 f3 ff ff       	call   15431 <__st>
   1610c:	52                   	push   %edx
   1610d:	56                   	push   %esi
   1610e:	8d 54 24 44          	lea    0x44(%esp),%edx
   16112:	52                   	push   %edx
   16113:	50                   	push   %eax
   16114:	e8 0d 07 00 00       	call   16826 <put_long_real>
   16119:	e9 a9 01 00 00       	jmp    162c7 <.L126+0x10>
			address = ea(info,code);
   1611e:	50                   	push   %eax
   1611f:	50                   	push   %eax
   16120:	56                   	push   %esi
   16121:	8d 44 24 48          	lea    0x48(%esp),%eax
   16125:	50                   	push   %eax
   16126:	e8 9a 02 00 00       	call   163c5 <ea>
				((long *) & I387)[code] =
   1612b:	8b 4d 00             	mov    0x0(%ebp),%ecx
   1612e:	83 c4 10             	add    $0x10,%esp
   16131:	31 d2                	xor    %edx,%edx
   16133:	81 c1 18 04 00 00    	add    $0x418,%ecx
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   16139:	64 8b 1c 10          	mov    %fs:(%eax,%edx,1),%ebx
   1613d:	89 1c 11             	mov    %ebx,(%ecx,%edx,1)
   16140:	83 c2 04             	add    $0x4,%edx
			for (code = 0 ; code < 27 ; code++) {
   16143:	83 fa 6c             	cmp    $0x6c,%edx
   16146:	75 f1                	jne    16139 <math_emulate+0xcb4>
   16148:	e9 50 02 00 00       	jmp    1639d <.L130+0x99>
			address = ea(info,code);
   1614d:	51                   	push   %ecx
   1614e:	51                   	push   %ecx
   1614f:	56                   	push   %esi
   16150:	8d 44 24 48          	lea    0x48(%esp),%eax
   16154:	50                   	push   %eax
   16155:	e8 6b 02 00 00       	call   163c5 <ea>
			verify_area(address,108);
   1615a:	5f                   	pop    %edi
			address = ea(info,code);
   1615b:	89 c6                	mov    %eax,%esi
			verify_area(address,108);
   1615d:	58                   	pop    %eax
   1615e:	6a 6c                	push   $0x6c
   16160:	56                   	push   %esi
   16161:	e8 85 1a ff ff       	call   7beb <verify_area>
				put_fs_long( ((long *) & I387)[code],
   16166:	8b 4d 00             	mov    0x0(%ebp),%ecx
   16169:	83 c4 10             	add    $0x10,%esp
   1616c:	31 d2                	xor    %edx,%edx
   1616e:	8d 99 18 04 00 00    	lea    0x418(%ecx),%ebx
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   16174:	8b 04 13             	mov    (%ebx,%edx,1),%eax
   16177:	64 89 04 16          	mov    %eax,%fs:(%esi,%edx,1)
   1617b:	83 c2 04             	add    $0x4,%edx
			for (code = 0 ; code < 27 ; code++) {
   1617e:	83 fa 6c             	cmp    $0x6c,%edx
   16181:	75 f1                	jne    16174 <math_emulate+0xcef>
			I387.cwd = 0x037f;
   16183:	c7 81 18 04 00 00 7f 	movl   $0x37f,0x418(%ecx)
   1618a:	03 00 00 
			I387.swd = 0x0000;
   1618d:	c7 81 1c 04 00 00 00 	movl   $0x0,0x41c(%ecx)
   16194:	00 00 00 
			I387.twd = 0x0000;
   16197:	c7 81 20 04 00 00 00 	movl   $0x0,0x420(%ecx)
   1619e:	00 00 00 
   161a1:	e9 f7 01 00 00       	jmp    1639d <.L130+0x99>
__asm__ ("movw %0,%%fs:%1"::"q" (val),"m" (*addr));
   161a6:	64 66 89 06          	mov    %ax,%fs:(%esi)
   161aa:	e9 eb 01 00 00       	jmp    1639a <.L130+0x96>
			put_short_int(PST(0),info,code);
   161af:	31 c0                	xor    %eax,%eax
   161b1:	e8 7b f2 ff ff       	call   15431 <__st>
   161b6:	51                   	push   %ecx
   161b7:	56                   	push   %esi
   161b8:	8d 54 24 44          	lea    0x44(%esp),%edx
   161bc:	52                   	push   %edx
   161bd:	50                   	push   %eax
   161be:	e8 fd 06 00 00       	call   168c0 <put_short_int>
   161c3:	e9 d2 01 00 00       	jmp    1639a <.L130+0x96>
			put_short_int(PST(0),info,code);
   161c8:	31 c0                	xor    %eax,%eax
   161ca:	e8 62 f2 ff ff       	call   15431 <__st>
   161cf:	52                   	push   %edx
   161d0:	56                   	push   %esi
   161d1:	8d 54 24 44          	lea    0x44(%esp),%edx
   161d5:	52                   	push   %edx
   161d6:	50                   	push   %eax
   161d7:	e8 e4 06 00 00       	call   168c0 <put_short_int>
   161dc:	e9 e6 00 00 00       	jmp    162c7 <.L126+0x10>
			fpush();
   161e1:	e8 1c f2 ff ff       	call   15402 <fpush>
			get_longlong_int(&tmp,info,code);
   161e6:	57                   	push   %edi
   161e7:	56                   	push   %esi
   161e8:	8d 44 24 44          	lea    0x44(%esp),%eax
   161ec:	50                   	push   %eax
   161ed:	8d 44 24 20          	lea    0x20(%esp),%eax
   161f1:	50                   	push   %eax
   161f2:	e8 be 04 00 00       	call   166b5 <get_longlong_int>
   161f7:	e9 18 01 00 00       	jmp    16314 <.L130+0x10>
			put_BCD(PST(0),info,code);
   161fc:	31 c0                	xor    %eax,%eax
   161fe:	e8 2e f2 ff ff       	call   15431 <__st>
   16203:	51                   	push   %ecx
   16204:	56                   	push   %esi
   16205:	8d 54 24 44          	lea    0x44(%esp),%edx
   16209:	52                   	push   %edx
   1620a:	50                   	push   %eax
   1620b:	e8 d4 07 00 00       	call   169e4 <put_BCD>
   16210:	e9 b2 00 00 00       	jmp    162c7 <.L126+0x10>
	switch (code >> 9) {
   16215:	66 c1 ea 09          	shr    $0x9,%dx
   16219:	66 83 fa 01          	cmp    $0x1,%dx
   1621d:	74 36                	je     16255 <math_emulate+0xdd0>
   1621f:	72 1d                	jb     1623e <math_emulate+0xdb9>
   16221:	66 83 fa 02          	cmp    $0x2,%dx
   16225:	75 4a                	jne    16271 <math_emulate+0xdec>
   16227:	89 44 24 08          	mov    %eax,0x8(%esp)
			get_long_real(&tmp,info,code);
   1622b:	55                   	push   %ebp
   1622c:	56                   	push   %esi
   1622d:	8d 54 24 44          	lea    0x44(%esp),%edx
   16231:	52                   	push   %edx
   16232:	8d 54 24 20          	lea    0x20(%esp),%edx
   16236:	52                   	push   %edx
   16237:	e8 45 03 00 00       	call   16581 <get_long_real>
   1623c:	eb 2c                	jmp    1626a <math_emulate+0xde5>
   1623e:	89 44 24 08          	mov    %eax,0x8(%esp)
			get_short_real(&tmp,info,code);
   16242:	50                   	push   %eax
   16243:	56                   	push   %esi
   16244:	8d 54 24 44          	lea    0x44(%esp),%edx
   16248:	52                   	push   %edx
   16249:	8d 54 24 20          	lea    0x20(%esp),%edx
   1624d:	52                   	push   %edx
   1624e:	e8 f4 02 00 00       	call   16547 <get_short_real>
   16253:	eb 15                	jmp    1626a <math_emulate+0xde5>
   16255:	89 44 24 08          	mov    %eax,0x8(%esp)
			get_long_int(&tmp,info,code);
   16259:	50                   	push   %eax
   1625a:	56                   	push   %esi
   1625b:	8d 54 24 44          	lea    0x44(%esp),%edx
   1625f:	52                   	push   %edx
   16260:	8d 54 24 20          	lea    0x20(%esp),%edx
   16264:	52                   	push   %edx
   16265:	e8 f2 03 00 00       	call   1665c <get_long_int>
			get_long_real(&tmp,info,code);
   1626a:	83 c4 10             	add    $0x10,%esp
   1626d:	8b 44 24 08          	mov    0x8(%esp),%eax
	switch ((code>>3) & 0x27) {
   16271:	83 e0 27             	and    $0x27,%eax
   16274:	66 83 f8 07          	cmp    $0x7,%ax
   16278:	0f 87 bb 00 00 00    	ja     16339 <.L130+0x35>
   1627e:	0f b7 c0             	movzwl %ax,%eax
   16281:	8d 74 24 14          	lea    0x14(%esp),%esi
   16285:	8b bc 83 34 8a ff ff 	mov    -0x75cc(%ebx,%eax,4),%edi
   1628c:	01 df                	add    %ebx,%edi
   1628e:	ff e7                	jmp    *%edi

00016290 <.L124>:
			fmul(&tmp,PST(0),&tmp);
   16290:	31 c0                	xor    %eax,%eax
   16292:	e8 9a f1 ff ff       	call   15431 <__st>
   16297:	57                   	push   %edi
   16298:	56                   	push   %esi
   16299:	50                   	push   %eax
   1629a:	56                   	push   %esi
   1629b:	e8 49 09 00 00       	call   16be9 <fmul>
   162a0:	eb 72                	jmp    16314 <.L130+0x10>

000162a2 <.L125>:
			fcom(&tmp,PST(0));
   162a2:	31 c0                	xor    %eax,%eax
   162a4:	e8 88 f1 ff ff       	call   15431 <__st>
   162a9:	51                   	push   %ecx
   162aa:	51                   	push   %ecx
   162ab:	50                   	push   %eax
   162ac:	56                   	push   %esi
   162ad:	e8 58 0c 00 00       	call   16f0a <fcom>
   162b2:	e9 e3 00 00 00       	jmp    1639a <.L130+0x96>

000162b7 <.L126>:
			fcom(&tmp,PST(0));
   162b7:	31 c0                	xor    %eax,%eax
   162b9:	e8 73 f1 ff ff       	call   15431 <__st>
   162be:	52                   	push   %edx
   162bf:	52                   	push   %edx
   162c0:	50                   	push   %eax
   162c1:	56                   	push   %esi
   162c2:	e8 43 0c 00 00       	call   16f0a <fcom>
			fpop();
   162c7:	e8 07 f1 ff ff       	call   153d3 <fpop>
   162cc:	e9 c9 00 00 00       	jmp    1639a <.L130+0x96>

000162d1 <.L127>:
			tmp.exponent ^= 0x8000;
   162d1:	66 81 44 24 1c 00 80 	addw   $0x8000,0x1c(%esp)
   162d8:	eb 0d                	jmp    162e7 <.L184>

000162da <.L128>:
			ST(0).exponent ^= 0x8000;
   162da:	31 c0                	xor    %eax,%eax
   162dc:	e8 50 f1 ff ff       	call   15431 <__st>
   162e1:	66 81 40 08 00 80    	addw   $0x8000,0x8(%eax)

000162e7 <.L184>:
			fadd(&tmp,PST(0),&tmp);
   162e7:	31 c0                	xor    %eax,%eax
   162e9:	e8 43 f1 ff ff       	call   15431 <__st>
   162ee:	55                   	push   %ebp
   162ef:	56                   	push   %esi
   162f0:	50                   	push   %eax
   162f1:	56                   	push   %esi
   162f2:	e9 4d f8 ff ff       	jmp    15b44 <math_emulate+0x6bf>

000162f7 <.L129>:
			fdiv(PST(0),&tmp,&tmp);
   162f7:	31 c0                	xor    %eax,%eax
   162f9:	e8 33 f1 ff ff       	call   15431 <__st>
   162fe:	57                   	push   %edi
   162ff:	56                   	push   %esi
   16300:	56                   	push   %esi
   16301:	50                   	push   %eax
   16302:	eb 0b                	jmp    1630f <.L130+0xb>

00016304 <.L130>:
			fdiv(&tmp,PST(0),&tmp);
   16304:	31 c0                	xor    %eax,%eax
   16306:	e8 26 f1 ff ff       	call   15431 <__st>
   1630b:	51                   	push   %ecx
   1630c:	56                   	push   %esi
   1630d:	50                   	push   %eax
   1630e:	56                   	push   %esi
   1630f:	e8 ba 09 00 00       	call   16cce <fdiv>
			real_to_real(&tmp,&ST(0));
   16314:	31 c0                	xor    %eax,%eax
   16316:	e8 16 f1 ff ff       	call   15431 <__st>
   1631b:	8b 4c 24 24          	mov    0x24(%esp),%ecx
   1631f:	8b 5c 24 28          	mov    0x28(%esp),%ebx
   16323:	89 08                	mov    %ecx,(%eax)
   16325:	89 58 04             	mov    %ebx,0x4(%eax)
   16328:	31 c0                	xor    %eax,%eax
   1632a:	e8 02 f1 ff ff       	call   15431 <__st>
   1632f:	8b 54 24 2c          	mov    0x2c(%esp),%edx
   16333:	66 89 50 08          	mov    %dx,0x8(%eax)
   16337:	eb 61                	jmp    1639a <.L130+0x96>
	if ((code & 0x138) == 0x100) {
   16339:	89 f8                	mov    %edi,%eax
   1633b:	66 25 38 01          	and    $0x138,%ax
   1633f:	66 3d 00 01          	cmp    $0x100,%ax
   16343:	75 2a                	jne    1636f <.L130+0x6b>
			fpush();
   16345:	e8 b8 f0 ff ff       	call   15402 <fpush>
			real_to_real(&tmp,&ST(0));
   1634a:	31 c0                	xor    %eax,%eax
   1634c:	e8 e0 f0 ff ff       	call   15431 <__st>
   16351:	8b 4c 24 14          	mov    0x14(%esp),%ecx
   16355:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   16359:	89 08                	mov    %ecx,(%eax)
   1635b:	89 58 04             	mov    %ebx,0x4(%eax)
   1635e:	31 c0                	xor    %eax,%eax
   16360:	e8 cc f0 ff ff       	call   15431 <__st>
   16365:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   16369:	66 89 50 08          	mov    %dx,0x8(%eax)
   1636d:	eb 2e                	jmp    1639d <.L130+0x99>
	printk("Unknown math-insns: %04x:%08x %04x\n\r",CS,EIP,code);
   1636f:	56                   	push   %esi
   16370:	ff 74 24 78          	pushl  0x78(%esp)
   16374:	0f b7 84 24 80 00 00 	movzwl 0x80(%esp),%eax
   1637b:	00 
   1637c:	50                   	push   %eax
   1637d:	8d 83 c4 89 ff ff    	lea    -0x763c(%ebx),%eax
   16383:	50                   	push   %eax
   16384:	e8 98 1d ff ff       	call   8121 <printk>
	math_abort(info,1<<(SIGFPE-1));
   16389:	58                   	pop    %eax
   1638a:	5a                   	pop    %edx
   1638b:	68 80 00 00 00       	push   $0x80
   16390:	8d 44 24 48          	lea    0x48(%esp),%eax
   16394:	50                   	push   %eax
   16395:	e8 c3 f0 ff ff       	call   1545d <__math_abort>
   1639a:	83 c4 10             	add    $0x10,%esp
}
   1639d:	83 c4 2c             	add    $0x2c,%esp
   163a0:	5b                   	pop    %ebx
   163a1:	5e                   	pop    %esi
   163a2:	5f                   	pop    %edi
   163a3:	5d                   	pop    %ebp
   163a4:	c3                   	ret    

000163a5 <math_error>:

// 协处理器错误中断int 16调用的处理函数。
// 当协处理器检测到自己发生错误时，就会通过ERROR引脚通知CPU。下面代码用于处理协处理器发出的出错信号。并跳转去执行math_error()
// 返回后将跳转到标号ret_from_sys_call处继续执行。
void math_error(void)
{
   163a5:	e8 d0 3a ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   163aa:	05 56 ac 00 00       	add    $0xac56,%eax
	__asm__("fnclex");              // 让80387清除状态字中所有异常标志位和忙位。
   163af:	db e2                	fnclex 
	if (last_task_used_math)        // 若使用了协处理器，则设置协处理器出错信号。
   163b1:	c7 c0 60 2a 02 00    	mov    $0x22a60,%eax
   163b7:	8b 00                	mov    (%eax),%eax
   163b9:	85 c0                	test   %eax,%eax
   163bb:	74 07                	je     163c4 <math_error+0x1f>
		last_task_used_math->signal |= 1<<(SIGFPE-1);
   163bd:	81 48 0c 80 00 00 00 	orl    $0x80,0xc(%eax)
}
   163c4:	c3                   	ret    

000163c5 <ea>:
	return (char *) offset;
}

// 根据指令中寻址模式字节计算有效地址值。
char * ea(struct info * info, unsigned short code)
{
   163c5:	55                   	push   %ebp
   163c6:	57                   	push   %edi
   163c7:	56                   	push   %esi
   163c8:	53                   	push   %ebx
   163c9:	e8 5e 06 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   163ce:	81 c3 32 ac 00 00    	add    $0xac32,%ebx
   163d4:	83 ec 1c             	sub    $0x1c,%esp
   163d7:	8b 44 24 34          	mov    0x34(%esp),%eax
   163db:	8b 54 24 30          	mov    0x30(%esp),%edx
   163df:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
	long * tmp = &EAX;
	int offset = 0;

// 首先取代码中的MOD字段和R/M字段值。如果MOD=0b11，表示是单字节指令，没有偏移字段。如果R/M字段=0b100，并且MOD不为0b11，
// 表示是2字节地址模式寻址，因此调用sib()求出偏移值并返回即可。
	mod = (code >> 6) & 3;          // MOD字段。
   163e5:	89 c1                	mov    %eax,%ecx
	rm = code & 7;                  // R/M字段。
   163e7:	83 e0 07             	and    $0x7,%eax
	mod = (code >> 6) & 3;          // MOD字段。
   163ea:	66 c1 e9 06          	shr    $0x6,%cx
   163ee:	83 e1 03             	and    $0x3,%ecx
	if (rm == 4 && mod != 3)
   163f1:	3c 04                	cmp    $0x4,%al
	mod = (code >> 6) & 3;          // MOD字段。
   163f3:	88 4c 24 0d          	mov    %cl,0xd(%esp)
	if (rm == 4 && mod != 3)
   163f7:	0f 85 9f 00 00 00    	jne    1649c <ea+0xd7>
   163fd:	80 f9 03             	cmp    $0x3,%cl
   16400:	0f 84 96 00 00 00    	je     1649c <ea+0xd7>
	base = get_fs_byte((char *) EIP);
   16406:	8b 72 38             	mov    0x38(%edx),%esi
		return sib(info,mod);
   16409:	0f b6 c1             	movzbl %cl,%eax
		offset = 0;
   1640c:	31 ff                	xor    %edi,%edi
		return sib(info,mod);
   1640e:	89 44 24 08          	mov    %eax,0x8(%esp)
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   16412:	64 8a 0e             	mov    %fs:(%esi),%cl
	EIP++;
   16415:	8d 46 01             	lea    0x1(%esi),%eax
   16418:	89 42 38             	mov    %eax,0x38(%edx)
	ss = base >> 6;                 // 比例因子大小ss。
   1641b:	88 c8                	mov    %cl,%al
   1641d:	c0 e8 06             	shr    $0x6,%al
   16420:	88 44 24 0f          	mov    %al,0xf(%esp)
	index = (base >> 3) & 7;        // 索引值索引代号index。
   16424:	88 c8                	mov    %cl,%al
	base &= 7;                      // 基地址代号base。
   16426:	83 e1 07             	and    $0x7,%ecx
	index = (base >> 3) & 7;        // 索引值索引代号index。
   16429:	c0 e8 03             	shr    $0x3,%al
	base &= 7;                      // 基地址代号base。
   1642c:	88 4c 24 0e          	mov    %cl,0xe(%esp)
	index = (base >> 3) & 7;        // 索引值索引代号index。
   16430:	83 e0 07             	and    $0x7,%eax
	if (index == 4)
   16433:	3c 04                	cmp    $0x4,%al
   16435:	74 0d                	je     16444 <ea+0x7f>
		offset = REG(index);
   16437:	0f b6 c0             	movzbl %al,%eax
   1643a:	8b 84 83 60 8a ff ff 	mov    -0x75a0(%ebx,%eax,4),%eax
   16441:	8b 3c 02             	mov    (%edx,%eax,1),%edi
	offset <<= ss;
   16444:	8a 4c 24 0f          	mov    0xf(%esp),%cl
   16448:	d3 e7                	shl    %cl,%edi
	if (mod || base != 5)
   1644a:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
   1644f:	75 0b                	jne    1645c <ea+0x97>
   16451:	80 7c 24 0e 05       	cmpb   $0x5,0xe(%esp)
   16456:	0f 84 d1 00 00 00    	je     1652d <ea+0x168>
		offset += REG(base);
   1645c:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
   16461:	8b 84 83 60 8a ff ff 	mov    -0x75a0(%ebx,%eax,4),%eax
   16468:	03 3c 02             	add    (%edx,%eax,1),%edi
	if (mod == 1) {
   1646b:	80 7c 24 0d 01       	cmpb   $0x1,0xd(%esp)
   16470:	75 0e                	jne    16480 <ea+0xbb>
   16472:	64 8a 4e 01          	mov    %fs:0x1(%esi),%cl
		offset += (signed char) get_fs_byte((char *) EIP);
   16476:	0f be c9             	movsbl %cl,%ecx
		EIP++;
   16479:	83 c6 02             	add    $0x2,%esi
		offset += (signed char) get_fs_byte((char *) EIP);
   1647c:	01 cf                	add    %ecx,%edi
   1647e:	eb 17                	jmp    16497 <ea+0xd2>
	} else if (mod == 2 || base == 5) {
   16480:	83 7c 24 08 02       	cmpl   $0x2,0x8(%esp)
   16485:	74 07                	je     1648e <ea+0xc9>
   16487:	80 7c 24 0e 05       	cmpb   $0x5,0xe(%esp)
   1648c:	75 27                	jne    164b5 <ea+0xf0>
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   1648e:	64 8b 46 01          	mov    %fs:0x1(%esi),%eax
		EIP += 4;
   16492:	83 c6 05             	add    $0x5,%esi
		offset += (signed) get_fs_long((unsigned long *) EIP);
   16495:	01 c7                	add    %eax,%edi
		EIP += 4;
   16497:	89 72 38             	mov    %esi,0x38(%edx)
   1649a:	eb 19                	jmp    164b5 <ea+0xf0>
// 如果R/M字段为0b101，并且MOD为0，表示是单字节地址模式编码且后随32字节偏移值。于是取出用户代码中4字节偏移值，保存并返回
// 之。
	if (rm == 5 && !mod) {
   1649c:	3c 05                	cmp    $0x5,%al
   1649e:	75 2a                	jne    164ca <ea+0x105>
   164a0:	80 7c 24 0d 00       	cmpb   $0x0,0xd(%esp)
   164a5:	75 23                	jne    164ca <ea+0x105>
		offset = get_fs_long((unsigned long *) EIP);
   164a7:	8b 42 38             	mov    0x38(%edx),%eax
   164aa:	64 8b 18             	mov    %fs:(%eax),%ebx
   164ad:	89 df                	mov    %ebx,%edi
		EIP += 4;
   164af:	83 c0 04             	add    $0x4,%eax
   164b2:	89 42 38             	mov    %eax,0x38(%edx)
		I387.foo = offset;
   164b5:	8b 45 00             	mov    0x0(%ebp),%eax
   164b8:	89 b8 2c 04 00 00    	mov    %edi,0x42c(%eax)
		I387.fos = 0x17;
   164be:	c7 80 30 04 00 00 17 	movl   $0x17,0x430(%eax)
   164c5:	00 00 00 
		return (char *) offset;
   164c8:	eb 73                	jmp    1653d <ea+0x178>
	}
// 对于其余情况，则根据MOD进行处理。首先取出R/M代码对应寄存器内容的值作为指针tmp。对于MOD=0，无偏移值。对于MOD=1，代码后
// 随1字节偏移值。对于MOD=2，代码后有4字节偏移值。最后保存并返回有效地址值。
	tmp = & REG(rm);
   164ca:	0f b6 c0             	movzbl %al,%eax
   164cd:	8b b4 83 60 8a ff ff 	mov    -0x75a0(%ebx,%eax,4),%esi
   164d4:	01 d6                	add    %edx,%esi
	switch (mod) {
   164d6:	80 7c 24 0d 02       	cmpb   $0x2,0xd(%esp)
   164db:	74 1a                	je     164f7 <ea+0x132>
   164dd:	80 7c 24 0d 03       	cmpb   $0x3,0xd(%esp)
   164e2:	74 23                	je     16507 <ea+0x142>
   164e4:	80 7c 24 0d 01       	cmpb   $0x1,0xd(%esp)
   164e9:	75 29                	jne    16514 <ea+0x14f>
		case 0: offset = 0; break;
		case 1:
			offset = (signed char) get_fs_byte((char *) EIP);
   164eb:	8b 4a 38             	mov    0x38(%edx),%ecx
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   164ee:	64 8a 01             	mov    %fs:(%ecx),%al
   164f1:	0f be f8             	movsbl %al,%edi
			EIP++;
   164f4:	41                   	inc    %ecx
   164f5:	eb 0b                	jmp    16502 <ea+0x13d>
			break;
		case 2:
			offset = (signed) get_fs_long((unsigned long *) EIP);
   164f7:	8b 4a 38             	mov    0x38(%edx),%ecx
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   164fa:	64 8b 01             	mov    %fs:(%ecx),%eax
   164fd:	89 c7                	mov    %eax,%edi
			EIP += 4;
   164ff:	83 c1 04             	add    $0x4,%ecx
   16502:	89 4a 38             	mov    %ecx,0x38(%edx)
			break;
   16505:	eb 0f                	jmp    16516 <ea+0x151>
		case 3:
			math_abort(info,1<<(SIGILL-1));
   16507:	50                   	push   %eax
   16508:	50                   	push   %eax
   16509:	6a 08                	push   $0x8
   1650b:	52                   	push   %edx
   1650c:	e8 4c ef ff ff       	call   1545d <__math_abort>
   16511:	83 c4 10             	add    $0x10,%esp
	int offset = 0;
   16514:	31 ff                	xor    %edi,%edi
	}
	I387.foo = offset;
   16516:	8b 45 00             	mov    0x0(%ebp),%eax
   16519:	89 b8 2c 04 00 00    	mov    %edi,0x42c(%eax)
	I387.fos = 0x17;
   1651f:	c7 80 30 04 00 00 17 	movl   $0x17,0x430(%eax)
   16526:	00 00 00 
	return offset + (char *) *tmp;
   16529:	03 3e                	add    (%esi),%edi
   1652b:	eb 10                	jmp    1653d <ea+0x178>
	if (mod == 1) {
   1652d:	80 7c 24 0d 01       	cmpb   $0x1,0xd(%esp)
   16532:	0f 85 56 ff ff ff    	jne    1648e <ea+0xc9>
   16538:	e9 35 ff ff ff       	jmp    16472 <ea+0xad>
}
   1653d:	83 c4 1c             	add    $0x1c,%esp
   16540:	89 f8                	mov    %edi,%eax
   16542:	5b                   	pop    %ebx
   16543:	5e                   	pop    %esi
   16544:	5f                   	pop    %edi
   16545:	5d                   	pop    %ebp
   16546:	c3                   	ret    

00016547 <get_short_real>:
// 根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得短实数所在有效地址（math/ea.c），然后从用户
// 数据区读取相应实数值。最后把用户短实数转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_short_real(temp_real * tmp,
	struct info * info, unsigned short code)
{
   16547:	53                   	push   %ebx
   16548:	e8 df 04 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1654d:	81 c3 b3 aa 00 00    	add    $0xaab3,%ebx
   16553:	83 ec 20             	sub    $0x20,%esp
	char * addr;
	short_real sr;

	addr = ea(info,code);                           // 计算有效地址。
   16556:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   1655b:	50                   	push   %eax
   1655c:	ff 74 24 30          	pushl  0x30(%esp)
   16560:	e8 60 fe ff ff       	call   163c5 <ea>
   16565:	64 8b 00             	mov    %fs:(%eax),%eax
	sr = get_fs_long((unsigned long *) addr);       // 取用户数据区中的值。
   16568:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	short_to_temp(&sr,tmp);                         // 转换成临时实数格式。
   1656c:	58                   	pop    %eax
   1656d:	5a                   	pop    %edx
   1656e:	ff 74 24 28          	pushl  0x28(%esp)
   16572:	8d 44 24 18          	lea    0x18(%esp),%eax
   16576:	50                   	push   %eax
   16577:	e8 d6 09 00 00       	call   16f52 <short_to_temp>
}
   1657c:	83 c4 28             	add    $0x28,%esp
   1657f:	5b                   	pop    %ebx
   16580:	c3                   	ret    

00016581 <get_long_real>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得长实数所在有效地址（math/ec.c），然后从
// 用户数据区读取相应实数值。最后把用户实数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_long_real(temp_real * tmp,
	struct info * info, unsigned short code)
{
   16581:	53                   	push   %ebx
   16582:	e8 a5 04 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   16587:	81 c3 79 aa 00 00    	add    $0xaa79,%ebx
   1658d:	83 ec 20             	sub    $0x20,%esp
	char * addr;
	long_real lr;

	addr = ea(info,code);                           // 取指令中的有效地址。
   16590:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   16595:	50                   	push   %eax
   16596:	ff 74 24 30          	pushl  0x30(%esp)
   1659a:	e8 26 fe ff ff       	call   163c5 <ea>
   1659f:	64 8b 10             	mov    %fs:(%eax),%edx
	lr.a = get_fs_long((unsigned long *) addr);     // 取长8字节实数。
   165a2:	89 54 24 18          	mov    %edx,0x18(%esp)
   165a6:	64 8b 40 04          	mov    %fs:0x4(%eax),%eax
	lr.b = get_fs_long(1 + (unsigned long *) addr); // 转换成临时实数格式。
   165aa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	long_to_temp(&lr,tmp);
   165ae:	58                   	pop    %eax
   165af:	5a                   	pop    %edx
   165b0:	ff 74 24 28          	pushl  0x28(%esp)
   165b4:	8d 44 24 14          	lea    0x14(%esp),%eax
   165b8:	50                   	push   %eax
   165b9:	e8 f8 09 00 00       	call   16fb6 <long_to_temp>
}
   165be:	83 c4 28             	add    $0x28,%esp
   165c1:	5b                   	pop    %ebx
   165c2:	c3                   	ret    

000165c3 <get_temp_real>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得临时实数所在有效地址（math/ea.c），然后
// 从用户数据区读取相应临时实数值。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_temp_real(temp_real * tmp,
	struct info * info, unsigned short code)
{
   165c3:	56                   	push   %esi
   165c4:	53                   	push   %ebx
   165c5:	e8 62 04 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   165ca:	81 c3 36 aa 00 00    	add    $0xaa36,%ebx
   165d0:	83 ec 0c             	sub    $0xc,%esp
	char * addr;

	addr = ea(info,code);           // 取指令中的有效地址值。
   165d3:	0f b7 44 24 20       	movzwl 0x20(%esp),%eax
{
   165d8:	8b 74 24 18          	mov    0x18(%esp),%esi
	addr = ea(info,code);           // 取指令中的有效地址值。
   165dc:	50                   	push   %eax
   165dd:	ff 74 24 20          	pushl  0x20(%esp)
   165e1:	e8 df fd ff ff       	call   163c5 <ea>
   165e6:	64 8b 10             	mov    %fs:(%eax),%edx
	tmp->a = get_fs_long((unsigned long *) addr);
   165e9:	89 16                	mov    %edx,(%esi)
   165eb:	64 8b 50 04          	mov    %fs:0x4(%eax),%edx
	__asm__ ("movw %%fs:%1,%0":"=q" (_v):"m" (*addr));
   165ef:	64 66 8b 40 08       	mov    %fs:0x8(%eax),%ax
	tmp->b = get_fs_long(1 + (unsigned long *) addr);
   165f4:	89 56 04             	mov    %edx,0x4(%esi)
	tmp->exponent = get_fs_word(4 + (unsigned short *) addr);
   165f7:	66 89 46 08          	mov    %ax,0x8(%esi)
}
   165fb:	83 c4 14             	add    $0x14,%esp
   165fe:	5b                   	pop    %ebx
   165ff:	5e                   	pop    %esi
   16600:	c3                   	ret    

00016601 <get_short_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得短整数所在有效地址（math/ea.c）
// 然后从用户数据区读取相应整数值，并保存为临时整数格式。最后把临时整数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_short_int(temp_real * tmp,
	struct info * info, unsigned short code)
{
   16601:	53                   	push   %ebx
   16602:	e8 25 04 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   16607:	81 c3 f9 a9 00 00    	add    $0xa9f9,%ebx
   1660d:	83 ec 20             	sub    $0x20,%esp
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取指令中的有效地址值。
   16610:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   16615:	50                   	push   %eax
   16616:	ff 74 24 30          	pushl  0x30(%esp)
   1661a:	e8 a6 fd ff ff       	call   163c5 <ea>
   1661f:	64 66 8b 00          	mov    %fs:(%eax),%ax
	ti.a = (signed short) get_fs_word((unsigned short *) addr);
   16623:	98                   	cwtl   
	ti.b = 0;
   16624:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   1662b:	00 
	if (ti.sign = (ti.a < 0))       // 若是负数，则设置临时整数符号位。
   1662c:	89 c2                	mov    %eax,%edx
	ti.a = (signed short) get_fs_word((unsigned short *) addr);
   1662e:	89 44 24 14          	mov    %eax,0x14(%esp)
	if (ti.sign = (ti.a < 0))       // 若是负数，则设置临时整数符号位。
   16632:	c1 ea 1f             	shr    $0x1f,%edx
   16635:	66 89 54 24 1c       	mov    %dx,0x1c(%esp)
   1663a:	83 c4 10             	add    $0x10,%esp
   1663d:	85 c0                	test   %eax,%eax
   1663f:	79 06                	jns    16647 <get_short_int+0x46>
		ti.a = - ti.a;          // 临时整数“尾数”部分为无符号数。
   16641:	f7 d8                	neg    %eax
   16643:	89 44 24 04          	mov    %eax,0x4(%esp)
	int_to_real(&ti,tmp);           // 把临时整数转换成临时实数格式。
   16647:	50                   	push   %eax
   16648:	50                   	push   %eax
   16649:	ff 74 24 28          	pushl  0x28(%esp)
   1664d:	8d 44 24 10          	lea    0x10(%esp),%eax
   16651:	50                   	push   %eax
   16652:	e8 61 0c 00 00       	call   172b8 <int_to_real>
}
   16657:	83 c4 28             	add    $0x28,%esp
   1665a:	5b                   	pop    %ebx
   1665b:	c3                   	ret    

0001665c <get_long_int>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得长整数所在有效地址（math/ea.c），然后从
// 用户数据区读取相应整数值，并保存为临时整数格式。最后把临时整数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_long_int(temp_real * tmp,
	struct info * info, unsigned short code)
{
   1665c:	53                   	push   %ebx
   1665d:	e8 ca 03 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   16662:	81 c3 9e a9 00 00    	add    $0xa99e,%ebx
   16668:	83 ec 20             	sub    $0x20,%esp
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取指令中的有效地址值。
   1666b:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   16670:	50                   	push   %eax
   16671:	ff 74 24 30          	pushl  0x30(%esp)
   16675:	e8 4b fd ff ff       	call   163c5 <ea>
	__asm__ ("movl %%fs:%1,%0":"=q" (_v):"m" (*addr)); \
   1667a:	64 8b 00             	mov    %fs:(%eax),%eax
	ti.a = get_fs_long((unsigned long *) addr);
	ti.b = 0;
	if (ti.sign = (ti.a < 0))       // 若是负数，则设置临时整数符号位。
   1667d:	89 c2                	mov    %eax,%edx
	ti.a = get_fs_long((unsigned long *) addr);
   1667f:	89 44 24 14          	mov    %eax,0x14(%esp)
	ti.b = 0;
   16683:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
   1668a:	00 
	if (ti.sign = (ti.a < 0))       // 若是负数，则设置临时整数符号位。
   1668b:	c1 ea 1f             	shr    $0x1f,%edx
   1668e:	66 89 54 24 1c       	mov    %dx,0x1c(%esp)
   16693:	83 c4 10             	add    $0x10,%esp
   16696:	85 c0                	test   %eax,%eax
   16698:	79 06                	jns    166a0 <get_long_int+0x44>
		ti.a = - ti.a;          // 临时整数“尾数”部分为无符号数。
   1669a:	f7 d8                	neg    %eax
   1669c:	89 44 24 04          	mov    %eax,0x4(%esp)
	int_to_real(&ti,tmp);           // 把临时整数转换成临时实数格式。
   166a0:	50                   	push   %eax
   166a1:	50                   	push   %eax
   166a2:	ff 74 24 28          	pushl  0x28(%esp)
   166a6:	8d 44 24 10          	lea    0x10(%esp),%eax
   166aa:	50                   	push   %eax
   166ab:	e8 08 0c 00 00       	call   172b8 <int_to_real>
}
   166b0:	83 c4 28             	add    $0x28,%esp
   166b3:	5b                   	pop    %ebx
   166b4:	c3                   	ret    

000166b5 <get_longlong_int>:
// 首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得64位长整数所有有效地址（math/ea.c），
// 然后从用户数据区读取相应整数值，并保存为临时整数格式。最后再把临时整数值转换成临时实数（math/convert.c）。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_longlong_int(temp_real * tmp,
	struct info * info, unsigned short code)
{
   166b5:	53                   	push   %ebx
   166b6:	e8 71 03 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   166bb:	81 c3 45 a9 00 00    	add    $0xa945,%ebx
   166c1:	83 ec 20             	sub    $0x20,%esp
	char * addr;
	temp_int ti;

	addr = ea(info,code);                           // 取指令中的有效地址值。
   166c4:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   166c9:	50                   	push   %eax
   166ca:	ff 74 24 30          	pushl  0x30(%esp)
   166ce:	e8 f2 fc ff ff       	call   163c5 <ea>
   166d3:	64 8b 10             	mov    %fs:(%eax),%edx
	ti.a = get_fs_long((unsigned long *) addr);     // 取用户64位长整数。
   166d6:	89 54 24 14          	mov    %edx,0x14(%esp)
   166da:	64 8b 40 04          	mov    %fs:0x4(%eax),%eax
	ti.b = get_fs_long(1 + (unsigned long *) addr);
	if (ti.sign = (ti.b < 0))                       // 若是负数则设置临时整数符号位。
   166de:	89 c1                	mov    %eax,%ecx
	ti.b = get_fs_long(1 + (unsigned long *) addr);
   166e0:	89 44 24 18          	mov    %eax,0x18(%esp)
	if (ti.sign = (ti.b < 0))                       // 若是负数则设置临时整数符号位。
   166e4:	c1 e9 1f             	shr    $0x1f,%ecx
   166e7:	66 89 4c 24 1c       	mov    %cx,0x1c(%esp)
   166ec:	83 c4 10             	add    $0x10,%esp
   166ef:	85 c0                	test   %eax,%eax
   166f1:	79 12                	jns    16705 <get_longlong_int+0x50>
		__asm__("notl %0 ; notl %1\n\t"         // 同时取反加1和进位调整。
   166f3:	f7 d2                	not    %edx
   166f5:	f7 d0                	not    %eax
   166f7:	83 c2 01             	add    $0x1,%edx
   166fa:	83 d0 00             	adc    $0x0,%eax
   166fd:	89 54 24 04          	mov    %edx,0x4(%esp)
   16701:	89 44 24 08          	mov    %eax,0x8(%esp)
			"addl $1,%0 ; adcl $0,%1"
			:"=r" (ti.a),"=r" (ti.b)
			:"0" (ti.a),"1" (ti.b));
	int_to_real(&ti,tmp);                           // 把临时整数转换成临时实数格式。
   16705:	50                   	push   %eax
   16706:	50                   	push   %eax
   16707:	ff 74 24 28          	pushl  0x28(%esp)
   1670b:	8d 44 24 10          	lea    0x10(%esp),%eax
   1670f:	50                   	push   %eax
   16710:	e8 a3 0b 00 00       	call   172b8 <int_to_real>
}
   16715:	83 c4 28             	add    $0x28,%esp
   16718:	5b                   	pop    %ebx
   16719:	c3                   	ret    

0001671a <get_BCD>:
// 取用户内存中的BCD码数值并转换成临时实数格式。
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得BCD码所在有效地址（math/ea.c），
// 然后从用户数据区读取10字节相应BCD码值（其中1字节用于符号），同时转换成临时整数形式。最后把临时整数值转换成临时实数。
// 参数：tmp - 转换成临时实数后的指针；info - info结构指针；code - 指令代码。
void get_BCD(temp_real * tmp, struct info * info, unsigned short code)
{
   1671a:	55                   	push   %ebp
   1671b:	57                   	push   %edi
   1671c:	56                   	push   %esi
   1671d:	53                   	push   %ebx
   1671e:	e8 6d a0 ff ff       	call   10790 <__x86.get_pc_thunk.di>
   16723:	81 c7 dd a8 00 00    	add    $0xa8dd,%edi
   16729:	83 ec 34             	sub    $0x34,%esp
	unsigned char c;

// 取得BCD码数值所在内存有效地址。然后从最后1个BCD码字节（最高有效位）开始处理。
// 先取得BCD码数值的符号位，并设置临时整数的符号位。然后把9字节的BCD码值转换成临时整数格式，最后把临时整数值转换成临时
// 实数。
	addr = ea(info,code);                   // 取有效地址。
   1672c:	0f b7 44 24 50       	movzwl 0x50(%esp),%eax
   16731:	89 fb                	mov    %edi,%ebx
   16733:	50                   	push   %eax
   16734:	ff 74 24 50          	pushl  0x50(%esp)
   16738:	e8 88 fc ff ff       	call   163c5 <ea>
	__asm__ ("movb %%fs:%1,%0":"=q" (_v):"m" (*addr));
   1673d:	64 8a 50 09          	mov    %fs:0x9(%eax),%dl
	addr += 9;                              // 指向最后一个（第10个）字节。
	i.sign = 0x80 & get_fs_byte(addr--);    // 取其中符号位。
   16741:	83 e2 80             	and    $0xffffff80,%edx
   16744:	8d 70 08             	lea    0x8(%eax),%esi
   16747:	8d 68 ff             	lea    -0x1(%eax),%ebp
   1674a:	0f b6 d2             	movzbl %dl,%edx
	i.a = i.b = 0;
   1674d:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
   16754:	00 
   16755:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
   1675c:	00 
	i.sign = 0x80 & get_fs_byte(addr--);    // 取其中符号位。
   1675d:	66 89 54 24 2c       	mov    %dx,0x2c(%esp)
   16762:	83 c4 10             	add    $0x10,%esp
   16765:	64 8a 06             	mov    %fs:(%esi),%al
	for (k = 0; k < 9; k++) {               // 转换成临时整数格式。
		c = get_fs_byte(addr--);
		MUL10(i.a, i.b);
   16768:	8b 54 24 18          	mov    0x18(%esp),%edx
   1676c:	88 44 24 0c          	mov    %al,0xc(%esp)
   16770:	4e                   	dec    %esi
   16771:	8b 44 24 14          	mov    0x14(%esp),%eax
   16775:	01 c0                	add    %eax,%eax
   16777:	11 d2                	adc    %edx,%edx
   16779:	89 c1                	mov    %eax,%ecx
   1677b:	89 d3                	mov    %edx,%ebx
   1677d:	01 c0                	add    %eax,%eax
   1677f:	11 d2                	adc    %edx,%edx
   16781:	01 c0                	add    %eax,%eax
   16783:	11 d2                	adc    %edx,%edx
   16785:	01 c8                	add    %ecx,%eax
   16787:	11 da                	adc    %ebx,%edx
		ADD64((c>>4), i.a, i.b);
   16789:	8a 4c 24 0c          	mov    0xc(%esp),%cl
   1678d:	c0 e9 04             	shr    $0x4,%cl
   16790:	0f b6 c9             	movzbl %cl,%ecx
   16793:	01 c8                	add    %ecx,%eax
   16795:	83 d2 00             	adc    $0x0,%edx
		MUL10(i.a, i.b);
   16798:	01 c0                	add    %eax,%eax
   1679a:	11 d2                	adc    %edx,%edx
   1679c:	89 c1                	mov    %eax,%ecx
   1679e:	89 d3                	mov    %edx,%ebx
   167a0:	01 c0                	add    %eax,%eax
   167a2:	11 d2                	adc    %edx,%edx
   167a4:	01 c0                	add    %eax,%eax
   167a6:	11 d2                	adc    %edx,%edx
   167a8:	01 c8                	add    %ecx,%eax
   167aa:	11 da                	adc    %ebx,%edx
		ADD64((c&0xf), i.a, i.b);
   167ac:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   167b0:	83 e1 0f             	and    $0xf,%ecx
   167b3:	01 c8                	add    %ecx,%eax
   167b5:	83 d2 00             	adc    $0x0,%edx
	for (k = 0; k < 9; k++) {               // 转换成临时整数格式。
   167b8:	39 ee                	cmp    %ebp,%esi
		ADD64((c&0xf), i.a, i.b);
   167ba:	89 44 24 14          	mov    %eax,0x14(%esp)
   167be:	89 54 24 18          	mov    %edx,0x18(%esp)
	for (k = 0; k < 9; k++) {               // 转换成临时整数格式。
   167c2:	75 a1                	jne    16765 <get_BCD+0x4b>
	}
	int_to_real(&i,tmp);                    // 转换成临时实数格式。
   167c4:	50                   	push   %eax
   167c5:	50                   	push   %eax
   167c6:	89 fb                	mov    %edi,%ebx
   167c8:	ff 74 24 48          	pushl  0x48(%esp)
   167cc:	8d 44 24 20          	lea    0x20(%esp),%eax
   167d0:	50                   	push   %eax
   167d1:	e8 e2 0a 00 00       	call   172b8 <int_to_real>
}
   167d6:	83 c4 3c             	add    $0x3c,%esp
   167d9:	5b                   	pop    %ebx
   167da:	5e                   	pop    %esi
   167db:	5f                   	pop    %edi
   167dc:	5d                   	pop    %ebp
   167dd:	c3                   	ret    

000167de <put_short_real>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时实
// 数格式的结果转换成短实数格式并存储到有效地址addr处。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_short_real(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   167de:	56                   	push   %esi
   167df:	53                   	push   %ebx
   167e0:	e8 47 02 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   167e5:	81 c3 1b a8 00 00    	add    $0xa81b,%ebx
   167eb:	83 ec 1c             	sub    $0x1c,%esp
	char * addr;
	short_real sr;

	addr = ea(info,code);                           // 取有效地址。
   167ee:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   167f3:	50                   	push   %eax
   167f4:	ff 74 24 30          	pushl  0x30(%esp)
   167f8:	e8 c8 fb ff ff       	call   163c5 <ea>
   167fd:	89 c6                	mov    %eax,%esi
	verify_area(addr,4);                            // 为保存结果验证或分配内存。
   167ff:	58                   	pop    %eax
   16800:	5a                   	pop    %edx
   16801:	6a 04                	push   $0x4
   16803:	56                   	push   %esi
   16804:	e8 e2 13 ff ff       	call   7beb <verify_area>
	temp_to_short(tmp,&sr);                         // 结果转换成短实数格式。
   16809:	59                   	pop    %ecx
   1680a:	58                   	pop    %eax
   1680b:	8d 44 24 14          	lea    0x14(%esp),%eax
   1680f:	50                   	push   %eax
   16810:	ff 74 24 2c          	pushl  0x2c(%esp)
   16814:	e8 11 08 00 00       	call   1702a <temp_to_short>
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   16819:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1681d:	64 89 06             	mov    %eax,%fs:(%esi)
	put_fs_long(sr,(unsigned long *) addr);         // 存储数据到用户内存区。
}
   16820:	83 c4 24             	add    $0x24,%esp
   16823:	5b                   	pop    %ebx
   16824:	5e                   	pop    %esi
   16825:	c3                   	ret    

00016826 <put_long_real>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时
// 实数格式的结果转换成长实数格式，并存储到有效地址addr处。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_long_real(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   16826:	56                   	push   %esi
   16827:	53                   	push   %ebx
   16828:	e8 ff 01 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1682d:	81 c3 d3 a7 00 00    	add    $0xa7d3,%ebx
   16833:	83 ec 1c             	sub    $0x1c,%esp
	char * addr;
	long_real lr;

	addr = ea(info,code);                           // 取有效地址。
   16836:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   1683b:	50                   	push   %eax
   1683c:	ff 74 24 30          	pushl  0x30(%esp)
   16840:	e8 80 fb ff ff       	call   163c5 <ea>
   16845:	89 c6                	mov    %eax,%esi
	verify_area(addr,8);                            // 为保存结果验证或分配内存。
   16847:	58                   	pop    %eax
   16848:	5a                   	pop    %edx
   16849:	6a 08                	push   $0x8
   1684b:	56                   	push   %esi
   1684c:	e8 9a 13 ff ff       	call   7beb <verify_area>
	temp_to_long(tmp,&lr);                          // 结果转换成长实数格式。
   16851:	59                   	pop    %ecx
   16852:	58                   	pop    %eax
   16853:	8d 44 24 10          	lea    0x10(%esp),%eax
   16857:	50                   	push   %eax
   16858:	ff 74 24 2c          	pushl  0x2c(%esp)
   1685c:	e8 6c 08 00 00       	call   170cd <temp_to_long>
   16861:	8b 44 24 18          	mov    0x18(%esp),%eax
   16865:	64 89 06             	mov    %eax,%fs:(%esi)
   16868:	8b 44 24 1c          	mov    0x1c(%esp),%eax
   1686c:	64 89 46 04          	mov    %eax,%fs:0x4(%esi)
	put_fs_long(lr.a, (unsigned long *) addr);      // 存储数据到用户内存区。
	put_fs_long(lr.b, 1 + (unsigned long *) addr);
}
   16870:	83 c4 24             	add    $0x24,%esp
   16873:	5b                   	pop    %ebx
   16874:	5e                   	pop    %esi
   16875:	c3                   	ret    

00016876 <put_temp_real>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临
// 时实数存储到有效地址addr处。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_temp_real(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   16876:	57                   	push   %edi
   16877:	56                   	push   %esi
   16878:	53                   	push   %ebx
   16879:	8b 7c 24 10          	mov    0x10(%esp),%edi
	char * addr;

	addr = ea(info,code);                           // 取有效地址。
   1687d:	50                   	push   %eax
   1687e:	50                   	push   %eax
   1687f:	0f b7 44 24 20       	movzwl 0x20(%esp),%eax
   16884:	e8 a3 01 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   16889:	81 c3 77 a7 00 00    	add    $0xa777,%ebx
   1688f:	50                   	push   %eax
   16890:	ff 74 24 20          	pushl  0x20(%esp)
   16894:	e8 2c fb ff ff       	call   163c5 <ea>
	verify_area(addr,10);                           // 为保存结果验证或分配内存。
   16899:	5a                   	pop    %edx
   1689a:	59                   	pop    %ecx
   1689b:	6a 0a                	push   $0xa
   1689d:	50                   	push   %eax
	addr = ea(info,code);                           // 取有效地址。
   1689e:	89 c6                	mov    %eax,%esi
	verify_area(addr,10);                           // 为保存结果验证或分配内存。
   168a0:	e8 46 13 ff ff       	call   7beb <verify_area>
   168a5:	8b 07                	mov    (%edi),%eax
   168a7:	64 89 06             	mov    %eax,%fs:(%esi)
   168aa:	8b 47 04             	mov    0x4(%edi),%eax
   168ad:	64 89 46 04          	mov    %eax,%fs:0x4(%esi)
__asm__ ("movw %0,%%fs:%1"::"q" (val),"m" (*addr));
   168b1:	8b 47 08             	mov    0x8(%edi),%eax
   168b4:	64 66 89 46 08       	mov    %ax,%fs:0x8(%esi)
	put_fs_long(tmp->a, (unsigned long *) addr);    // 存储数据到用户内存区。
	put_fs_long(tmp->b, 1 + (unsigned long *) addr);
	put_fs_word(tmp->exponent, 4 + (short *) addr);
}
   168b9:	83 c4 10             	add    $0x10,%esp
   168bc:	5b                   	pop    %ebx
   168bd:	5e                   	pop    %esi
   168be:	5f                   	pop    %edi
   168bf:	c3                   	ret    

000168c0 <put_short_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临
// 时实数格式的结果转换成临时整数格式。如果是负数则设置整数符号位。最后把整数保存到用户内存中。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_short_int(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   168c0:	56                   	push   %esi
   168c1:	53                   	push   %ebx
   168c2:	e8 65 01 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   168c7:	81 c3 39 a7 00 00    	add    $0xa739,%ebx
   168cd:	83 ec 1c             	sub    $0x1c,%esp
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取有效地址。
   168d0:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   168d5:	50                   	push   %eax
   168d6:	ff 74 24 30          	pushl  0x30(%esp)
   168da:	e8 e6 fa ff ff       	call   163c5 <ea>
   168df:	89 c6                	mov    %eax,%esi
	real_to_int(tmp,&ti);           // 转换成临时整数格式。
   168e1:	58                   	pop    %eax
   168e2:	5a                   	pop    %edx
   168e3:	8d 44 24 0c          	lea    0xc(%esp),%eax
   168e7:	50                   	push   %eax
   168e8:	ff 74 24 2c          	pushl  0x2c(%esp)
   168ec:	e8 ae 08 00 00       	call   1719f <real_to_int>
	verify_area(addr,2);            // 验证或分配存储内存。
   168f1:	59                   	pop    %ecx
   168f2:	58                   	pop    %eax
   168f3:	6a 02                	push   $0x2
   168f5:	56                   	push   %esi
   168f6:	e8 f0 12 ff ff       	call   7beb <verify_area>
	if (ti.sign)                    // 若有符号位，则取负数值。
   168fb:	83 c4 10             	add    $0x10,%esp
   168fe:	66 83 7c 24 0c 00    	cmpw   $0x0,0xc(%esp)
   16904:	74 04                	je     1690a <put_short_int+0x4a>
		ti.a = -ti.a;
   16906:	f7 5c 24 04          	negl   0x4(%esp)
	put_fs_word(ti.a,(short *) addr);       // 存储到用户数据区中。
   1690a:	8b 44 24 04          	mov    0x4(%esp),%eax
   1690e:	64 66 89 06          	mov    %ax,%fs:(%esi)
}
   16912:	83 c4 14             	add    $0x14,%esp
   16915:	5b                   	pop    %ebx
   16916:	5e                   	pop    %esi
   16917:	c3                   	ret    

00016918 <put_long_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时
// 实数格式的结果转换成临时整数格式。如果是负数则设置整数符号位。最后把整数保存到用户内存中。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_long_int(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   16918:	56                   	push   %esi
   16919:	53                   	push   %ebx
   1691a:	e8 0d 01 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   1691f:	81 c3 e1 a6 00 00    	add    $0xa6e1,%ebx
   16925:	83 ec 1c             	sub    $0x1c,%esp
	char * addr;
	temp_int ti;

	addr = ea(info,code);                           // 取有效地址值。
   16928:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   1692d:	50                   	push   %eax
   1692e:	ff 74 24 30          	pushl  0x30(%esp)
   16932:	e8 8e fa ff ff       	call   163c5 <ea>
   16937:	89 c6                	mov    %eax,%esi
	real_to_int(tmp,&ti);                           // 转换成临时整数格式。
   16939:	58                   	pop    %eax
   1693a:	5a                   	pop    %edx
   1693b:	8d 44 24 0c          	lea    0xc(%esp),%eax
   1693f:	50                   	push   %eax
   16940:	ff 74 24 2c          	pushl  0x2c(%esp)
   16944:	e8 56 08 00 00       	call   1719f <real_to_int>
	verify_area(addr,4);                            // 验证或分配存储内存。
   16949:	59                   	pop    %ecx
   1694a:	58                   	pop    %eax
   1694b:	6a 04                	push   $0x4
   1694d:	56                   	push   %esi
   1694e:	e8 98 12 ff ff       	call   7beb <verify_area>
	if (ti.sign)                                    // 若有符号位，则取负数值。
   16953:	83 c4 10             	add    $0x10,%esp
   16956:	66 83 7c 24 0c 00    	cmpw   $0x0,0xc(%esp)
   1695c:	74 04                	je     16962 <put_long_int+0x4a>
		ti.a = -ti.a;
   1695e:	f7 5c 24 04          	negl   0x4(%esp)
__asm__ ("movl %0,%%fs:%1"::"q" (val),"m" (*addr));
   16962:	8b 44 24 04          	mov    0x4(%esp),%eax
   16966:	64 89 06             	mov    %eax,%fs:(%esi)
	put_fs_long(ti.a,(unsigned long *) addr);       // 存储到用户数据区中。
}
   16969:	83 c4 14             	add    $0x14,%esp
   1696c:	5b                   	pop    %ebx
   1696d:	5e                   	pop    %esi
   1696e:	c3                   	ret    

0001696f <put_longlong_int>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，然后把临时
// 实数格式的结果转换成临时整数格式。如果是负数则设置整数符号位。最后把整数保存到用户内存中。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_longlong_int(const temp_real * tmp,
	struct info * info, unsigned short code)
{
   1696f:	56                   	push   %esi
   16970:	53                   	push   %ebx
   16971:	e8 b6 00 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   16976:	81 c3 8a a6 00 00    	add    $0xa68a,%ebx
   1697c:	83 ec 1c             	sub    $0x1c,%esp
	char * addr;
	temp_int ti;

	addr = ea(info,code);           // 取有效地址。
   1697f:	0f b7 44 24 30       	movzwl 0x30(%esp),%eax
   16984:	50                   	push   %eax
   16985:	ff 74 24 30          	pushl  0x30(%esp)
   16989:	e8 37 fa ff ff       	call   163c5 <ea>
   1698e:	89 c6                	mov    %eax,%esi
	real_to_int(tmp,&ti);           // 转换成临时整数格式。
   16990:	58                   	pop    %eax
   16991:	5a                   	pop    %edx
   16992:	8d 44 24 0c          	lea    0xc(%esp),%eax
   16996:	50                   	push   %eax
   16997:	ff 74 24 2c          	pushl  0x2c(%esp)
   1699b:	e8 ff 07 00 00       	call   1719f <real_to_int>
	verify_area(addr,8);            // 验证存储区域。
   169a0:	59                   	pop    %ecx
   169a1:	58                   	pop    %eax
   169a2:	6a 08                	push   $0x8
   169a4:	56                   	push   %esi
   169a5:	e8 41 12 ff ff       	call   7beb <verify_area>
	if (ti.sign)                    // 若是负数，则取反加1。
   169aa:	83 c4 10             	add    $0x10,%esp
   169ad:	66 83 7c 24 0c 00    	cmpw   $0x0,0xc(%esp)
   169b3:	74 1a                	je     169cf <put_longlong_int+0x60>
		__asm__("notl %0 ; notl %1\n\t"
   169b5:	8b 4c 24 04          	mov    0x4(%esp),%ecx
   169b9:	8b 54 24 08          	mov    0x8(%esp),%edx
   169bd:	f7 d1                	not    %ecx
   169bf:	f7 d2                	not    %edx
   169c1:	83 c1 01             	add    $0x1,%ecx
   169c4:	83 d2 00             	adc    $0x0,%edx
   169c7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
   169cb:	89 54 24 08          	mov    %edx,0x8(%esp)
   169cf:	8b 44 24 04          	mov    0x4(%esp),%eax
   169d3:	64 89 06             	mov    %eax,%fs:(%esi)
   169d6:	8b 44 24 08          	mov    0x8(%esp),%eax
   169da:	64 89 46 04          	mov    %eax,%fs:0x4(%esi)
			"addl $1,%0 ; adcl $0,%1"
			:"=r" (ti.a),"=r" (ti.b)
			:"0" (ti.a),"1" (ti.b));
	put_fs_long(ti.a,(unsigned long *) addr);       // 存储到用户数据区中。
	put_fs_long(ti.b,1 + (unsigned long *) addr);
}
   169de:	83 c4 14             	add    $0x14,%esp
   169e1:	5b                   	pop    %ebx
   169e2:	5e                   	pop    %esi
   169e3:	c3                   	ret    

000169e4 <put_BCD>:
// 该函数首先根据浮点指令代码中寻址模式字节中的内容和info结构中当前寄存器中的内容，取得保存结果的有效地址addr，并验证保
// 存10字节BCD码的用户空间。然后把临时实数格式的结果转换成BCD码格式的数据并保存到用户内存中。如果是负数则设置最高存储字
// 节的最高有效位。
// 参数：tmp - 临时实数格式结果值；info - info结构指针；code - 指令代码。
void put_BCD(const temp_real * tmp,struct info * info, unsigned short code)
{
   169e4:	55                   	push   %ebp
   169e5:	57                   	push   %edi
   169e6:	56                   	push   %esi
   169e7:	53                   	push   %ebx
   169e8:	e8 3f 00 ff ff       	call   6a2c <__x86.get_pc_thunk.bx>
   169ed:	81 c3 13 a6 00 00    	add    $0xa613,%ebx
   169f3:	83 ec 34             	sub    $0x34,%esp
	int k,rem;
	char * addr;
	temp_int i;
	unsigned char c;

	addr = ea(info,code);                   // 取有效地址。
   169f6:	0f b7 44 24 50       	movzwl 0x50(%esp),%eax
   169fb:	50                   	push   %eax
   169fc:	ff 74 24 50          	pushl  0x50(%esp)
   16a00:	e8 c0 f9 ff ff       	call   163c5 <ea>
	verify_area(addr,10);                   // 验证存储空间容量。
   16a05:	5a                   	pop    %edx
   16a06:	59                   	pop    %ecx
   16a07:	6a 0a                	push   $0xa
   16a09:	50                   	push   %eax
	addr = ea(info,code);                   // 取有效地址。
   16a0a:	89 c7                	mov    %eax,%edi
	verify_area(addr,10);                   // 验证存储空间容量。
   16a0c:	e8 da 11 ff ff       	call   7beb <verify_area>
	real_to_int(tmp,&i);                    // 转换成临时整数格式。
   16a11:	5e                   	pop    %esi
   16a12:	5d                   	pop    %ebp
   16a13:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   16a17:	50                   	push   %eax
   16a18:	ff 74 24 4c          	pushl  0x4c(%esp)
   16a1c:	e8 7e 07 00 00       	call   1719f <real_to_int>
	if (i.sign)                             // 若是负数，则设置符号字节最高有效位。
   16a21:	83 c4 10             	add    $0x10,%esp
__asm__ ("movb %0,%%fs:%1"::"q" (val),"m" (*addr));
   16a24:	b0 80                	mov    $0x80,%al
   16a26:	66 83 7c 24 1c 00    	cmpw   $0x0,0x1c(%esp)
   16a2c:	75 02                	jne    16a30 <put_BCD+0x4c>
   16a2e:	31 c0                	xor    %eax,%eax
   16a30:	64 88 47 09          	mov    %al,%fs:0x9(%edi)
   16a34:	8d 47 09             	lea    0x9(%edi),%eax
		put_fs_byte(0x80, addr+9);
	else                                    // 否则符号字节设置为0。
		put_fs_byte(0, addr+9);
	for (k = 0; k < 9; k++) {               // 临时整数转换成BCD码并保存。
		DIV10(i.a,i.b,rem);
   16a37:	31 ed                	xor    %ebp,%ebp
   16a39:	b9 0a 00 00 00       	mov    $0xa,%ecx
   16a3e:	89 44 24 08          	mov    %eax,0x8(%esp)
   16a42:	8b 44 24 18          	mov    0x18(%esp),%eax
   16a46:	8b 5c 24 14          	mov    0x14(%esp),%ebx
   16a4a:	89 ea                	mov    %ebp,%edx
   16a4c:	f7 f1                	div    %ecx
   16a4e:	93                   	xchg   %eax,%ebx
   16a4f:	f7 f1                	div    %ecx
		c = rem;
		DIV10(i.a,i.b,rem);
   16a51:	89 de                	mov    %ebx,%esi
		DIV10(i.a,i.b,rem);
   16a53:	89 54 24 0c          	mov    %edx,0xc(%esp)
		DIV10(i.a,i.b,rem);
   16a57:	89 c3                	mov    %eax,%ebx
   16a59:	89 ea                	mov    %ebp,%edx
   16a5b:	89 f0                	mov    %esi,%eax
   16a5d:	f7 f1                	div    %ecx
   16a5f:	93                   	xchg   %eax,%ebx
   16a60:	f7 f1                	div    %ecx
   16a62:	89 44 24 14          	mov    %eax,0x14(%esp)
		c += rem<<4;
   16a66:	c1 e2 04             	shl    $0x4,%edx
		DIV10(i.a,i.b,rem);
   16a69:	89 5c 24 18          	mov    %ebx,0x18(%esp)
		put_fs_byte(c,addr++);
   16a6d:	8d 47 01             	lea    0x1(%edi),%eax
		c += rem<<4;
   16a70:	03 54 24 0c          	add    0xc(%esp),%edx
   16a74:	64 88 17             	mov    %dl,%fs:(%edi)
	for (k = 0; k < 9; k++) {               // 临时整数转换成BCD码并保存。
   16a77:	39 44 24 08          	cmp    %eax,0x8(%esp)
   16a7b:	89 c7                	mov    %eax,%edi
   16a7d:	75 c3                	jne    16a42 <put_BCD+0x5e>
	}
   16a7f:	83 c4 2c             	add    $0x2c,%esp
   16a82:	5b                   	pop    %ebx
   16a83:	5e                   	pop    %esi
   16a84:	5f                   	pop    %edi
   16a85:	5d                   	pop    %ebp
   16a86:	c3                   	ret    

00016a87 <signify>:
{
// 把64位二进制尾数右移2位（因此指数需要加2）。因为指针字段exponent的最高位是符号位，所以若指数值小于零，说明该数是负数。
// 于是则把尾数用补码表示（取负）。然后把指数取正值。此时尾数中不仅包含移过2位的有效数，而且还包含数值的符号位。
// 30行上：%0 - a->a；%1 - a->b。汇编指令“shrdl $2, %1, %0”执行双精度（64位）右移，即把组合尾数<b,a>右移2位。由于
// 该移动操作不会改变%1（a->b）中的值，因此还需要单独对其右移2位。
	a->exponent += 2;
   16a87:	66 83 40 08 02       	addw   $0x2,0x8(%eax)
	__asm__("shrdl $2,%1,%0 ; shrl $2,%1"   // 使用双精度指令把尾数右移2位。
   16a8c:	8b 08                	mov    (%eax),%ecx
   16a8e:	8b 50 04             	mov    0x4(%eax),%edx
   16a91:	0f ac d1 02          	shrd   $0x2,%edx,%ecx
   16a95:	c1 ea 02             	shr    $0x2,%edx
		:"=r" (a->a),"=r" (a->b)
		:"0" (a->a),"1" (a->b));
	if (a->exponent < 0)                    // 是负数，则尾数用补码表示（取负值）。
   16a98:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
	__asm__("shrdl $2,%1,%0 ; shrl $2,%1"   // 使用双精度指令把尾数右移2位。
   16a9d:	89 08                	mov    %ecx,(%eax)
   16a9f:	89 50 04             	mov    %edx,0x4(%eax)
	if (a->exponent < 0)                    // 是负数，则尾数用补码表示（取负值）。
   16aa2:	79 0f                	jns    16ab3 <signify+0x2c>
		NEGINT(a);
   16aa4:	f7 d1                	not    %ecx
   16aa6:	f7 d2                	not    %edx
   16aa8:	83 c1 01             	add    $0x1,%ecx
   16aab:	83 d2 00             	adc    $0x0,%edx
   16aae:	89 08                	mov    %ecx,(%eax)
   16ab0:	89 50 04             	mov    %edx,0x4(%eax)
	a->exponent &= 0x7fff;                  // 去掉符号位（若有）。
   16ab3:	66 81 60 08 ff 7f    	andw   $0x7fff,0x8(%eax)
}
   16ab9:	c3                   	ret    

00016aba <fadd>:
}

// 仿真浮点加法指令运算。
// 临时实数参数src1 + src2 -> result。
void fadd(const temp_real * src1, const temp_real * src2, temp_real * result)
{
   16aba:	55                   	push   %ebp
   16abb:	57                   	push   %edi

// 首先取两个数的指数值x1、x2（去掉符号位）。然后让变量a等于基中最大值，shift为指数差值（即相差2的倍数值）。
	x1 = src1->exponent & 0x7fff;
	x2 = src2->exponent & 0x7fff;
	if (x1 > x2) {
		a = *src1;
   16abc:	b9 03 00 00 00       	mov    $0x3,%ecx
{
   16ac1:	56                   	push   %esi
   16ac2:	53                   	push   %ebx
   16ac3:	83 ec 24             	sub    $0x24,%esp
	x2 = src2->exponent & 0x7fff;
   16ac6:	8b 44 24 3c          	mov    0x3c(%esp),%eax
{
   16aca:	8b 54 24 38          	mov    0x38(%esp),%edx
   16ace:	8d 74 24 18          	lea    0x18(%esp),%esi
   16ad2:	89 34 24             	mov    %esi,(%esp)
	x2 = src2->exponent & 0x7fff;
   16ad5:	8b 58 08             	mov    0x8(%eax),%ebx
	x1 = src1->exponent & 0x7fff;
   16ad8:	8b 6a 08             	mov    0x8(%edx),%ebp
   16adb:	8d 44 24 0c          	lea    0xc(%esp),%eax
		a = *src1;
   16adf:	89 c7                	mov    %eax,%edi
	x1 = src1->exponent & 0x7fff;
   16ae1:	81 e5 ff 7f 00 00    	and    $0x7fff,%ebp
	x2 = src2->exponent & 0x7fff;
   16ae7:	81 e3 ff 7f 00 00    	and    $0x7fff,%ebx
	if (x1 > x2) {
   16aed:	39 dd                	cmp    %ebx,%ebp
   16aef:	7e 18                	jle    16b09 <fadd+0x4f>
		a = *src1;
   16af1:	89 d6                	mov    %edx,%esi
   16af3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		b = *src2;
   16af5:	b9 03 00 00 00       	mov    $0x3,%ecx
   16afa:	8b 3c 24             	mov    (%esp),%edi
   16afd:	8b 74 24 3c          	mov    0x3c(%esp),%esi
   16b01:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		shift = x1-x2;
   16b03:	89 e9                	mov    %ebp,%ecx
   16b05:	29 d9                	sub    %ebx,%ecx
   16b07:	eb 16                	jmp    16b1f <fadd+0x65>
	} else {
		a = *src2;
		b = *src1;
		shift = x2-x1;
   16b09:	29 eb                	sub    %ebp,%ebx
		a = *src2;
   16b0b:	8b 74 24 3c          	mov    0x3c(%esp),%esi
   16b0f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		b = *src1;
   16b11:	b9 03 00 00 00       	mov    $0x3,%ecx
   16b16:	8b 3c 24             	mov    (%esp),%edi
   16b19:	89 d6                	mov    %edx,%esi
   16b1b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		shift = x2-x1;
   16b1d:	89 d9                	mov    %ebx,%ecx
	}
// 若两者相差太大，大于等于2的64次方，则我们可以忽略小的那个数，即b值。于是直接返回a值即可。否则，若相差大于等于2的32次
// 方，那么我们可以忽略小值b中的低32位值。于是我们把b的高long字段值b.b右移32位，即放到b.a中。然后把b的指数值相应地增加
// 32次方。即指数差值减去32。这样调整之后，相加的两个数的尾数基本上落在相同区域中。
	if (shift >= 64) {
   16b1f:	83 f9 3f             	cmp    $0x3f,%ecx
   16b22:	7e 17                	jle    16b3b <fadd+0x81>
		*result = a;
   16b24:	8d 74 24 0c          	lea    0xc(%esp),%esi
   16b28:	8b 7c 24 40          	mov    0x40(%esp),%edi
   16b2c:	b9 03 00 00 00       	mov    $0x3,%ecx
   16b31:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	__asm__("addl %4,%0 ; adcl %5,%1"                       // 执行加法运算。
		:"=r" (a.a),"=r" (a.b)
		:"0" (a.a),"1" (a.b),"g" (b.a),"g" (b.b));
	unsignify(&a);                                          // 再变换回临时实数格式。
	*result = a;
}
   16b33:	83 c4 24             	add    $0x24,%esp
   16b36:	5b                   	pop    %ebx
   16b37:	5e                   	pop    %esi
   16b38:	5f                   	pop    %edi
   16b39:	5d                   	pop    %ebp
   16b3a:	c3                   	ret    
	if (shift >= 32) {
   16b3b:	83 f9 1f             	cmp    $0x1f,%ecx
   16b3e:	7e 13                	jle    16b53 <fadd+0x99>
		b.a = b.b;
   16b40:	8b 54 24 1c          	mov    0x1c(%esp),%edx
		shift -= 32;
   16b44:	83 e9 20             	sub    $0x20,%ecx
		b.b = 0;
   16b47:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
   16b4e:	00 
		b.a = b.b;
   16b4f:	89 54 24 18          	mov    %edx,0x18(%esp)
	__asm__("shrdl %4,%1,%0 ; shrl %4,%1"                   // 双精度（64位）右移。
   16b53:	8b 5c 24 18          	mov    0x18(%esp),%ebx
   16b57:	8b 54 24 1c          	mov    0x1c(%esp),%edx
   16b5b:	0f ad d3             	shrd   %cl,%edx,%ebx
   16b5e:	d3 ea                	shr    %cl,%edx
   16b60:	89 54 24 1c          	mov    %edx,0x1c(%esp)
   16b64:	89 5c 24 18          	mov    %ebx,0x18(%esp)
	signify(&a);                                            // 变换格式。
   16b68:	e8 1a ff ff ff       	call   16a87 <signify>
	signify(&b);
   16b6d:	8b 04 24             	mov    (%esp),%eax
   16b70:	e8 12 ff ff ff       	call   16a87 <signify>
	__asm__("addl %4,%0 ; adcl %5,%1"                       // 执行加法运算。
   16b75:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16b79:	8b 54 24 10          	mov    0x10(%esp),%edx
   16b7d:	03 44 24 18          	add    0x18(%esp),%eax
   16b81:	13 54 24 1c          	adc    0x1c(%esp),%edx
	if (!(a->a || a->b)) {                          // 若值为0就返回。
   16b85:	85 c0                	test   %eax,%eax
	__asm__("addl %4,%0 ; adcl %5,%1"                       // 执行加法运算。
   16b87:	89 44 24 0c          	mov    %eax,0xc(%esp)
   16b8b:	89 54 24 10          	mov    %edx,0x10(%esp)
	if (!(a->a || a->b)) {                          // 若值为0就返回。
   16b8f:	75 0d                	jne    16b9e <fadd+0xe4>
   16b91:	85 d2                	test   %edx,%edx
   16b93:	75 09                	jne    16b9e <fadd+0xe4>
		a->exponent = 0;
   16b95:	66 c7 44 24 14 00 00 	movw   $0x0,0x14(%esp)
   16b9c:	eb 86                	jmp    16b24 <fadd+0x6a>
	if (a->b < 0) {                                 // 去负数，则尾数取正值。
   16b9e:	8b 54 24 10          	mov    0x10(%esp),%edx
	a->exponent &= 0x7fff;                          // 去掉符号位（若有）。
   16ba2:	66 81 64 24 14 ff 7f 	andw   $0x7fff,0x14(%esp)
	if (a->b < 0) {                                 // 去负数，则尾数取正值。
   16ba9:	85 d2                	test   %edx,%edx
   16bab:	79 19                	jns    16bc6 <fadd+0x10c>
		a->exponent |= 0x8000;                  // 临时实数添加置符号位。
   16bad:	66 81 4c 24 14 00 80 	orw    $0x8000,0x14(%esp)
		NEGINT(a);
   16bb4:	f7 d0                	not    %eax
   16bb6:	f7 d2                	not    %edx
   16bb8:	83 c0 01             	add    $0x1,%eax
   16bbb:	83 d2 00             	adc    $0x0,%edx
   16bbe:	89 44 24 0c          	mov    %eax,0xc(%esp)
   16bc2:	89 54 24 10          	mov    %edx,0x10(%esp)
	while (a->b >= 0) {                             // 对尾数进行规格化处理。
   16bc6:	8b 44 24 10          	mov    0x10(%esp),%eax
   16bca:	85 c0                	test   %eax,%eax
   16bcc:	0f 88 52 ff ff ff    	js     16b24 <fadd+0x6a>
		__asm__("addl %0,%0 ; adcl %1,%1"
   16bd2:	8b 54 24 0c          	mov    0xc(%esp),%edx
		a->exponent--;
   16bd6:	66 ff 4c 24 14       	decw   0x14(%esp)
		__asm__("addl %0,%0 ; adcl %1,%1"
   16bdb:	01 d2                	add    %edx,%edx
   16bdd:	11 c0                	adc    %eax,%eax
   16bdf:	89 54 24 0c          	mov    %edx,0xc(%esp)
   16be3:	89 44 24 10          	mov    %eax,0x10(%esp)
   16be7:	eb dd                	jmp    16bc6 <fadd+0x10c>

00016be9 <fmul>:
}

// 仿真浮点指令FMUL。
// 临时实数src1 * src2 -> result处。
void fmul(const temp_real * src1, const temp_real * src2, temp_real * result)
{
   16be9:	55                   	push   %ebp
   16bea:	57                   	push   %edi
	int i,sign;
	int tmp[4] = {0,0,0,0};
   16beb:	31 c0                	xor    %eax,%eax
{
   16bed:	56                   	push   %esi
   16bee:	53                   	push   %ebx
	int tmp[4] = {0,0,0,0};
   16bef:	b9 04 00 00 00       	mov    $0x4,%ecx
   16bf4:	e8 2f fe fe ff       	call   6a28 <__x86.get_pc_thunk.dx>
   16bf9:	81 c2 07 a4 00 00    	add    $0xa407,%edx
{
   16bff:	83 ec 10             	sub    $0x10,%esp
   16c02:	8b 5c 24 24          	mov    0x24(%esp),%ebx
	int tmp[4] = {0,0,0,0};
   16c06:	89 e7                	mov    %esp,%edi
{
   16c08:	8b 74 24 2c          	mov    0x2c(%esp),%esi
	int tmp[4] = {0,0,0,0};
   16c0c:	f3 ab                	rep stos %eax,%es:(%edi)

// 首先确定两数相乘的符号。符号值等于两者符号位异或值。然后计算乘后的指数值。相乘时指数值需要相加。但是由于指数使用偏置
// 格式保存，两个数的指数相加时偏置量也被加了两次，因此需要减掉一个偏置量值（临时实数的偏置量是16383）。
	sign = (src1->exponent ^ src2->exponent) & 0x8000;
   16c0e:	8b 44 24 28          	mov    0x28(%esp),%eax
   16c12:	8b 4b 08             	mov    0x8(%ebx),%ecx
   16c15:	8b 40 08             	mov    0x8(%eax),%eax
   16c18:	89 cd                	mov    %ecx,%ebp
	i = (src1->exponent & 0x7fff) + (src2->exponent & 0x7fff) - 16383 + 1;
   16c1a:	81 e1 ff 7f 00 00    	and    $0x7fff,%ecx
	sign = (src1->exponent ^ src2->exponent) & 0x8000;
   16c20:	31 c5                	xor    %eax,%ebp
	i = (src1->exponent & 0x7fff) + (src2->exponent & 0x7fff) - 16383 + 1;
   16c22:	25 ff 7f 00 00       	and    $0x7fff,%eax
   16c27:	8d 84 01 02 c0 ff ff 	lea    -0x3ffe(%ecx,%eax,1),%eax
	sign = (src1->exponent ^ src2->exponent) & 0x8000;
   16c2e:	81 e5 00 80 00 00    	and    $0x8000,%ebp
// 如果结果指数变成了负值，表示两数相乘后产生下溢。于是直接返回带符号的零值。如果结果指数大于0x7fff，表示产生上溢，于是
// 设置状态字溢出异常标志位，并返回。
	if (i<0) {
   16c34:	85 c0                	test   %eax,%eax
   16c36:	79 13                	jns    16c4b <fmul+0x62>
		result->exponent = sign;
   16c38:	66 89 6e 08          	mov    %bp,0x8(%esi)
		result->a = result->b = 0;
   16c3c:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
   16c43:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		return;
   16c49:	eb 62                	jmp    16cad <fmul+0xc4>
	}
	if (i>0x7fff) {
   16c4b:	3d ff 7f 00 00       	cmp    $0x7fff,%eax
   16c50:	7e 11                	jle    16c63 <fmul+0x7a>
		set_OE();       // 置位溢出标志位。
   16c52:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   16c58:	8b 00                	mov    (%eax),%eax
   16c5a:	83 88 1c 04 00 00 08 	orl    $0x8,0x41c(%eax)
		return;
   16c61:	eb 4a                	jmp    16cad <fmul+0xc4>
	__asm__("movl (%0),%%eax\n\t"           // 取a->a的值到eax。
   16c63:	89 e7                	mov    %esp,%edi
   16c65:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   16c69:	8b 03                	mov    (%ebx),%eax
   16c6b:	f7 21                	mull   (%ecx)
   16c6d:	89 07                	mov    %eax,(%edi)
   16c6f:	89 57 04             	mov    %edx,0x4(%edi)
   16c72:	8b 43 04             	mov    0x4(%ebx),%eax
   16c75:	f7 61 04             	mull   0x4(%ecx)
   16c78:	89 47 08             	mov    %eax,0x8(%edi)
   16c7b:	89 57 0c             	mov    %edx,0xc(%edi)
   16c7e:	8b 03                	mov    (%ebx),%eax
   16c80:	f7 61 04             	mull   0x4(%ecx)
   16c83:	01 47 04             	add    %eax,0x4(%edi)
   16c86:	11 57 08             	adc    %edx,0x8(%edi)
   16c89:	83 57 0c 00          	adcl   $0x0,0xc(%edi)
   16c8d:	8b 43 04             	mov    0x4(%ebx),%eax
   16c90:	f7 21                	mull   (%ecx)
   16c92:	01 47 04             	add    %eax,0x4(%edi)
   16c95:	11 57 08             	adc    %edx,0x8(%edi)
   16c98:	83 57 0c 00          	adcl   $0x0,0xc(%edi)
			i--;
			shift(tmp);
		}
	else
		i = 0;
	result->exponent = i | sign;
   16c9c:	66 89 6e 08          	mov    %bp,0x8(%esi)
	result->a = tmp[2];
   16ca0:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	result->b = tmp[3];
   16ca6:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
}
   16cad:	83 c4 10             	add    $0x10,%esp
   16cb0:	5b                   	pop    %ebx
   16cb1:	5e                   	pop    %esi
   16cb2:	5f                   	pop    %edi
   16cb3:	5d                   	pop    %ebp
   16cb4:	c3                   	ret    

00016cb5 <shift_left>:

#include <linux/math_emu.h>

// 将指针c指向的4字节中内容左移1位。
static void shift_left(int * c)
{
   16cb5:	89 c2                	mov    %eax,%edx
	__asm__ __volatile__("movl (%0),%%eax ; addl %%eax,(%0)\n\t"
   16cb7:	8b 02                	mov    (%edx),%eax
   16cb9:	01 02                	add    %eax,(%edx)
   16cbb:	8b 42 04             	mov    0x4(%edx),%eax
   16cbe:	11 42 04             	adc    %eax,0x4(%edx)
   16cc1:	8b 42 08             	mov    0x8(%edx),%eax
   16cc4:	11 42 08             	adc    %eax,0x8(%edx)
   16cc7:	8b 42 0c             	mov    0xc(%edx),%eax
   16cca:	11 42 0c             	adc    %eax,0xc(%edx)
		"movl 4(%0),%%eax ; adcl %%eax,4(%0)\n\t"
		"movl 8(%0),%%eax ; adcl %%eax,8(%0)\n\t"
		"movl 12(%0),%%eax ; adcl %%eax,12(%0)"
		::"r" ((long) c):"ax");
}
   16ccd:	c3                   	ret    

00016cce <fdiv>:
}

// 仿真浮点指令FDIV。
// 临时实数src1 / src2 -> result处。
void fdiv(const temp_real * src1, const temp_real * src2, temp_real * result)
{
   16cce:	55                   	push   %ebp
   16ccf:	57                   	push   %edi
	int i,sign;
	int a[4],b[4],tmp[4] = {0,0,0,0};
   16cd0:	31 c0                	xor    %eax,%eax
{
   16cd2:	56                   	push   %esi
   16cd3:	53                   	push   %ebx
	int a[4],b[4],tmp[4] = {0,0,0,0};
   16cd4:	b9 04 00 00 00       	mov    $0x4,%ecx
   16cd9:	e8 a4 31 ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   16cde:	81 c6 22 a3 00 00    	add    $0xa322,%esi
{
   16ce4:	83 ec 3c             	sub    $0x3c,%esp
	int a[4],b[4],tmp[4] = {0,0,0,0};
   16ce7:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
{
   16ceb:	8b 54 24 54          	mov    0x54(%esp),%edx
   16cef:	8b 5c 24 58          	mov    0x58(%esp),%ebx
	int a[4],b[4],tmp[4] = {0,0,0,0};
   16cf3:	f3 ab                	rep stos %eax,%es:(%edi)

// 首先确定两个数相除的符号。符号值等于两者符号位异或值。然后判断除数src2值是否为0，如果是，则置被零除异常。
	sign = (src1->exponent ^ src2->exponent) & 0x8000;
   16cf5:	8b 44 24 50          	mov    0x50(%esp),%eax
   16cf9:	8b 7a 08             	mov    0x8(%edx),%edi
   16cfc:	8b 40 08             	mov    0x8(%eax),%eax
   16cff:	89 c1                	mov    %eax,%ecx
   16d01:	31 f9                	xor    %edi,%ecx
   16d03:	81 e1 00 80 00 00    	and    $0x8000,%ecx
   16d09:	89 4c 24 04          	mov    %ecx,0x4(%esp)
	if (!(src2->a || src2->b)) {
   16d0d:	8b 0a                	mov    (%edx),%ecx
   16d0f:	85 c9                	test   %ecx,%ecx
   16d11:	75 1a                	jne    16d2d <fdiv+0x5f>
   16d13:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
   16d17:	75 14                	jne    16d2d <fdiv+0x5f>
		set_ZE();               // 置被零除异常。
   16d19:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   16d1f:	8b 00                	mov    (%eax),%eax
   16d21:	83 88 1c 04 00 00 04 	orl    $0x4,0x41c(%eax)
		return;
   16d28:	e9 56 01 00 00       	jmp    16e83 <fdiv+0x1b5>
	}
// 然后计算除后的指数值。相除时指数值需要相减。但是由于指数使用偏置格式保存，两个数的指数相减时偏置量也被减去了，因此需
// 要加上偏置量值（临时实数的偏置量是16383）。
        i = (src1->exponent & 0x7fff) - (src2->exponent & 0x7fff) + 16383;
   16d2d:	25 ff 7f 00 00       	and    $0x7fff,%eax
   16d32:	81 e7 ff 7f 00 00    	and    $0x7fff,%edi
   16d38:	29 f8                	sub    %edi,%eax
// 如果结果指数变成了负值，表示两数相除后产生下溢。于是直接返回带符号的零值。
	if (i<0) {
   16d3a:	05 ff 3f 00 00       	add    $0x3fff,%eax
   16d3f:	89 04 24             	mov    %eax,(%esp)
   16d42:	79 29                	jns    16d6d <fdiv+0x9f>
		set_UE();
   16d44:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   16d4a:	8b 00                	mov    (%eax),%eax
   16d4c:	83 88 1c 04 00 00 10 	orl    $0x10,0x41c(%eax)
		result->exponent = sign;        // 设置符号位。
   16d53:	8b 44 24 04          	mov    0x4(%esp),%eax
		result->a = result->b = 0;      // 设置返回值为0。
   16d57:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
   16d5e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		result->exponent = sign;        // 设置符号位。
   16d64:	66 89 43 08          	mov    %ax,0x8(%ebx)
		return;
   16d68:	e9 16 01 00 00       	jmp    16e83 <fdiv+0x1b5>
	a[0] = a[1] = 0;
	a[2] = src1->a;
	a[3] = src1->b;
	b[0] = b[1] = 0;
	b[2] = src2->a;
	b[3] = src2->b;
   16d6d:	8b 42 04             	mov    0x4(%edx),%eax
	b[0] = b[1] = 0;
   16d70:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
   16d77:	00 
   16d78:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   16d7f:	00 
	b[2] = src2->a;
   16d80:	89 4c 24 14          	mov    %ecx,0x14(%esp)
	b[3] = src2->b;
   16d84:	89 44 24 18          	mov    %eax,0x18(%esp)
// 如果b[3]大于等于0，则进行规格化处理，即对b进行左移调整b[3]为负数。
	while (b[3] >= 0) {
   16d88:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
   16d8d:	78 0e                	js     16d9d <fdiv+0xcf>
		i++;
		shift_left(b);
   16d8f:	8d 44 24 0c          	lea    0xc(%esp),%eax
		i++;
   16d93:	ff 04 24             	incl   (%esp)
		shift_left(b);
   16d96:	e8 1a ff ff ff       	call   16cb5 <shift_left>
   16d9b:	eb eb                	jmp    16d88 <fdiv+0xba>
	c += 4;
   16d9d:	8d 7c 24 2c          	lea    0x2c(%esp),%edi
		"setae %%al":"=a" (ok):"c" ((long) a),"d" ((long) b));
   16da1:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
   16da5:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
   16dac:	00 
	unsigned int mask = 0;  // 操作位。
   16dad:	31 ed                	xor    %ebp,%ebp
		"setae %%al":"=a" (ok):"c" ((long) a),"d" ((long) b));
   16daf:	89 fa                	mov    %edi,%edx
		if (!(mask >>= 1)) {
   16db1:	d1 ed                	shr    %ebp
   16db3:	75 08                	jne    16dbd <fdiv+0xef>
			c--;
   16db5:	83 ef 04             	sub    $0x4,%edi
			mask = 0x80000000;
   16db8:	bd 00 00 00 80       	mov    $0x80000000,%ebp
	__asm__ __volatile__("movl (%1),%%eax ; subl %%eax,(%2)\n\t"
   16dbd:	8b 01                	mov    (%ecx),%eax
   16dbf:	29 02                	sub    %eax,(%edx)
   16dc1:	8b 41 04             	mov    0x4(%ecx),%eax
   16dc4:	19 42 04             	sbb    %eax,0x4(%edx)
   16dc7:	8b 41 08             	mov    0x8(%ecx),%eax
   16dca:	19 42 08             	sbb    %eax,0x8(%edx)
   16dcd:	8b 41 0c             	mov    0xc(%ecx),%eax
   16dd0:	19 42 0c             	sbb    %eax,0xc(%edx)
   16dd3:	0f 93 c0             	setae  %al
		if (try_sub(b,tmp)) {           // 是否有借位。
   16dd6:	84 c0                	test   %al,%al
   16dd8:	74 02                	je     16ddc <fdiv+0x10e>
			*c |= mask;             // 如果无借位，置当前操作位，把余数存入a，用于下次操作。
   16dda:	09 2f                	or     %ebp,(%edi)
	__asm__("shrl $1,12(%0) ; rcrl $1,8(%0) ; rcrl $1,4(%0) ; rcrl $1,(%0)"
   16ddc:	d1 69 0c             	shrl   0xc(%ecx)
   16ddf:	d1 59 08             	rcrl   0x8(%ecx)
   16de2:	d1 59 04             	rcrl   0x4(%ecx)
   16de5:	d1 19                	rcrl   (%ecx)
	for (i = 0 ; i<64 ; i++) {
   16de7:	ff 4c 24 08          	decl   0x8(%esp)
   16deb:	75 c4                	jne    16db1 <fdiv+0xe3>
	}
// 进行64位除法操作。
	div64(a,b,tmp);
// 如果除结果tmp[0]、tmp[1]、tmp[2]和tmp[3]都为0的话，说明结果为0,则设置指数i为0。否则进行规格化处理。
	if (tmp[0] || tmp[1] || tmp[2] || tmp[3]) {
   16ded:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   16df2:	75 16                	jne    16e0a <fdiv+0x13c>
   16df4:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   16df9:	75 0f                	jne    16e0a <fdiv+0x13c>
   16dfb:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
   16e00:	75 08                	jne    16e0a <fdiv+0x13c>
   16e02:	8b 4c 24 28          	mov    0x28(%esp),%ecx
   16e06:	85 c9                	test   %ecx,%ecx
   16e08:	74 47                	je     16e51 <fdiv+0x183>
			mask = 0x80000000;
   16e0a:	8b 0c 24             	mov    (%esp),%ecx
		while (i && tmp[3] >= 0) {      // 进行规格化处理。
   16e0d:	85 c9                	test   %ecx,%ecx
   16e0f:	8b 44 24 28          	mov    0x28(%esp),%eax
   16e13:	74 29                	je     16e3e <fdiv+0x170>
   16e15:	85 c0                	test   %eax,%eax
   16e17:	78 0c                	js     16e25 <fdiv+0x157>
			i--;
			shift_left(tmp);
   16e19:	8d 44 24 1c          	lea    0x1c(%esp),%eax
			i--;
   16e1d:	49                   	dec    %ecx
			shift_left(tmp);
   16e1e:	e8 92 fe ff ff       	call   16cb5 <shift_left>
   16e23:	eb e8                	jmp    16e0d <fdiv+0x13f>
		if (tmp[3] >= 0)                // 如果tmp[3]大于等于0，设置状态字非格式化异常标志位。
			set_DE();
	} else
		i = 0;          // 设置结果指数为0。
// 如果结果指数大于0x7fff，表示产生上溢，于是设置状态字溢出异常标志位，并返回。
	if (i>0x7fff) {
   16e25:	81 f9 ff 7f 00 00    	cmp    $0x7fff,%ecx
   16e2b:	7e 24                	jle    16e51 <fdiv+0x183>
		set_OE();
   16e2d:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   16e33:	8b 00                	mov    (%eax),%eax
   16e35:	83 88 1c 04 00 00 08 	orl    $0x8,0x41c(%eax)
		return;
   16e3c:	eb 45                	jmp    16e83 <fdiv+0x1b5>
		if (tmp[3] >= 0)                // 如果tmp[3]大于等于0，设置状态字非格式化异常标志位。
   16e3e:	85 c0                	test   %eax,%eax
   16e40:	78 0f                	js     16e51 <fdiv+0x183>
			set_DE();
   16e42:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   16e48:	8b 00                	mov    (%eax),%eax
   16e4a:	83 88 1c 04 00 00 02 	orl    $0x2,0x41c(%eax)
	}
// 如果tmp[0]或tmp[1]不为0，则设置状态字精度异常标志位
	if (tmp[0] || tmp[1])
   16e51:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
   16e56:	75 07                	jne    16e5f <fdiv+0x191>
   16e58:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
   16e5d:	74 0f                	je     16e6e <fdiv+0x1a0>
		set_PE();
   16e5f:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   16e65:	8b 00                	mov    (%eax),%eax
   16e67:	83 88 1c 04 00 00 20 	orl    $0x20,0x41c(%eax)
	result->exponent = i | sign;            // 设置返回临时实数的符号位和指数值。
	result->a = tmp[2];                     // 设置返回临时实数的有效值。
   16e6e:	8b 44 24 24          	mov    0x24(%esp),%eax
	result->exponent = i | sign;            // 设置返回临时实数的符号位和指数值。
   16e72:	0b 4c 24 04          	or     0x4(%esp),%ecx
	result->a = tmp[2];                     // 设置返回临时实数的有效值。
   16e76:	89 03                	mov    %eax,(%ebx)
	result->b = tmp[3];
   16e78:	8b 44 24 28          	mov    0x28(%esp),%eax
	result->exponent = i | sign;            // 设置返回临时实数的符号位和指数值。
   16e7c:	66 89 4b 08          	mov    %cx,0x8(%ebx)
	result->b = tmp[3];
   16e80:	89 43 04             	mov    %eax,0x4(%ebx)
}
   16e83:	83 c4 3c             	add    $0x3c,%esp
   16e86:	5b                   	pop    %ebx
   16e87:	5e                   	pop    %esi
   16e88:	5f                   	pop    %edi
   16e89:	5d                   	pop    %ebp
   16e8a:	c3                   	ret    

00016e8b <ftst>:

// 仿真浮点指令FTST。
// 即栈定累加器ST(0)与0比较，并根据比较结果设置条件位。若ST > 0.0，则C3，C2，C0分别为000；若ST < 0.0，则条件位为001；若
// ST == 0.0，则条件位是100；若不可比较，则条件位为111。
void ftst(const temp_real * a)
{
   16e8b:	e8 ea 2f ff ff       	call   9e7a <__x86.get_pc_thunk.ax>
   16e90:	05 70 a1 00 00       	add    $0xa170,%eax
   16e95:	57                   	push   %edi
   16e96:	56                   	push   %esi
	temp_real b;

// 首先清状态字中条件标志位，并对比较值b（ST）进行规格化处理。若b不等于零并且设置了符号位（是负数），则设置条件位C0。否则设置
// 条件位C3。
	clear_Cx();
   16e97:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
{
   16e9d:	53                   	push   %ebx
   16e9e:	8b 54 24 10          	mov    0x10(%esp),%edx
	clear_Cx();
   16ea2:	8b 30                	mov    (%eax),%esi
	b = *a;
   16ea4:	8b 7a 08             	mov    0x8(%edx),%edi
   16ea7:	8b 1a                	mov    (%edx),%ebx
   16ea9:	8b 42 04             	mov    0x4(%edx),%eax
	clear_Cx();
   16eac:	8b 8e 1c 04 00 00    	mov    0x41c(%esi),%ecx
	int i = a->exponent & 0x7fff;           // 取指数值（略去符号位）。
   16eb2:	89 fa                	mov    %edi,%edx
	int sign = a->exponent & 0x8000;        // 取符号位。
   16eb4:	81 e7 00 80 00 00    	and    $0x8000,%edi
	int i = a->exponent & 0x7fff;           // 取指数值（略去符号位）。
   16eba:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
	clear_Cx();
   16ec0:	80 e5 ba             	and    $0xba,%ch
	if (!(a->a || a->b)) {
   16ec3:	85 db                	test   %ebx,%ebx
	clear_Cx();
   16ec5:	89 8e 1c 04 00 00    	mov    %ecx,0x41c(%esi)
	if (!(a->a || a->b)) {
   16ecb:	75 0f                	jne    16edc <ftst+0x51>
   16ecd:	85 c0                	test   %eax,%eax
   16ecf:	75 0b                	jne    16edc <ftst+0x51>
   16ed1:	eb 28                	jmp    16efb <ftst+0x70>
	while (i && a->b >= 0) {
   16ed3:	85 c0                	test   %eax,%eax
   16ed5:	78 09                	js     16ee0 <ftst+0x55>
		i--;
   16ed7:	4a                   	dec    %edx
		__asm__("addl %0,%0 ; adcl %1,%1"
   16ed8:	01 db                	add    %ebx,%ebx
   16eda:	11 c0                	adc    %eax,%eax
	while (i && a->b >= 0) {
   16edc:	85 d2                	test   %edx,%edx
   16ede:	75 f3                	jne    16ed3 <ftst+0x48>
	a->exponent = i | sign;
   16ee0:	09 fa                	or     %edi,%edx
	normalize(&b);
	if (b.a || b.b || b.exponent) {
   16ee2:	85 db                	test   %ebx,%ebx
   16ee4:	75 09                	jne    16eef <ftst+0x64>
   16ee6:	85 c0                	test   %eax,%eax
   16ee8:	75 05                	jne    16eef <ftst+0x64>
   16eea:	66 85 d2             	test   %dx,%dx
   16eed:	74 0c                	je     16efb <ftst+0x70>
		if (b.exponent < 0)
   16eef:	66 85 d2             	test   %dx,%dx
   16ef2:	79 12                	jns    16f06 <ftst+0x7b>
			set_C0();
   16ef4:	89 c8                	mov    %ecx,%eax
   16ef6:	80 cc 01             	or     $0x1,%ah
   16ef9:	eb 05                	jmp    16f00 <ftst+0x75>
	} else
		set_C3();
   16efb:	89 c8                	mov    %ecx,%eax
   16efd:	80 cc 40             	or     $0x40,%ah
   16f00:	89 86 1c 04 00 00    	mov    %eax,0x41c(%esi)
}
   16f06:	5b                   	pop    %ebx
   16f07:	5e                   	pop    %esi
   16f08:	5f                   	pop    %edi
   16f09:	c3                   	ret    

00016f0a <fcom>:

// 仿真浮点指令FCOM。
// 比较两个参数src1、src2。并根据比较结果设置条件位。若src1 > src2，则C3，C2，C0分别为000；若src1 < src2，则条件位为
// 001；若两者相等，则条件位是100。
void fcom(const temp_real * src1, const temp_real * src2)
{
   16f0a:	57                   	push   %edi
   16f0b:	56                   	push   %esi
	temp_real a;

	a = *src1;
   16f0c:	b9 03 00 00 00       	mov    $0x3,%ecx
{
   16f11:	53                   	push   %ebx
   16f12:	e8 15 fb fe ff       	call   6a2c <__x86.get_pc_thunk.bx>
   16f17:	81 c3 e9 a0 00 00    	add    $0xa0e9,%ebx
   16f1d:	83 ec 10             	sub    $0x10,%esp
   16f20:	8b 74 24 20          	mov    0x20(%esp),%esi
	a = *src1;
   16f24:	8d 7c 24 04          	lea    0x4(%esp),%edi
   16f28:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	a.exponent ^= 0x8000;           // 符号位取反。
   16f2a:	66 81 44 24 0c 00 80 	addw   $0x8000,0xc(%esp)
	fadd(&a,src2,&a);               // 两者相加（即相减）。
   16f31:	50                   	push   %eax
   16f32:	8d 74 24 08          	lea    0x8(%esp),%esi
   16f36:	56                   	push   %esi
   16f37:	ff 74 24 2c          	pushl  0x2c(%esp)
   16f3b:	56                   	push   %esi
   16f3c:	e8 79 fb ff ff       	call   16aba <fadd>
	ftst(&a);                       // 测试结果并设置条件位。
   16f41:	89 34 24             	mov    %esi,(%esp)
   16f44:	e8 42 ff ff ff       	call   16e8b <ftst>
}
   16f49:	83 c4 20             	add    $0x20,%esp
   16f4c:	5b                   	pop    %ebx
   16f4d:	5e                   	pop    %esi
   16f4e:	5f                   	pop    %edi
   16f4f:	c3                   	ret    

00016f50 <fucom>:

// 仿真浮点指令FUCOM（无次序比较）。
// 用于操作数之一是NaN的比较。
void fucom(const temp_real * src1, const temp_real * src2)
{
	fcom(src1,src2);
   16f50:	eb b8                	jmp    16f0a <fcom>

00016f52 <short_to_temp>:
 */

// 短实数转换成临时实数格式。
// 短实数长度是32位，基有效数（尾数）长度是23位，指数是8位，还有1个符号位。
void short_to_temp(const short_real * a, temp_real * b)
{
   16f52:	53                   	push   %ebx
   16f53:	8b 54 24 08          	mov    0x8(%esp),%edx
   16f57:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
// 首先处理被转换的短实数是0的情况。若为0,则设置对应临时实数b的有效数为0。然后根据短实数符号位设置临时实数的符号位，即exponent
// 的最高有效位。
	if (!(*a & 0x7fffffff)) {
   16f5b:	8b 02                	mov    (%edx),%eax
   16f5d:	a9 ff ff ff 7f       	test   $0x7fffffff,%eax
   16f62:	75 22                	jne    16f86 <short_to_temp+0x34>
		b->a = b->b = 0;                // 置临时实数的有效数 = 0。
   16f64:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
   16f6b:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		if (*a)
   16f71:	83 3a 00             	cmpl   $0x0,(%edx)
   16f74:	74 08                	je     16f7e <short_to_temp+0x2c>
			b->exponent = 0x8000;   // 设置符号位。
   16f76:	66 c7 41 08 00 80    	movw   $0x8000,0x8(%ecx)
   16f7c:	eb 36                	jmp    16fb4 <short_to_temp+0x62>
		else
			b->exponent = 0;
   16f7e:	66 c7 41 08 00 00    	movw   $0x0,0x8(%ecx)
   16f84:	eb 2e                	jmp    16fb4 <short_to_temp+0x62>
	}
// 对于一般短实数，先确定对应临时实数的指数值。这里需要用到整型数偏置表示方法的概念。短实数指数的偏置量是127，而临时实数指数的偏置
// 量是16383。因此在取出短实数中指数值后需要变更其中的偏置量为16383。此时就形成了临时实数格式的指数值exponent。另外，如果短实数
// 是负数，则需要设置临时实数的符号位（位79）。下一步设置尾数值。方法是把短实数左移8位，让23位尾数最高有效位处于临时实数的位62处。
// 而临时实数尾数位63处需要恒置一个1，即需要或上0x80000000。最后清掉临时实数低32位有效数。
	b->exponent = ((*a>>23) & 0xff)-127+16383;      // 取出短实数指数位，更换偏置量。
   16f86:	89 c2                	mov    %eax,%edx
	if (*a<0)
		b->exponent |= 0x8000;                  // 若为负数则设置符号位。
	b->b = (*a<<8) | 0x80000000;                    // 放置尾数，添加固定1值。
	b->a = 0;
   16f88:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	b->exponent = ((*a>>23) & 0xff)-127+16383;      // 取出短实数指数位，更换偏置量。
   16f8e:	c1 fa 17             	sar    $0x17,%edx
   16f91:	0f b6 d2             	movzbl %dl,%edx
   16f94:	66 81 c2 80 3f       	add    $0x3f80,%dx
   16f99:	89 d3                	mov    %edx,%ebx
   16f9b:	66 81 cb 00 80       	or     $0x8000,%bx
   16fa0:	85 c0                	test   %eax,%eax
   16fa2:	0f 48 d3             	cmovs  %ebx,%edx
	b->b = (*a<<8) | 0x80000000;                    // 放置尾数，添加固定1值。
   16fa5:	c1 e0 08             	shl    $0x8,%eax
   16fa8:	0d 00 00 00 80       	or     $0x80000000,%eax
	b->exponent = ((*a>>23) & 0xff)-127+16383;      // 取出短实数指数位，更换偏置量。
   16fad:	66 89 51 08          	mov    %dx,0x8(%ecx)
	b->b = (*a<<8) | 0x80000000;                    // 放置尾数，添加固定1值。
   16fb1:	89 41 04             	mov    %eax,0x4(%ecx)
}
   16fb4:	5b                   	pop    %ebx
   16fb5:	c3                   	ret    

00016fb6 <long_to_temp>:

// 长实数转换成临时实数格式。
// 方法与short_to_temp()安全一样。不过长实数指数偏置量是1034。
void long_to_temp(const long_real * a, temp_real * b)
{
   16fb6:	56                   	push   %esi
   16fb7:	53                   	push   %ebx
   16fb8:	8b 44 24 0c          	mov    0xc(%esp),%eax
   16fbc:	8b 4c 24 10          	mov    0x10(%esp),%ecx
	if (!a->a && !(a->b & 0x7fffffff)) {
   16fc0:	8b 18                	mov    (%eax),%ebx
   16fc2:	8b 40 04             	mov    0x4(%eax),%eax
   16fc5:	85 db                	test   %ebx,%ebx
   16fc7:	75 28                	jne    16ff1 <long_to_temp+0x3b>
   16fc9:	a9 ff ff ff 7f       	test   $0x7fffffff,%eax
   16fce:	75 21                	jne    16ff1 <long_to_temp+0x3b>
		b->a = b->b = 0;                // 置临时实数的有效数 = 0。
		if (a->b)
   16fd0:	85 c0                	test   %eax,%eax
		b->a = b->b = 0;                // 置临时实数的有效数 = 0。
   16fd2:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
   16fd9:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		if (a->b)
   16fdf:	74 08                	je     16fe9 <long_to_temp+0x33>
			b->exponent = 0x8000;   // 设置符号位。
   16fe1:	66 c7 41 08 00 80    	movw   $0x8000,0x8(%ecx)
   16fe7:	eb 3e                	jmp    17027 <long_to_temp+0x71>
		else
			b->exponent = 0;
   16fe9:	66 c7 41 08 00 00    	movw   $0x0,0x8(%ecx)
   16fef:	eb 36                	jmp    17027 <long_to_temp+0x71>
		return;
	}
	b->exponent = ((a->b >> 20) & 0x7ff)-1023+16383;        // 取长实数指数，更换偏置量。
   16ff1:	89 c2                	mov    %eax,%edx
   16ff3:	c1 fa 14             	sar    $0x14,%edx
   16ff6:	66 81 e2 ff 07       	and    $0x7ff,%dx
   16ffb:	66 81 c2 00 3c       	add    $0x3c00,%dx
   17000:	89 d6                	mov    %edx,%esi
   17002:	66 81 ce 00 80       	or     $0x8000,%si
   17007:	85 c0                	test   %eax,%eax
   17009:	0f 48 d6             	cmovs  %esi,%edx
	if (a->b<0)
		b->exponent |= 0x8000;          // 若为负数则设置符号位。
	b->b = 0x80000000 | (a->b<<11) | (((unsigned long)a->a)>>21);
   1700c:	c1 e0 0b             	shl    $0xb,%eax
	b->exponent = ((a->b >> 20) & 0x7ff)-1023+16383;        // 取长实数指数，更换偏置量。
   1700f:	66 89 51 08          	mov    %dx,0x8(%ecx)
	b->b = 0x80000000 | (a->b<<11) | (((unsigned long)a->a)>>21);
   17013:	89 da                	mov    %ebx,%edx
	b->a = a->a<<11;                        // 放置尾数，添1。
   17015:	c1 e3 0b             	shl    $0xb,%ebx
	b->b = 0x80000000 | (a->b<<11) | (((unsigned long)a->a)>>21);
   17018:	c1 ea 15             	shr    $0x15,%edx
	b->a = a->a<<11;                        // 放置尾数，添1。
   1701b:	89 19                	mov    %ebx,(%ecx)
	b->b = 0x80000000 | (a->b<<11) | (((unsigned long)a->a)>>21);
   1701d:	09 d0                	or     %edx,%eax
   1701f:	0d 00 00 00 80       	or     $0x80000000,%eax
   17024:	89 41 04             	mov    %eax,0x4(%ecx)
}
   17027:	5b                   	pop    %ebx
   17028:	5e                   	pop    %esi
   17029:	c3                   	ret    

0001702a <temp_to_short>:

// 临时实数转换成短实数格式。
// 过程与short_to_temp()相反，但需要处理精度和舍入问题。
void temp_to_short(const temp_real * a, short_real * b)
{
   1702a:	57                   	push   %edi
   1702b:	56                   	push   %esi
   1702c:	53                   	push   %ebx
   1702d:	8b 74 24 10          	mov    0x10(%esp),%esi
   17031:	e8 f2 f9 fe ff       	call   6a28 <__x86.get_pc_thunk.dx>
   17036:	81 c2 ca 9f 00 00    	add    $0x9fca,%edx
   1703c:	8b 4c 24 14          	mov    0x14(%esp),%ecx
// 如果指数部分为0，则根据有无符号位设置短实数为-0或0。
	if (!(a->exponent & 0x7fff)) {
   17040:	8b 5e 08             	mov    0x8(%esi),%ebx
   17043:	66 f7 c3 ff 7f       	test   $0x7fff,%bx
   17048:	75 0f                	jne    17059 <temp_to_short+0x2f>
		*b = (a->exponent)?0x80000000:0;
   1704a:	66 83 fb 01          	cmp    $0x1,%bx
   1704e:	19 c0                	sbb    %eax,%eax
   17050:	f7 d0                	not    %eax
   17052:	25 00 00 00 80       	and    $0x80000000,%eax
   17057:	eb 6e                	jmp    170c7 <temp_to_short+0x9d>
		return;
	}
// 先处理指数部分。即更换临时实数指数偏置量（16383）为短实数的偏置量127。
	*b = ((((long) a->exponent)-16383+127) << 23) & 0x7f800000;
   17059:	89 d8                	mov    %ebx,%eax
	if (a->exponent < 0)                    // 若是负数则设置符号位。
		*b |= 0x80000000;
	*b |= (a->b >> 8) & 0x007fffff;         // 取临时实数有效数高23位。
// 根据控制字中的舍入设置执行舍入操作。
	switch (ROUNDING) {
   1705b:	c7 c2 60 23 02 00    	mov    $0x22360,%edx
	*b = ((((long) a->exponent)-16383+127) << 23) & 0x7f800000;
   17061:	c1 e0 17             	shl    $0x17,%eax
   17064:	05 00 00 00 40       	add    $0x40000000,%eax
   17069:	25 00 00 80 7f       	and    $0x7f800000,%eax
	switch (ROUNDING) {
   1706e:	8b 12                	mov    (%edx),%edx
	*b = ((((long) a->exponent)-16383+127) << 23) & 0x7f800000;
   17070:	89 c7                	mov    %eax,%edi
   17072:	81 cf 00 00 00 80    	or     $0x80000000,%edi
   17078:	66 85 db             	test   %bx,%bx
   1707b:	0f 48 c7             	cmovs  %edi,%eax
   1707e:	89 01                	mov    %eax,(%ecx)
	*b |= (a->b >> 8) & 0x007fffff;         // 取临时实数有效数高23位。
   17080:	8b 46 04             	mov    0x4(%esi),%eax
   17083:	c1 f8 08             	sar    $0x8,%eax
   17086:	25 ff ff 7f 00       	and    $0x7fffff,%eax
   1708b:	0b 01                	or     (%ecx),%eax
   1708d:	89 01                	mov    %eax,(%ecx)
	switch (ROUNDING) {
   1708f:	8b 92 18 04 00 00    	mov    0x418(%edx),%edx
   17095:	c1 fa 0a             	sar    $0xa,%edx
   17098:	83 e2 03             	and    $0x3,%edx
   1709b:	83 fa 01             	cmp    $0x1,%edx
   1709e:	74 14                	je     170b4 <temp_to_short+0x8a>
   170a0:	83 fa 02             	cmp    $0x2,%edx
   170a3:	74 16                	je     170bb <temp_to_short+0x91>
   170a5:	85 d2                	test   %edx,%edx
   170a7:	75 20                	jne    170c9 <temp_to_short+0x9f>
		case ROUND_NEAREST:
			if ((a->b & 0xff) > 0x80)
   170a9:	0f b6 56 04          	movzbl 0x4(%esi),%edx
   170ad:	83 c2 80             	add    $0xffffff80,%edx
   170b0:	7e 17                	jle    170c9 <temp_to_short+0x9f>
   170b2:	eb 12                	jmp    170c6 <temp_to_short+0x9c>
				++*b;
			break;
		case ROUND_DOWN:
			if ((a->exponent & 0x8000) && (a->b & 0xff))
   170b4:	66 85 db             	test   %bx,%bx
   170b7:	79 10                	jns    170c9 <temp_to_short+0x9f>
   170b9:	eb 05                	jmp    170c0 <temp_to_short+0x96>
				++*b;
			break;
		case ROUND_UP:
			if (!(a->exponent & 0x8000) && (a->b & 0xff))
   170bb:	66 85 db             	test   %bx,%bx
   170be:	78 09                	js     170c9 <temp_to_short+0x9f>
   170c0:	80 7e 04 00          	cmpb   $0x0,0x4(%esi)
   170c4:	74 03                	je     170c9 <temp_to_short+0x9f>
				++*b;
   170c6:	40                   	inc    %eax
   170c7:	89 01                	mov    %eax,(%ecx)
			break;
	}
}
   170c9:	5b                   	pop    %ebx
   170ca:	5e                   	pop    %esi
   170cb:	5f                   	pop    %edi
   170cc:	c3                   	ret    

000170cd <temp_to_long>:

// 临时实数转换成长实数。
void temp_to_long(const temp_real * a, long_real * b)
{
   170cd:	55                   	push   %ebp
   170ce:	57                   	push   %edi
   170cf:	56                   	push   %esi
   170d0:	53                   	push   %ebx
   170d1:	52                   	push   %edx
   170d2:	8b 54 24 18          	mov    0x18(%esp),%edx
   170d6:	e8 9e bf ff ff       	call   13079 <__x86.get_pc_thunk.bp>
   170db:	81 c5 25 9f 00 00    	add    $0x9f25,%ebp
   170e1:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
// 如果指数部分为0，则根据有无符号位设置长实数为-0或0。
	if (!(a->exponent & 0x7fff)) {
   170e5:	8b 5a 08             	mov    0x8(%edx),%ebx
   170e8:	89 d8                	mov    %ebx,%eax
   170ea:	66 25 ff 7f          	and    $0x7fff,%ax
   170ee:	75 18                	jne    17108 <temp_to_long+0x3b>
		b->a = 0;
		b->b = (a->exponent)?0x80000000:0;
   170f0:	66 83 fb 01          	cmp    $0x1,%bx
		b->a = 0;
   170f4:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
		b->b = (a->exponent)?0x80000000:0;
   170fa:	19 c0                	sbb    %eax,%eax
   170fc:	f7 d0                	not    %eax
   170fe:	25 00 00 00 80       	and    $0x80000000,%eax
   17103:	e9 8e 00 00 00       	jmp    17196 <temp_to_long+0xc9>
		return;
	}
// 先处理指数部分。即更换临时实数指数偏置量（16383）为长实数的偏置量1023.
	b->b = (((0x7fff & (long) a->exponent)-16383+1023) << 20) & 0x7ff00000;
   17108:	c1 e0 14             	shl    $0x14,%eax
	if (a->exponent < 0)            // 若是负数则设置符号位。
		b->b |= 0x80000000;
	b->b |= (a->b >> 11) & 0x000fffff;      // 取临时实数有效数高20位。
   1710b:	8b 72 04             	mov    0x4(%edx),%esi
	b->a = a->b << 21;
	b->a |= (a->a >> 11) & 0x001fffff;
// 根据控制字中的舍入设置执行舍入操作。
	switch (ROUNDING) {
   1710e:	c7 c5 60 23 02 00    	mov    $0x22360,%ebp
	b->b = (((0x7fff & (long) a->exponent)-16383+1023) << 20) & 0x7ff00000;
   17114:	05 00 00 00 40       	add    $0x40000000,%eax
   17119:	25 00 00 f0 7f       	and    $0x7ff00000,%eax
   1711e:	89 c7                	mov    %eax,%edi
	switch (ROUNDING) {
   17120:	8b 6d 00             	mov    0x0(%ebp),%ebp
	b->b = (((0x7fff & (long) a->exponent)-16383+1023) << 20) & 0x7ff00000;
   17123:	81 cf 00 00 00 80    	or     $0x80000000,%edi
   17129:	66 85 db             	test   %bx,%bx
   1712c:	0f 49 f8             	cmovns %eax,%edi
	b->b |= (a->b >> 11) & 0x000fffff;      // 取临时实数有效数高20位。
   1712f:	89 f0                	mov    %esi,%eax
   17131:	c1 f8 0b             	sar    $0xb,%eax
	switch (ROUNDING) {
   17134:	8b ad 18 04 00 00    	mov    0x418(%ebp),%ebp
	b->b |= (a->b >> 11) & 0x000fffff;      // 取临时实数有效数高20位。
   1713a:	25 ff ff 0f 00       	and    $0xfffff,%eax
   1713f:	09 f8                	or     %edi,%eax
	b->a |= (a->a >> 11) & 0x001fffff;
   17141:	8b 3a                	mov    (%edx),%edi
	b->a = a->b << 21;
   17143:	89 f2                	mov    %esi,%edx
   17145:	c1 e2 15             	shl    $0x15,%edx
	switch (ROUNDING) {
   17148:	c1 fd 0a             	sar    $0xa,%ebp
	b->b |= (a->b >> 11) & 0x000fffff;      // 取临时实数有效数高20位。
   1714b:	89 41 04             	mov    %eax,0x4(%ecx)
	b->a = a->b << 21;
   1714e:	89 14 24             	mov    %edx,(%esp)
	switch (ROUNDING) {
   17151:	83 e5 03             	and    $0x3,%ebp
	b->a |= (a->a >> 11) & 0x001fffff;
   17154:	89 fa                	mov    %edi,%edx
   17156:	c1 ea 0b             	shr    $0xb,%edx
   17159:	0b 14 24             	or     (%esp),%edx
	switch (ROUNDING) {
   1715c:	83 fd 01             	cmp    $0x1,%ebp
	b->a |= (a->a >> 11) & 0x001fffff;
   1715f:	89 11                	mov    %edx,(%ecx)
	switch (ROUNDING) {
   17161:	74 19                	je     1717c <temp_to_long+0xaf>
   17163:	83 fd 02             	cmp    $0x2,%ebp
   17166:	74 1b                	je     17183 <temp_to_long+0xb6>
   17168:	85 ed                	test   %ebp,%ebp
   1716a:	75 2d                	jne    17199 <temp_to_long+0xcc>
		case ROUND_NEAREST:
			if ((a->a & 0x7ff) > 0x400)
   1716c:	81 e7 ff 07 00 00    	and    $0x7ff,%edi
   17172:	81 ff 00 04 00 00    	cmp    $0x400,%edi
   17178:	7e 1f                	jle    17199 <temp_to_long+0xcc>
   1717a:	eb 12                	jmp    1718e <temp_to_long+0xc1>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
			break;
		case ROUND_DOWN:
			if ((a->exponent & 0x8000) && (a->b & 0xff))
   1717c:	66 85 db             	test   %bx,%bx
   1717f:	79 18                	jns    17199 <temp_to_long+0xcc>
   17181:	eb 05                	jmp    17188 <temp_to_long+0xbb>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
			break;
		case ROUND_UP:
			if (!(a->exponent & 0x8000) && (a->b & 0xff))
   17183:	66 85 db             	test   %bx,%bx
   17186:	78 11                	js     17199 <temp_to_long+0xcc>
   17188:	89 f3                	mov    %esi,%ebx
   1718a:	84 db                	test   %bl,%bl
   1718c:	74 0b                	je     17199 <temp_to_long+0xcc>
				__asm__("addl $1,%0 ; adcl $0,%1"
   1718e:	83 c2 01             	add    $0x1,%edx
   17191:	83 d0 00             	adc    $0x0,%eax
   17194:	89 11                	mov    %edx,(%ecx)
   17196:	89 41 04             	mov    %eax,0x4(%ecx)
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
			break;
	}
}
   17199:	58                   	pop    %eax
   1719a:	5b                   	pop    %ebx
   1719b:	5e                   	pop    %esi
   1719c:	5f                   	pop    %edi
   1719d:	5d                   	pop    %ebp
   1719e:	c3                   	ret    

0001719f <real_to_int>:

// 临时实数转换成临时整数格式。
// 临时整数也用10字节表示。其中低8字节是无符号整数值，高2字节表示指数值和符号位。如果高2字节最高有效位为1，则表示是负数；
// 若位0，表示是正数。
void real_to_int(const temp_real * a, temp_int * b)
{
   1719f:	57                   	push   %edi
   171a0:	56                   	push   %esi
// 整数值最大值是2的63次方，加上临时实数偏置值16383,表示一个整数值转换为临时实数，临时实数指数最大值，减去临时实数指数，
// 得到指数差值（相当于与最大整数值的差值）。
	int shift =  16383 + 63 - (a->exponent & 0x7fff);
   171a1:	b9 3e 40 00 00       	mov    $0x403e,%ecx
{
   171a6:	53                   	push   %ebx
   171a7:	e8 d6 2c ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   171ac:	81 c6 54 9e 00 00    	add    $0x9e54,%esi
   171b2:	83 ec 10             	sub    $0x10,%esp
   171b5:	8b 44 24 20          	mov    0x20(%esp),%eax
   171b9:	8b 5c 24 24          	mov    0x24(%esp),%ebx
	unsigned long underflow;

	b->a = b->b = underflow = 0;    // 初始化临时整数值为0。
   171bd:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
   171c4:	00 
	int shift =  16383 + 63 - (a->exponent & 0x7fff);
   171c5:	8b 78 08             	mov    0x8(%eax),%edi
	b->a = b->b = underflow = 0;    // 初始化临时整数值为0。
   171c8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
   171cf:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	int shift =  16383 + 63 - (a->exponent & 0x7fff);
   171d5:	89 fa                	mov    %edi,%edx
	b->sign = (a->exponent < 0);    // 置临时整数符号与临时实数符号一致。
   171d7:	66 c1 ef 0f          	shr    $0xf,%di
	int shift =  16383 + 63 - (a->exponent & 0x7fff);
   171db:	81 e2 ff 7f 00 00    	and    $0x7fff,%edx
	b->sign = (a->exponent < 0);    // 置临时整数符号与临时实数符号一致。
   171e1:	66 89 7b 08          	mov    %di,0x8(%ebx)
	if (shift < 0) {                // 如果指数差值小于0，说明这个临时实数不能放入临时整数中，
   171e5:	29 d1                	sub    %edx,%ecx
   171e7:	79 14                	jns    171fd <real_to_int+0x5e>
		set_OE();               // 置状态字溢出位。
   171e9:	c7 c0 60 23 02 00    	mov    $0x22360,%eax
   171ef:	8b 00                	mov    (%eax),%eax
   171f1:	83 88 1c 04 00 00 08 	orl    $0x8,0x41c(%eax)
		return;
   171f8:	e9 b4 00 00 00       	jmp    172b1 <real_to_int+0x112>
	}
// 如果两值差值小于2的32次方，直接把实数值放入整数值。
	if (shift < 32) {
   171fd:	83 f9 1f             	cmp    $0x1f,%ecx
   17200:	7f 0c                	jg     1720e <real_to_int+0x6f>
		b->b = a->b; b->a = a->a;
   17202:	8b 50 04             	mov    0x4(%eax),%edx
   17205:	8b 00                	mov    (%eax),%eax
   17207:	89 53 04             	mov    %edx,0x4(%ebx)
   1720a:	89 03                	mov    %eax,(%ebx)
   1720c:	eb 2e                	jmp    1723c <real_to_int+0x9d>
// 如果两值差值介于2的32次方与64次方之间，把实数高位a->b放入整数低位b->a，然后把实数低位放入下溢出变量underflow，指数差值
// shift-32。
	} else if (shift < 64) {
   1720e:	83 f9 3f             	cmp    $0x3f,%ecx
   17211:	7f 12                	jg     17225 <real_to_int+0x86>
		b->a = a->b; underflow = a->a;
   17213:	8b 48 04             	mov    0x4(%eax),%ecx
   17216:	8b 00                	mov    (%eax),%eax
   17218:	89 0b                	mov    %ecx,(%ebx)
   1721a:	89 44 24 0c          	mov    %eax,0xc(%esp)
		shift -= 32;
   1721e:	b9 1e 40 00 00       	mov    $0x401e,%ecx
   17223:	eb 15                	jmp    1723a <real_to_int+0x9b>
// 如果两值差值介于2的64次方与96次方之间，把实数高位a->b放入下溢出变量underflow，指数差值shift-64。
	} else if (shift < 96) {
   17225:	83 f9 5f             	cmp    $0x5f,%ecx
   17228:	0f 8f 83 00 00 00    	jg     172b1 <real_to_int+0x112>
		underflow = a->b;
   1722e:	8b 40 04             	mov    0x4(%eax),%eax
		shift -= 64;
   17231:	b9 fe 3f 00 00       	mov    $0x3ffe,%ecx
		underflow = a->b;
   17236:	89 44 24 0c          	mov    %eax,0xc(%esp)
		shift -= 64;
   1723a:	29 d1                	sub    %edx,%ecx
// 否则返回0。
	} else
		return;
// 接着再进行细致的调整，调整方法是把临时整数b的向下溢出变量underflow右移shift位。
	__asm__("shrdl %2,%1,%0"
   1723c:	8b 54 24 0c          	mov    0xc(%esp),%edx
   17240:	8b 03                	mov    (%ebx),%eax
   17242:	0f ad c2             	shrd   %cl,%eax,%edx
   17245:	89 54 24 0c          	mov    %edx,0xc(%esp)
		:"=r" (underflow),"=r" (b->a)
		:"c" ((char) shift),"0" (underflow),"1" (b->a));
// 然后把临时整数b的尾数b->a右移shift位。
	__asm__("shrdl %2,%1,%0"
   17249:	8b 53 04             	mov    0x4(%ebx),%edx
   1724c:	0f ad d0             	shrd   %cl,%edx,%eax
		:"=r" (b->a),"=r" (b->b)
		:"c" ((char) shift),"0" (b->a),"1" (b->b));
// 最后把临时整数b的尾数b->b右移shift位。
	__asm__("shrl %1,%0"
   1724f:	d3 ea                	shr    %cl,%edx
		:"=r" (b->b)
		:"c" ((char) shift),"0" (b->b));
// 根据控制字中的舍入设置执行舍入操作。
	switch (ROUNDING) {
   17251:	c7 c1 60 23 02 00    	mov    $0x22360,%ecx
	__asm__("shrdl %2,%1,%0"
   17257:	89 03                	mov    %eax,(%ebx)
	__asm__("shrl %1,%0"
   17259:	89 53 04             	mov    %edx,0x4(%ebx)
	switch (ROUNDING) {
   1725c:	8b 09                	mov    (%ecx),%ecx
   1725e:	8b 89 18 04 00 00    	mov    0x418(%ecx),%ecx
   17264:	c1 f9 0a             	sar    $0xa,%ecx
   17267:	83 e1 03             	and    $0x3,%ecx
   1726a:	83 f9 01             	cmp    $0x1,%ecx
   1726d:	74 29                	je     17298 <real_to_int+0xf9>
   1726f:	83 f9 02             	cmp    $0x2,%ecx
   17272:	74 1b                	je     1728f <real_to_int+0xf0>
   17274:	85 c9                	test   %ecx,%ecx
   17276:	75 39                	jne    172b1 <real_to_int+0x112>
		case ROUND_NEAREST:
			__asm__("addl %4,%5 ; adcl $0,%0 ; adcl $0,%1"
				:"=r" (b->a),"=r" (b->b)
				:"0" (b->a),"1" (b->b)
				,"r" (0x7fffffff + (b->a & 1))
   17278:	89 c1                	mov    %eax,%ecx
   1727a:	83 e1 01             	and    $0x1,%ecx
   1727d:	81 c1 ff ff ff 7f    	add    $0x7fffffff,%ecx
			__asm__("addl %4,%5 ; adcl $0,%0 ; adcl $0,%1"
   17283:	01 4c 24 0c          	add    %ecx,0xc(%esp)
   17287:	83 d0 00             	adc    $0x0,%eax
   1728a:	83 d2 00             	adc    $0x0,%edx
   1728d:	eb 1d                	jmp    172ac <real_to_int+0x10d>
				,"m" (*&underflow));
			break;
		case ROUND_UP:
			if (!b->sign && underflow)
   1728f:	66 83 7b 08 00       	cmpw   $0x0,0x8(%ebx)
   17294:	74 09                	je     1729f <real_to_int+0x100>
   17296:	eb 19                	jmp    172b1 <real_to_int+0x112>
				__asm__("addl $1,%0 ; adcl $0,%1"
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
			break;
		case ROUND_DOWN:
			if (b->sign && underflow)
   17298:	66 83 7b 08 00       	cmpw   $0x0,0x8(%ebx)
   1729d:	74 12                	je     172b1 <real_to_int+0x112>
   1729f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
   172a4:	74 0b                	je     172b1 <real_to_int+0x112>
				__asm__("addl $1,%0 ; adcl $0,%1"
   172a6:	83 c0 01             	add    $0x1,%eax
   172a9:	83 d2 00             	adc    $0x0,%edx
   172ac:	89 03                	mov    %eax,(%ebx)
   172ae:	89 53 04             	mov    %edx,0x4(%ebx)
					:"=r" (b->a),"=r" (b->b)
					:"0" (b->a),"1" (b->b));
			break;
	}
}
   172b1:	83 c4 10             	add    $0x10,%esp
   172b4:	5b                   	pop    %ebx
   172b5:	5e                   	pop    %esi
   172b6:	5f                   	pop    %edi
   172b7:	c3                   	ret    

000172b8 <int_to_real>:

// 临时整数转换成临时实数格式。
void int_to_real(const temp_int * a, temp_real * b)
{
   172b8:	53                   	push   %ebx
   172b9:	8b 54 24 08          	mov    0x8(%esp),%edx
   172bd:	8b 44 24 0c          	mov    0xc(%esp),%eax
// 由于原值是整数，所以转换成临时实数时指数除了需要加上偏置量16383外，还要加上63。表示
	b->a = a->a;
   172c1:	8b 1a                	mov    (%edx),%ebx
	b->b = a->b;
   172c3:	8b 4a 04             	mov    0x4(%edx),%ecx
	b->a = a->a;
   172c6:	89 18                	mov    %ebx,(%eax)
	if (b->a || b->b)
   172c8:	09 cb                	or     %ecx,%ebx
	b->b = a->b;
   172ca:	89 48 04             	mov    %ecx,0x4(%eax)
	if (b->a || b->b)
   172cd:	74 17                	je     172e6 <int_to_real+0x2e>
		b->exponent = 16383 + 63 + (a->sign? 0x8000:0);
   172cf:	66 83 7a 08 01       	cmpw   $0x1,0x8(%edx)
   172d4:	19 d2                	sbb    %edx,%edx
   172d6:	66 81 e2 00 80       	and    $0x8000,%dx
   172db:	66 81 ea c2 3f       	sub    $0x3fc2,%dx
   172e0:	66 89 50 08          	mov    %dx,0x8(%eax)
	else {
		b->exponent = 0;
		return;
	}
// 对格式转换后的临时实数进行规格化处理，即让有效数最高有效位不是0。
	while (b->b >= 0) {
   172e4:	eb 08                	jmp    172ee <int_to_real+0x36>
		b->exponent = 0;
   172e6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		return;
   172ec:	eb 18                	jmp    17306 <int_to_real+0x4e>
	while (b->b >= 0) {
   172ee:	8b 50 04             	mov    0x4(%eax),%edx
   172f1:	85 d2                	test   %edx,%edx
   172f3:	78 11                	js     17306 <int_to_real+0x4e>
		b->exponent--;
		__asm__("addl %0,%0 ; adcl %1,%1"
   172f5:	8b 08                	mov    (%eax),%ecx
		b->exponent--;
   172f7:	66 ff 48 08          	decw   0x8(%eax)
		__asm__("addl %0,%0 ; adcl %1,%1"
   172fb:	01 c9                	add    %ecx,%ecx
   172fd:	11 d2                	adc    %edx,%edx
   172ff:	89 08                	mov    %ecx,(%eax)
   17301:	89 50 04             	mov    %edx,0x4(%eax)
   17304:	eb e8                	jmp    172ee <int_to_real+0x36>
			:"=r" (b->a),"=r" (b->b)
			:"0" (b->a),"1" (b->b));
	}
}
   17306:	5b                   	pop    %ebx
   17307:	c3                   	ret    

00017308 <_exit>:
// 直接调用系统中断int 0x80,功能号__NR_exit.
// 参数:exit_code - 退出码.
// 函数名前的关键字volatile用于告诉编译器gcc该函数不会返回.这样可让gcc产生更好的代码,更重要的是使用这个关键字可以避免产生某些(未初始化变量的)
// 假警告信息.等同于gcc的函数属性说明:void do_exit(int error_code) __attribute__((noreturn));
void _exit(int exit_code)
{
   17308:	53                   	push   %ebx
	__asm__ __volatile__ ("int $0x80"::"a" (__NR_exit), "b" (exit_code));
   17309:	b8 01 00 00 00       	mov    $0x1,%eax
   1730e:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   17312:	cd 80                	int    $0x80
}
   17314:	5b                   	pop    %ebx
   17315:	c3                   	ret    

00017316 <open>:
// 打开文件函数
// 打开并有可能创建一个文件.
// 参数:filname - 文件名;flag - 文件打开标志;...
// 返回:文件描述符,若出错则置出错码,并返回-1.
int open(const char * filename, int flag, ...)
{
   17316:	56                   	push   %esi
	// 利用va_start()宏函数,取得flag后面参数的指针,然后调用系统中断int 0x80,功能open进行.
	// 文件打开操作.
	// %0 - eax(返回的描述符或出错码); %1 - eax(系统中断调用功能号__NR_open);
	// %2 - ebx(文件名filename); %3 - ecx(打开文件标志flag); %4 - edx(后随参数文件属性mode).
	va_start(arg, flag);
	__asm__(
   17317:	b8 05 00 00 00       	mov    $0x5,%eax
{
   1731c:	53                   	push   %ebx
   1731d:	e8 60 2b ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   17322:	81 c6 de 9c 00 00    	add    $0x9cde,%esi
	__asm__(
   17328:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1732c:	8b 54 24 14          	mov    0x14(%esp),%edx
   17330:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   17334:	cd 80                	int    $0x80
		"int $0x80"
		:"=a" (res)
		:"0" (__NR_open), "b" (filename), "c" (flag),
		"d" (va_arg(arg, int)));
	// 系统中断调用返回值大于或等于0,表示是一个文件描述符,则直接返回之.
	if (res >= 0)
   17336:	85 c0                	test   %eax,%eax
   17338:	79 0d                	jns    17347 <open+0x31>
		return res;
	// 否则说明返回值小于0,则代表一个出错码.设置该出错码并返回-1.
	errno = -res;
   1733a:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   17340:	f7 d8                	neg    %eax
   17342:	89 02                	mov    %eax,(%edx)
	return -1;
   17344:	83 c8 ff             	or     $0xffffffff,%eax
}
   17347:	5b                   	pop    %ebx
   17348:	5e                   	pop    %esi
   17349:	c3                   	ret    

0001734a <close>:
#define __LIBRARY__
#include <unistd.h>	                                // Linux标准头文件.定义了各种符号常数和类型,并声明了各种函数.

// 关闭文件函数
// 下面该调用宏函数对应:int close(int fd).直接调用了系统中断int 0x80,参数是__NR_close.其中fd是文件描述符.
_syscall1(int, close, int, fd)
   1734a:	53                   	push   %ebx
   1734b:	b8 06 00 00 00       	mov    $0x6,%eax
   17350:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   17354:	e8 cf f6 fe ff       	call   6a28 <__x86.get_pc_thunk.dx>
   17359:	81 c2 a7 9c 00 00    	add    $0x9ca7,%edx
   1735f:	cd 80                	int    $0x80
   17361:	85 c0                	test   %eax,%eax
   17363:	79 0d                	jns    17372 <close+0x28>
   17365:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   1736b:	f7 d8                	neg    %eax
   1736d:	89 02                	mov    %eax,(%edx)
   1736f:	83 c8 ff             	or     $0xffffffff,%eax
   17372:	5b                   	pop    %ebx
   17373:	c3                   	ret    

00017374 <write>:

// 写文件系统调用函函数.
// 该宏结构对应于函数:int write(int fd, const char * buf, off_t count)
// 参数:fd - 文件描述符;buf - 写缓冲指针; count - 写字节数.
// 返回:成功时返回写入的字节数(0表示写入0字节);出错时将返回-1,并且设置了出错号.
_syscall3(int, write, int, fd, const char *, buf, off_t, count)
   17374:	56                   	push   %esi
   17375:	b8 04 00 00 00       	mov    $0x4,%eax
   1737a:	53                   	push   %ebx
   1737b:	e8 02 2b ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   17380:	81 c6 80 9c 00 00    	add    $0x9c80,%esi
   17386:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1738a:	8b 54 24 14          	mov    0x14(%esp),%edx
   1738e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   17392:	cd 80                	int    $0x80
   17394:	85 c0                	test   %eax,%eax
   17396:	79 0d                	jns    173a5 <write+0x31>
   17398:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   1739e:	f7 d8                	neg    %eax
   173a0:	89 02                	mov    %eax,(%edx)
   173a2:	83 c8 ff             	or     $0xffffffff,%eax
   173a5:	5b                   	pop    %ebx
   173a6:	5e                   	pop    %esi
   173a7:	c3                   	ret    

000173a8 <dup>:
			                                    // 如定义了__LIBRARY__,则还含系统调用号和内嵌汇编_syscall0()等.

// 复制文件描述符函数.
// 下面该调用宏函数对应:int dup(int fd).直接调用了系统中断int 0x80,参数是__NR_dup.
// 其中fd是文件描述符.
_syscall1(int, dup, int, fd)
   173a8:	53                   	push   %ebx
   173a9:	b8 29 00 00 00       	mov    $0x29,%eax
   173ae:	8b 5c 24 08          	mov    0x8(%esp),%ebx
   173b2:	e8 71 f6 fe ff       	call   6a28 <__x86.get_pc_thunk.dx>
   173b7:	81 c2 49 9c 00 00    	add    $0x9c49,%edx
   173bd:	cd 80                	int    $0x80
   173bf:	85 c0                	test   %eax,%eax
   173c1:	79 0d                	jns    173d0 <dup+0x28>
   173c3:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   173c9:	f7 d8                	neg    %eax
   173cb:	89 02                	mov    %eax,(%edx)
   173cd:	83 c8 ff             	or     $0xffffffff,%eax
   173d0:	5b                   	pop    %ebx
   173d1:	c3                   	ret    

000173d2 <setsid>:
#include <unistd.h>

// 创建一个会话并设置进程组号。
// 下面系统调用宏对应于函数：pid_t setsid()。
// 返回：调用进程的会话标识符（session ID）。
_syscall0(pid_t, setsid)
   173d2:	e8 51 f6 fe ff       	call   6a28 <__x86.get_pc_thunk.dx>
   173d7:	81 c2 29 9c 00 00    	add    $0x9c29,%edx
   173dd:	b8 42 00 00 00       	mov    $0x42,%eax
   173e2:	cd 80                	int    $0x80
   173e4:	85 c0                	test   %eax,%eax
   173e6:	79 0d                	jns    173f5 <setsid+0x23>
   173e8:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   173ee:	f7 d8                	neg    %eax
   173f0:	89 02                	mov    %eax,(%edx)
   173f2:	83 c8 ff             	or     $0xffffffff,%eax
   173f5:	c3                   	ret    

000173f6 <execve>:

// 加载并执行子进程(其他程序)函数.
// 下面该调用宏函数对应:int execve(const char * file,char ** argv, char ** envp).
// 参数:file - 被执行程序文件名;argv - 命令行参数指针数组;envp - 环境变量指针数组.
// 直接调用了系统中断int 0x80,参数是__NR_execve.参见include/unistd.h和fs/exec.c程序.
_syscall3(int, execve, const char *, file, char **, argv, char **, envp)
   173f6:	56                   	push   %esi
   173f7:	b8 0b 00 00 00       	mov    $0xb,%eax
   173fc:	53                   	push   %ebx
   173fd:	e8 80 2a ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   17402:	81 c6 fe 9b 00 00    	add    $0x9bfe,%esi
   17408:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   1740c:	8b 54 24 14          	mov    0x14(%esp),%edx
   17410:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   17414:	cd 80                	int    $0x80
   17416:	85 c0                	test   %eax,%eax
   17418:	79 0d                	jns    17427 <execve+0x31>
   1741a:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   17420:	f7 d8                	neg    %eax
   17422:	89 02                	mov    %eax,(%edx)
   17424:	83 c8 ff             	or     $0xffffffff,%eax
   17427:	5b                   	pop    %ebx
   17428:	5e                   	pop    %esi
   17429:	c3                   	ret    

0001742a <waitpid>:

// 等待进程终止系统调用函数.
// 该下面宏结构对应于函数:pid_t waitpid(pid_t pid,int * wait_stat,int options)
//
// 参数:pid - 等待被终止进程的进程id,或者是用于指定特殊情况的其他特定数值;wait_stat - 用于存放状态信息;options - WNOHANG或WUNTRACED或是0.
_syscall3(pid_t, waitpid, pid_t, pid, int *, wait_stat, int, options)
   1742a:	56                   	push   %esi
   1742b:	b8 07 00 00 00       	mov    $0x7,%eax
   17430:	53                   	push   %ebx
   17431:	e8 4c 2a ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   17436:	81 c6 ca 9b 00 00    	add    $0x9bca,%esi
   1743c:	8b 4c 24 10          	mov    0x10(%esp),%ecx
   17440:	8b 54 24 14          	mov    0x14(%esp),%edx
   17444:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
   17448:	cd 80                	int    $0x80
   1744a:	85 c0                	test   %eax,%eax
   1744c:	79 0d                	jns    1745b <waitpid+0x31>
   1744e:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   17454:	f7 d8                	neg    %eax
   17456:	89 02                	mov    %eax,(%edx)
   17458:	83 c8 ff             	or     $0xffffffff,%eax
   1745b:	5b                   	pop    %ebx
   1745c:	5e                   	pop    %esi
   1745d:	c3                   	ret    

0001745e <wait>:

// wait()系统调用.直接调用waitpid()函数.
pid_t wait(int * wait_stat)
{
   1745e:	56                   	push   %esi
_syscall3(pid_t, waitpid, pid_t, pid, int *, wait_stat, int, options)
   1745f:	b8 07 00 00 00       	mov    $0x7,%eax
{
   17464:	53                   	push   %ebx
   17465:	e8 18 2a ff ff       	call   9e82 <__x86.get_pc_thunk.si>
   1746a:	81 c6 96 9b 00 00    	add    $0x9b96,%esi
_syscall3(pid_t, waitpid, pid_t, pid, int *, wait_stat, int, options)
   17470:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
   17474:	83 cb ff             	or     $0xffffffff,%ebx
   17477:	31 d2                	xor    %edx,%edx
   17479:	cd 80                	int    $0x80
   1747b:	85 c0                	test   %eax,%eax
   1747d:	79 0d                	jns    1748c <wait+0x2e>
   1747f:	c7 c2 04 97 03 00    	mov    $0x39704,%edx
   17485:	f7 d8                	neg    %eax
   17487:	89 02                	mov    %eax,(%edx)
   17489:	83 c8 ff             	or     $0xffffffff,%eax
	return waitpid(-1, wait_stat, 0);
}
   1748c:	5b                   	pop    %ebx
   1748d:	5e                   	pop    %esi
   1748e:	c3                   	ret    

0001748f <Log>:

static unsigned short cur_log_level = LOG_INFO_TYPE;

// linux0.12 kernel log function
void Log(unsigned short log_level, const char *fmt, ...)
{
   1748f:	56                   	push   %esi
   17490:	53                   	push   %ebx
   17491:	e8 96 f5 fe ff       	call   6a2c <__x86.get_pc_thunk.bx>
   17496:	81 c3 6a 9b 00 00    	add    $0x9b6a,%ebx
   1749c:	83 ec 08             	sub    $0x8,%esp
        va_list args;                           // va_list实际上是一个字符指针类型.

        // 运行参数处理开始函数.然后使用格式串fmt将参数列表args输出到buf中.返回值i等于输出字符串的长度.再运行参数处理结束函数.最后调用控制台显示
        // 函数并返回显示字符数.
        va_start(args, fmt);
        vsprintf(log_buf, fmt, args);
   1749f:	8d 44 24 1c          	lea    0x1c(%esp),%eax
   174a3:	8d b3 e0 21 01 00    	lea    0x121e0(%ebx),%esi
   174a9:	50                   	push   %eax
   174aa:	ff 74 24 1c          	pushl  0x1c(%esp)
   174ae:	56                   	push   %esi
   174af:	e8 92 0e ff ff       	call   8346 <vsprintf>
        va_end(args);
        console_print(log_buf);                 // chr_drv/console.c
   174b4:	89 34 24             	mov    %esi,(%esp)
   174b7:	e8 19 cf ff ff       	call   143d5 <console_print>
    }
}
   174bc:	83 c4 14             	add    $0x14,%esp
   174bf:	5b                   	pop    %ebx
   174c0:	5e                   	pop    %esi
   174c1:	c3                   	ret    
